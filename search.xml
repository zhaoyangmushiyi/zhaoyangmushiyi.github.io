<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker安装与常用命令</title>
    <url>/2019/01/11/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><h4 id="卸载老版本的Docker"><a href="#卸载老版本的Docker" class="headerlink" title="卸载老版本的Docker"></a>卸载老版本的Docker</h4><p>　　在CentOS中，老版本Docker名称是<code>docker</code>或<code>docker-engine</code>，而Docker CE的软件包名称是<code>docker-ce</code>。因此，如已安装过老版本的Docker，需使用如下命令卸载。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<p>　　需要注意的是，执行该命令只会卸载Docker本身，而不会删除Docker存储的文件，例如镜像、容器、卷以及网络文件等。这些文件保存在<code>/var/lib/docker</code>目录中，需要手动删除。</p>
<span id="more"></span>
<h4 id="安装仓库"><a href="#安装仓库" class="headerlink" title="安装仓库"></a>安装仓库</h4><p>　　执行以下命令，安装Docker所需的包。其中，<code>yum-utils</code>提供了<code>yum-config-manager</code>工具；<code>device-mapper-persistent-data</code>及<code>lvm2</code>则是<code>devicemapper</code>存储驱动所需的包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
<p>　　执行如下命令，安装<code>stable</code>仓库。必须安装<code>stable</code>仓库，即使你想安装<code>edge</code>或<code>test</code>仓库中的Docker构建版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>　　[可选] 执行如下命令，启用<code>edge</code>及<code>test</code>仓库。<code>edge/test</code>仓库其实也包含在了<code>docker.repo</code>文件中，但默认是禁用的，可使用以下命令来启用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --enable docker-ce-edge    # 启用edge仓库</span><br><span class="line">sudo yum-config-manager --enable docker-ce-test    # 启用test仓库</span><br></pre></td></tr></table></figure>
<p>　　如需再次禁用，可加上<code>--disable</code>标签。例如，执行如下命令即可禁用<code>edge</code>仓库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --disable docker-ce-edge</span><br></pre></td></tr></table></figure>
<p>　　TIPS：从<code>Docker 17.06</code>起，<code>stable</code>版本也会发布到<code>edge</code>以及<code>test</code>仓库中。</p>
<h4 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h4><p>　　执行以下命令，更新yum的包索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>
<p>　　执行如下命令即可安装最新版本的Docker CE</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure>
<p>　　在生产环境中，可能需要指定想要安装的版本，此时可使用如下命令列出当前可用的Docker版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list docker-ce.x86_64  --showduplicates | sort -r</span><br></pre></td></tr></table></figure>
<p>　　这样，列出版本后，可使用如下命令，安装想要安装的Docker CE版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce-&lt;VERSION&gt;</span><br></pre></td></tr></table></figure>
<p>　　启动Docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<p>　　验证安装是否正确。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<p>　　这样，Docker将会下载测试镜像，并使用该镜像启动一个容器。如能够看到类似如下的输出，则说明安装成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unable to find image &#39;hello-world:latest&#39; locally</span><br><span class="line">latest: Pulling from library&#x2F;hello-world</span><br><span class="line">b04784fba78d: Pull complete</span><br><span class="line">Digest: sha256:f3b3b28a45160805bb16542c9531888519430e9e6d6ffc09d72261b0d26ff74f</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https:&#x2F;&#x2F;cloud.docker.com&#x2F;</span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;userguide&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="升级Docker-CE"><a href="#升级Docker-CE" class="headerlink" title="升级Docker CE"></a>升级Docker CE</h4><p>　　如需升级Docker CE，只需执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>
<p>　　然后按照安装Docker的步骤，即可升级Docker。</p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p>　　CentOS 7安装Docker官方文档：<a href="https://docs.docker.com/install/linux/docker-ce/centos/">Docker for CentOS</a>，文档中还讲解了在CentOS 7中安装Docker CE的其他方式，本文不作赘述。</p>
<h3 id="shell一键安装"><a href="#shell一键安装" class="headerlink" title="shell一键安装"></a>shell一键安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>
<h2 id="Windows-docker-for-windows"><a href="#Windows-docker-for-windows" class="headerlink" title="Windows(docker for windows)"></a>Windows(docker for windows)</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>　　Windows 10 Professional 或 Windows 10 Enterprise X64 或Windows Home 10(Version 2004 or later，Windows Home can only run the WSL 2 backend)</p>
<p>　　对于Win 7 or 低版本Windows 10 Home，可使用Docker Toolbox（不建议使用）</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>　　前往<a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows">Docker for Windows 10</a>，下载安装包，双击即可安装。</p>
<h4 id="配置Table自动补全"><a href="#配置Table自动补全" class="headerlink" title="配置Table自动补全"></a>配置Table自动补全</h4><ol>
<li><p>启动一个的PowerShell（即以管理员身份运行）。搜索PowerShell，右键单击，然后选择以管理员身份运行。在PowerShell提示符下键入： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查策略设置是否正确，运行：<code>get-executionpolicy</code> ，应该返回RemoteSigned。</p>
</li>
<li><p>安装posh-dockerPowerShell模块以自动完成Docker命令，键入：<code>Install-Module posh-docker</code>或者，要仅为当前用户安装模块，键入： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Install-Module -Scope CurrentUser posh-docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完成后，只能为当前PowerShell启用自动完成功能，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Import-Module posh-docker</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h2><h3 id="阿里云加速器"><a href="#阿里云加速器" class="headerlink" title="阿里云加速器"></a>阿里云加速器</h3><p>　　注册阿里云账号后，进入<a href="https://cr.console.aliyun.com/#/accelerator">阿里云控制台</a>。<br>　　针对Docker客户端版本大于 1.10.0 的用户，可以通过修改daemon配置文件<code>/etc/docker/daemon.json</code>来使用加速器：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;arbzyqhz.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>　　以上内容转载自周立的Docker教程，<a href="http://www.itmuch.com/docker/02-docker-install/">Docker系列教程02-Docker安装(CentOS7/Ubuntu/macOS/Windows)</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装morunchang/fastdfs</title>
    <url>/2021/03/24/Docker%E5%AE%89%E8%A3%85morunchang-fastdfs/</url>
    <content><![CDATA[<h1 id="Docker安装morunchang-fastdfs"><a href="#Docker安装morunchang-fastdfs" class="headerlink" title="Docker安装morunchang/fastdfs"></a>Docker安装morunchang/fastdfs</h1><h2 id="FastDFS简介"><a href="#FastDFS简介" class="headerlink" title="FastDFS简介"></a>FastDFS简介</h2><p>FastDFS是一款开源的分布式文件系统，功能主要包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了文件大容量存储和高性能访问的问题。FastDFS特别适合以文件为载体的在线服务，如图片、视频、文档等等。</p>
<p>FastDFS作为一款轻量级分布式文件系统，版本V6.01代码量6.3万行。FastDFS用C语言实现，支持Linux、FreeBSD、MacOS等类UNIX系统。FastDFS类似google FS，属于应用级文件系统，不是通用的文件系统，只能通过专有API访问，目前提供了C和Java SDK，以及PHP扩展SDK。</p>
<p>FastDFS为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性。FastDFS可以看做是基于文件的key value存储系统，key为文件ID，value为文件内容，因此称作分布式文件存储服务更为合适。</p>
<span id="more"></span>

<h2 id="FastDFS由跟踪服务器-Tracker-Server-、存储服务器-Storage-Server-和客户端-Client-构成。"><a href="#FastDFS由跟踪服务器-Tracker-Server-、存储服务器-Storage-Server-和客户端-Client-构成。" class="headerlink" title="FastDFS由跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)构成。"></a>FastDFS由跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)构成。</h2><h3 id="Tracker-server-追踪服务器"><a href="#Tracker-server-追踪服务器" class="headerlink" title="Tracker server 追踪服务器"></a>Tracker server 追踪服务器</h3><p>追踪服务器负责接收客户端的请求，选择合适的组合storage server ，tracker server 与 storage server之间也会用心跳机制来检测对方是否活着。<br>Tracker需要管理的信息也都放在内存中，并且里面所有的Tracker都是对等的（每个节点地位相等），很容易扩展客户端访问集群的时候会随机分配一个Tracker来和客户端交互。</p>
<h3 id="Storage-server-储存服务器"><a href="#Storage-server-储存服务器" class="headerlink" title="Storage server 储存服务器"></a>Storage server 储存服务器</h3><p>实际存储数据，分成若干个组（group），实际traker就是管理的storage中的组，而组内机器中则存储数据，group可以隔离不同应用的数据，不同的应用的数据放在不同group里面，</p>
<ul>
<li>优点：<br>海量的存储：主从型分布式存储，存储空间方便拓展,<br>fastDFS对文件内容做hash处理，避免出现重复文件<br>然后fastDFS结合Nginx集成, 提供网站效率</li>
</ul>
<h3 id="客户端Client"><a href="#客户端Client" class="headerlink" title="客户端Client"></a>客户端Client</h3><ul>
<li>主要是上传下载数据的服务器，也就是我们自己的项目所部署在的服务器。</li>
</ul>
<h2 id="FastDFS特点"><a href="#FastDFS特点" class="headerlink" title="FastDFS特点"></a>FastDFS特点</h2><ol>
<li>分组存储，简单灵活；</li>
<li>对等结构，不存在单点；</li>
<li>文件ID由FastDFS生成，作为文件访问凭证。FastDFS不需要传统的name server或meta server；</li>
<li>大、中、小文件均可以很好支持，可以存储海量小文件；</li>
<li>一台storage支持多块磁盘，支持单盘数据恢复；</li>
<li>提供了nginx扩展模块，可以和nginx无缝衔接；</li>
<li>支持多线程方式上传和下载文件，支持断点续传；</li>
<li>存储服务器上可以保存文件附加属性。</li>
</ol>
<h2 id="安装FastDFS"><a href="#安装FastDFS" class="headerlink" title="安装FastDFS"></a>安装FastDFS</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull morunchang/fastdfs;</span><br></pre></td></tr></table></figure>

<h3 id="设置Tracker"><a href="#设置Tracker" class="headerlink" title="设置Tracker"></a>设置Tracker</h3><h4 id="运行-tracker"><a href="#运行-tracker" class="headerlink" title="运行 tracker"></a>运行 tracker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name tracker --net=host morunchang/fastdfs sh tracker.sh</span><br></pre></td></tr></table></figure>

<p>上面的启动命令是在Linux下，如果是Mac或Windows操作系统network=host（容器与主机享受相同的network namespace）会失效，此时需要指定对应的端口映射，-p 22122:22122 </p>
<h4 id="进入-tracker"><a href="#进入-tracker" class="headerlink" title="进入 tracker"></a>进入 tracker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it tracker /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h4><p><strong><code>/etc/nginx/conf/nginx.conf</code></strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       21000;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>/etc/fdfs/client.conf</code></strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">tracker_server</span>=<span class="string">127.0.0.1:22122</span></span><br><span class="line"><span class="attr">......</span></span><br><span class="line"><span class="meta">http.tracker_server_port</span>=<span class="string">21000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>/etc/fdfs/tracker.conf</code></strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">port</span>=<span class="string">22122</span></span><br><span class="line"><span class="attr">......</span></span><br><span class="line"><span class="meta">http.server_port</span>=<span class="string">21000</span></span><br></pre></td></tr></table></figure>

<h3 id="设置Storage"><a href="#设置Storage" class="headerlink" title="设置Storage"></a>设置Storage</h3><h4 id="运行-storage"><a href="#运行-storage" class="headerlink" title="*运行 storage *"></a>*<em>运行 storage *</em></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name storage --net=host -e TRACKER_IP=127.0.0.1:22122 -e GROUP_NAME=group1 morunchang/fastdfs sh storage.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">共享卷</span></span><br><span class="line">docker run -d --name storage --net=host -e TRACKER_IP=127.0.0.1:22122 -v /home/monochrome/app/fastdfs/storage:/data/fast_data -e GROUP_NAME=group1 morunchang/fastdfs sh storage.sh</span><br><span class="line"></span><br><span class="line">docker run -d --name storage -p 22000:22000 -p 23000:23000 -e TRACKER_IP=127.0.0.1:22122 -e GROUP_NAME=group1 morunchang/fastdfs sh storage.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">共享卷</span></span><br><span class="line">docker run -d --name storage -p 22000:22000 -p 23000:23000 -e TRACKER_IP=127.0.0.1:22122 -v /home/monochrome/app/fastdfs/storage:/data/fast_data -e GROUP_NAME=mono morunchang/fastdfs sh storage.sh</span><br></pre></td></tr></table></figure>

<h4 id="进入-storage"><a href="#进入-storage" class="headerlink" title="进入 storage"></a><strong>进入 storage</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it storage /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="修改端口-1"><a href="#修改端口-1" class="headerlink" title="修改端口"></a>修改端口</h4><p><strong><code>/etc/nginx/conf/nginx.conf</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       22000;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>/etc/fdfs/client.conf</code></strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">tracker_server</span>=<span class="string">127.0.0.1:22122</span></span><br><span class="line"><span class="meta">http.tracker_server_port</span>=<span class="string">21000</span></span><br></pre></td></tr></table></figure>

<p><strong><code>/etc/fdfs/storage.conf</code></strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">port</span>=<span class="string">23000</span></span><br><span class="line"><span class="attr">tracker_server</span>=<span class="string">127.0.0.1:22122</span></span><br><span class="line"><span class="meta">http.server_port</span>=<span class="string">22000</span></span><br></pre></td></tr></table></figure>

<h3 id="替换配置文件"><a href="#替换配置文件" class="headerlink" title="替换配置文件"></a>替换配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp nginx.conf tracker:/etc/nginx/conf/nginx.conf</span><br><span class="line">docker cp client.conf tracker:/etc/fdfs/client.conf</span><br><span class="line">docker cp tracker.conf tracker:/etc/fdfs/tracker.conf</span><br><span class="line"></span><br><span class="line">docker cp nginx.conf storage:/etc/nginx/conf/nginx.conf</span><br><span class="line">docker cp client.conf storage:/etc/fdfs/client.conf</span><br><span class="line">docker cp storage.conf storage:/etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure>

<h2 id="通过Spring-Boot使用FastDFS"><a href="#通过Spring-Boot使用FastDFS" class="headerlink" title="通过Spring Boot使用FastDFS"></a>通过Spring Boot使用FastDFS</h2><h3 id="导入Maven依赖"><a href="#导入Maven依赖" class="headerlink" title="导入Maven依赖"></a>导入Maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.tobato<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastdfs-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.27.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>详见作者GitHub：<a href="https://github.com/tobato/FastDFS_Client">https://github.com/tobato/FastDFS_Client</a></p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>FastDFS</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item0 引言</title>
    <url>/2018/12/06/Effective-Java-Item0-%E5%BC%95%E8%A8%80/</url>
    <content><![CDATA[<p>这本书的目的是帮助你高效地使用java这门编程语言和它的基本类库：java.lang ,  java.util, and java.io<br>和这些包子包下的：java.util.concurrent 和java.util.function 。其它的类库也会时不时地被讨论到。</p>
<p>这本书有90个小项，每一项都表达了一个准则。这些准则是由那些最优秀、最有经验的程序员总结出来的最佳实践。<br>这些小项松散地被分到11个章节下面，每个章节都涵盖了软件设计的一个广泛的方面。这本书不需要一页一页地读，每一项都是独立的，正正好好。<br>这些项目被大量交叉引用，因此您可以轻松地在书中计划自己的课程。</p>
<span id="more"></span>

<p>自从这本书第二版出版后，Java平台又增添了很多新特性。这本书大部分都或多或少地用到了这些特性。这张表向您展示了主要覆盖了的关键特性:</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>所在条目</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Lambdas</td>
<td>第42~44条</td>
<td>Java8</td>
</tr>
<tr>
<td>Streams</td>
<td>第45~48条</td>
<td>Java8</td>
</tr>
<tr>
<td>Optionals</td>
<td>第55条</td>
<td>Java8</td>
</tr>
<tr>
<td>Default methods in interfaces</td>
<td>第21条</td>
<td>Java8</td>
</tr>
<tr>
<td>try -with-resources</td>
<td>第9条</td>
<td>Java7</td>
</tr>
<tr>
<td>@SafeVarargs</td>
<td>第32条</td>
<td>Java7</td>
</tr>
<tr>
<td>Modules</td>
<td>第15条</td>
<td>Java9</td>
</tr>
</tbody></table>
<p>大多数项目都用程序示例进行说明的。<br>这本书的一个重要特点是它通过一些代码示例，来阐明许多设计模式和习惯用法。<br>在适当的情况下，它们被交叉引用到这个领域的标准参考工作[Gamma95]。</p>
<p>很多项目都包含了一个或多个程序示例，来说明有些行为是可以避免的。<br>这种例子，被称为反例，然后被清楚地加上了注释，如“Never do this!”。<br>在每种情况下，该项目解释了为什么这个例子不好，并提出了另一种方法。</p>
<p>这本书不适合初学者:它假定您已经熟悉Java。<br>因为effective java是为那些有这门语言工作经验的人阅读的，所以它应该给那些高级开发人员提供更高级的使用。</p>
<p>这本书中的大部分规则都源于一些基本原则。简单明了就是是很重要的原则之一。组件的使用者不会对它的行为感到惊讶。<br>组件应该尽可能地小，但又不能太小。（就像这本书中提到的，这里的术语“组件”是指可重用的软件元素，即从一个独立的方法到一个由多个模块组成的复杂的框架，<br>都可以被称为“组件”）。<br>代码应该能重复使用而不是到处复制。组建之间的依赖应该保持低耦合。代码在完成之后错误应该尽快被检测出来，最好是在编译时期。</p>
<p>虽然这本书中的规则并不是100%的适用，但在绝大多数情况下它们确实都是最佳的编程实践。<br>你不应该盲目地遵循这些规则，如果有充分的理由，你也可以不遵循这些规则。<br>学习编程的艺术，就跟其它大多数学科一样，先要学习规则，然后要知道什么时候去打破规则。</p>
<p>大部分情况下，这本书并没有涉及性能方面。它指导我们如何写出清晰的，正确的，可重用的，健壮的，可维护的代码。如果你能做到这点，那么提升你想要的性能就是一件相对简单的事情了(Item 67)。<br>有些项目确实讨论了所关心的性能问题，有些项目还给出了有关性能的数据。这些数据在被介绍时，都提前说明是在“我的机器上”。这种描述是被认为最恰当的。</p>
<p>当讨论Java编程语言的特性和它的类库时，有时候需要引用特定版本。为了方便起见，这本书用别名来指定官方版本名。<br>下面的表展示了官方版本名和别名之间的映射关系。</p>
<table>
<thead>
<tr>
<th>官方版本名</th>
<th>别名</th>
</tr>
</thead>
<tbody><tr>
<td>JDK 1.0.x</td>
<td>Java 1.0</td>
</tr>
<tr>
<td>JDK 1.1.x</td>
<td>Java 1.1</td>
</tr>
<tr>
<td>Java 2 Platform, Standard Edition, v1.2</td>
<td>Java 2</td>
</tr>
<tr>
<td>Java 2 Platform, Standard Edition, v1.3</td>
<td>Java 3</td>
</tr>
<tr>
<td>Java 2 Platform, Standard Edition, v1.4</td>
<td>Java 4</td>
</tr>
<tr>
<td>Java 2 Platform, Standard Edition, v5.0</td>
<td>Java 5</td>
</tr>
<tr>
<td>Java Platform, Standard Edition 6</td>
<td>Java 6</td>
</tr>
<tr>
<td>Java Platform, Standard Edition 7</td>
<td>Java 7</td>
</tr>
<tr>
<td>Java Platform, Standard Edition 8</td>
<td>Java 8</td>
</tr>
<tr>
<td>Java Platform, Standard Edition 9</td>
<td>Java 9</td>
</tr>
</tbody></table>
<p>书中的例子都已经相当完整了，但是比完整性跟重要的是可读性。程序员们大量地使用java.util和java.io包下的类。为了成功编译书中的示例，您可能需要添加一个或多个导入声明，或其他这样的样板文件。<br>这本书的网址上<a href="http://joshbloch.com/effectivejava">Effective Java</a>，包含了每个示例的一个完整版本，你可以下载下来编译并运行它。</p>
<p>大多数情况下，这本书里用到的技术术语都在Java SE 8这个版本的Java语言规范中定义的。其中有一些术语特别值得提出来。比如说，Java支持四种类型:接口(包括注解)、类(包括枚举)、数组和原生类型。前三种被称为引用类型。类的实例化和数组叫做对象，<br>而原生类型的值不是对象。类的成员包括它的字段、方法、成员类和成员接口。方法的签名包括它的名字和形参的类型；签名不包括方法的返回类型。</p>
<p>本书使用了一些与Java语言规范不同的术语。与Java语言规范不同，本书使用继承作为子类化的同义词。与使用术语继承来实现接口不同，这本书简单地说明了一个类实现了一个接口，或者一个接口继承了另一个接口。本书使用了传统的包私有的（package-private）访问级别，<br>而不是技术上正确的包访问（package access），来描述没有指定的访问级别。</p>
<p>这本书用到了一些《Java语言规范》没有定义的技术术语。API暴露出的术语(简称API)指程序员访问类、接口或包里面的的类、接口、构造函数、成员和序列化形式。术语API是application programming interface的简称，它更倾向于使用其他更好的术语接口，<br>以避免与该名称的语言结构混淆。编写使用API的程序的程序员被称为API的用户。通过API来实现的类叫做API的客户端。</p>
<p>类、接口、构造函数、成员和序列化形式统称为API元素。<br>一个暴露出来的API是由可以在定义该API的包外访问到的API元素组成。这些API元素可以给任意客户端使用，并且API的作者提供支持。不凑巧的是，它们也是Javadoc实用程序在其默认的操作模式中生成文档的元素。宽泛地说，一个包的对外API由公共和受保护的成员和包中的每个公共类或接口的构造函数组成。<br>在Java9中，模块系统被添加到平台里。如果一个库使用了模块系统，它对外的API是该模块系统声明对外包下的对外API的联和。<br>最后，提供一下<a href="https://github.com/jbloch/effective-java-3e-source-code">Effective Java源码</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 1</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item1 考虑静态工厂方法代替构造方法</title>
    <url>/2018/12/06/Effective-Java-Item1-%E8%80%83%E8%99%91%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>一个类允许客户端获取他的一个实例的传统方法是提供一个公有的构造函数。除此之外，还有一个技术，每个程序员都应该掌握。就是一个类提供一个公有的静态工厂方法，这个方法就是一个简单的返回当前类一个实例的静态方法。这里有个来自于<strong>Boolean</strong>（对原生类型<strong>boolean</strong>的装箱）类内部实现的简单的例。下面的方法可以将一个原生<strong>boolean</strong>类型的值转变成一个对<strong>Boolean</strong>对象的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>请注意，上面这个静态工厂方法与设计模式[Gamma95]中的工厂方法模式并不一样。本条款所介绍的静态工厂方法在设计模式一书中并没有直接的等价物。  </p>
<p>除了公有构造方法外，类还可以向其客户端提供静态工厂方法。相比于公有构造方法来说，提供静态工厂方法有利也有弊。</p>
<p><strong>静态工厂方法其中一个好处是，它可以有自己的名字，而构造函数不行</strong>。如果构造函数的参数，他们本身并不能描述返回的对象，那么拥有恰当名字的静态工厂将会更加易于使用，所生成的客户端代码的可读性也更好。举个例子，通过构造函数<strong>BigInteger(int, int, Random)</strong> 返回一个值可能是质数的<strong>BigInteger</strong> 对象，还有更好的方法，就是通<strong>BigInteger.probablePrime</strong> 这个静态工厂方法来实现。（这个方法在java4时加入）</p>
<p>一个类只能有一个指定签名的构造函数。程序员们已经知道如何绕过这个限制了，那就是提供两个构造方法，<br>这两个构造方法之间唯一的差别就是参数列表中参数类型的顺序是不同的。<br>这是一个非常差劲的想法。像这样的API，使用者将永远不能够记住哪个构造函数是哪个的，最终会错误地调用错误的构造函数。<br>人们在读使用了这些构造函数的代码时，如果没有类说明文档，就没有办法知道这些代码是做什么的。</p>
<p>由于拥有名字，因此静态工厂方法不会遇到上面所讨论的限制。当一个类需要多个拥有相同签名的构造方法时，只需使用静态工厂方法来代替构造方法，<br>并精心选择好名字来明确他们之间的差别即可。</p>
<p><strong>静态工厂方法的第二个好处是，它不像构造函数那样，他不需要每次调用都创建一个新的对象</strong>。这样就可以让不变类使用预先构造好的实例，或是在构造时将其缓存起来，从而避免了创建不必要的重复对象的情况。<strong>Boolea.valueOf(boolean)</strong> 这个方法就论证了这个技术：它绝不会创建一个对象。这个技术非常像享元设计模式。如果相同的一个对象经常被请求而且创建这个对象的成本是昂贵的，那么静态工厂方法能极大地提高性能。</p>
<p>静态工厂方法可以在重复调用的情况下返回同一个对象的能力使得类可以在任何时候都能严格控制哪些实例可以存在<br>采取这种做法的类叫做实例控制。这里有几个理由去使用实例化控制的类。<br>实例化控制允许一个类可以保证他是单例的（条目3）或者不可实例化的（条目4）。此外，它允许不可变值类(条目17)保证没有两个相等的实例存在：<br>当且仅当a == b时，a.equals(b)才为true。这是享元模式的基础[Gamma95]。<br>枚举类型(条目34)提供了此保证。</p>
<p><strong>静态工厂方法的第三个优点是，与构造函数不同，它们可以返回所声明的返回类型的任何子类型的对象</strong>。这样，在选择返回对象的类型时，给了你很大的灵活性。</p>
<p>这种灵活性的一个应用场景就是API能够在无需将类声明为公有的情况下就可以返回对象。以这种方式隐藏实现类使得API变得非常紧凑。这项技术也被应用到了基于接口的框架（条目20）中，其中接口就为静态工厂方法提供了自然而然的返回类型。</p>
<p>在Java 8之前，接口不能有静态方法。根据约定，针对名为Type的接口的静态工厂方法会被放到名为Types的不可实例化的伴生类（条目4）当中。Java集合框架有接口的45个辅助实现，提供了不可修改的集合、同步集合等等。几乎所有接口的实现都是通过一个不能实例化的类（<strong>java.util.Collections</strong>）的静态工厂方法提供的。返回对象的类型都是非公开的。</p>
<p>集合框架API要比它本来的样子小很多，它公开了了45个独立的公有类，每个类都针对于一个便捷的实现。这并不仅仅只是API的数量少了了，更为重要的是概念上的数量少了。程序员使用API所需掌握的概念的数量和难度都降低了。程序员知道所返回的对象是由其接口API所精确描述的，因此不需要读取额外的关于实现类的文档说明。使用这种静态工厂方法要求客户端引用接口而非实现类所返回的对象，这通常是很好的实践(条目64)。</p>
<p>在Java 8中，接口不能包含静态方法的限制被消除了，这样一般来说，我们就没必要再为接口提供不可实例化的伴生类了。很多本应该位于这种类中的公有静态成员现在应该放到接口自身当中了。不过，值得注意的是，我们还是需要将这些静态方法的实现代码放到单独的包级别的私有类中。这是因为Java 8要求接口的所有静态成员都是公共的。Java 9允许私有静态方法，但是静态字段和静态成员类仍然需要公开。</p>
<p><strong>静态工厂的第四个好处在于，作为输入参数的函数，返回对象所属的类会随着调用的不同而不同</strong>。所声明的返回类型的任何子类型都是允许的。返回对象所属的类也会随着调用的不同而不同</p>
<p>EnumSet类（条款36）没有公有的构造方法，只有静态工厂方法。在OpenJDK的实现当中，它返回其中两个子类中任意一个类的一个实例，这取决于底层枚举类型的大小：如果拥有的元素数量小于等于64个（这也是大多数枚举类型的情况），它的静态工厂方法会返回一个RegularEnumSet实例，其底层是个long类型。如果枚举类型拥有的元素数量大于等于65个，那么工厂返回一个JumboEnumSet实例，其底层是个long类型的数组。</p>
<p>这两个实现类的存在对客户端是透明的。如果RegularEnumSet不再为小型枚举类型提供性能优势，那么它可以在未来的版本中消除，不会有任何不良影响。类似地，将来的版本可以添加第三或第四个EnumSet 实现，只要这些实现被证明对性能有好处。客户端既不知道也不关心他们从工厂返回的对象的类型，它们只在乎它是EnumSet的某个子类就行。</p>
<p><strong>静态工厂的第五个好处在于，在使用包含了了方法的类时，返回对象所属的类不必事先存在。</strong>。这种灵活的静态工厂方法构成了服务提供者框架的基础，如Java 数据库连接API （JDBC）。服务提供者框架是这样一种系统，提供者实现了某个服务，系统将其实现公开给客户端，从而实现了客户端与实现之间的解耦。</p>
<p>服务提供者框架里有3个最基本的组件：</p>
<ul>
<li>服务接口，代表某一个实现。</li>
<li>提供者注册API，提供者通过它来注册实现 。</li>
<li>服务访问API，客户端通过它获取服务实例。</li>
</ul>
<p>客户端可以通过服务访问API来指定标准，从而选择相应的实现 。如果没有指定这样的一个标准，那么API返回一个默认实现的实例，或者允许客户端循环所有可得到的实例。服务访问API是灵活的静态工厂，它构成了服务提供者框架的基础。</p>
<p>服务提供者框架第四个可选的组件是服务提供者接口，它描述了一个生产服务接口实例的工厂对象。在缺少服务提供者接口的情况下，实现必须通过反射的方式去实例化 (项目65)。在JDBC的场景下，Connection扮演这服务接口的角色，DriverManager.registerDriver就是服务提供者注册API，DriverManager.getConnection就是服务访问API，Driver就是服务提供者接口。</p>
<p>服务提供者框架模式有许多变形。比如说，服务访问API可以向客户端返回比提供者所规定的更为宽泛的服务接口 。这就是桥接模式[Gamma95]。依赖注入框架(项目5)可以看作是强大的服务提供者。从Java 6开始，Java平台有一个通用的服务者提供框架，java.util.ServiceLoader，所以通常你不必，也不应该自己去写这个框架了(条目59)。JDBC并未使用ServiceLoader，因为前者出现的时间要更早一些。。</p>
<p><strong>只提供静态工厂方法的主要限制是没有公共或受保护构造函数的类不能被子类化</strong>。例如，在集合框架中不可能子类化任何方便实现类。可以说，这可能是因祸得福，因为它鼓励程序员使用组合而不是继承(条目18)，并且需要不可变类型(条目17)</p>
<p><strong>静态工厂方法的第二个缺点是，程序员很难找到它们</strong>。他们并不像构造方法那样在API文档中有清楚的说明，这样对于只提供静态工厂方法，而没提供构造方法的类来说，我们就很难知晓到底该用那种方式来实例化它。Javadoc工具可能有一天会引起对静态工厂方法的注意。与此同时，你可以多多注意到类或接口文档中的静态工厂并坚持使用常见的命名约定来减少此类问题的发生。下面是一些静态工厂方法的常用名称。这个列表并不是十分详尽:</p>
<ul>
<li>From —— 一种类型转换方法，它接受单个参数并返回该类型的相应实例，例如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date d = Date.from(instant);</span><br></pre></td></tr></table></figure></li>
<li>Of —— 一个聚合方法，它接受多个参数并返回该类型的实例，该实例包含了它们，例如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</span><br></pre></td></tr></table></figure></li>
<li>valueOf —— from与of的一种更加冗长的替代方案 ，例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</span><br></pre></td></tr></table></figure></li>
<li>instance或者getInstance —— 返回一个实例，该实例由其参数(如果有)描述，但不能说具有相同的值，例如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StackWalker luke = StackWalker.getInstance(options);</span><br></pre></td></tr></table></figure></li>
<li>create或者newInstance —— 跟instance和getInstance方法有点类似,期望方法能保证每次调用都返回新的实例，例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object newArray = Array.newInstance(classObject, arrayLen);</span><br></pre></td></tr></table></figure></li>
<li>getType —— 有点像getInstance，但是，是在工厂方法在一个不同的类中时使用。Type就是工厂方法返回的对象类型，比如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileStore fs = Files.getFileStore(path);</span><br></pre></td></tr></table></figure></li>
<li>newType —— 有点像newInstance，但是，是在工厂方法在一个不同的类中时使用。Type就是工厂方法返回的对象类型，比如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader br = Files.newBufferedReader(path);</span><br></pre></td></tr></table></figure></li>
<li>type ——  getType与newType的一个简洁的替代方案，比如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Complaint&gt; litany = Collections.list(legacyLitany);</span><br></pre></td></tr></table></figure>
总结来说，静态工厂方法和构造方法都有他们的用法，我们需要理解他们各自的优点。通常，静态工厂是优先选择的，这样可以避免习惯性地在没有考虑静态工厂的情况下就提供公有构造方法的情况发生 。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring REST API实体和DTO之间的转换</title>
    <url>/2018/11/26/API%E5%AE%9E%E4%BD%93%E5%92%8CDTO%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="Spring-REST-API实体和DTO之间的转换"><a href="#Spring-REST-API实体和DTO之间的转换" class="headerlink" title="Spring REST API实体和DTO之间的转换"></a>Spring REST API实体和DTO之间的转换</h1><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h2><p>在本教程中，我们将处理在Spring应用程序的内部实体和被发送到客户端的外部DTO（数据传输对象）之间的转换。</p>
<h2 id="2-ModelMapper"><a href="#2-ModelMapper" class="headerlink" title="2. ModelMapper"></a>2. ModelMapper</h2><p>首先，让我们看看用来执行实体-DTO转换的主要类库——ModelMapper。</p>
<p>我们需要在pom.xml中添加这个依赖：</p>
<figure class="highlight plain"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.modelmapper&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;modelmapper&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.3.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>如果需要检查这个库是否有更新的版本， 请<a href="https://search.maven.org/classic/#search|gav|1|g%3A%22org.modelmapper%22%20AND%20a%3A%22modelmapper%22">点击这里</a>。</p>
<p>然后，我们将在Spring配置中定义ModelMapperbean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelMapper <span class="title">modelMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ModelMapper();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-DTO"><a href="#3-DTO" class="headerlink" title="3. DTO"></a>3. DTO</h2><p>话分两头，接下来让我们来看看本例使用的DTO——PostDto。</p>
<figure class="highlight java"><figcaption><span>PostDto.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostDto</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDto user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getSubmissionDateConverted</span><span class="params">(String timezone)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        dateFormat.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">        <span class="keyword">return</span> dateFormat.parse(<span class="keyword">this</span>.date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubmissionDate</span><span class="params">(Date date, String timezone)</span> </span>&#123;</span><br><span class="line">        dateFormat.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">        <span class="keyword">this</span>.date = dateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，上面与日期相关的两个方法，它们是用来处理客户端和服务器之间日期数据转换的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getSubmissionDateConverted()方法将日期字符串转换为服务器所在时区中的日期，以便将其用于持久化Post实体</span><br><span class="line">setSubmissionDate()方法是将DTO的日期设置为当前用户所在时区的Post日期</span><br></pre></td></tr></table></figure>

<h2 id="4-服务层"><a href="#4-服务层" class="headerlink" title="4. 服务层"></a>4. 服务层</h2><p>现在让我们看一下服务层的操作——它显然是与实体（而不是DTO）一起工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Post&gt; <span class="title">getPostsList</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> page, <span class="keyword">int</span> size, String sortDir, String sort)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PageRequest pageReq</span><br><span class="line">     = <span class="keyword">new</span> PageRequest(page, size, Sort.Direction.fromString(sortDir), sort);</span><br><span class="line"></span><br><span class="line">    Page&lt;Post&gt; posts = postRepository</span><br><span class="line">      .findByUser(userService.getCurrentUser(), pageReq);</span><br><span class="line">    <span class="keyword">return</span> posts.getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-控制器层"><a href="#5-控制器层" class="headerlink" title="5. 控制器层"></a>5. 控制器层</h2><p>下面让我们来看看服务层上面的控制器层，这才是转换操作实际触发的地方。<br>现在，让我们来看一个标准的控制器，一个暴露Post资源的REST API。  </p>
<p>我们将在这里展示一些简单的CRUD操作：创建、更新、获取一条和全部记录。考虑到操作非常简单，并且我们特别感兴趣的是实体-DTO转换方面：  </p>
<figure class="highlight java"><figcaption><span>PostRestController.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostRestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IPostService postService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ModelMapper modelMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PostDto&gt; <span class="title">getPosts</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        List&lt;Post&gt; posts = postService.getPostsList(page, size, sortDir, sort);</span><br><span class="line">        <span class="keyword">return</span> posts.stream()</span><br><span class="line">          .map(post -&gt; convertToDto(post))</span><br><span class="line">          .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CREATED)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PostDto <span class="title">createPost</span><span class="params">(<span class="meta">@RequestBody</span> PostDto postDto)</span> </span>&#123;</span><br><span class="line">        Post post = convertToEntity(postDto);</span><br><span class="line">        Post postCreated = postService.createPost(post));</span><br><span class="line">        <span class="keyword">return</span> convertToDto(postCreated);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PostDto <span class="title">getPost</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> convertToDto(postService.getPostById(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.PUT)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatePost</span><span class="params">(<span class="meta">@RequestBody</span> PostDto postDto)</span> </span>&#123;</span><br><span class="line">        Post post = convertToEntity(postDto);</span><br><span class="line">        postService.updatePost(post);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我们从Post实体到PostDto的转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PostDto <span class="title">convertToDto</span><span class="params">(Post post)</span> </span>&#123;</span><br><span class="line">    PostDto postDto = modelMapper.map(post, PostDto.class);</span><br><span class="line">    postDto.setSubmissionDate(post.getSubmissionDate(), </span><br><span class="line">        userService.getCurrentUser().getPreference().getTimezone());</span><br><span class="line">    <span class="keyword">return</span> postDto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是从DTO到实体的转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Post <span class="title">convertToEntity</span><span class="params">(PostDto postDto)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    Post post = modelMapper.map(postDto, Post.class);</span><br><span class="line">    post.setSubmissionDate(postDto.getSubmissionDateConverted(</span><br><span class="line">      userService.getCurrentUser().getPreference().getTimezone()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (postDto.getId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Post oldPost = postService.getPostById(postDto.getId());</span><br><span class="line">        post.setRedditID(oldPost.getRedditID());</span><br><span class="line">        post.setSent(oldPost.isSent());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> post;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，正如您所看到的，在modelmapper库的帮助下，转换逻辑是快速且简单的——我们使用了modelMapper的map API，并且在不编写任何转换逻辑的情况下完成了数据转换。</p>
<h2 id="6-单元测试"><a href="#6-单元测试" class="headerlink" title="6. 单元测试"></a>6. 单元测试</h2><p>最后，让我们做一个非常简单的测试，以确保实体和DTO之间的转换可以很好地工作：</p>
<figure class="highlight java"><figcaption><span>PostDtoUnitTest.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostDtoUnitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ModelMapper modelMapper = <span class="keyword">new</span> ModelMapper();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenConvertPostEntityToPostDto_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Post post = <span class="keyword">new</span> Post();</span><br><span class="line">        post.setId(Long.valueOf(<span class="number">1</span>));</span><br><span class="line">        post.setTitle(randomAlphabetic(<span class="number">6</span>));</span><br><span class="line">        post.setUrl(<span class="string">&quot;www.test.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        PostDto postDto = modelMapper.map(post, PostDto.class);</span><br><span class="line">        assertEquals(post.getId(), postDto.getId());</span><br><span class="line">        assertEquals(post.getTitle(), postDto.getTitle());</span><br><span class="line">        assertEquals(post.getUrl(), postDto.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenConvertPostDtoToPostEntity_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PostDto postDto = <span class="keyword">new</span> PostDto();</span><br><span class="line">        postDto.setId(Long.valueOf(<span class="number">1</span>));</span><br><span class="line">        postDto.setTitle(randomAlphabetic(<span class="number">6</span>));</span><br><span class="line">        postDto.setUrl(<span class="string">&quot;www.test.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Post post = modelMapper.map(postDto, Post.class);</span><br><span class="line">        assertEquals(postDto.getId(), post.getId());</span><br><span class="line">        assertEquals(postDto.getTitle(), post.getTitle());</span><br><span class="line">        assertEquals(postDto.getUrl(), post.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item3 通过私有的构造方法或者一个枚举类型来使用单例属性</title>
    <url>/2018/12/06/Effective-Java-Item3-%E9%80%9A%E8%BF%87%E7%A7%81%E6%9C%89%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E4%B8%80%E4%B8%AA%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E4%BD%BF%E7%94%A8%E5%8D%95%E4%BE%8B%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p><strong>单例</strong>对象是一个仅仅只会实例化一次的类。单例对象通常表示一个无状态对象，例如一个函数(Item 24)或一个本质上惟一的系统组件。<strong>使类成为单例会使测试它的客户端变得困难</strong>，因为不可能用模拟实现代替单例，除非它实现一个接口作为它的类型。</p>
<span id="more"></span>
<p>实现单例有两种常见的方法。两者都基于保持构造函数为私有，并对外提供公共静态成员以提供对唯一实例的访问。在第一种方式中，成员是个<code>final</code>字段:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singleton with public final field</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>只调用私有构造函数一次，以初始化公共静态<code>final</code>字段<code>Elvi.instance</code></strong>。不提供公有的或者受保护的构造函数保证了全局“唯一性”：当Elvis类初始化的时候，仅仅只会有一个<code>Elvis</code>实例存在——不多也不少 。无论客户端怎么做都无法改变这一点，只不过我还是要警告一下 ：授权的客户端可以通过反射来调用私有构造方法（Item 65），借助于<code>AccessibleObject.setAccessible</code>方法即可做到 。如果需要防范这种攻击，请修改构造函数，使其在被要求创建第二个实例时抛出异常。</p>
<p><strong>第二种实现单例模式的方法是，提供一个公有的静态工厂方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singleton with static factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有调用<code>Elvis</code>类的<code>getInstance</code>方法，返回相同的对象引用，并且不会有其它的<code>Elvis</code>对象被创建。（但同样有上面提到的警告）</p>
<p>公共字段方法的主要优点是，通过API我们就可以很清晰地看到类是个单例 ：<code>public static</code>字段是<code>final</code>的，所以它将始终包含相同的对象引用。 第二个优点是它更简单。静态工厂方法的一个优点是它可以让你灵活地改变你的想法，即当你想要改变类的单例特性时，你无需修改其API 。工厂方法返回唯一的实例，但可以修改它，使得每个线程调用它时都返回一个单独的实例。所以，如果你的项目需要，你可以定义一个通用的单例工厂。使用静态工厂方法最后一个好处就是，方法引用可以当做一个提供者，例如，<code>Elvis::instance</code>就是一个<code>Supplier&lt;Elvis&gt;</code>的实例。除非上述这些好处存在一定程度的相关性 ，不然提供公有字段的方法更适合。</p>
<p>要想让上述两种方式实现的单例类能够序列化（Chapter 12），仅仅在声明中添加实现Serializable接口是不够的。为了保证单例，将所有实例字段声明为<code>transient</code>，并提供一个<code>readResolve</code>方法(Item 89)。否则，每次反序列化一个序列化的实例时，都会创建一个新的实例，在我们的示例中，就会出现另一个<code>Elvise</code>。为了阻止这样的事发生，给<code>Elvis</code>类添加一个<code>readResolve</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readResolve method to preserve singleton property</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return the one true Elvis and let the garbage collector</span></span><br><span class="line">    <span class="comment">// take care of the Elvis impersonator.</span></span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三种实现单例的方式是，声明一个单元素的枚举类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法跟提供公有的字段方法很类似，但它更简洁，提供天然的可序列化机制和能够强有力地保证不会出现多次实例化的情况 ，甚至面对复杂的序列化和反射的攻击下。这种方法可能看起来不太自然，但是<strong>拥有单元素的枚举类型可能是实现单例模式的最佳实践</strong>。注意，如果单例必须要继承一个父类而非枚举的情况下是无法使用该方式的（不过可以声明一个实现了接口的枚举）。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item2 当遇到许多构造方法参数时，考虑构建器</title>
    <url>/2018/12/06/Effective-Java-Item2-%E5%BD%93%E9%81%87%E5%88%B0%E8%AE%B8%E5%A4%9A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%97%B6%EF%BC%8C%E8%80%83%E8%99%91%E6%9E%84%E5%BB%BA%E5%99%A8/</url>
    <content><![CDATA[<p>静态工厂和构造函数有一个共同的限制:它们不能很好地扩展到大量可选参数。考虑一个代表包装食品上出现的营养成分标签的类的例子。这些标签有一些必要的字段，如分量大小、每瓶容量以及每份的卡路里里数，以及超过20个可选的字段——总脂肪，饱和脂肪，反式脂肪，胆固醇，钠，等等。大多数产品只有少数几个可选字段的值为非零值。</p>
<span id="more"></span>

<p>对于这样一个类来说，你应该编写哪种构造方法或是静态工厂呢？传统上，程序员们会使用重叠构造方法模式，在这种模式中，您只提供了一个只有必需参数的构造函数，然后编写一个接收单个可选参数的构造方法，再编写一个接收两个可选参数的构造方法，以此类推，最后提供一个接收所有可选参数的构造方法。如下代码示例例就说明了了这一点。出于简洁的目的，这里只给出了4个可选字段：</p>
<figure class="highlight java"><figcaption><span>NutritionFacts.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Telescoping constructor pattern - does not scale well!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize; <span class="comment">// (mL) required</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings; <span class="comment">// (per container) required</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories; <span class="comment">// (per serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat; <span class="comment">// (g/serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium; <span class="comment">// (mg/serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate; <span class="comment">// (g/serving) optional</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(servingSize, servings, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> calories)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(servingSize, servings, calories, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> calories, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(servingSize, servings, calories, fat, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> calories, <span class="keyword">int</span> fat, <span class="keyword">int</span> sodium)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(servingSize, servings, calories, fat, sodium, <span class="number">0</span>);</span><br><span class="line">    &#125;                                                            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> calories, <span class="keyword">int</span> fat, <span class="keyword">int</span> sodium, <span class="keyword">int</span> carbohydrate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">        <span class="keyword">this</span>.servings = servings;</span><br><span class="line">        <span class="keyword">this</span>.calories = calories;</span><br><span class="line">        <span class="keyword">this</span>.fat = fat;</span><br><span class="line">        <span class="keyword">this</span>.sodium = sodium;</span><br><span class="line">        <span class="keyword">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当您想要创建一个实例时，您可以使用包含您想要设置的所有参数的最短参数列表的构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts(<span class="number">240</span>, <span class="number">8</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">35</span>, <span class="number">27</span>);</span><br></pre></td></tr></table></figure>

<p>通常，这个构造函数调用需要许多您不想设置的参数，但是您必须为它们传递一个值。在本例中，我们传递了一个值为0的<code>fat</code>。“只有”6个参数可能看起来不那么糟糕，但是随着参数数量的增加，很快你就数不过来了。</p>
<p><strong>简而言之，构造函数模式是有效的，但是当有许多参数时，客户端的代码很难写，而且可读性更差</strong>。读者不知道这些值是什么意思，必须仔细地计算参数的个数来找出答案。长长的同类型参数序列会导致非常隐秘的Bug。。如果客户端不小心将两个这样的参数位置颠倒，编译器是不会报错的，但是程序在运行时将会出错(Item 51)。</p>
<p>当你遇到一个构造函数中有许多可选参数时，第二个替代方法是<strong>JavaBeans</strong>模式，在这个模式中，你调用一个无参数的构造函数来创建对象，然后调用<strong>setter</strong>方法来设置每个必需的参数和每个可选的参数:</p>
<figure class="highlight java"><figcaption><span>NutritionFacts.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaBeans Pattern - allows inconsistency, mandates mutability</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters initialized to default values (if any)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> servingSize = -<span class="number">1</span>; <span class="comment">// Required; no default value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> servings = -<span class="number">1</span>; <span class="comment">// Required; no default value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// Setters</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServingSize</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; servingSize = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServings</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; servings = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCalories</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; calories = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFat</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; fat = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSodium</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; sodium = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCarbohydrate</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; carbohydrate = val; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模式没有重叠构造函数模式的缺点。通过这种方式可以轻松创建实例例（就是稍微有点冗长），并且代码读起来也比较容易：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts();</span><br><span class="line">cocaCola.setServingSize(<span class="number">240</span>);</span><br><span class="line">cocaCola.setServings(<span class="number">8</span>);</span><br><span class="line">cocaCola.setCalories(<span class="number">100</span>);</span><br><span class="line">cocaCola.setSodium(<span class="number">35</span>);</span><br><span class="line">cocaCola.setCarbohydrate(<span class="number">27</span>);</span><br></pre></td></tr></table></figure>

<p>不幸的是，JavaBeans模式本身有严重的缺点。由于构造方法在多个调用中被拆分，所以JavaBean可能在其构建过程中处于不一致的状态。仅仅通过检查构造函数参数的有效性，该类没法实现一致性。在不一致的状态下尝试使用对象可能会导致与包含bug的代码相去甚远的错误，因此很难进行调试。与此相关的一个缺点是，JavaBeans模式排除了使类不可变的可能性(见Item 17)，并要求程序员为确保线程安全而增加工作。</p>
<p>当构造完毕时，我们可以通过手工『冻结』对象并且直到冻结后才允许使用对象来消除这些缺陷，不过这种做法很少使用。此外，这么做会导致运行期错误，因为编译器无法确保程序员在使用对象前会调用对象的冻结方法。</p>
<p>幸运的是，还有第三种选择，它将伸缩构造函数模式的安全性与JavaBeans模式的可读性相结合。它就是构建器模式的形式。客户端调用一个构造方法（或是静态工厂），并附上它需要的参数来获得一个构建器对象，来代替直接创造所需的目标对象。然后客户端调用构建起对象上的类似setter的方法去设置每一个感兴趣的可选的参数。最后，客户端调用无参的build方法去生成目标对象，通常它是不可变的。一般来说，这个构建器类是它构建的类的静态成员类。在实践中它通常看起来就是下面的样子：</p>
<figure class="highlight java"><figcaption><span>NutritionFacts.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Builder Pattern</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Required parameters</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">        <span class="comment">// Optional parameters - initialized to default values</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="keyword">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">        </span>&#123; calories = val; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">        </span>&#123; fat = val; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sodium</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">        </span>&#123; sodium = val; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">carbohydrate</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">        </span>&#123; carbohydrate = val; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        servingSize = builder.servingSize;</span><br><span class="line">        servings = builder.servings;</span><br><span class="line">        calories = builder.calories;</span><br><span class="line">        fat = builder.fat;</span><br><span class="line">        sodium = builder.sodium;</span><br><span class="line">        carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NutritionFacts</code>类是不可变的，所有参数默认值都在一个位置。构建器的<code>setter</code>方法返回构建器本身，这样调用就可以链接起来，形成一种流式API 。客户端代码是这样的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts.Builder(<span class="number">240</span>, <span class="number">8</span>)</span><br><span class="line">                            .calories(<span class="number">100</span>)</span><br><span class="line">                            .sodium(<span class="number">35</span>)</span><br><span class="line">                            .carbohydrate(<span class="number">27</span>)</span><br><span class="line">                            .build();</span><br></pre></td></tr></table></figure>

<p>该客户端代码易于编写，更重要的是易于阅读。构建器模式模拟了在Python和Scala中找到的命名可选参数。</p>
<p>为简便起见，省略了有效性检查。要检查构建器的构造函数和方法中的参数有效性，为了尽快检查出无效参数。检查<code>build</code>方法调用的构造函数中涉及多个参数的不变量。要确保这些不变量没被篡改，请在复制构造器参数(Item 50)之后对对象字段进行检查。如果检查失败，会抛出一个<code>IllegalArgumentException</code>（Item 72），它的详细消息会指示出哪些参数无效(Item 75)。</p>
<p>构建器模式非常适合类的层次结构。使用并行的构建器层次结构，每个构建器嵌套在相应的类中。抽象类有抽象的构建器;具体类有具体的构建器。例如，将一个抽象类当做代表了不同种类披萨的层次结构的根类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Builder pattern for class hierarchies</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Topping</span> </span>&#123; HAM, MUSHROOM, ONION, PEPPER, SAUSAGE &#125;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;Topping&gt; toppings;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">addTopping</span><span class="params">(Topping topping)</span> </span>&#123;</span><br><span class="line">            toppings.add(Objects.requireNonNull(topping));</span><br><span class="line">            <span class="keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> Pizza <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// Subclasses must override this method to return &quot;this&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">self</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pizza(Builder&lt;?&gt; builder) &#123;</span><br><span class="line">        toppings = builder.toppings.clone(); <span class="comment">// See Item 50</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>Pizza.Builder</code>是个泛型类型，它有一个递归的类型参数（Item 30）。通过该参数以及抽象的<code>self</code>方法可以让方法在子类中恰当地链接起来，而无需进行类型转换。这种对于Java缺乏自我类型问题的解决方案叫做模拟的自我类型。</p>
<p>这里有两个具体的披萨子类，一个是标准的纽约风格披萨，另一个是奶酪馅饼式披萨。前者有一个必填的<code>size</code>参数 ，而后者可以让你指定酱汁是在里面还是在外面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NyPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Size</span> </span>&#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">Pizza</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Size size)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.size = Objects.requireNonNull(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> NyPizza <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NyPizza(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Builder <span class="title">self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NyPizza</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(builder);</span><br><span class="line">        size = builder.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calzone</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> sauceInside;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">Pizza</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> sauceInside = <span class="keyword">false</span>; <span class="comment">// Default</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sauceInside</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sauceInside = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Calzone <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Calzone(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Builder <span class="title">self</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Calzone</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(builder);</span><br><span class="line">        sauceInside = builder.sauceInside;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意每个子类的<code>builder</code>的<code>build()</code>方法都被声明成返回一个具类： <code>NyPizza.Builder</code>的<code>build</code>方法返回<code>NyPizza</code>类，而<code>Calzone.Builder</code>的<code>build</code>方法返回<code>Calzone</code>类，这种子类方法返回父类中声明的返回类型的子类型的技术，称为协变返回类型 。它允许客户端使用这些构建器，而不需要强制转换。</p>
<p>这些“层次化的构建器”的客户端代码本质上等价于简单的<code>NutritionFacts</code>的构建器的代码。如下的示例客户端代码假设已经静态导入了枚举常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NyPizza pizza = <span class="keyword">new</span> NyPizza.Builder(SMALL)</span><br><span class="line">                    .addTopping(SAUSAGE)</span><br><span class="line">                    .addTopping(ONION)</span><br><span class="line">                    .build();</span><br><span class="line">Calzone calzone = <span class="keyword">new</span> Calzone.Builder()</span><br><span class="line">                    .addTopping(HAM)</span><br><span class="line">                    .sauceInside()</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure>

<p>与构造函数相比，构建器的一个小小的优势是，构建器可以有多个可变的参数，因为每个参数都在自己的方法中指定。或者，构建器可以把多次调用所需要的参数聚合到一个方法里的一个单一字段上，正如前面<code>addTopping</code>方法所展示的那样。</p>
<p>构建器模式非常灵活。一个构建器可以重复使用建立多个对象。构建器的参数可以在调用构建方法时进行调整，以改变创建的对象。构建器可以在对象创建时自动填充一些字段，比如说每次创建一个对象时递增的序列号等。</p>
<p>构建器模式也有缺点。为了能创建一个对象，你必须先创建它的构建器。虽然创建这个构建器的成本在实践中不太可能被注意到，但是在对性能要求很高的场景下这可能是个问题。此外，构建器模式比可伸缩构造器模式更加冗长，因此，只有当有足够多的参数时，使用它才有价值，比如4个以上的参数时。但如果一开始使用的是构造方法或是静态工厂，当参数量变得很多时，想要切换到构建器，那么显而易见，会遗留很多废弃的构造方法或是静态工厂。因此，更好的做法则是一开始就使用构建器器。</p>
<p>总之，在设计类时，如果类的构造方法或是静态工厂有很多参数，那么构建器模式是一个很好的选择，特别是如果许多参数是可选的或类型相同的情况下更是如此。 与重叠构造函数相比，使用构建器模式的客户端代码更容易读写，而且构建器比JavaBeans要安全得多。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item10 覆盖equals时请遵守通用约定</title>
    <url>/2018/12/10/Effective-Java-Item10-%E8%A6%86%E7%9B%96equals%E6%97%B6%E8%AF%B7%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h2><p>　　尽管<code>Object</code>是一个具体类，但是设计它主要是为了扩展。它所有的非<code>final</code>方法(<code>equals</code>、<code>hashCode</code>、<code>toString</code>、<code>clone</code>和<code>finalize</code>)都有明确的通用约定（<strong><code>general contract</code></strong>）,因为它们被设计成是要被覆盖（<code>override</code>）的。任何一个类，它在覆盖这些方法的时候，都有责任遵守这些通用约定；如果不能做到这一点，其他依赖于这些约定的类（例如<code>HashMap</code>和<code>HashSet</code>）就无法结合该类一起正常运作。</p>
<p>　　本章将讲述何时以及如何盖这些非<code>final</code>的<code>Object</code>方法。本章不再讨论<code>finalize</code>方法，因为Item 8已经讨论过这个方法了。而<code>Comparable.compareTo</code>虽然不是<code>Object</code>方法，但是本章也对它进行讨论，因为它具有类似的特征。</p>
<span id="more"></span>

<h3 id="Item-10：覆盖equals时请遵守通用约定"><a href="#Item-10：覆盖equals时请遵守通用约定" class="headerlink" title="Item 10：覆盖equals时请遵守通用约定"></a>Item 10：覆盖<code>equals</code>时请遵守通用约定</h3><p> 　　覆盖<code>equals</code>方法看起来似乎很简单，但是有许多覆盖方式会导致错误，并且后果非常严重。最容易避免这类问提的办法就是不覆盖<code>equals</code>方法，在这种情况下，类的每个实例都只与它自身相等。如果满足了以下任何一个条件，这就正是所期望的结果：</p>
<ul>
<li><p><strong>类的每个实例本质上都是唯一的</strong>。对于代表活动实体而不是值(<code>value</code>)的类来说确实如此，例如<code>Thread</code>。<code>Object</code>的<code>equals</code>实现对于这些类来说正是正确的行为。  </p>
</li>
<li><p><strong>不关心类是否提供了“逻辑相等(<code>logical equality</code>)”的测试功能</strong>。例如，<code>java.util.Random</code>覆盖了<code>equals</code>，以检查两个<code>Random</code>实例是否产生相同的随机数序列，但是设计者并不认为客户需要或者期望这样的功能。在这样的情况下，从<code>Object</code>继承得到的<code>equals</code>实现已经足够了。  </p>
</li>
<li><p><strong>超类己经覆盖了equals．从超类继承过来的行为对于子类也是合适的</strong>。例如，大多数的<code>Set</code>实现都从<code>AbstractSet</code>继承<code>equals</code>实现，<code>Map</code>实现从<code>AbstractMap</code>继承<code>equals</code>实现。</p>
</li>
<li><p><strong>类是私有的或是包级私有的，可以确定它的<code>equals</code>方法永远不会被调用</strong>。在这种情况下，无疑是应该覆盖<code>equals</code>方法的，以防它被意外调用：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(); <span class="comment">// Method is never called</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　那么，什么时候应该覆盖<code>Object.equals</code>呢？如果类具有自己特有的“逻辑相等”概念（不同于对象等同的概念),而且超类还没有覆盖<code>equals</code>以实现期望的行为。这时我们就需要覆盖<code>equals</code>方法。这通常属于“值类（<code>value class</code>）”的情形。值类仅仅是一个表示值的类，例如<code>Integer</code>或者<code>Date</code>。程序员在利用<code>equals</code>方法来比较对象的引用时，希望知道它们在逻辑上是否相等，而不是想了解它们是否指向同一个对象。为了满足程序员的要求，不仅必需覆盖<code>equals</code>方法，而且这样做也使得这个类的实例可以被用做映射表(<code>map</code>)的键(<code>key</code>)，或者集合（<code>set</code>）的元素，使映射或者集合表现出预期的行为。</p>
</li>
</ul>
<p>　　有一种“值类”不需要覆盖<code>equals</code>方法，即用实例受控（Item 1）确保“每个值至多只存在一个对象”的类。枚举类型（Item 34）就属于这种类。对于这样的类而言，逻辑相同与对象等同是一回事，因此<code>Object</code>的<code>equals</code>方法等同于逻辑意义上的<code>equals</code>方法。</p>
<p>　　在覆盖<code>equals</code>方法的时候，你必须要遵守它的通用约定。下面是约定的内容，来自<code>Object</code>的规范[JavaSE6]: </p>
<p>　　<code>equals</code>方法实现了等价关系(<code>equivalence relation</code>):</p>
<ul>
<li><p>自反性(<code>reflexive</code>)。对于任何非<code>null</code>的引用值，<code>x.equals(x)</code>必须返回<code>true</code>。</p>
</li>
<li><p>对称性(<code>symmetric</code>)。对于任何非<code>null</code>的引用值x和Y，当且仅当<code>y.equals(x)</code>返回<code>true</code>时，<br><code>x.equals(y)</code>必须返回<code>true</code>。</p>
</li>
<li><p>传递性(<code>transitive</code>)。对于任何非<code>null</code>的引用值x、y和z,如果<code>x.equals(y)</code>返回<code>true</code>，并<br>且<code>y.equals(z)</code>也返回true，那么<code>x.equals(z)</code>也必须返回<code>true</code>。</p>
</li>
<li><p>一致性：(<code>consistent</code>)。对于任何非<code>null</code>的引用值x和y，只要<code>equals</code>的比较操作在对象中<br>所用的信息没有被修改多次调用<code>x.equals(y)</code>就会一致地返回<code>true</code>，或者一致地返回<code>false</code>。</p>
</li>
<li><p>对于任何非<code>null</code>的引用值x，<code>x.equals(null)</code>必须返回<code>false</code>。</p>
<p>  　　除非你对数学特别感兴，否则这些规定看起来可能有点让人感到恐惧，但是绝对不要忽视这些规定！如果你违反了它们，就会发现你的程序将会表现不正常，甚至崩溃，而且很难找到失败的根源。用John Donne的话说，没有哪个类是孤立的。一个类的实例通常会被频繁地传递给另一个类的实例。有许多类，包括所有的集合类（<code>collection class</code>)在内，都依赖于传递给它们的对象是否遵守了<code>equals</code>约定。</p>
</li>
</ul>
<p>　　现在你已经知道了违反<code>equals</code>约定有多么可怕，现在我们就来更细致地讨论这些约定。值得欣慰的是，这些约定虽然看起来很吓人，实际上并不十分复杂。一旦理解了这些约定，要遵守它们并不困难。现在我们按照顺序逐一查看以下5个要求：</p>
<p>　　<strong>自反性（<code>reflexivity</code>)</strong>——第一个要求仅仅说明对象必须等于其自身。很难想像会无意识地违反这一条。假如违背了这一条，然后把该类的实例添加到集合(<code>collection</code>)中，该集合的<code>contain</code>方法将果断地告诉你，该集合不包含你刚刚添加的实例。</p>
<p>　　<strong>对称性(<code>symmetry</code>)</strong>——第二个要求是说，任何两个对象对于“它们是否相等”的问题都必须保持一致。与第一个要求不同，若无意中违反这一条，这种情形倒是不难想像。例如，考虑下面的类，它实现了一个区分大小写的字符串。字符串由<code>toString</code>保存，但在比较操作中被忽略。<br>    <figure class="highlight java"><figcaption><span>CaseInsensitiveString.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - violates symmetry!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CaseInsensitiveString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = Objects.requireNonNull(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Broken - violates symmetry!</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> CaseInsensitiveString)</span><br><span class="line">            <span class="keyword">return</span> s.equalsIgnoreCase(</span><br><span class="line">                    ((CaseInsensitiveString) o).s);</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> String)  <span class="comment">// One-way interoperability!</span></span><br><span class="line">            <span class="keyword">return</span> s.equalsIgnoreCase((String) o);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Demonstration of the problem (Page 40)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CaseInsensitiveString cis = <span class="keyword">new</span> CaseInsensitiveString(<span class="string">&quot;Polish&quot;</span>);</span><br><span class="line">        String s = <span class="string">&quot;polish&quot;</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;CaseInsensitiveString&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(cis);</span><br><span class="line"></span><br><span class="line">        System.out.println(list.contains(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // Fixed equals method (Page 40)</span></span><br><span class="line"><span class="comment">//    @Override public boolean equals(Object o) &#123;</span></span><br><span class="line"><span class="comment">//        return o instanceof CaseInsensitiveString &amp;&amp;</span></span><br><span class="line"><span class="comment">//                ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　在这个类中，<code>equals</code>方法的意图非常好，它企图与普通的字符串(<code>String</code>)对象进行互操作。假设我们有一个不区分大小写的字符串和一个普通的字符串：<br>    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CaseInsensitiveString cis = <span class="keyword">new</span> CaseInsensitiveString(<span class="string">&quot;PoliSh&quot;</span>);</span><br><span class="line">String s = <span class="string">&quot;polish&quot;</span>;</span><br></pre></td></tr></table></figure><br>　　正如所料，<code>cis.equals(s)</code>返回<code>true</code>。问题在于，虽然<code>CaseInsensitiveString</code>类中的<code>equals</code>方法知道普通的字符串(<code>String</code>)对象，但是，<code>String</code>类中的<code>equals</code>方法却并不知道不区分大小写的字符串。因此，<code>s.equals(cis)</code>返回<code>false</code>，显然违反了对称性，假设你把不区分大小写的字符串对象放到一个集合中：<br>    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;CaseInsensitiveString&gt; list = <span class="keyword">new</span> ArrayList&lt;CaseInsensitiveString&gt;();</span><br><span class="line">list.add(ics);</span><br></pre></td></tr></table></figure><br>　　此时<code>list.contains(s)</code>会返回什么结果呢？没人知道。在OpenJDK的当前实现中，它碰巧返回<code>false</code>，但这只是这个特定实现得出的结果而已。在其他的实现中，它有可能返回<code>true</code>，或者抛出一个运行时(<code>runtime</code>)异常。<strong>一旦违反了<code>equals</code>约定，当其他对象面对你的对象时，你完全不知道这些对象的行为会怎么样。</strong></p>
<p>　　为了解决这个问题，只需把企图与<code>String</code>互操作的这段代码从<code>equals</code>方法中去掉就可以了。这样做之后，就可以重构该方法，使它变成一条单独的返回句：<br>    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o <span class="keyword">instanceof</span> CaseInsensitiveString &amp;&amp;</span><br><span class="line">        ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　<strong>传递性(<code>transitivity</code>)</strong>——<code>equals</code>约定的第三个要求是，如果一个对象等于第二个对象，并且第二个对象又等于第三个对象，则第一个对象一定等于第三个对象。同样地，无意识地违反这条规则的情形也不难想像。考虑子类的情形，它将一个新的值组件(<code>value component</code>)添加到了超类中。换句话说，子类增加的信息会影响到<code>equals</code>的比较结果。我们首先以一个简单的不可变的二维整数型<code>Point</code>类作为开始：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Simple immutable two-dimensional integer point class (Page 37)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Point p = (Point)o;</span><br><span class="line">        <span class="keyword">return</span> p.x == x &amp;&amp; p.y == y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    // Broken - violates Liskov substitution principle (page 43)</span></span><br><span class="line"><span class="comment">//    @Override public boolean equals(Object o) &#123;</span></span><br><span class="line"><span class="comment">//        if (o == null || o.getClass() != getClass())</span></span><br><span class="line"><span class="comment">//            return false;</span></span><br><span class="line"><span class="comment">//        Point p = (Point) o;</span></span><br><span class="line"><span class="comment">//        return p.x == x &amp;&amp; p.y == y;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// See Item 11</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　假设你想要扩展这个类，为一个点添加颜色信息：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adds a value component without violating the equals contract (page 44)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Point point;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Color color)</span> </span>&#123;</span><br><span class="line">        point = <span class="keyword">new</span> Point(x, y);</span><br><span class="line">        <span class="keyword">this</span>.color = Objects.requireNonNull(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the point-view of this color point.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">asPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ColorPoint cp = (ColorPoint) o;</span><br><span class="line">        <span class="keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * point.hashCode() + color.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　<code>equals</code>方法会怎么样呢？如果完全不提供<code>equals</code>方法，而是直接从<code>Point</code>继承过来，在<code>equals</code>做比较的时候颜色信息就被忽略掉了，虽然这样做不会违反<code>equals</code>约定，但是很明显这是无法接受的。假设你编写了一个<code>equals</code>方法，只有当它的参数是另一个有色点，并且具有同样的位置和颜色时，它才会返回<code>true</code>：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - violates symmetry!</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　这个方法的问题在于，你在比较普通点和有色点，以及相反的情形时，可能会得到不同的结果。前一种比较忽略了颜色信息，而后一种比较则总是返回<code>false</code>，因为参数的类型不正确。为了直观地说明问题所在，我们创建一个普通点和一个有色点！<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">ColorPoint cp = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br></pre></td></tr></table></figure><br>　　然后，<code>p.equals(cp)</code>返回<code>true</code>，<code>cp.equals(p)</code>则返回<code>false</code>。你可以做这样的尝试来修正这个问题，让<code>ColorPoint.equals</code>在进行“混合比较”时忽略颜色信息:<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - violates transitivity!</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// If o is a normal Point, do a color-blind comparison</span></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">        <span class="keyword">return</span> o.equals(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// o is a ColorPoint; do a full comparison</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　这种方法确实提供了对称性，但是却牺牲了传递性：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ColorPoint p1 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line">Point p2 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">ColorPoint p3 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</span><br></pre></td></tr></table></figure><br>　　此时，<code>p1.equalS(p2)</code>和<code>p2.equals(p3)</code>都返回<code>true</code>，但是<code>p1.equals(p3)</code>则返回<code>false</code>，很显然违反了传递性。前两种比较不考虑颜色信息（“色盲”），而第三种比较中则考虑了倾色信息。</p>
<p>　　怎么解决呢？事实上，这是面向对象语言中关于等价关系的一个基本问题。<strong>我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留<code>equals</code>约定</strong>，除非愿意放弃面向对象的抽象所带来的优势。</p>
<p>　　你可能听说，在<code>equals</code>方法中用<code>getClass</code>测试代替<code>instanceof</code>测试，可以扩展可实例化的类和增加新的值组件，同时保留<code>equals</code>约定：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - violates Liskov substitution principle (page 43)</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || o.getClass() != getClass())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Point p = (Point) o;</span><br><span class="line">    <span class="keyword">return</span> p.x == x &amp;&amp; p.y == y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　这段程序只有当对象具有相同的实现时，才能使对象等同。虽然这样也不算太槽糕，但是结果却是无法接受的。假设我们要编写一个方法，以检验某个整值点是否处在单位圆中。下面是可以采用的其中一种方法，<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize unitCircle to contain all Points on the unit circle</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Point&gt; unitCircle = Set.of(</span><br><span class="line">    <span class="keyword">new</span> Point( <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> Point( <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> Point(-<span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> Point( <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onUnitCircle</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unitCircle.contains(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　虽然这可能不是实现这种功能的最快方式，不过它的效果很好。但是假设你通过某种不添加值组件的方式扩展了<code>Point</code>，例如让它的构造器记录创建了多少个实例：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger counter =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberCreated</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> counter.get(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　<strong>里氏替换原则（Liskov substitution principle）</strong> 认为，一个类型的任何重要属性也将适用于它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行得很好[Liskov87]。但是假设我们将<code>CounterPoint</code>实例传给了<code>onUnitCircle</code>方法。如果<code>Point</code>类使用了基于<code>getClass</code>的<code>equals</code>方法，无论<code>CounterPoint</code>实例的x和y值是什么，<code>onUnitCircle</code>方法都会返回<code>false</code>。之所以如此，是因为像<code>onUnitCircle</code>方法所用的<code>HashSet</code>这样的集合，利用<code>equals</code>方法检验包含条件，没有任何<code>CounterPoint</code>实例与任何<code>Point</code>对应。但是，如果在<code>Point</code>上使用适当的基于<code>instanceof</code>的<code>equals</code>方法，当遇到<code>Counterpoint</code>时，相同的<code>onUnitCircle</code>方法就会工作得很好。</p>
<p>　　虽然没有一种令人满意的办法可以既扩展不可实例化的类，又增加值组件，但还是有一种不错的权宜之计（<code>workaround</code>)。根据Item 18的建议：复合优先于继承。我们不再让<code>ColorPoint</code>扩展<code>Point</code>，而是在<code>ColorPoint</code>中加人一个私有的<code>Point</code>域，以及一个公有的视图(<code>view</code>)方法（Item 6），此方法返回一个与该有色点处在相同位置的普通<code>Point</code>对象：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adds a value component without violating the equals contract</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Point point;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Color color)</span> </span>&#123;</span><br><span class="line">        point = <span class="keyword">new</span> Point(x, y);</span><br><span class="line">        <span class="keyword">this</span>.color = Objects.requireNonNull(color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the point-view of this color point.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">asPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ColorPoint cp = (ColorPoint) o;</span><br><span class="line">        <span class="keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　在Java平台类库中，有一些类扩展了可实例化的类，并添加了新的值组件。例如，<code>java.sql.Timestamp</code>对<code>java.util.Date</code>进行了扩展，并增加了<code>nanoseconds</code>域，<code>Timestamp</code>的<code>equals</code>实现确实违反了对称性，如果<code>Timestamp</code>和<code>Date</code>对象被用于同一个集合中，或者以其他方式被混合在一起，则会引起不正确的行为。<code>Timestamp</code>类有一个免责声明，告诫程序员不要混合使用<code>Date</code>和<code>Timestamp</code>对象。只要你不把它们混合在一起，就不会有麻烦，除此之外没有其他的措施可以防止你这么做，而且结果导致的错误将很难调试。<code>Timestamp</code>的这种行为是个错误，不值得仿效。</p>
<p>　　注意，你可以在一个抽象(<code>abstract</code>)类的子类中增加新的值组件，而不会违反<code>equals</code>约定。对于Item 23的建议“用类层次(<code>class hierarchies</code>)代替标签类(<code>tagged class</code>)”而得到的那种类层次结构来说，这一点非常重要。例如，你可能有一个抽象的<code>Shape</code>类，它没有任何值组件，<code>Circle</code>子类添加了一个<code>radiust</code>域，<code>Rectangle</code>子类添加了<code>length</code>和<code>width</code>域。只要不可能直接创建超类的实例，前面所述的种种问题就都不会发生。</p>
<ul>
<li><p>一致性(<code>consistency</code>)——<code>equals</code>约定的第四个要求是，如果两个对象相等，它们就必须始终保持相等，除非它们中有一个对象（或者两个都）被修改了。换句话说，可变对象在不同的时候可以与不同的对象相等，而不可变对象则不会这样。当你在写一个类的时候，应该仔细考虑它是否应该是不可变的（Item 17）。如果认为它应该是不可变的，就必须保证<code>equals</code>方法满足这样的限制条件：相等的对象永远相等，不相等的对象永远不相等。</p>
<p>  　　无论类是否是不可变的，都不要使<code>equals</code>方法依赖于不可靠的资源。如果违反了这条禁令，要想满足一致性的要求就十分困难了。例如，<code>java.net.URL</code>的<code>equals</code>方法依赖于对URL中主机IP地址的比较。将一个主机名转变成IP地址可能需要访问网络，随着时间的推移，不确保会产生相同的结果．这样会导致URL的<code>equals</code>方法违反<code>equals</code>约定，在实践中有可能引发一些问题。（遗憾的是，因为兼容性的要求，这一行为无法被改变。）除了极少数的例外情况，<code>equals</code>方法都应该对驻留在内存中的对象执行确定性的计算。</p>
</li>
<li><p>非空性(<code>Non-nullity</code>)——最后一个要求没有名称，我姑且称它为“非空性(<code>Non-nullity</code>)”，意思是指所有的对象都必须不等于<code>null</code>。尽管很难想像什么情况下<code>o.equals(null)</code>调用会意外地返回<code>true</code>，但是意外抛出<code>NullPointerException</code>异常的情形却不难想像。通用约定不允许抛出<code>NullPointerException</code>异常。许多类的<code>equals</code>方法都通过一个显式的null测试来防止这种情况:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    `<span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  　　这项测试是不必要的。为了测试其参数的等同性，<code>equals</code>方法必须先把参数转换成适当的类型，以便可以调用它的访问方法(<code>accessor</code>),或者访问它的域。在进行转换之前，<code>equals</code>方法必须使用<code>instanceof</code>操作符，检查其参数是否为正确的类型：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> MyType))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    MyType mt = (MyType) o;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  　　如果漏掉了这一步的类型检查，并且传递给<code>equals</code>方法的参数又是错误的类型，那么<code>equals</code>方法将会抛出<code>ClassCastException</code>异常，这就违反了<code>equals</code>的约定但是，如果<code>instanceof</code>的第一个操作数为<code>null</code>，那么，不管第二个操作数是哪种类型，<code>instanceof</code>操作符都指定应该返回<code>false</code>[JLS, 15.20.2]。因此，如果把<code>null</code>传给<code>equals</code>方法，类型检查就会返回<code>false</code>，所以不需要单独的<code>null</code>检查。</p>
</li>
</ul>
<p>　　结合所有这些要求，得出了以下实现高质量<code>equals</code>方法的诀窍：</p>
<p>　　1．<strong>使用==操作符检查“参數是否为这个对象的引用”</strong>。如果是，则返回<code>true</code>。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。</p>
<p>　　2．<strong>使用<code>instanceof</code>操作符检查“参數是否为正确的类型”</strong>。如果不是、则返回<code>false</code>。一般说来，所谓“正确的类型”是指<code>equals</code>方法所在的那个类。有些情况下，是指该类所实现的某个接口。如果类实现的接口改进了<code>equals</code>约定，允许在实现了该接口的类之间进行比较，那么就使用接口。集合接口(<code>collection interface</code>)如<code>Set</code>、<code>List</code>、<code>Map</code>和<code>MapEntry</code>具有这样的特性。</p>
<p>　　3．<strong>把参数转换成正确的类型</strong>。因为转换之前进行过<code>instanceof</code>测试，所以确保会成功。</p>
<p>　　4．<strong>对于该类中的每个“关键(<code>significant</code>)”域，检查参数中的域是否与该对象中对应的域相匹配</strong>。如果这些测试全部成功，则返回否則返回<code>false</code>。如果第2步中的类型是个接口，就必须通过接口方法访问参数中的域，如果该类型是个类，也许就能够直接访问参数中的域，这要取决干它们的可访问性。</p>
<p>　　对于既不是<code>float</code>也不是<code>double</code>类型的基本类型域，可以使用==操作符进行比较；对于对象引用域，可以递归地调用<code>equals</code>这方法；对于<code>float</code>域，可以使用<code>Float.compare</code>方法；对于<code>double</code>域，则使用<code>Double.compare</code>。对<code>float</code>和<code>double</code>域进行特殊的处理是有必要的，因为存在着<code>Float.NaN</code>、<code>-0.0f</code>及类似的<code>double</code>常量；详细信息请参考[JLS 15.21.1]或<code>Float.equals</code>的文档。对于数组域，则要把以上这些指导原则应用到每个元素上。如果数组域中的每个元素都很重要，就可以使用其中一个<code>Arrays.equals</code>方法。</p>
<p>　　有些对象引用域包含<code>null</code>可能是合法的，所以，为了避兔可能导致<code>NullPointerException</code>异常，则使用静态方法<code>Objects.equals(Object, Object)</code>来检查这样的域。</p>
<p>　　对干有些类，比如前面提到的<code>CaseInsensitiveString</code>类，域的比较要比简单的等同性测试复杂得多，如果是这种情况，可能会希望保存该域的一个“范式(<code>canonical form</code>)”，这样<code>equals</code>方法就可以根据这些范式进行低开销的精确比较，而不是高开销的非精确比较。这种方法对于不可变类（Item 17）是最为合适的；如果对象可能发生化，必须使其范式保持最新。</p>
<p>　　域的比较顺序可能会影响到<code>equals</code>方法的性能。为了获得最隹的性能，应该最先比较最有可能不一致的域，或者是开销最低的域，最理想的情况是两个条件同时满足的域，你不应该去比较那些不属于对象逻辑状态的域，例如用于同步操作的<code>Lock</code>域。也不需要比较冗余域(<code>redundant field</code>)，因为这些冗余域可以由“关键域”计算获得，但是这样做有可能提高<code>equals</code>方法的性能。如果冗余域代表了整个对象的综合描述，比较这个域可以节省当比较失败时去比较实际数据所需要的开销。例如，假设有一个<code>Polygon</code>类，并缓存了该区域。如果两个多边形有着不同的区域，就没有必要去比较它们的边和至高点。</p>
<p>　　5.<strong>当你编写完成了<code>equals</code>方法之后，应该问自己三个问题：它是否是对称的、传递的、一致的</strong>？并且不要只是自问，还要编写单元测试来检验这些特性！如果答案是否定的，就要找出原因，再相应地修改<code>equals</code>方法的代码。当然，<code>equals</code>方法也必须满足其他两个特性（自反性和非空性），但是这两种特性通常会自动满足。</p>
<p>　　下面是一个根据上面的诀窍构建的<code>equals</code>方法的具体例子，在一个简单的PhoneNumber类里面：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class with a typical equals method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> areaCode, prefix, lineNum;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhoneNumber</span><span class="params">(<span class="keyword">int</span> areaCode, <span class="keyword">int</span> prefix, <span class="keyword">int</span> lineNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.areaCode = rangeCheck(areaCode, <span class="number">999</span>, <span class="string">&quot;area code&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.prefix = rangeCheck(prefix, <span class="number">999</span>, <span class="string">&quot;prefix&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.lineNum = rangeCheck(lineNum, <span class="number">9999</span>, <span class="string">&quot;line num&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">short</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> max, String arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; <span class="number">0</span> || val &gt; max)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(arg + <span class="string">&quot;: &quot;</span> + val);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>) val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PhoneNumber))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        PhoneNumber pn = (PhoneNumber) o;</span><br><span class="line">        <span class="keyword">return</span> pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix</span><br><span class="line">                &amp;&amp; pn.areaCode == areaCode;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　下面是最后的一些告诚:</p>
<ul>
<li><p><strong>覆盖<code>equals</code>时总要覆<code>hashCode</code></strong>（Item 9）。</p>
</li>
<li><p><strong>不要企图让<code>equals</code>方法过于智能</strong>。如果只是简单地测试域中的值是否相等，则不难做到遵守<code>equals</code>约定。如果想过度地去寻求各种等价关系，则很容易陷人麻烦之中。把任何一种别名形式考虑到等价的范围内，往往不会是个好主意。例如，<code>File</code>类不应该试图把指向同一个文件的符号链接(<code>symbolic link</code>)当作相等的对象来看待。所幸<code>File</code>类没有这样做。</p>
</li>
<li><p><strong>不要将<code>equals</code>声明中的<code>Object</code>对象替换为其他的类型</strong>。程序员编写出下面这样的<code>equals</code>方法并不鲜见，这会使程序员花上数个小时都搞不清为什么它不能正常工作：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - parameter type must be Object!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(MyClass o)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  　　问题在于，这个方法并没有覆盖<code>Object.equals</code>，因为它的参数应该是<code>Object</code>类型，相反，它重载(<code>overload</code>)了<code>Object.equals</code>（Item 52）。在原有<code>equals</code>方法的基础上，再提供一个“强类型(<code>strongly typed</code>)”的<code>equals</code>方法，即使这两个方法返回同样的结果（没有强制的理由必须这样做），这也是不可以接受的。因为它能导致<code>@Override</code>注解在子类生成误报并提供错误的安全感。</p>
<p>  　　<code>@Override</code>注解的用法一致，就如本条目中所示，可以防止犯这种错误（Item 40）。这个<code>equals</code>方法不能编译，错误消息会告诉你到底哪里出了问题：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Still broken, but won’t compile</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(MyClass o)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  　　编写和测试<code>equals</code>（和<code>hashCode</code>）方法很繁琐，结果代码很平常。手动编写和测试这些方法的一个很好的替代方法是使用Google的开源<code>AutoValue</code>框架，该框架会自动为您生成这些方法，由类中的单个注释触发。在大多数情况下，<code>AutoValue</code>生成的方法与您自己编写的方法基本相同。</p>
<p>  　　IDE也有生成<code>equals</code>和<code>hashCode</code>方法的工具，但生成的源代码比使用<code>AutoValue</code>的代码更冗长，更不易读，不会自动跟踪类中的更改，因此需要测试。也就是说，让IDE生成<code>equals</code>（和<code>hashCode</code>）方法通常比手动实现它们更可取，因为IDE不会造成粗心的错误，大多数人也会这样做。</p>
<p>  　　总之，不要覆盖<code>equals</code>方法，除非你必须：在许多情况下，从<code>Object</code>继承的实现完全符合您的要求。如果你确实覆盖了<code>equals</code>，请确保比较所有类的重要字段，并以保留<code>equals</code>约定的所有五个条款的方式对它们进行比较。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 3</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item4 通过私有的构造方法来阻止类的实例化</title>
    <url>/2018/12/06/Effective-Java-Item4-%E9%80%9A%E8%BF%87%E7%A7%81%E6%9C%89%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9D%A5%E9%98%BB%E6%AD%A2%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96/</url>
    <content><![CDATA[<p>有时，你想要编写一个只包含一组静态方法和静态字段的类。这种类有一个不太好的名声，因为有些人会滥用他们，不从对象的角度来思考，而是坚信他们的想法是正确无误的 。他们可以把原生类型的值或数组相关的方法分一组，就像<code>java.lang.Math</code>或<code>java.util.Arrays</code>的方式。还可以将静态方法划分到一起，包括工厂（Item 1），用于实现了某个接口的对象，就想<code>java.util.Collections</code>一样。（从Java 8开始，如果想要自己修改，那么你还可以将这类方法放到接口中）最后，还可以将针对终态类的方法划分到一起，因为你无法再将他们放到子类中了 。</p>
<span id="more"></span>

<p>把这样的公共类设计成不可实例化，是因为它的实例化是没有意义地。然而，在没有显式构造函数的情况下，编译器提供一个公共的、无参数的默认构造函数。对使用者来说，这个构造函数跟其它的没什么区别。我们常常会在已发布的APIs中看到无意中被实例化的类 。</p>
<p><strong>通过将一个类设置为抽象类来强制禁止类的实例化是行不通的</strong>。这个抽象类可以有子类，然后子类可以实例化。而且这会误导使用者去想要去设计一个类，然后继承这个抽象类（Item 19）。然后这里有一个简单的做法来保证非实例化。只有在类不包含显示构造函数时候，默认的构造函数才会生成。所以，一个类可以通过提供私有的构造函数来做到非实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Noninstantiable utility class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UtilityClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Suppress default constructor for noninstantiability</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UtilityClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为显示指定构造函数是私有的，所有无法在类外面访问到。<code>AssertionError</code>不是必须的，但它提供了一个保障，防止构造函数在类的内部被意外调用。它保证了类在任何情况都不会被实例化。这种做法有点反常识，因为提供构造方法的目的仅仅是为了自己不能被调用 。所以，更好的做法则是加上一些注释说明，正如上述代码所做的那样。</p>
<p>这样做的副作用是，阻止了类被子类化。所有构造函数都必须显式或隐式地调用父类构造函数，但是子类将没有可访问的父类构造函数来调用。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item5 优先使用依赖注入而非硬编码资源的关联关系</title>
    <url>/2018/12/07/Effective-Java-Item5-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%80%8C%E9%9D%9E%E7%A1%AC%E7%BC%96%E7%A0%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>很多类都会依赖于一个或多个底层资源。比如说，拼写检查器会依赖于字典。我们常常会看<br>到这种类被实现为了静态辅助类（Item 4）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inappropriate use of static utility - inflexible &amp; untestable!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lexicon dictionary = ...;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// Noninstantiable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">suggestions</span><span class="params">(String typo)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>同样地，将他们以单例的形式来实现也很常见(Item 3)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inappropriate use of singleton - inflexible &amp; untestable!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lexicon dictionary = ...;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">(...)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> INSTANCE = <span class="keyword">new</span> SpellChecker(...);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">suggestions</span><span class="params">(String typo)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方法都不令人满意，因为它们假定只有一个字典值得使用。实际上，每种语言都有自己的字典，特殊的字典用于特殊的词汇表。此外，我们还需要一个特殊的字典用于测试。想当然地认为一本字典就足够了，这是一厢情愿的想法。</p>
<p>你可以尝试让<strong>拼写检查器</strong>支持多个字典，方法是使<code>dictionary</code>字段成为非<code>final</code>类型，并在现有的拼写检查器中添加一个方法来更改<code>dictionary</code>的引用，不过这么做有些笨拙、易出错，并且在并发设置下无法正常工作。<strong>如果一个类的行为是通过底层资源来参数化的，那么静态辅助类与单例就不适合这种情况</strong>。</p>
<p>我们所需要的是支持类的多个实例的能力(在我们的例子中，<code>SpellChecker</code>)，每个实例都使用客户机所希望的资源(在我们的例子中，是字典)。满足此需求的一个简单模式是在<strong>创建新实例时将资源传递给它的构造函数</strong>。这是依赖注入的一种形式：字典是拼写检查器器的依赖，在创建拼写检查器时会将字典注入到其中 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dependency injection provides flexibility and testability</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lexicon dictionary;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Lexicon dictionary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dictionary = Objects.requireNonNull(dictionary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">suggestions</span><span class="params">(String typo)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依赖注入模式如此简单，以至于许多程序员使用了多年，却不知道它的名字。 虽然我们的拼写检查的示例只有一个资源(字典)，但是依赖项注入可以处理任意数量的资源和任意依赖图。它保持了不可变性(Item 17)，因此多个客户机可以共享依赖对象(假设客户机需要相同的底层资源)。依赖项注入同样适用于构造函数、静态工厂(Item 1)和构建器(Item 2)。</p>
<p>这个模式的有一个有用的变换是将资源工厂传递给构造函数。工厂是一个对象，可以反复调用它来创建同一类型的实例。这些工厂体现了一种设计模式，即<strong>工厂方法模式</strong>。Java 8中引入的<code>Supplier&lt;T&gt;</code>接口非常适合表示工厂。将<code>Supplier&lt;T&gt;</code>作为输入的方法会通过绑定的<strong>通配符类型</strong>（item 31）来限制工厂的类型参数。比如说，如下方法会通过客户端提供的用于生成每个瓷砖的工厂来创建一个马赛克：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Mosaic <span class="title">create</span><span class="params">(Supplier&lt;? extends Tile&gt; tileFactory)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>尽管依赖注入极大地提高了灵活性和可测试性，但它可能会使大型项目变得混乱，而大型项目通常包含数千个依赖项。如果我们使用依赖注入框架(如Dagger [Dagger]、Guice [Guice]或Spring [Spring])，几乎可以消除这种混乱。这些框架的使用介绍超出了本书的范围，不过请注意，针对手工进行依赖管理所设计的APIs也是适合于这些框架的 。</p>
<p>总结一下，如果一个类依赖于一个或多个底层资源，而这些资源的行为会影响到类的行为，那么请不要使用单例或是静态辅助类来实现，也不要让类直接创建这些资源。替代的方法是，将该资源或生产这个资源的工厂传递给构造方法(或者是静态工厂或者是构建器)。这种实践叫做依赖注入，它会极大增强类的灵活性、重用性与可测试性。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item6 避免创建不必要的对象</title>
    <url>/2018/12/07/Effective-Java-Item6-%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>在需要一个对象时，恰当的做法是尽可能重用这个对象而非创建一个功能完全一样的新对象。重用既比较快又比较流行。如果一个对象是不可变的(Item 17)，那么它总是可以被重用的。</p>
<span id="more"></span>

<p>作为一个绝对不要这么做的极端示例，考虑如下语句：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;bikini&quot;</span>); <span class="comment">// DON&#x27;T DO THIS!</span></span><br></pre></td></tr></table></figure>

<p>这个语句在每次执行时都会创建一个新的字符串实例，而这些对象创建其实都是不必要的。<code>String</code>构造方法的参数(“<code>bikini</code>“)本身就是个<code>String</code>实例，与构造函数创建的所有对象功能相同。如果这种用法出现在一个循环语句中或一个被频繁调用的方法中，那么可能会创建百万个没必要的<code>String</code>实例。</p>
<p>改进后的版本简单如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;bikini&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这个版本使用单个的字符串实例，而不是每次执行时创建一个新的。此外，它还确保了运行在同一个虚拟机中并且包含了相同字符串字面值的其他代码能够重用该对象 。如果不变类既提供了静态工厂方法（Item 1），也提供了构造方法，那么你就可以通过前者来避免创建不必要的对象。例如，工厂方法<code>Boolean.valueOf(String)</code>比构造函数<code>Boolean(String)</code>更可取，后者在Java 9中已经被弃用。每一次调用构造方法，一定会创建一个新的对象，然而工厂方法完全没必要这么做，而且实践当中也不会这么做。除了重用不可变对象之外，如果你知道不会修改这个可变对象，那么你也可以重用这个可变对象。</p>
<p>有些对象创建要比其他对象昂贵得多。如果你以后会反复需要这样一个“昂贵的对象”，那么最好将其缓存以供重用。不幸的是，在创建这样的对象时，并不总是显而易见的。假设你想写一个方法来确定字符串是否是有效的罗马数字。这里有个最简单的方法就是，使用正则表达式来做这件事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Performance can be greatly improved!</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span></span><br><span class="line">            + <span class="string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现的问题在于它依赖于<code>String.matches</code>方法。<strong>虽然<code>String.matches</code>是检查一个字符串是否匹配这个正则表达式最简单的方法，但是在性能要求苛刻的场景下，他并不适合重复使用</strong>。这样做的问题是，它会在内部为正则表达式创建一个<code>Pattern</code>实例，并且仅仅使用它一次，之后它就可以进行垃圾收集了。创建一个<code>Pattern</code>实例非常昂贵，因为它需要将正则表达式编译成一个有限状态机。</p>
<p>为了改进性能，请在类的初始化过程中手动将正则表达式编译为<code>Pattern</code>实例（它是不可变的），然后将其缓存起来，并在每次调用<code>isRomanNumeral</code>方法时重用这个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reusing expensive object for improved performance</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RomanNumerals</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern ROMAN = Pattern.compile(<span class="string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span></span><br><span class="line">    		+ <span class="string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">   	 	<span class="keyword">return</span> ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进版本的<code>isRomanNumeral</code>在频繁调用的情况下极大提升了性能 。在我的机器上，当输入长度为8的字符串时，第一版的方法执行了1.1微秒，而改进版的方法执行了0.17微秒，比原来快了6.5倍。不仅性能得到了改善，而且可以认为代码也变得更清晰了。使用一个静态<code>final</code>字段来表示原本不可见的Pattern的实例，这样允许我们给这个字段取个名字，这样做比正则表达式本身可读性高多了。</p>
<p>如果包含改进版的<code>isRomanNumeral</code>方法的类被初始化了，但是没有主动调用这个方法，那么字段<code>ROMAN</code>依然会被没必要地初始化。当第一次调用<code>isRomanNumeral</code>方法时，我们可以通过惰性初始化字段的方法来消除上面的没必要地初始化。但是不推荐这样做。因为对于延迟初始化来说，它常常会导致实现变得复杂，并且不能带来很大的性能提升。当一个对象是不可变的时，很明显它可以安全地被重用，但是在其他情况下，它就不那么明显了，甚至是违反直觉的。考虑适配器的情况，也称为视图。所谓适配器，指的是委托给支撑对象的对象，并提供了另外的接口。由于适配器除了支撑对象的状态外，它自身是没有状态的，因此对于给定的对象来说，没必要为其创建多个适配器实例 。</p>
<p>例如，<code>Map</code>接口的<code>keySet</code>方法返回<code>Map</code>对象的<code>Set</code>视图，其中包含映射中的所有键。直觉上，似乎每个对<code>keySet</code>的调用都必须创建一个新的<code>Set</code>实例，不过实际情况却是，每次调用给定<code>Map</code>对象的<code>keySet</code>都只会返回同一个<code>Set</code>实例 。虽然返回的Set实例通常是可变的，但所有返回的对象在功能上是相同的: 当其中一个返回的对象发生更改时，其他的对象也会发生变化，因为它们都是由同一个<code>Map</code>实例支持的。虽然创建<code>keySet</code>视图对象的多个实例基本上是无害的，但它是不必要的，没有任何好处。</p>
<p>另一种创建不必要对象的方法是自动装箱 ，它允许程序员把原生类型和原生类型的包装类混合用，并且会根据需要自动地拆箱和装箱。<strong>自动装箱使原生类型和包装类之间界限变得模糊，但是并没有消除原生类型和原生类型的包装类之间的区别</strong>。这里存在一些微小的语义上的差别以及稍微有点大的性能上的差别（Item 61)。考虑如下方法，它会计算所有正整型int值的和。为了做到这一点，程序需要使用<code>long</code>运算，因为<code>int</code>不足以容纳所有正整型<code>int</code>值的和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hideously slow! Can you spot the object creation?</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">    	sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序会得到正确的答案，不过要比预计慢很多，原因在于一个字符拼写上的错误 。变量sum被声明为Long型而不是long型，这就意味着这个程序要构造2^31个不必要的<code>Long</code>实例（大概每一次<code>long</code>型<code>i</code>与<code>Long</code>类型的<code>sum</code>相加都会创建一个实例）。在我的机器上，将<code>sum</code>声明由<code>Long</code>改为<code>long</code>则会将运行时间由6.3s减少到0.59s。这个例子很清楚：<strong>相对包装类型，优先使用原生类型，并且注意无意识地自动装箱</strong>。</p>
<p>不应该误解该条款，以为对象创建是非常昂贵的，应该避免。相反地，小对象的创建和回收是廉价的，因为他们的构造函数没有做什么明显的工作，特别是在现代JVM实现中 。创建额外的对象来增强程序的清晰度、简单性或程序的能力通常是一件好事。相反，除非池中的对象非常重量级，否则通过维护自己的对象池来避免对象创建是一个坏主意。真正需要对象池的对象的一个典型示例就是数据库连接。建立连接的成本非常高，因此重用这些对象是有意义的。然而，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代JVM实现具有高度优化的垃圾收集器，它们在轻量级对象上轻松胜过此类对象池。 </p>
<p>与本条款对应的是关于<strong>防御式拷贝</strong>的Item 50。当前的条款说，“当应该重用一个已经存在的对象时，就不应该创建新的对象”。然而，第50条说，“当您应该创建一个新的对象时，不要重用现有的对象。”注意，在需要进行防御性复制时重用对象的惩罚远远大于不必要地创建重复对象的惩罚。如果不能在需要的地方创建防御复制，可能会导致潜在的bug和安全漏洞;而不必要地创建对象只会影响样式和性能。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item9 优先使用“try-with-resources”来代替“try-finally”</title>
    <url>/2018/12/07/Effective-Java-Item9-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E2%80%9Ctry-with-resources%E2%80%9D%E6%9D%A5%E4%BB%A3%E6%9B%BF%E2%80%9Ctry-finally%E2%80%9D/</url>
    <content><![CDATA[<p>Java库包含许多必须通过手动调用<code>close</code>方法关闭的资源。其中包括：<code>InputStream</code>，<code>OutputStream</code>和<code>java.sql.Connection</code>。关闭资源常常会被客户端所忽视，这会导致可怕的性能问题。虽然很多资源使用了终结器来作为安全网，不过终结器却并不那么尽如人意（Item 8）。</p>
<span id="more"></span>

<p>纵观历史，<code>try-finally</code>语句是保证资源被正确关闭的最好方法，即便在遇到异常或是返回语句时亦如此：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try-finally - No longer the best way to close resources!</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> br.readLine();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		br.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来还不错，不过当添加了第二个资源时情况就变得有些糟糕了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try-finally is ugly when used with more than one resource!</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     InputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">	 OutputStream out = <span class="keyword">new</span> FileOutputStream(dst);</span><br><span class="line">	 <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">	     <span class="keyword">int</span> n;</span><br><span class="line">	     <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">		 out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">	 &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	     out.close();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	 in.close();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可能难以置信，但即使是优秀的程序员也有犯这个错误的时候。对于初学者来说，我在<strong>Java Puzzlers</strong>[Bloch05]的第88页指出了问题，但多年来没人注意到。事实上，2007年，在Java库中对<code>close</code>方法的使用有2/3是错误的。</p>
<p>即使使用<code>try-finally</code>语句关闭资源的正确代码(如前两个代码示例所示)也有一个细微的缺陷。<code>try</code>块和<code>finally</code>块中的代码都能够抛出异常。例如，在<code>firstLineOfFile</code>方法中，由于底层物理设备发生故障，对<code>readLine</code>的调用可能会抛出异常，而<code>close</code>的调用也可能出于同样的原因而失败。在这种情况下，第二个异常完全把第一个异常给覆盖了。异常堆栈跟踪中没有第一个异常的记录，这可能会使实际系统中的调试变得非常复杂——通常这是你希望看到的第一个异常，以便诊断问题。虽然可以通过编写代码来抑制第二个异常而支持第一个异常，但实际上没有人会这样做，因为它太过啰嗦。</p>
<p>当Java 7引入了<code>try-with-resources</code>语句[JLS，14.20.3]时，所有这些问题都被一举解决了。要想使用这个结构，资源必须实现<code>AutoCloseable</code>接口，该接口包含了唯一一个返回<code>void</code>类型的<code>close</code>方法。现在Java库和第三方库中的许多类和接口去实现或继承了<code>AutoCloseable</code>接口。如果你要编写一个代表必须关闭的资源的类，那么你的类也应该实现<code>AutoCloseable</code>接口。</p>
<p>如下代码使用<code>try-with-resources</code>改写了上面第一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try-with-resources - the the best way to close resources!</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line">    	<span class="keyword">return</span> br.readLine();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下代码使用<code>try-with-resources</code>改写了上面第二个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try-with-resources on multiple resources - short and sweet</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">    		OutputStream out = <span class="keyword">new</span> FileOutputStream(dst)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">        	out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与以前的版本相比，<code>try-with-resources</code>版本不仅更短，可读性更好，而且提供了更好的诊断。仔细想想<code>firstLineOfFile</code>方法。如果<code>firstLineOfFile</code>和<code>close</code>方法（不可见）都抛出了异常，则后一个异常将被抑制，来支持前一个异常。 实际上，可能会抑制多个异常，而保留你实际希望看到的异常。这些被压制的异常并不是被丢弃掉；它们会被打印到堆栈信息里，并用一个标记来说明它们是被抑制的。在程序中你可以用<code>getSuppressed</code>方法来访问它们，该方法是在Java 7中被添加到<code>Throwable</code>中的。</p>
<p>你可以将<code>catch</code>从句放到<code>try-with-resources</code>语句上，就像在正常的<code>try-finally</code>语句中那样。这样就可以在处理异常的同时又不会在另一个嵌套层次上搞乱代码了。举个例子，举个例子下面是不抛出异常的<code>firstLineOfFile</code>方法版本，不过如果无法打开文件或是无法读取文件，那么它会接收一个默认值来返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/ <span class="keyword">try</span>-with-resources with a <span class="keyword">catch</span> clause</span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path, String defaultVal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line">    	<span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    	<span class="keyword">return</span> defaultVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论很明显：当使用了必须关闭的资源时，总是优先使用<code>try-with-resources</code>，来代替<code>try-finally</code>。结果代码更短、也更清晰，它所生成的异常也更加有用。<code>try-with-resources</code>语句使得编写使用了必须要关闭的资源的代码更加轻松，而这是<code>try-finally</code>所做不到的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item8 避免使用终结器与清理器</title>
    <url>/2018/12/07/Effective-Java-Item8-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%BB%88%E7%BB%93%E5%99%A8%E4%B8%8E%E6%B8%85%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p><strong>终结器是不可预测的、常常会很危险，而且通常没必要。使用终结器会导致奇怪的行为、孱弱的性能以及可移植性问题</strong>。终结器有一些有效的用途，我们将在后面的条款中介绍，但是作为一个规则，你应该避免他们。在Java 9中，终结器已经被弃用，但是Java库仍然在使用它们。Java 9中，替代终结器的是清除器（<strong>cleaner</strong>）。<strong>清除器比终结器危险小，但仍然不可预测、效率慢，而且通常没有必要</strong>。 </p>
<span id="more"></span>

<p>C++程序员们不要将Java中的终结器或是清理器当作是C++中的析构函数。在C++中，析构函数是回收与对象所关联的资源的常规方式，它是与构造函数必要的一个对应之物。 在Java中，当与对象所关联的存储变得不可达时，垃圾收集器就会将其回收，不需要程序员做任何额外的事情。 c++析构函数也可以用于回收其他非内存资源。在Java中，<code>try-with-resources</code>或<code>try-finally</code>代码块就是用于此目的(Item 9)。</p>
<p>终结器与清理器的一个缺点在于，没有人可以保证他们会立刻执行[JLS, 12.6]。在对象变得不可及与终结器或是清理器开始运行之间可能会间隔任意长的时间。这意味着你永远不要在终结器或是清理器中做任何时间关键的事情。例如，依赖于终结器或清除器来关闭文件就是一个严重的错误，因为打开的文件描述符是有限的资源。如果由于系统运行终结器或是清理器产生了延迟而导致很多文件处于打开的状态，那么程序就有可能失败，因为它无法再打开文件了。</p>
<p>到底哪个终结器和清理器会执行主要是由垃圾回收算法来决定的，而算法在不同的实现间存在着较大的差别 。依赖于终结器或是清理器的立刻执行的程序行为也存在着较大的差别。因此，同样一个程序在你测试的JVM中完美运行，然后却在你最重要的客户上的机器上不幸地失败了，这种情况是完全有可能发生的。</p>
<p>终结器不会立刻执行并不仅仅是个理论上的问题 。为类提供终结器可能会随意地延迟自己的实例的回收。一位同事调试了一个长期运行的GUI应用程序，该应用程序因<code>OutOfMemoryError</code>而奇怪地崩溃过。分析显示，在应用程序崩溃的时候，它的终结器队列中有数千个图形对象等待被终结并回收。遗憾的是，终结器运行所在的线程要比另一个应用线程的优先级低，这样对象被终止的速度远远跟不上其进入到终止状态的速度。Java语言规范没有明确说明哪个线程将执行终结器，因此除了避免使用终结器之外，没有其他更方便的方法来防止这类问题。这个问题上，清洁器在这方面要比终结器好一些，因为类的创建者可以控制自己的清洁器线程，不过，清洁器依然运行在后台，在垃圾收集器的控制之下，因此对于立刻清洁这个问题也没有提供任何保证。</p>
<p>规范不仅没有提供终结器或是清理器会立刻运行的保证，也没有对其一定会运行提供任何保证。完全有可能出现这样的情况，当程序终止时，它并没有对早就处于不可达的对象运行其终结器和清理器。因此，你<strong>永远都不应该依赖于终结器或是清理器来更新持久化状态</strong>。比如说，依赖于终结器或是清理器来释放如数据库等共享资源上的持久化锁可能会导致整个分布式系统陷入瘫痪状态。</p>
<p>不要被<code>System.gc</code>和<code>System.runFinalization</code>方法所诱惑。它们可能会增加终结器或清除器被执行的几率，但他们并不能保证一定如此。曾经有两个方法做过这个保证：<code>System.runFinalizersOnExit</code>及其搭档<code>Runtime.runFinalizersOnExit</code>。这两个方法存在严重的问题，早就已经不建议使用了[ThreadStop]。</p>
<p>终结器的另一个问题是在执行终结时，未捕获的异常会被忽略掉，这时对象的终结会被终止[JLS, 12.6]。未捕获的异常会导致其他对象的状态被破坏掉。如果另一个线程试图使用这样一个已损坏的对象，则可能导致任意的不确定性行为。正常情况下，未捕获的异常会终止线程并打印堆栈信息，但如果在终结器中就不会这样——它甚至不会打印出任何警告信息。清理器不存在这个问题，因为使用了清理器的库会自己控制其线程。。</p>
<p><strong>使用终结方法和清除方法会有严重的性能损失</strong>。在我的机器上，创建一个简单的<code>AutoCloseable</code>对象，使用<code>try-with-resources</code>关闭它，然后让垃圾收集器对其进行回收，大约需要花费12ns。使用终结器可以将时间增加到550纳秒。换句话说，使用终结器创建和销毁对象的速度要慢50倍。这主要是因为终结器阻碍了高效的垃圾回收。如果使用清理器来清除类的所有实例（在我的机器上每个实例大约需要花费500ns），它在速度上与终结器大致相同；不过，如果只是将清理器作为一个安全网（后续将会介绍），那么其速度将会快很多。如下所述。在这些情况下，我的机器上创建、清理与销毁一个对象所花费的时间大约需要66ns，这意味着你为安全网的使用需要付出5倍因子（不是50倍）的代价。</p>
<p><strong>终结方法有一个严重的安全问题：他们会使你的类遭遇到终结器攻击</strong>。终结器攻击背后的想法非常简单：如果异常是从构造方法或是序列化方法<code>readObject</code>与<code>readResolve</code>中抛出的（chapter 12），那么恶意的子类终结器就会运行在部分构建完毕的对象上，而这个对象本应该『中途夭折的』。这个终结器会将对对象的引用记录在一个静态字段中，防止其被垃圾回收掉。一旦将这个不完整的对象记录下来后，我们就可以轻松调用这个对象上的任意方法，而这个对象原本是不应该存在的。<strong>从构造方法中抛出异常足以禁止对象的创建；但在使用终结器的情况下，却并非如此</strong>。 这种攻击还会产生非常严重的后果。终态类不受终结器攻击的影响，因为没人可以创建终态类的恶意子类。若想保护非终态类免受终结器攻击，<strong>请编写一个什么都不做的<code>final</code>的<code>finalize</code>方法</strong>。</p>
<p>那么，对于封装了需要终止的资源（如文件或是线程）的对象来说，如果不为类编写终结器或是清理器，那该怎么办呢？只需让类实现<code>AutoCloseable</code>即可，并让其客户端在不需要其实例时调用其<code>close</code>方法，通常我们会使用<code>try-with-resources</code>来确保终止，即便在异常的情况下亦如此（Item 9）。值得提及的一个细节是，实例必须要追踪其是否已经关闭了：<code>close</code>方法必须要在一个字段中记录下对象已经不再有效了，其他方法则必须要检查该字段，如果当对象已经关闭后还调用这些方法，那就需要抛出<code>IllegalStateException</code>异常。</p>
<p>那么，清理器与终结器到底有什么好处呢？他们有两个合理的用途。一是作为安全网，防止资源所有者忘记调用其<code>close</code>方法。虽然没人能够保证清理器或是终结器会立刻运行（或是否运行），不过如果客户端忘记释放资源，那么迟做总比不做强。如果考虑编写这样的安全网终结器，那么请仔细考虑，这种保护是否真的值得。一些Java库类（如<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>ThreadPoolExecutor</code>及<code>java.sql.Connection</code>）都将终结器作为安全网。</p>
<p>清理器的第二个合理使用场景与拥有本地对端（<code>native peers</code>）的对象有关。所谓本地对端指的是本地对象（非Java对象），常规对象通过本地方法将调用委托给它由于本地对端并非常规对象，因此垃圾收集器并不知晓它，当其Java对端被回收时，也并不会对其进行回收。清理器或是终结器是完成这个任务的恰当工具，假设性能是可接受的，并且本地对端并没有持有关键资源。如果性能是不可接受的，或是本地对端持有必须要立刻回收的资源，那么类就应该拥有一个<code>close</code>方法，如前所示。</p>
<p>清理器的使用有一些棘手。如下是个简单的<code>Room</code>类，演示了其使用方式。假设房间在被回收前必须要清理。<code>Room</code>类实现了<code>AutoCloseable</code>；其自动清理安全网使用了清理器这个事实只不过是个实现细节而已。与终结器不同，清理器不会污染类的公有API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An autocloseable class using a cleaner as a safety net</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cleaner cleaner = Cleaner.create();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Resource that requires cleaning. Must not refer to Room!</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numJunkPiles; <span class="comment">// Number of junk piles in this room</span></span><br><span class="line">        </span><br><span class="line">        State(<span class="keyword">int</span> numJunkPiles) &#123;</span><br><span class="line">            <span class="keyword">this</span>.numJunkPiles = numJunkPiles;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Invoked by close method or cleaner</span></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Cleaning room&quot;</span>);</span><br><span class="line">            numJunkPiles = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The state of this room, shared with our cleanable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> State state;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Our cleanable. Cleans the room when it’s eligible for gc</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cleaner.Cleanable cleanable;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Room</span><span class="params">(<span class="keyword">int</span> numJunkPiles)</span> </span>&#123;</span><br><span class="line">        state = <span class="keyword">new</span> State(numJunkPiles);</span><br><span class="line">        cleanable = cleaner.register(<span class="keyword">this</span>, state);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类<code>State</code>持有清洁器清洁房间所需的资源。在这个例子中，资源就是字段<code>numJunkPiles</code>，表示房间中的混乱程度。更为现实的情况，它可以是个<code>final long</code>字段，包含着一个指针，指向了本地对端。<code>State</code>实现了<code>Runnable</code>，其<code>run</code>方法至多会被<code>Cleanable</code>调用一次，<code>Cleanable</code>则是我们在<code>Room</code>构造方法中将<code>State</code>实例注册到清理器上所得到的。对<code>run</code>方法的调用会被两个动作所触发：通常，它会被<code>Room</code>的<code>close</code>方法调用，<code>close</code>方法又会调用<code>Cleanable</code>的<code>clean</code>方法。如果在<code>Room</code>实例可以被垃圾回收时，客户端没有调用<code>close</code>方法，那么清理器就会（希望如此）调用<code>State</code>的<code>run</code>方法。</p>
<p><code>state</code>实例不持有对它的<code>Room</code>实例的引用，这一点很重要。如果它持有引用，那么它会创造一个死循环，阻止<code>Room</code>实例被垃圾收集器回收（以及自动清理）。因此，<code>State</code>必须是一个静态内部类，因为非静态内部类包含对其外部类实例的引用(item 24)。同样不建议使用<code>lambda</code>，因为它们可以很容易地捕获对外部类对象的引用。 </p>
<p>如前所述，<code>Room</code>的清理器只用作安全网。如果客户端在<code>try-with-resource</code>块中完成了所有的<code>Room</code>实例化动作，那么自动化清理就永远不需要了。如下行为良好的客户端演示了该行为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adult</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Room myRoom = <span class="keyword">new</span> Room(<span class="number">7</span>)) &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;Goodbye&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所想，运行<code>Adult</code>程序会打印出<code>Goodbye</code>，然后是<code>Cleaning room</code>。不过，下面这个有问题的程序呢，它永远不会清理房间？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teenager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">new</span> Room(<span class="number">99</span>);</span><br><span class="line">    	System.out.println(<span class="string">&quot;Peace out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能觉得它会打印出<code>Peace out</code>，然后是<code>Cleaning room</code>，不过在我的机器上，它永远不会打印出<code>Cleaning room</code>；它只不过退出了而已。这就是我们之前提到的不可预测性。<strong>Cleaner</strong>规范说到：『在<code>System.exit</code>时清理器的行为是特定于实现的』。没有人可以保证清理动作是否会被调用。虽然规范没这么说，但对于正常的程序退出来说就是如此。在我的机器上，往<code>Teenager</code>类的<code>main</code>方法里添加一行<code>System.gc()</code>，能让程序在退出前打印“<code>Cleaning room</code>”，但是不保证在你的机器上就能看到相同的结果。</p>
<p>总结一下，不要使用清理器，或者说不要在Java 9之前的版本使用终结器，除非将其作为安全网或是用来终止不重要的本地资源。即便如此，也请小心其不确定性和性能影响。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git开发规范</title>
    <url>/2019/12/20/Git%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h3 id="分支介绍及命名规则"><a href="#分支介绍及命名规则" class="headerlink" title="分支介绍及命名规则"></a>分支介绍及命名规则</h3><h4 id="master-分支"><a href="#master-分支" class="headerlink" title="master 分支"></a><strong>master 分支</strong></h4><ul>
<li>master 为主分支，也是用于部署生产环境的分支，一定要确保master分支稳定性</li>
<li>master 分支一般从develop或bugfix分支合并，任何时间都不能直接修改master分支的代码</li>
</ul>
<h4 id="develop-分支"><a href="#develop-分支" class="headerlink" title="develop 分支"></a><strong>develop 分支</strong></h4><ul>
<li>develop 为开发分支，始终保持最新完成以及bug修复后的代码，</li>
<li>一般开发的新功能时，feature分支都是基于develop分支下创建的</li>
</ul>
<h4 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a><strong>feature 分支</strong></h4><ul>
<li>feature 为开发新功能时创建的分支，并且一般是由develop为基础来创建feature分支</li>
<li>分支命名: feature/ 开头的为特性分支， 命名示例: feature/user_module、 feature/vacation_plan_module</li>
</ul>
<span id="more"></span>

<h4 id="release-分支"><a href="#release-分支" class="headerlink" title="release 分支"></a><strong>release 分支</strong></h4><ul>
<li>release 为预上线分支，发布提测阶段，会以release分支代码为基准提测，因为项目组实际情况，人数不够的情况下可以不需要此分支。</li>
</ul>
<h4 id="bugfix-分支"><a href="#bugfix-分支" class="headerlink" title="bugfix 分支"></a><strong>bugfix 分支</strong></h4><ul>
<li>bugfix 为修复分支，它的命名规则与 feature 分支类似，例如bugfix/xxx</li>
<li>线上出现紧急问题时，需要及时修复，以master或develop分支为基线，创建bugfix分支，修复完成后，需要合并到master分支和develop分支</li>
</ul>
<h3 id="操作步骤及命令"><a href="#操作步骤及命令" class="headerlink" title="操作步骤及命令"></a>操作步骤及命令</h3><h4 id="管理员「项目负责人」创建master及develop分支"><a href="#管理员「项目负责人」创建master及develop分支" class="headerlink" title="管理员「项目负责人」创建master及develop分支"></a>管理员「项目负责人」创建master及develop分支</h4><p>一般master分支在创建项目是会默认创建，现在只需要创建develop分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b develop #git checkout命令加上-b参数表示创建并切换，相当于git branch develop与git checkout develop</span><br></pre></td></tr></table></figure>

<p>用<code>git branch</code>命令查看当前分支，命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* develop</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>

<h4 id="项目成员「开发者」clone-项目，在本地建立自己的功能分支"><a href="#项目成员「开发者」clone-项目，在本地建立自己的功能分支" class="headerlink" title="项目成员「开发者」clone 项目，在本地建立自己的功能分支"></a>项目成员「开发者」clone 项目，在本地建立自己的功能分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone &lt;项目 git 地址&gt;</span><br><span class="line">git checkout -b develop origin/develop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建本地功能分支</span></span><br><span class="line">git checkout -b feature/[feature-name] develop</span><br></pre></td></tr></table></figure>

<p>在自己的本地feature分支上进行开发 ： <code>git add</code> ，<code>git commit</code> 等，注意此时不要 push 到远程分支（origin）。</p>
<p>功能完成后可以直接合并本地的 <code>feature</code> 分支到本地的 <code>develop</code> 分支后 push 到远程仓库，合并的时候很大几率发生冲突，此时需要 <code>merge</code> ，<code>merge</code> 的时候确保不影响项目其他成员，如果多个人都操作了同一个类，最好当面确认后在进行修改。等合并完成确认无误后，删除本地开发分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout develop </span><br><span class="line">git pull origin develop #确保本地 developer 分支为最新的</span><br><span class="line">git merge feature/[feature-name] #合并本地的 `feature` 分支到本地的 `develop` 分支</span><br><span class="line">git push #确保你当前在develop分支下面push</span><br><span class="line">git branch -d feature/[feature-name] #删除本地分支</span><br></pre></td></tr></table></figure>

<h4 id="发布分支"><a href="#发布分支" class="headerlink" title="发布分支"></a>发布分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b release-0.1 develop #从develop分支迁出预发布分支</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">一旦准备好了发版，合并修改到 master 分支和 developer 分支上，删除发布分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash">合并修改到 master 分支</span></span><br><span class="line">git checkout master </span><br><span class="line">git merge release-0.1 </span><br><span class="line">git push </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">合并修改到 develop 分支</span></span><br><span class="line">git checkout develop </span><br><span class="line">git merge release-0.1 </span><br><span class="line">git push </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除发布分支</span></span><br><span class="line">git branch -d release-0.1</span><br></pre></td></tr></table></figure>

<h4 id="为-master-分支打发版-tag"><a href="#为-master-分支打发版-tag" class="headerlink" title="为 master 分支打发版 tag"></a>为 master 分支打发版 tag</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git tag -a 0.1 -m &quot;Initial public release&quot; master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<h4 id="修复-bug"><a href="#修复-bug" class="headerlink" title="修复 bug"></a>修复 bug</h4><p>如果正在开发功能的同时，发现了线上 bug，或者未上线的 bug，我们可以开一个 bugfix 分支来修复 bug，然后将修复后的代码发布到线上以及正在开发的分支上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b bugfix/[bug-name] master（或 develop）</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> when fixed bug，合并修改好的代码到master以及develop分支</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge bugfix/[bug-name]</span><br><span class="line">git checkout develop</span><br><span class="line">git merge bugfix/[bug-name]</span><br><span class="line"></span><br><span class="line">git push</span><br><span class="line">git branch -d bugfix/[bug-name]</span><br></pre></td></tr></table></figure>

<h4 id="特别提示"><a href="#特别提示" class="headerlink" title="特别提示"></a>特别提示</h4><p>项目中存在很多配置文件，不同分支配置文件可能不同，因此在merge时需要忽略配置文件合并</p>
<ol>
<li><p>首先，需要创建自定义的 <code>merge driver</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global merge.ours.driver true</span><br></pre></td></tr></table></figure>
</li>
<li><p>在要被<code>merge</code>的分支上创建<code>.gitattributes</code>文件,并且在文件中置顶不<code>merge</code>的文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;Jenkinsfile merge=ours&#x27; &gt;&gt; .gitattributes</span><br><span class="line">git add .gitattributes</span><br><span class="line">git commit -m &#x27;chore: Preserve Jenkinsfile during merges&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>回到要合并到的分支<code>master</code>,执行<code>merge</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge xxxx</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>PS：只能<code>master</code>合并<code>其他分支</code>时忽略<code>其他分支</code>上的文件, <code>其他分支</code>合并<code>master</code>无法忽略<code>master</code>上的文件</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch整合Kibana和Logstash环境搭建</title>
    <url>/2020/01/07/Elasticsearch%E6%95%B4%E5%90%88Kibana%E5%92%8CLogstash%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="Install-Elasticsearch-with-Docker"><a href="#Install-Elasticsearch-with-Docker" class="headerlink" title="Install Elasticsearch with Docker"></a>Install Elasticsearch with Docker</h3><h4 id="Pulling-the-image"><a href="#Pulling-the-image" class="headerlink" title="Pulling the image"></a>Pulling the image</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch</span><br></pre></td></tr></table></figure>

<h4 id="Starting-a-single-node-cluster-with-Docker"><a href="#Starting-a-single-node-cluster-with-Docker" class="headerlink" title="Starting a single node cluster with Docker"></a>Starting a single node cluster with Docker</h4><p>采用Docker启动一个单节点的<code>Elasticsearch</code>集群:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -d：后台启动 -p：开放端口 --name：设置名称</span></span><br><span class="line">docker -d run -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; --name elasticsearch-monochrome docker.elastic.co/elasticsearch/elasticsearch:7.5.1</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="Starting-a-multi-node-cluster-with-Docker-Compose"><a href="#Starting-a-multi-node-cluster-with-Docker-Compose" class="headerlink" title="Starting a multi-node cluster with Docker Compose"></a>Starting a multi-node cluster with Docker Compose</h4><p>通过<code>Docker Compose</code>创建一个包含3个节点的<code>Elasticsearch</code>集群 :</p>
<ol>
<li><p>创建一个 <code>docker-compose.yml</code> file:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">es01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.5.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es01</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data01:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.5.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es02</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data02:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.5.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es03</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data03:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">data01:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data02:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data03:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">elastic:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>Run <code>docker-compose</code> 来启动集群:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Install-Kibana-with-Docker"><a href="#Install-Kibana-with-Docker" class="headerlink" title="Install Kibana with Docker"></a>Install Kibana with Docker</h3><h4 id="Pulling-the-image-1"><a href="#Pulling-the-image-1" class="headerlink" title="Pulling the image"></a>Pulling the image</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/kibana/kibana</span><br></pre></td></tr></table></figure>

<h4 id="Configuring-Kibana"><a href="#Configuring-Kibana" class="headerlink" title="Configuring Kibana"></a>Configuring Kibana</h4><p>新建配置文件<code>kibana.yml</code>，很多默认的配置，只需要修改几个配置即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Kibana is served by a back end server. This setting specifies the port to use.</span></span><br><span class="line"><span class="comment">#server.port: 5601</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.</span></span><br><span class="line"><span class="comment"># The default is &#x27;localhost&#x27;, which usually means remote machines will not be able to connect.</span></span><br><span class="line"><span class="comment"># To allow connections from remote users, set this parameter to a non-loopback address.</span></span><br><span class="line"><span class="comment"># 允许远程访问</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="comment">#server.host: &quot;localhost&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enables you to specify a path to mount Kibana at if you are running behind a proxy.</span></span><br><span class="line"><span class="comment"># Use the `server.rewriteBasePath` setting to tell Kibana if it should remove the basePath</span></span><br><span class="line"><span class="comment"># from requests it receives, and to prevent a deprecation warning at startup.</span></span><br><span class="line"><span class="comment"># This setting cannot end in a slash.</span></span><br><span class="line"><span class="comment">#server.basePath: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies whether Kibana should rewrite requests that are prefixed with</span></span><br><span class="line"><span class="comment"># `server.basePath` or require that they are rewritten by your reverse proxy.</span></span><br><span class="line"><span class="comment"># This setting was effectively always `false` before Kibana 6.3 and will</span></span><br><span class="line"><span class="comment"># default to `true` starting in Kibana 7.0.</span></span><br><span class="line"><span class="comment">#server.rewriteBasePath: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The maximum payload size in bytes for incoming server requests.</span></span><br><span class="line"><span class="comment">#server.maxPayloadBytes: 1048576</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Kibana server&#x27;s name.  This is used for display purposes.</span></span><br><span class="line"><span class="comment">#server.name: &quot;your-hostname&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The URLs of the Elasticsearch instances to use for all your queries.</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> [<span class="string">&quot;http://localhost:9200&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># When this setting&#x27;s value is true Kibana uses the hostname specified in the server.host</span></span><br><span class="line"><span class="comment"># setting. When the value of this setting is false, Kibana uses the hostname of the host</span></span><br><span class="line"><span class="comment"># that connects to this Kibana instance.</span></span><br><span class="line"><span class="comment">#elasticsearch.preserveHost: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kibana uses an index in Elasticsearch to store saved searches, visualizations and</span></span><br><span class="line"><span class="comment"># dashboards. Kibana creates a new index if the index doesn&#x27;t already exist.</span></span><br><span class="line"><span class="comment">#kibana.index: &quot;.kibana&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The default application to load.</span></span><br><span class="line"><span class="comment">#kibana.defaultAppId: &quot;home&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If your Elasticsearch is protected with basic authentication, these settings provide</span></span><br><span class="line"><span class="comment"># the username and password that the Kibana server uses to perform maintenance on the Kibana</span></span><br><span class="line"><span class="comment"># index at startup. Your Kibana users still need to authenticate with Elasticsearch, which</span></span><br><span class="line"><span class="comment"># is proxied through the Kibana server.</span></span><br><span class="line"><span class="comment">#elasticsearch.username: &quot;kibana&quot;</span></span><br><span class="line"><span class="comment">#elasticsearch.password: &quot;pass&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enables SSL and paths to the PEM-format SSL certificate and SSL key files, respectively.</span></span><br><span class="line"><span class="comment"># These settings enable SSL for outgoing requests from the Kibana server to the browser.</span></span><br><span class="line"><span class="comment">#server.ssl.enabled: false</span></span><br><span class="line"><span class="comment">#server.ssl.certificate: /path/to/your/server.crt</span></span><br><span class="line"><span class="comment">#server.ssl.key: /path/to/your/server.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional settings that provide the paths to the PEM-format SSL certificate and key files.</span></span><br><span class="line"><span class="comment"># These files validate that your Elasticsearch backend uses the same key files.</span></span><br><span class="line"><span class="comment">#elasticsearch.ssl.certificate: /path/to/your/client.crt</span></span><br><span class="line"><span class="comment">#elasticsearch.ssl.key: /path/to/your/client.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional setting that enables you to specify a path to the PEM file for the certificate</span></span><br><span class="line"><span class="comment"># authority for your Elasticsearch instance.</span></span><br><span class="line"><span class="comment">#elasticsearch.ssl.certificateAuthorities: [ &quot;/path/to/your/CA.pem&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To disregard the validity of SSL certificates, change this setting&#x27;s value to &#x27;none&#x27;.</span></span><br><span class="line"><span class="comment">#elasticsearch.ssl.verificationMode: full</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time in milliseconds to wait for Elasticsearch to respond to pings. Defaults to the value of</span></span><br><span class="line"><span class="comment"># the elasticsearch.requestTimeout setting.</span></span><br><span class="line"><span class="comment">#elasticsearch.pingTimeout: 1500</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time in milliseconds to wait for responses from the back end or Elasticsearch. This value</span></span><br><span class="line"><span class="comment"># must be a positive integer.</span></span><br><span class="line"><span class="comment">#elasticsearch.requestTimeout: 30000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Kibana client-side headers to send to Elasticsearch. To send *no* client-side</span></span><br><span class="line"><span class="comment"># headers, set this value to [] (an empty list).</span></span><br><span class="line"><span class="comment">#elasticsearch.requestHeadersWhitelist: [ authorization ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Header names and values that are sent to Elasticsearch. Any custom headers cannot be overwritten</span></span><br><span class="line"><span class="comment"># by client-side headers, regardless of the elasticsearch.requestHeadersWhitelist configuration.</span></span><br><span class="line"><span class="comment">#elasticsearch.customHeaders: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time in milliseconds for Elasticsearch to wait for responses from shards. Set to 0 to disable.</span></span><br><span class="line"><span class="comment">#elasticsearch.shardTimeout: 30000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time in milliseconds to wait for Elasticsearch at Kibana startup before retrying.</span></span><br><span class="line"><span class="comment">#elasticsearch.startupTimeout: 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logs queries sent to Elasticsearch. Requires logging.verbose set to true.</span></span><br><span class="line"><span class="comment">#elasticsearch.logQueries: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies the path where Kibana creates the process ID file.</span></span><br><span class="line"><span class="comment">#pid.file: /var/run/kibana.pid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enables you specify a file where Kibana stores log output.</span></span><br><span class="line"><span class="comment">#logging.dest: stdout</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the value of this setting to true to suppress all logging output.</span></span><br><span class="line"><span class="comment">#logging.silent: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the value of this setting to true to suppress all logging output other than error messages.</span></span><br><span class="line"><span class="comment">#logging.quiet: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the value of this setting to true to log all events, including system usage information</span></span><br><span class="line"><span class="comment"># and all requests.</span></span><br><span class="line"><span class="comment">#logging.verbose: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the interval in milliseconds to sample system and process performance</span></span><br><span class="line"><span class="comment"># metrics. Minimum is 100ms. Defaults to 5000.</span></span><br><span class="line"><span class="comment">#ops.interval: 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies locale to be used for all localizable strings, dates and number formats.</span></span><br><span class="line"><span class="comment"># Supported languages are the following: English - en , by default , Chinese - zh-CN .</span></span><br><span class="line"><span class="comment"># 默认语言设置为中文</span></span><br><span class="line"><span class="attr">i18n.locale:</span> <span class="string">&quot;zh-CN&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="编排docker-compose"><a href="#编排docker-compose" class="headerlink" title="编排docker-compose"></a>编排docker-compose</h4><p>新建文件<code>docker-compose.yml</code>，配置特权方式和端口，映射配置kibana.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/kibana/kibana:7.5.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5601:5601&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./kibana.yml:/usr/share/kibana/config/kibana.yml</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="启动Kibana"><a href="#启动Kibana" class="headerlink" title="启动Kibana"></a>启动Kibana</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h3 id="Install-Logstash-with-Docker-and-Auto-Sync-Mysql-data"><a href="#Install-Logstash-with-Docker-and-Auto-Sync-Mysql-data" class="headerlink" title="Install Logstash with Docker and Auto-Sync Mysql data"></a>Install Logstash with Docker and Auto-Sync Mysql data</h3><h4 id="Pulling-the-image-2"><a href="#Pulling-the-image-2" class="headerlink" title="Pulling the image"></a>Pulling the image</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/logstash/logstash:7.5.1</span><br></pre></td></tr></table></figure>

<h4 id="自定义docker镜像"><a href="#自定义docker镜像" class="headerlink" title="自定义docker镜像"></a>自定义docker镜像</h4><ol>
<li><p>新建<code>Dockerfile</code>文件</p>
</li>
<li><p>配置<code>Dockerfile</code></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> docker.elastic.co/logstash/logstash:<span class="number">7.5</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装input插件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> logstash-plugin install logstash-input-jdbc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装output插件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> logstash-plugin install logstash-output-elasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装json_lines插件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> logstash-plugin install logstash-codec-json_lines</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#容器启动时执行的命令.(CMD 能够被 docker run 后面跟的命令行参数替换)</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;-f&quot;</span>,<span class="string">&quot;/usr/share/logstash/config/mysql.conf&quot;</span>]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t my_logstash .</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="创建配置相关的文件"><a href="#创建配置相关的文件" class="headerlink" title="创建配置相关的文件"></a>创建配置相关的文件</h4><ol>
<li><p>创建配置文件夹，所有配置文件都放在这个文件夹下面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /data/logstash/config</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>logstash.yml (空文件就行)</strong></p>
</li>
<li><p><strong>log4j2.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logger.elasticsearchoutput.name</span> = <span class="string">logstash.outputs.elasticsearch</span></span><br><span class="line"><span class="meta">logger.elasticsearchoutput.level</span> = <span class="string">debug</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>pipelines.yml</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- pipeline.id: my-logstash</span><br><span class="line">  path.config: &quot;&#x2F;usr&#x2F;share&#x2F;logstash&#x2F;config&#x2F;*.conf&quot;</span><br><span class="line">  pipeline.workers: 3</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mysql.conf</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">	jdbc &#123;</span><br><span class="line">		jdbc_connection_string =&gt;</span><br><span class="line">			<span class="string">&quot;jdbc:mysql://localhost:3306/&lt;database_name&gt;?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true&quot;</span></span><br><span class="line">        ## 数据库账号和密码</span><br><span class="line">		jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">		jdbc_password =&gt; &quot;root&quot;</span><br><span class="line">		## 数据库驱动的JAR位置</span><br><span class="line">		jdbc_driver_library =&gt; &quot;/usr/share/logstash/config/mysql-connector-java-5.1.47.jar&quot;</span><br><span class="line">		jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">		jdbc_paging_enabled =&gt; &quot;true&quot;</span><br><span class="line">		jdbc_page_size =&gt; &quot;50000&quot;</span><br><span class="line">        ## 查询的数据，根据数据库自己定义</span><br><span class="line">		statement =&gt; &quot;select * from tb_user&quot;</span><br><span class="line">		## 每分钟执行一次</span><br><span class="line">		schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">	elasticsearch &#123;</span><br><span class="line">		## elasticsearch 地址</span><br><span class="line">		hosts =&gt; &quot;localhost:9200&quot;</span><br><span class="line">		## 索引名称</span><br><span class="line">		index =&gt; &quot;index-user&quot;</span><br><span class="line">        ## 主键</span><br><span class="line">		document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">		## 索引类型</span><br><span class="line">		document_type =&gt; &quot;user&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	stdout &#123;</span><br><span class="line">		codec =&gt; json_lines</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库驱动jar包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://repo1.maven.org/maven2/mysql/mysql-connector-java/5.1.47/mysql-connector-java-5.1.47.jar</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="特权方式启动Logstash"><a href="#特权方式启动Logstash" class="headerlink" title="特权方式启动Logstash"></a>特权方式启动<code>Logstash</code></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --privileged=true -p 4560:4560 -p 9600:9600 -it --name=my_logstash -v /data/logstash/config/:/usr/share/logstash/config/   my_logstash</span><br></pre></td></tr></table></figure>

<p>查看日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f -t --tail 10 my_logstash</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Kibana</category>
        <category>Logstash</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>Kibana</tag>
        <tag>Logstash</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC核心知识点</title>
    <url>/2021/04/20/JUC%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>JMM是指Java<strong>内存模型</strong>，不是Java<strong>内存布局</strong>，不是所谓的栈、堆、方法区。</p>
<p>每个Java线程都有自己的<strong>工作内存</strong>。操作数据，首先从主内存中读，得到一份拷贝，操作完毕后再写回到主内存。</p>
<p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/JMM.png" alt="threadPoolProcedure">JMM可能带来<strong>可见性</strong>、<strong>原子性</strong>和<strong>有序性</strong>问题。所谓可见性，就是某个线程对主内存内容的更改，应该立刻通知到其它线程。原子性是指一个操作是不可分割的，不能执行到一半，就不执行了。所谓有序性，就是指令是有序的，不会被重排。</p>
<span id="more"></span>

<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p><code>volatile</code>关键字是Java提供的一种<strong>轻量级</strong>同步机制。它能够保证<strong>可见性</strong>和<strong>有序性</strong>，但是不能保证<strong>原子性</strong>。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/thread/VolatileDemo.java">可见性测试</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//volatile int number=0;</span></span><br><span class="line"></span><br><span class="line">    AtomicInteger atomicInteger=<span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTo60</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number=<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时number前面已经加了volatile，但是不保证原子性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPlusPlus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtomic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//volatile可以保证可见性，及时通知其它线程主物理内存的值已被修改</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">volatileVisibilityDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;可见性测试&quot;</span>);</span><br><span class="line">    MyData myData = <span class="keyword">new</span> MyData();<span class="comment">//资源类</span></span><br><span class="line">    <span class="comment">//启动一个线程操作共享数据</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">3</span>);myData.setTo60();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t update number value: &quot;</span>+myData.number);&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;e.printStackTrace();&#125;</span><br><span class="line">    &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">    <span class="keyword">while</span> (myData.number==<span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">//main线程持有共享数据的拷贝，一直为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t mission is over. main get number value: &quot;</span>+myData.number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MyData</code>类是资源类，一开始<code>number</code>变量没有用<code>volatile</code>修饰，所以程序运行的结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">可见性测试</span><br><span class="line">AAA	 come in</span><br><span class="line">AAA	 update number value: <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>虽然一个线程把<code>number</code>修改成了60，但是<code>main</code>线程持有的仍然是最开始的0，所以一直循环，程序不会结束。</p>
<p>如果对<code>number</code>添加了<code>volatile</code>修饰，运行结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AAA	 come in</span><br><span class="line">AAA	 update number value: <span class="number">60</span></span><br><span class="line">main	 mission is over. main get number value: <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>可见某个线程对<code>number</code>的修改，会立刻反映到主内存上。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p><code>volatile</code>并<strong>不能保证操作的原子性</strong>。这是因为，比如一条number++的操作，会形成3条指令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getfield        &#x2F;&#x2F;读</span><br><span class="line">iconst_1	&#x2F;&#x2F;++常量1</span><br><span class="line">iadd		&#x2F;&#x2F;加操作</span><br><span class="line">putfield	&#x2F;&#x2F;写操作</span><br></pre></td></tr></table></figure>

<p>假设有3个线程，分别执行number++，都先从主内存中拿到最开始的值，number=0，然后三个线程分别进行操作。假设线程0执行完毕，number=1，也立刻通知到了其它线程，但是此时线程1、2已经拿到了number=0，所以结果就是写覆盖，线程1、2将number变成1。</p>
<p>解决的方式就是：</p>
<ol>
<li>对<code>addPlusPlus()</code>方法加锁。</li>
<li>使用<code>java.util.concurrent.AtomicInteger</code>类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomicDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;原子性测试&quot;</span>);</span><br><span class="line">    MyData myData=<span class="keyword">new</span> MyData();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                myData.addPlusPlus();</span><br><span class="line">                myData.addAtomic();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t int type finally number value: &quot;</span>+myData.number);</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t AtomicInteger type finally number value: &quot;</span>+myData.atomicInteger);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：可见，由于<code>volatile</code>不能保证原子性，出现了线程重复写的问题，最终结果比20000小。而<code>AtomicInteger</code>可以保证原子性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">原子性测试</span><br><span class="line">main	 <span class="keyword">int</span> type <span class="keyword">finally</span> number value: <span class="number">17542</span></span><br><span class="line">main	 AtomicInteger type <span class="keyword">finally</span> number value: <span class="number">20000</span></span><br></pre></td></tr></table></figure>

<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p><a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/thread/ResortSeqDemo.java">有序性案例</a></p>
<p>volatile可以保证<strong>有序性</strong>，也就是防止<strong>指令重排序</strong>。所谓指令重排序，就是出于优化考虑，CPU执行指令的顺序跟程序员自己编写的顺序不一致。就好比一份试卷，题号是老师规定的，是程序员规定的，但是考生（CPU）可以先做选择，也可以先做填空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">11</span>; <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">12</span>; <span class="comment">//语句2</span></span><br><span class="line">x = x + <span class="number">5</span>;  <span class="comment">//语句3</span></span><br><span class="line">y = x * x;  <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p>以上例子，可能出现的执行顺序有1234、2134、1342，这三个都没有问题，最终结果都是x = 16，y=256。但是如果是4开头，就有问题了，y=0。这个时候就<strong>不需要</strong>指令重排序。</p>
<p>volatile底层是用CPU的<strong>内存屏障</strong>（Memory Barrier）指令来实现的，有两个作用，一个是保证特定操作的顺序性，二是保证变量的可见性。在指令之间插入一条Memory Barrier指令，告诉编译器和CPU，在Memory Barrier指令之间的指令不能被重排序。</p>
<h2 id="哪些地方用到过volatile？"><a href="#哪些地方用到过volatile？" class="headerlink" title="哪些地方用到过volatile？"></a>哪些地方用到过volatile？</h2><h3 id="单例模式的安全问题"><a href="#单例模式的安全问题" class="headerlink" title="单例模式的安全问题"></a>单例模式的安全问题</h3><p>常见的DCL（Double Check Lock）模式虽然加了同步，但是在多线程下依然会有线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo singletonDemo=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 我是构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DCL模式 Double Check Lock 双端检索机制：在加锁前后都进行判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonDemo==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo.class)&#123;</span><br><span class="line">                 <span class="keyword">if</span> (singletonDemo==<span class="keyword">null</span>)&#123;</span><br><span class="line">                     singletonDemo=<span class="keyword">new</span> SingletonDemo();</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonDemo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;,String.valueOf(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个漏洞比较tricky，很难捕捉，但是是存在的。<code>instance=new SingletonDemo();</code>可以大致分为三步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();     <span class="comment">//1.分配内存</span></span><br><span class="line">instance(memory);	 <span class="comment">//2.初始化对象</span></span><br><span class="line">instance = memory;	 <span class="comment">//3.设置引用地址</span></span><br></pre></td></tr></table></figure>

<p>其中2、3没有数据依赖关系，<strong>可能发生重排</strong>。如果发生，此时内存已经分配，那么<code>instance=memory</code>不为null。如果此时线程挂起，<code>instance(memory)</code>还未执行，对象还未初始化。由于<code>instance!=null</code>，所以两次判断都跳过，最后返回的<code>instance</code>没有任何内容，还没初始化。</p>
<p>解决的方法就是对<code>singletondemo</code>对象添加上<code>volatile</code>关键字，禁止指令重排。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS是指<strong>Compare And Swap</strong>，<strong>比较并交换</strong>，是一种很重要的同步思想。如果主内存的值跟期望值一样，那么就进行修改，否则一直重试，直到一致为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger=<span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>)+<span class="string">&quot;\t current data : &quot;</span>+ atomicInteger.get());</span><br><span class="line">        <span class="comment">//修改失败</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>)+<span class="string">&quot;\t current data : &quot;</span>+ atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次修改，期望值为5，主内存也为5，修改成功，为2019。第二次修改，期望值为5，主内存为2019，修改失败。</p>
<p>查看<code>AtomicInteger.getAndIncrement()</code>方法，发现其没有加<code>synchronized</code><strong>也实现了同步</strong>。这是为什么？</p>
<h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><p><code>AtomicInteger</code>内部维护了<code>volatile int value</code>和<code>private  static final Unsafe unsafe</code>两个比较重要的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>,valueOffset,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AtomicInteger.getAndIncrement()</code>调用了<code>Unsafe.getAndAddInt()</code>方法。<code>Unsafe</code>类的大部分方法都是<code>native</code>的，用来像C语言一样从底层操作内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAnddAddInt</span><span class="params">(Object var1,<span class="keyword">long</span> var2,<span class="keyword">int</span> var4)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的var1和var2，就是根据<strong>对象</strong>和<strong>偏移量</strong>得到在<strong>主内存的快照值</strong>var5。然后<code>compareAndSwapInt</code>方法通过var1和var2得到当前<strong>主内存的实际值</strong>。如果这个<strong>实际值</strong>跟<strong>快照值</strong>相等，那么就更新主内存的值为var5+var4。如果不等，那么就一直循环，一直获取快照，一直对比，直到实际值和快照值相等为止。</p>
<p>比如有A、B两个线程，一开始都从主内存中拷贝了原值为3，A线程执行到<code>var5=this.getIntVolatile</code>，即var5=3。此时A线程挂起，B修改原值为4，B线程执行完毕，由于加了volatile，所以这个修改是立即可见的。A线程被唤醒，执行<code>this.compareAndSwapInt()</code>方法，发现这个时候主内存的值不等于快照值3，所以继续循环，<strong>重新</strong>从主内存获取。</p>
<h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><p>CAS实际上是一种自旋锁，</p>
<ol>
<li>一直循环，开销比较大。</li>
<li>只能保证一个变量的原子操作，多个变量依然要加锁。</li>
<li>引出了<strong>ABA问题</strong>。</li>
</ol>
<h1 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h1><p>所谓ABA问题，就是比较并交换的循环，存在一个<strong>时间差</strong>，而这个时间差可能带来意想不到的问题。比如线程T1将值从A改为B，然后又从B改为A。线程T2看到的就是A，但是<strong>却不知道这个A发生了更改</strong>。尽管线程T2 CAS操作成功，但不代表就没有问题。<br>有的需求，比如CAS，<strong>只注重头和尾</strong>，只要首尾一致就接受。但是有的需求，还看重过程，中间不能发生任何修改，这就引出了<code>AtomicReference</code>原子引用。</p>
<h2 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h2><p><code>AtomicInteger</code>对整数进行原子操作，如果是一个POJO呢？可以用<code>AtomicReference</code>来包装这个POJO，使其操作原子化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user1 = <span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>,<span class="number">25</span>);</span><br><span class="line">User user2 = <span class="keyword">new</span> User(<span class="string">&quot;Lucy&quot;</span>,<span class="number">21</span>);</span><br><span class="line">AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">atomicReference.set(user1);</span><br><span class="line">System.out.println(atomicReference.compareAndSet(user1,user2)); <span class="comment">// true</span></span><br><span class="line">System.out.println(atomicReference.compareAndSet(user1,user2)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="AtomicStampedReference和ABA问题的解决"><a href="#AtomicStampedReference和ABA问题的解决" class="headerlink" title="AtomicStampedReference和ABA问题的解决"></a>AtomicStampedReference和ABA问题的解决</h2><p>使用<code>AtomicStampedReference</code>类可以解决ABA问题。这个类维护了一个“<strong>版本号</strong>”Stamp，在进行CAS操作的时候，不仅要比较当前值，还要比较<strong>版本号</strong>。只有两者都相等，才执行更新操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicStampedReference.compareAndSet(expectedReference,newReference,oldStamp,newStamp);</span><br></pre></td></tr></table></figure>

<p>详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/thread/ABADemo.java">ABADemo</a>。</p>
<h1 id="集合类不安全问题"><a href="#集合类不安全问题" class="headerlink" title="集合类不安全问题"></a>集合类不安全问题</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><code>ArrayList</code>不是线程安全类，在多线程同时写的情况下，会抛出<code>java.util.ConcurrentModificationException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listNotSafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + list);</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：</p>
<ol>
<li>使用<code>Vector</code>（<code>ArrayList</code>所有方法加<code>synchronized</code>，太重）。</li>
<li>使用<code>Collections.synchronizedList()</code>转换成线程安全类。</li>
<li>使用<code>java.concurrent.CopyOnWriteArrayList</code>（推荐）。</li>
</ol>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>这是JUC的类，通过<strong>写时复制</strong>来实现<strong>读写分离</strong>。比如其<code>add()</code>方法，就是先<strong>复制</strong>一个新数组，长度为原数组长度+1，然后将新数组最后一个元素设为添加的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//得到旧数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//复制新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//设置新元素</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//设置新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>跟List类似，<code>HashSet</code>和<code>TreeSet</code>都不是线程安全的，与之对应的有<code>CopyOnWriteSet</code>这个线程安全类。这个类底层维护了一个<code>CopyOnWriteArrayList</code>数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet和HashMap"><a href="#HashSet和HashMap" class="headerlink" title="HashSet和HashMap"></a>HashSet和HashMap</h3><p><code>HashSet</code>底层是用<code>HashMap</code>实现的。既然是用<code>HashMap</code>实现的，那<code>HashMap.put()</code>需要传<strong>两个参数</strong>，而<code>HashSet.add()</code>只<strong>传一个参数</strong>，这是为什么？实际上<code>HashSet.add()</code>就是调用的<code>HashMap.put()</code>，只不过<strong>Value</strong>被写死了，是一个<code>private static final Object</code>对象。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>HashMap</code>不是线程安全的，<code>Hashtable</code>是线程安全的，但是跟<code>Vector</code>类似，太重量级。所以也有类似CopyOnWriteMap，只不过叫<code>ConcurrentHashMap</code>。</p>
<p>关于集合不安全类请看<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/thread/ContainerNotSafeDemo.java">ContainerNotSafeDemo</a>。</p>
<h1 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h1><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h2><p><strong>概念</strong>：所谓<strong>公平锁</strong>，就是多个线程按照<strong>申请锁的顺序</strong>来获取锁，类似排队，先到先得。而<strong>非公平锁</strong>，则是多个线程抢夺锁，会导致<strong>优先级反转</strong>或<strong>饥饿现象</strong>。</p>
<p><strong>区别</strong>：公平锁在获取锁时先查看此锁维护的<strong>等待队列</strong>，<strong>为空</strong>或者当前线程是等待队列的<strong>队首</strong>，则直接占有锁，否则插入到等待队列，FIFO原则。非公平锁比较粗鲁，上来直接<strong>先尝试占有锁</strong>，失败则采用公平锁方式。非公平锁的优点是<strong>吞吐量</strong>比公平锁更大。</p>
<p><code>synchronized</code>和<code>juc.ReentrantLock</code>默认都是<strong>非公平锁</strong>。<code>ReentrantLock</code>在构造的时候传入<code>true</code>则是<strong>公平锁</strong>。</p>
<h2 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁/递归锁"></a>可重入锁/递归锁</h2><p>可重入锁又叫递归锁，指的同一个线程在<strong>外层方法</strong>获得锁时，进入<strong>内层方法</strong>会自动获取锁。也就是说，线程可以进入任何一个它已经拥有锁的代码块。比如<code>get</code>方法里面有<code>set</code>方法，两个方法都有同一把锁，得到了<code>get</code>的锁，就自动得到了<code>set</code>的锁。</p>
<p>就像有了家门的锁，厕所、书房、厨房就为你敞开了一样。可重入锁可以<strong>避免死锁</strong>的问题。</p>
<p>ReentrantLockDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone=<span class="keyword">new</span> Phone();</span><br><span class="line">        syncTest(phone);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Thread t3=<span class="keyword">new</span> Thread(phone);</span><br><span class="line">        Thread t4=<span class="keyword">new</span> Thread(phone);</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">syncTest</span><span class="params">(Phone phone)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//Synchronized TEST</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;sendSMS()&quot;</span>);</span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;sendEmail()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Reentrant TEST</span></span><br><span class="line"></span><br><span class="line">    Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;get()&quot;</span>);</span><br><span class="line">            set();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;set()&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="锁的配对"><a href="#锁的配对" class="headerlink" title="锁的配对"></a>锁的配对</h3><p>锁之间要配对，加了几把锁，最后就得解开几把锁，下面的代码编译和运行都没有任何问题，但锁的数量不匹配会导致死循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    someAction();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>所谓自旋锁，就是尝试获取锁的线程不会<strong>立即阻塞</strong>，而是采用<strong>循环的方式去尝试获取</strong>。自己在那儿一直循环获取，就像“<strong>自旋</strong>”一样。这样的好处是减少<strong>线程切换的上下文开销</strong>，缺点是会<strong>消耗CPU</strong>。CAS底层的<code>getAndAddInt</code>就是<strong>自旋锁</strong>思想。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跟CAS类似，一直循环比较。</span></span><br><span class="line"><span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>SpinLockDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋锁Demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLocDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;Thread&gt; threadAtomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;\t come in...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!threadAtomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        threadAtomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;\t unlock...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLocDemo spinLocDemo = <span class="keyword">new</span> SpinLocDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLocDemo.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLocDemo.unlock();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLocDemo.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLocDemo.unlock();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="读写锁-独占-共享锁"><a href="#读写锁-独占-共享锁" class="headerlink" title="读写锁/独占/共享锁"></a>读写锁/独占/共享锁</h2><p><strong>读锁</strong>是<strong>共享的</strong>，<strong>写锁</strong>是<strong>独占的</strong>。<code>juc.ReentrantLock</code>和<code>synchronized</code>都是<strong>独占锁</strong>，独占锁就是<strong>一个锁</strong>只能被<strong>一个线程</strong>所持有。有的时候，需要<strong>读写分离</strong>，那么就要引入读写锁，即<code>juc.ReentrantReadWriteLock</code>。</p>
<p>比如缓存，就需要读写锁来控制。缓存就是一个键值对，以下Demo模拟了缓存的读写操作，读的<code>get</code>方法使用了<code>ReentrantReadWriteLock.ReadLock()</code>，写的<code>put</code>方法使用了<code>ReentrantReadWriteLock.WriteLock()</code>。这样避免了写被打断，实现了多个线程同时读。</p>
<p>ReadWriteLockDemo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; myCache.put(tempInt + <span class="string">&quot;&quot;</span>, tempInt + <span class="string">&quot;&quot;</span>), String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; myCache.get(tempInt + <span class="string">&quot;&quot;</span>), String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在写入：&quot;</span> + key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成：&quot;</span> + key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Object value = <span class="keyword">null</span>;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在读取：&quot;</span> + key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            value = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized和Lock的区别"><a href="#Synchronized和Lock的区别" class="headerlink" title="Synchronized和Lock的区别"></a>Synchronized和Lock的区别</h2><p><code>synchronized</code>关键字和<code>java.util.concurrent.locks.Lock</code>都能加锁，两者有什么区别呢？</p>
<ol>
<li><strong>原始构成</strong>：<code>sync</code>是JVM层面的，底层通过<code>monitorenter</code>和<code>monitorexit</code>来实现的。<code>Lock</code>是JDK API层面的。（<code>sync</code>一个enter会有两个exit，一个是正常退出，一个是异常退出）</li>
<li><strong>使用方法</strong>：<code>sync</code>不需要手动释放锁，而<code>Lock</code>需要手动释放。</li>
<li><strong>是否可中断</strong>：<code>sync</code>不可中断，除非抛出异常或者正常运行完成。<code>Lock</code>是可中断的，通过调用<code>interrupt()</code>方法。</li>
<li><strong>是否为公平锁</strong>：<code>sync</code>只能是非公平锁，而<code>Lock</code>既能是公平锁，又能是非公平锁。</li>
<li><strong>绑定多个条件<code>Condition</code></strong>：<code>sync</code>不能，只能随机唤醒。而<code>Lock</code>可以通过<code>Condition</code>来绑定多个条件，精确唤醒。</li>
</ol>
<h1 id="CountDownLatch-CyclicBarrier-Semaphore"><a href="#CountDownLatch-CyclicBarrier-Semaphore" class="headerlink" title="CountDownLatch/CyclicBarrier/Semaphore"></a>CountDownLatch/CyclicBarrier/Semaphore</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><code>CountDownLatch</code>内部维护了一个<strong>计数器</strong>，只有当<strong>计数器==0</strong>时，某些线程才会停止阻塞，开始执行。</p>
<p><code>CountDownLatch</code>主要有两个方法，<code>countDown()</code>来让计数器-1，<code>await()</code>来让线程阻塞。当<code>count==0</code>时，阻塞线程自动唤醒。</p>
<p><strong>案例一班长关门</strong>：main线程是班长，6个线程是学生。只有6个线程运行完毕，都离开教室后，main线程班长才会关教室门。</p>
<p><strong>案例二秦灭六国</strong>：只有6国都被灭亡后（执行完毕），main线程才会显示“秦国一统天下”。</p>
<h3 id="枚举类的使用"><a href="#枚举类的使用" class="headerlink" title="枚举类的使用"></a>枚举类的使用</h3><p>在<strong>案例二</strong>中会使用到枚举类，因为灭六国，循环6次，想根据<code>i</code>的值来确定输出什么国，比如1代表楚国，2代表赵国。如果用判断则十分繁杂，而枚举类可以简化操作。</p>
<p>枚举类就像一个<strong>简化的数据库</strong>，枚举类名就像数据库名，枚举的项目就像数据表，枚举的属性就像表的字段。</p>
<p>CountDownLatchDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        closeDoor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeDoor</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 上完课，go&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;***** 班长上完课，关门，go&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CountDownLatch</code>是减，而<code>CyclicBarrier</code>是加，理解了<code>CountDownLatch</code>，<code>CyclicBarrier</code>就很容易。比如召集7颗龙珠才能召唤神龙。</p>
<p>CyclicBarrierDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; System.out.println(<span class="string">&quot;*****召唤神龙&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 收集到第：&quot;</span> + finalI + <span class="string">&quot;龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>CountDownLatch</code>的问题是<strong>不能复用</strong>。比如<code>count=3</code>，那么加到3，就不能继续操作了。而<code>Semaphore</code>可以解决这个问题，比如6辆车3个停车位，对于<code>CountDownLatch</code><strong>只能停3辆车</strong>，而<code>Semaphore</code>可以停6辆车，车位空出来后，其它车可以占有，这就涉及到了<code>Semaphore.accquire()</code>和<code>Semaphore.release()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟3个停车位</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;量汽车抢到了车位&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;量汽车停车3秒后离开车位&quot;</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p><strong>概念</strong>：当阻塞队列为空时，获取（take）操作是阻塞的；当阻塞队列为满时，添加（put）操作是阻塞的。</p>
<p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/BlockingQueue.png" alt=""></p>
<p><strong>好处</strong>：阻塞队列不用手动控制什么时候该被阻塞，什么时候该被唤醒，简化了操作。</p>
<p><strong>体系</strong>：<code>Collection</code>→<code>Queue</code>→<code>BlockingQueue</code>→七个阻塞队列实现类。</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ArrayBlockingQueue</strong></td>
<td>由<strong>数组</strong>构成的<strong>有界</strong>阻塞队列</td>
</tr>
<tr>
<td><strong>LinkedBlockingQueue</strong></td>
<td>由<strong>链表</strong>构成的<strong>有界</strong>阻塞队列</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>支持优先级排序的无界阻塞队列</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>支持优先级的延迟无界阻塞队列</td>
</tr>
<tr>
<td><strong>SynchronousQueue</strong></td>
<td>单个元素的阻塞队列</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>由链表构成的无界阻塞队列</td>
</tr>
<tr>
<td>LinkedBlockingDeque</td>
<td>由链表构成的双向阻塞队列</td>
</tr>
</tbody></table>
<p>粗体标记的三个用得比较多，许多消息中间件底层就是用它们实现的。</p>
<p>需要注意的是<code>LinkedBlockingQueue</code>虽然是有界的，但有个巨坑，其默认大小是<code>Integer.MAX_VALUE</code>，高达21亿，一般情况下内存早爆了（在线程池的<code>ThreadPoolExecutor</code>有体现）。</p>
<p><strong>API</strong>：抛出异常是指当队列满时，再次插入会抛出异常；返回布尔是指当队列满时，再次插入会返回false；阻塞是指当队列满时，再次插入会被阻塞，直到队列取出一个元素，才能插入。超时是指当一个时限过后，才会插入或者取出。</p>
<table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>返回布尔</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(E e)</td>
<td>offer(E e)</td>
<td>put(E e)</td>
<td>offer(E e,Time,TimeUnit)</td>
</tr>
<tr>
<td>取出</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(Time,TimeUnit)</td>
</tr>
<tr>
<td>队首</td>
<td>element()</td>
<td>peek()</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>抛出异常</td>
<td>当阻塞队列满时，再往队列里面add插入元素会抛IllegalStateException: Queue full<br />当阻塞队列空时，再往队列Remove元素时候回抛出NoSuchElementException</td>
</tr>
<tr>
<td>特殊值</td>
<td>插入方法，成功返回true 失败返回false<br />移除方法，成功返回元素，队列里面没有就返回null</td>
</tr>
<tr>
<td>一直阻塞</td>
<td>当阻塞队列满时，生产者继续往队列里面put元素，队列会一直阻塞直到put数据or响应中断退出。<br />当阻塞队列空时，消费者试图从队列take元素，队列会一直阻塞消费者线程直到队列可用。</td>
</tr>
<tr>
<td>超时退出</td>
<td>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过后限时后生产者线程就会退出</td>
</tr>
</tbody></table>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>队列只有一个元素，如果想插入多个，必须等队列元素取出后，才能插入，只能有一个“坑位”，用一个插一个，详见</p>
<p>SynchronousQueueDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 1&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 2&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 3&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + blockingQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h1><p><strong>与Runnable的区别</strong>：</p>
<ol>
<li>Callable带返回值。</li>
<li>会抛出异常。</li>
<li>覆写<code>call()</code>方法，而不是<code>run()</code>方法。</li>
</ol>
<p><strong>Callable接口的使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;come in callable&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1234</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;come in callable&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1234</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask3 = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(() -&gt; System.out.println(<span class="string">&quot;come in runnable&quot;</span>), <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask4 = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;come in runnable&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(futureTask, <span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="阻塞队列的应用——生产者消费者"><a href="#阻塞队列的应用——生产者消费者" class="headerlink" title="阻塞队列的应用——生产者消费者"></a>阻塞队列的应用——生产者消费者</h1><h2 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h2><p>传统模式使用<code>Lock</code>来进行操作，需要手动加锁、解锁。</p>
<p>ProdConsTradiDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目: 一个初始值为零的变量，两个线程对其交替操作，一个加1，一个减1 ，来5轮</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductConsumerTraditionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    shareData.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    shareData.decrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 judge</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 work</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\tincrement &quot;</span> + number);</span><br><span class="line">            <span class="comment">//3 notify to wake</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 judge</span></span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 work</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\tdecrement &quot;</span> + number);</span><br><span class="line">            <span class="comment">//3 notify to wake</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阻塞队列模式"><a href="#阻塞队列模式" class="headerlink" title="阻塞队列模式"></a>阻塞队列模式</h2><p>使用阻塞队列就不需要手动加锁了</p>
<p>ProducerConsumerBlockQueueDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerBlockQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyResource myResource = <span class="keyword">new</span> MyResource(<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者线程启动！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.product();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者线程启动！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.consume();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;5秒后叫停&quot;</span>);</span><br><span class="line">            myResource.stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认开启，进行生产和消费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> FLAG = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> returnVal;</span><br><span class="line">        <span class="keyword">while</span> (FLAG) &#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            returnVal = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (returnVal) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t插入队列&quot;</span> + data + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t插入队列&quot;</span> + data + <span class="string">&quot;失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; STOP，表明FLAG=false，生产结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (FLAG) &#123;</span><br><span class="line">            result = blockingQueue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span> || result.equalsIgnoreCase(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                FLAG = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t超过2秒没有获取到产品，消费退出&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t消费队列&quot;</span> + result + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; STOP，表明FLAG=false，生产结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.FLAG = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="阻塞队列的应用——线程池"><a href="#阻塞队列的应用——线程池" class="headerlink" title="阻塞队列的应用——线程池"></a>阻塞队列的应用——线程池</h1><h2 id="线程池基本概念"><a href="#线程池基本概念" class="headerlink" title="线程池基本概念"></a>线程池基本概念</h2><p><strong>概念</strong>：线程池主要是控制运行线程的数量，将待处理任务放到等待队列，然后创建线程执行这些任务。如果超过了最大线程数，则等待。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>线程复用：不用一直new新线程，重复利用已经创建的线程来降低线程的创建和销毁开销，节省系统资源。</li>
<li>提高响应速度：当任务达到时，不用创建新的线程，直接利用线程池的线程。</li>
<li>管理线程：可以控制最大并发数，控制线程的创建等。</li>
</ol>
<p><strong>体系</strong>：<code>Executor</code>→<code>ExecutorService</code>→<code>AbstractExecutorService</code>→<code>ThreadPoolExecutor</code>。<code>ThreadPoolExecutor</code>是线程池创建的核心类。类似<code>Arrays</code>、<code>Collections</code>工具类，<code>Executor</code>也有自己的工具类<code>Executors</code>。</p>
<h2 id="线程池三种常用创建方式"><a href="#线程池三种常用创建方式" class="headerlink" title="线程池三种常用创建方式"></a>线程池三种常用创建方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newFixedThreadPool(5);//一池5个处理线程       执行一个长期的任务，性能好很多</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newSingleThreadExecutor();//一池1个处理线程   一个任务一个线程执行的任务场景</span></span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();<span class="comment">//一池N个处理线程         执行很多短期异步的小程序或者负载较轻的服务器</span></span><br><span class="line">        <span class="comment">//模拟10个用户来办理业务，每个用户就是一个来自外部的请求线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>newFixedThreadPool</strong>：使用<code>LinkedBlockingQueue</code>实现，定长线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>newSingleThreadExecutor</strong>：使用<code>LinkedBlockingQueue</code>实现，一池只有一个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>newCachedThreadPool</strong>：使用<code>SynchronousQueue</code>实现，变长线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池创建的七个参数"><a href="#线程池创建的七个参数" class="headerlink" title="线程池创建的七个参数"></a>线程池创建的七个参数</h2><table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>线程池常驻核心线程数</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>能够容纳的最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>空闲线程存活时间</td>
</tr>
<tr>
<td>unit</td>
<td>存活时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>存放提交但未执行任务的队列</td>
</tr>
<tr>
<td>threadFactory</td>
<td>创建线程的工厂类</td>
</tr>
<tr>
<td>handler</td>
<td>等待队列满后的拒绝策略</td>
</tr>
</tbody></table>
<p><strong>理解</strong>：线程池的创建参数，就像一个<strong>银行</strong>。</p>
<p><code>corePoolSize</code>就像银行的“<strong>当值窗口</strong>“，比如今天有<strong>2位柜员</strong>在受理<strong>客户请求</strong>（任务）。如果超过2个客户，那么新的客户就会在<strong>等候区</strong>（等待队列<code>workQueue</code>）等待。当<strong>等候区</strong>也满了，这个时候就要开启“<strong>加班窗口</strong>”，让其它3位柜员来加班，此时达到<strong>最大窗口</strong><code>maximumPoolSize</code>，为5个。如果开启了所有窗口，等候区依然满员，此时就应该启动”<strong>拒绝策略</strong>“<code>handler</code>，告诉不断涌入的客户，叫他们不要进入，已经爆满了。由于不再涌入新客户，办完事的客户增多，窗口开始空闲，这个时候就通过<code>keepAlivetTime</code>将多余的3个”加班窗口“取消，恢复到2个”当值窗口“。</p>
<h2 id="线程池底层原理"><a href="#线程池底层原理" class="headerlink" title="线程池底层原理"></a>线程池底层原理</h2><p><strong>原理图</strong>：上面银行的例子，实际上就是线程池的工作原理。</p>
<p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/threadPool.png" alt="threadPool"></p>
<ol>
<li><p>在创建了线程池后，等待提交过来的任务请求。</p>
</li>
<li><p>当调用<code>execute()</code>方法添加一-个请求任务时，线程池会做如下判断:</p>
<ol>
<li>如果正在运行的线程数量小于<code>corePoolSize</code>，那么马上创建线程运行这个任务</li>
<li>如果正在运行的线程数量大于或等于<code>corePoolSize</code>，那么将这个任务放入队列</li>
<li>如果这时候队列满了且正在运行的线程数量还小于<code>maximumPoolSize</code>，那么还是要创建非核心线程<strong>立刻运行</strong>这个任务</li>
<li>如果队列满了且正在运行的线程数量大于或等于<code>maximumPoolSize</code>，那么线程池会启动饱和拒绝策略来执行</li>
</ol>
</li>
<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>
</li>
<li><p>当一个线程无事可做超过一定的时间(<code>keepAliveTime</code>) 时，线程池会判断:</p>
<p>​    如果当前运行的线程数大于<code>corePoolSize</code>，那么这个线程就被停掉。</p>
</li>
</ol>
<p><strong>流程图</strong>：</p>
<p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/threadPoolProcedure.png" alt="threadPoolProcedure"></p>
<p>新任务到达→</p>
<p>如果正在运行的线程数小于<code>corePoolSize</code>，创建核心线程；大于等于<code>corePoolSize</code>，放入等待队列。</p>
<p>如果等待队列已满，但正在运行的线程数小于<code>maximumPoolSize</code>，创建非核心线程；大于等于<code>maximumPoolSize</code>，启动拒绝策略。</p>
<p>当一个线程无事可做一段时间<code>keepAliveTime</code>后，如果正在运行的线程数大于<code>corePoolSize</code>，则关闭非核心线程。</p>
<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>当等待队列满时，且达到最大线程数，再有新任务到来，就需要启动拒绝策略。JDK提供了四种拒绝策略，分别是。</p>
<ol>
<li><strong>AbortPolicy</strong>：默认的策略，直接抛出<code>RejectedExecutionException</code>异常，阻止系统正常运行。</li>
<li><strong>CallerRunsPolicy</strong>：既不会抛出异常，也不会终止任务，而是将任务返回给调用者。</li>
<li><strong>DiscardOldestPolicy</strong>：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交任务。</li>
<li><strong>DiscardPolicy</strong>：直接丢弃任务，不做任何处理。</li>
</ol>
<h2 id="实际生产使用哪一个线程池？"><a href="#实际生产使用哪一个线程池？" class="headerlink" title="实际生产使用哪一个线程池？"></a>实际生产使用哪一个线程池？</h2><p><strong>单一、可变、定长都不用</strong>！原因就是<code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>底层都是用<code>LinkedBlockingQueue</code>实现的，这个队列最大长度为<code>Integer.MAX_VALUE</code>，显然会导致OOM(Out Of Memery)。所以实际生产一般自己通过<code>ThreadPoolExecutor</code>的7个参数，自定义线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>,<span class="number">5</span>,</span><br><span class="line">                        <span class="number">1L</span>,TimeUnit.SECONDS,</span><br><span class="line">                        <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                        Executors.defaultThreadFactory(),</span><br><span class="line">                        <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure>

<h3 id="自定义线程池参数选择"><a href="#自定义线程池参数选择" class="headerlink" title="自定义线程池参数选择"></a>自定义线程池参数选择</h3><p>查看CPU核数：<code>System.out.println(Runtime.getRuntime().availableProcessors());</code></p>
<p>CPU密集型：CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。CPU密集型任务配置尽可能少的线程数量：一般公式: CPU核 数+1介线程的线程池。</p>
<p>IO密集型任务：任务需要大量的IO，即大量的阻塞，因此尽量多配点，可以是CPU线程数*2，或者CPU线程数/(1-阻塞系数)。</p>
<h1 id="死锁编码和定位"><a href="#死锁编码和定位" class="headerlink" title="死锁编码和定位"></a>死锁编码和定位</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String lockA = <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        String lockB = <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockA, lockB), <span class="string">&quot;ThreadAAA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockB, lockA), <span class="string">&quot;ThreadBBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldLockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoldLockThread</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t自己持有&quot;</span> + lockA + <span class="string">&quot;，尝试获取：&quot;</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t自己持有&quot;</span> + lockB + <span class="string">&quot;，尝试获取：&quot;</span> + lockA);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要是两个命令配合起来使用，定位死锁。</p>
<p><strong>jps</strong>指令：<code>jps -l</code>可以查看运行的Java进程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">9688</span> thread.DeadLockDemo</span><br><span class="line"><span class="number">12177</span> sun.tools.jps.Jps</span><br></pre></td></tr></table></figure>

<p><strong>jstack</strong>指令：<code>jstack pid</code>可以查看某个Java进程的堆栈信息，同时分析出死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;ThreadBBB&quot;</span>:</span><br><span class="line">        at com.monochrome.thread.HoldLockThread.run(DeadLockDemo.java:<span class="number">43</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x00000006edd5eae8</span>&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;<span class="number">0x00000006edd5eb20</span>&gt; (a java.lang.String)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">&quot;ThreadAAA&quot;</span>:</span><br><span class="line">        at com.monochrome.thread.HoldLockThread.run(DeadLockDemo.java:<span class="number">43</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x00000006edd5eb20</span>&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;<span class="number">0x00000006edd5eae8</span>&gt; (a java.lang.String)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item7 消除废弃的对象引用</title>
    <url>/2018/12/07/Effective-Java-Item7-%E6%B6%88%E9%99%A4%E5%BA%9F%E5%BC%83%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>如果您从使用手动管理内存的语言(如C或c++)切换到使用垃圾收集语言(如Java)，那么你作为程序员的工作就会变得容易得多，因为你的对象在使用完后会自动被回收。 当你第一次体验这种编程的时候，它看起来就像是魔术一般。它很容易给人留下这样的印象：你不必考虑内存管理，但这并不完全正确。 </p>
<span id="more"></span>

<p>思考下面这个简单的堆栈实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Can you spot the &quot;memory leak&quot;?</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Ensure space for at least one more element, roughly</span></span><br><span class="line"><span class="comment">    * doubling the capacity each time the array needs to grow.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">        	elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序并没有明显的错误（不过请查看Item 29来了解更加通用的版本）。你可以不断测试该程序，程序也会顺利通过每个测试，不过有一个潜伏的问题。大致来说，该程序存在一处『内存泄露』，其性能会逐步降低，这是因为不断增加的垃圾收集器活动与内存占用问题。在极端情况下，这种内存泄露会导致磁盘分页，甚至会因<code>OutOfMemoryError</code>造成程序失败，不过这种失败的情况是非常少见的。</p>
<p>所以，内存泄漏在哪呢？如果栈不断增长，然后再收缩，那么出站的数据并不会被垃圾回收。即便使用了栈的程序不再引用他们亦如此。这是因为堆栈维护着对他们的<strong><em>过时的引用</em></strong>。废弃的引用指的是永远不会被解引用的引用。在该示例中，位于元素数组『活动部分』之外的任何引用都是废弃的。活动部分包含了索引小于<code>size</code>的元素。</p>
<p>垃圾收集语言中的内存泄露（更恰当的叫法是无意的对象保持）是非常不易察觉的。如果对象引用被无意保持了，那么不仅该对象会从垃圾收集中排除出去，该对象所引用的其他对象也会被排除出去，以此类推。即便只有少量的对象引用被无意保持了，造成的后果就是会有很多、很多对象会从垃圾收集中排除出去，这会对性能造成很严重的影响。</p>
<p>这类问题的解决方案很简单：一旦引用变成废弃状态，立刻将其置为<code>null</code>。对于我们的<code>Stack</code>类来说，如果元素从栈中弹出，那么对其的引用就变成废弃状态了。<code>pop</code>方法的正确版本如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    Object result = elements[--size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>; <span class="comment">// Eliminate obsolete reference</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将过时的引用指向<code>null</code>的另一个好处是，如果他们后面被错误地取消引用了，程序会立刻报<code>NullPointerException</code>的错误，而不是静静地做错误的事情。尽可能快地发现程序的错误总是有益的。</p>
<p>当程序员初次遇到这个问题时，他们会采取矫枉过正的措施：当程序使用完对象后，会将每个对象引用都设为<code>null</code>。这么做既没必要，也不值得；它会毫无必要地将程序搞乱。取消对象引用应该是例外而不是规范。消除废弃引用的最佳方式是让包含了引用的变量离开作用域。如果在最小的作用域内定义每个变量，那么这就是自然而然的事情了（Item 57）。</p>
<p>那么应该在何时将引用置为<code>null</code>呢？<code>Stack</code>类的哪个地方使得它容易出现内存泄露问题呢？简而言之，它来管理自己的内存。存储池包含了<code>elements</code>数组的元素（对象引用单元，而非对象自身）。位于数组活跃部分中的元素（如之前所定义的那样）会被分配，而数组其他部分的元素则是空闲的。垃圾收集器并不知晓这一点；对于垃圾收集器器来说，<code>elements</code>数组中的所有对象引用都是有效的。程序员可以与垃圾收集器就这个事实进行高效的沟通，方式是当数组元素进入到非活跃部分中时就立刻将其手工置为<code>null</code>。</p>
<p>一般来说，<strong>当类管理自己的内存时，程序员应该警惕内存泄露问题</strong>。当元素释放时，包含在该元素中的任何对象引用都应该被置为<code>null</code>。</p>
<p><strong>另一个常见的内存泄漏源是缓存</strong>。一旦将对象引用放入缓存中，就很容易忘记它的存在，然后当缓存失效后它就会一直在那儿。这里有几个解决该问题的办法。如果实现了一个缓存，只要缓存外有引用指向缓存的键，缓存就处于有效状态时，那么缓存就可以使用<code>WeakHashMap</code>来表示;当变为废弃状态时，缓存中的条目就会自动移除。请记住，只有在缓存条目的生命周期是由对其键（而非值）的外部引用所决定时，<code>WeakHashMap</code>才是适合的。</p>
<p>更为常见的情况则是，缓存条目的生命周期不是那么明确的，随着时间的流逝，缓存条目的价值也变得越来越低。在这些情况下，我们应该适时清理那些不再使用的缓存条目。这可以通过后台线程（也许是<code>ScheduledThreadPoolExecutor</code>）来实现，或是在将新的条目添加到缓存中时顺便完成。<code>LinkedHashMap</code>类通过其<code>removeEldestEntry</code>方法可以简化后者的操作。对于更加复杂的缓存来说，你可能需要直接使用<code>java.lang.ref</code>。</p>
<p><strong>内存泄漏的第三个常见来源是监听器和其他回调</strong>。如果实现了一个API，客户端在该API上注册了回调，但却没有显式取消注册，那么他们就会不断累积，除非采取一些行动。确保回调会立刻被垃圾收集的一种方式是只存储对其的弱引用，比如说，在<code>WeakHashMap</code>中只将其以键的形式存储。</p>
<p>由于内存泄露通常并不会导致立刻失败，因此它们可能会在系统中保留多年。他们通常是通过精心的代码检查或是借助于调试工具（<strong>heap profiler</strong>）的帮助才能发现。因此，你需要学习如何在内存泄露出现前就能预测到问题，并防止他们发生。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM核心知识点</title>
    <url>/2021/06/01/JVM%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="Java8-JVM内存结构"><a href="#Java8-JVM内存结构" class="headerlink" title="Java8  JVM内存结构"></a>Java8  JVM内存结构</h1><p>基本结构与之前类似，只是Java8取消了之前的“永久代”，取而代之的是“元空间”——<strong>Metaspace</strong>，两者本质是一样的。“永久代”使用的是JVM的堆内存，而“元空间”是直接使用的本机物理内存。</p>
<p><img src="./images/JVM//JVMMem.png" alt=""></p>
<span id="more"></span>

<h1 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h1><h2 id="如果判断一个对象可以被回收？"><a href="#如果判断一个对象可以被回收？" class="headerlink" title="如果判断一个对象可以被回收？"></a>如果判断一个对象可以被回收？</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>维护一个计数器，如果有对该对象的引用，计数器+1，反之-1。无法解决循环引用的问题。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>从一组名为“GC Roots”的根节点对象出发，向下遍历。那些没有被遍历到、与GC Roots形成通路的对象，会被标记为“回收”。</p>
<h2 id="哪些对象可以作为GC-Roots？"><a href="#哪些对象可以作为GC-Roots？" class="headerlink" title="哪些对象可以作为GC Roots？"></a>哪些对象可以作为GC Roots？</h2><ol>
<li>虚拟机栈（栈帧中的局部变量）中引用的对象。</li>
<li>本地方法栈（native）中引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
</ol>
<h1 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h1><h2 id="JVM-三种类型参数"><a href="#JVM-三种类型参数" class="headerlink" title="JVM 三种类型参数"></a>JVM 三种类型参数</h2><h3 id="标配参数"><a href="#标配参数" class="headerlink" title="标配参数"></a>标配参数</h3><p>比如<code>-version</code>、<code>-help</code>、<code>-showversion</code>等，几乎不会改变。</p>
<h3 id="X参数"><a href="#X参数" class="headerlink" title="X参数"></a>X参数</h3><p>用得不多，比如<code>-Xint</code>，解释执行模式；<code>-Xcomp</code>，编译模式；<code>-Xmixed</code>，开启混合模式（默认）。</p>
<p><img src="./images/JVM//InkedJVMXParam_LI.jpg" alt=""></p>
<h3 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h3><p>重要，用于JVM调优。</p>
<h2 id="JVM-XX参数"><a href="#JVM-XX参数" class="headerlink" title="JVM XX参数"></a>JVM XX参数</h2><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p><strong>公式</strong>：<code>-XX:+某个属性</code>、<code>-XX:-某个属性</code>，开启或关闭某个功能。比如<code>-XX:+PrintGCDetails</code>，开启GC详细信息。</p>
<h3 id="KV键值类型"><a href="#KV键值类型" class="headerlink" title="KV键值类型"></a>KV键值类型</h3><p><strong>公式</strong>：<code>-XX:属性key=值value</code>。比如<code>-XX:Metaspace=128m</code>、<code>-XX:MaxTenuringThreshold=15</code>。</p>
<h2 id="JVM-Xms-Xmx参数"><a href="#JVM-Xms-Xmx参数" class="headerlink" title="JVM Xms/Xmx参数"></a>JVM Xms/Xmx参数</h2><p><code>-Xms</code>和<code>-Xmx</code>十分常见，用于设置<strong>初始堆大小</strong>和<strong>最大堆大小</strong>。第一眼看上去，既不像X参数，也不像XX参数。实际上<code>-Xms</code>等价于<code>-XX:InitialHeapSize</code>，<code>-Xmx</code>等价于<code>-XX:MaxHeapSize</code>。所以<code>-Xms</code>和<code>-Xmx</code>属于XX参数。</p>
<h2 id="JVM-查看参数"><a href="#JVM-查看参数" class="headerlink" title="JVM 查看参数"></a>JVM 查看参数</h2><h3 id="查看某个参数"><a href="#查看某个参数" class="headerlink" title="查看某个参数"></a>查看某个参数</h3><p>使用<code>jps -l</code>配合<code>jinfo -flag JVM参数 pid</code> 。先用<code>jsp -l</code>查看java进程，选择某个进程号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">17888</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class="line"><span class="number">5360</span> org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line"><span class="number">18052</span> demo3.demo3</span><br></pre></td></tr></table></figure>

<p><code>jinfo -flag PrintGCDetails 18052</code>可以查看18052 Java进程的<code>PrintGCDetails</code>参数信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:-PrintGCDetails</span><br></pre></td></tr></table></figure>

<h3 id="查看所有参数"><a href="#查看所有参数" class="headerlink" title="查看所有参数"></a>查看<strong>所有</strong>参数</h3><p>使用<code>jps -l</code>配合<code>jinfo -flags pid</code>可以查看所有参数。</p>
<p>也可以使用<code>java -XX:+PrintFlagsInitial</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">     intx ActiveProcessorCount                      = -<span class="number">1</span>            &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeDecrementScaleFactor          = <span class="number">4</span>             &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale         = <span class="number">10</span>            &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePausePolicy                   = <span class="number">0</span>             &#123;product&#125;</span><br><span class="line">······</span><br><span class="line">    uintx YoungPLABSize                             = <span class="number">4096</span>          &#123;product&#125;</span><br><span class="line">     bool ZeroTLAB                                  = <span class="keyword">false</span>         &#123;product&#125;</span><br><span class="line">     intx hashCode                                  = <span class="number">5</span>             &#123;product&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查看修改后的参数"><a href="#查看修改后的参数" class="headerlink" title="查看修改后的参数"></a>查看<strong>修改</strong>后的参数</h3><p>使用<code>java -XX:PrintFlagsFinal</code>可以查看修改后的参数，与上面类似。只是修改过后是<code>:=</code>而不是<code>=</code>。</p>
<h3 id="查看常见参数"><a href="#查看常见参数" class="headerlink" title="查看常见参数"></a>查看<strong>常见</strong>参数</h3><p>如果不想查看所有参数，可以用<code>-XX:+PrintCommandLineFlags</code>查看常用参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=<span class="number">132375936</span> -XX:MaxHeapSize=<span class="number">2118014976</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure>

<h2 id="JVM-常用参数"><a href="#JVM-常用参数" class="headerlink" title="JVM 常用参数"></a>JVM 常用参数</h2><h3 id="Xmx-Xms"><a href="#Xmx-Xms" class="headerlink" title="-Xmx/-Xms"></a>-Xmx/-Xms</h3><p>最大和初始堆大小。最大默认为物理内存的1/4，初始默认为物理内存的1/64。</p>
<h3 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h3><p>等价于<code>-XX:ThresholdStackSize</code>。用于设置单个栈的大小，系统默认值是0，<strong>不代表栈大小为0</strong>。而是根据操作系统的不同，有不同的值。比如64位的Linux系统是1024K，而Windows系统依赖于虚拟内存。</p>
<h3 id="Xmn"><a href="#Xmn" class="headerlink" title="-Xmn"></a>-Xmn</h3><p>新生代大小，一般不调。</p>
<h3 id="XX-MetaspaceSize"><a href="#XX-MetaspaceSize" class="headerlink" title="-XX:MetaspaceSize"></a>-XX:MetaspaceSize</h3><p>设置元空间大小。</p>
<h3 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a>-XX:+PrintGCDetails</h3><p>输出GC收集信息，包含<code>GC</code>和<code>Full GC</code>信息。</p>
<h3 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h3><p>新生代中，<code>Eden</code>区和两个<code>Survivor</code>区的比例，默认是<code>8:1:1</code>。通过<code>-XX:SurvivorRatio=4</code>改成<code>4:1:1</code></p>
<h3 id="XX-NewRatio"><a href="#XX-NewRatio" class="headerlink" title="-XX:NewRatio"></a>-XX:NewRatio</h3><p>老生代和新年代的比列，默认是2，即老年代占2，新生代占1。如果改成<code>-XX:NewRatio=4</code>，则老年代占4，新生代占1。</p>
<h3 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h3><p>新生代设置进入老年代的时间，默认是新生代逃过15次GC后，进入老年代。如果改成0，那么对象不会在新生代分配，直接进入老年代。</p>
<h1 id="四大引用"><a href="#四大引用" class="headerlink" title="四大引用"></a>四大引用</h1><p>以下Demo都需要设置<code>-Xmx</code>和<code>-Xms</code>，不然系统默认很大，很难演示。</p>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>使用<code>new</code>方法创造出来的对象，默认都是强引用。GC的时候，就算<strong>内存不够</strong>，抛出<code>OutOfMemoryError</code>也不会回收对象，<strong>死了也不回收</strong>。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/StrongReferenceDemo.java">StrongReferenceDemo</a>。</p>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>需要用<code>Object.Reference.SoftReference</code>来显示创建。<strong>如果内存够</strong>，GC的时候<strong>不回收</strong>。<strong>内存不够</strong>，<strong>则回收</strong>。常用于内存敏感的应用，比如高速缓存。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/SoftReferenceDemo.java">SoftReferenceDemo</a>。</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>需要用<code>Object.Reference.WeakReference</code>来显示创建。<strong>无论内存够不够，GC的时候都回收</strong>，也可以用在高速缓存上。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/WeakReferenceDemo.java">WeakReferenceDemo</a></p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>传统的<code>HashMap</code>就算<code>key==null</code>了，也不会回收键值对。但是如果是<code>WeakHashMap</code>，一旦内存不够用时，且<code>key==null</code>时，会回收这个键值对。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/WeakHashMapDemo.java">WeakHashMapDemo</a>。</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>软应用和弱引用可以通过<code>get()</code>方法获得对象，但是虚引用不行。虚引形同虚设，在任何时候都可能被GC，不能单独使用，必须配合<strong>引用队列（ReferenceQueue）</strong>来使用。设置虚引用的<strong>唯一目的</strong>，就是在这个对象被回收时，收到一个<strong>通知</strong>以便进行后续操作，有点像<code>Spring</code>的后置通知。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/PhantomReferenceDemo.java">PhantomReferenceDemo</a>。</p>
<h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><p>弱引用、虚引用被回收后，会被放到引用队列里面，通过<code>poll</code>方法可以得到。关于引用队列和弱、虚引用的配合使用，见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/ReferenceQueueDemo.java">ReferenceQueueDemo</a>。</p>
<h1 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h1><h2 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h2><p>栈满会抛出该错误。无限递归就会导致StackOverflowError，是<code>java.lang.Throwable</code>→<code>java.lang.Error</code>→<code>java.lang.VirtualMachineError</code>下的错误。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/StackOverflowErrorDemo.java">StackOverflowErrorDemo</a>。</p>
<h2 id="OOM—Java-head-space"><a href="#OOM—Java-head-space" class="headerlink" title="OOM—Java head space"></a>OOM—Java head space</h2><p>栈满会抛出该错误。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/JavaHeapSpaceDemo.java">JavaHeapSpaceDemo</a>。</p>
<h2 id="OOM—GC-overhead-limit-exceeded"><a href="#OOM—GC-overhead-limit-exceeded" class="headerlink" title="OOM—GC overhead limit exceeded"></a>OOM—GC overhead limit exceeded</h2><p>这个错误是指：GC的时候会有“Stop the World”，STW越小越好，正常情况是GC只会占到很少一部分时间。但是如果用超过98%的时间来做GC，而且收效甚微，就会被JVM叫停。下例中，执行了多次<code>Full GC</code>，但是内存回收很少，最后抛出了<code>OOM:GC overhead limit exceeded</code>错误。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/GCOverheadDemo.java">GCOverheadDemo</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;496K(2560K)] 2048K-&gt;960K(9728K), <span class="number">0.0036555</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2544K-&gt;489K(2560K)] 3008K-&gt;2689K(9728K), <span class="number">0.0060306</span> secs] [Times: user=<span class="number">0.08</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2537K-&gt;512K(2560K)] 4737K-&gt;4565K(9728K), <span class="number">0.0050620</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2560K-&gt;496K(2560K)] 6613K-&gt;6638K(9728K), <span class="number">0.0064025</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2048K-&gt;860<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 6264K-&gt;7008<span class="title">K</span><span class="params">(7168K)</span>] 8312K-&gt;7869<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3223K-&gt;3223<span class="title">K</span><span class="params">(1056768K)</span>], 0.1674947 secs] [Times: user</span>=<span class="number">0.63</span> sys=<span class="number">0.00</span>, real=<span class="number">0.17</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2048K-&gt;2006<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 7008K-&gt;7008<span class="title">K</span><span class="params">(7168K)</span>] 9056K-&gt;9015<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3224K-&gt;3224<span class="title">K</span><span class="params">(1056768K)</span>], 0.1048666 secs] [Times: user</span>=<span class="number">0.45</span> sys=<span class="number">0.00</span>, real=<span class="number">0.10</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2047K-&gt;2047<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 7082K-&gt;7082<span class="title">K</span><span class="params">(7168K)</span>] 9130K-&gt;9130<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3313K-&gt;3313<span class="title">K</span><span class="params">(1056768K)</span>], 0.0742516 secs] [Times: user</span>=<span class="number">0.28</span> sys=<span class="number">0.00</span>, real=<span class="number">0.07</span> secs] </span><br><span class="line"></span><br><span class="line">·······</span><br><span class="line"></span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2047K-&gt;2047<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 7084K-&gt;7084<span class="title">K</span><span class="params">(7168K)</span>] 9132K-&gt;9132<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3313K-&gt;3313<span class="title">K</span><span class="params">(1056768K)</span>], 0.0738461 secs] [Times: user</span>=<span class="number">0.36</span> sys=<span class="number">0.02</span>, real=<span class="number">0.07</span> secs] </span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> [<span class="function">Full <span class="title">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2047K-&gt;0<span class="title">K</span><span class="params">(2560K)</span>] [ParOldGen: 7119K-&gt;647<span class="title">K</span><span class="params">(7168K)</span>] 9167K-&gt;647<span class="title">K</span><span class="params">(9728K)</span>, [Metaspace: 3360K-&gt;3360<span class="title">K</span><span class="params">(1056768K)</span>], 0.0129597 secs] [Times: user</span>=<span class="number">0.11</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">	at java.lang.Integer.toString(Integer.java:<span class="number">401</span>)</span><br><span class="line">	at java.lang.String.valueOf(String.java:<span class="number">3099</span>)</span><br><span class="line">	at jvm.GCOverheadDemo.main(GCOverheadDemo.java:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<h2 id="OOM—GC-Direct-buffer-memory"><a href="#OOM—GC-Direct-buffer-memory" class="headerlink" title="OOM—GC Direct buffer memory"></a>OOM—GC Direct buffer memory</h2><p>在写<code>NIO</code>程序的时候，会用到<code>ByteBuffer</code>来读取和存入数据。与Java堆的数据不一样，<code>ByteBuffer</code>使用<code>native</code>方法，直接在<strong>堆外分配内存</strong>。当堆外内存（也即本地物理内存）不够时，就会抛出这个异常。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/DirectBufferMemoryDemo.java">DirectBufferMemoryDemo</a>。</p>
<h2 id="OOM—unable-to-create-new-native-thread"><a href="#OOM—unable-to-create-new-native-thread" class="headerlink" title="OOM—unable to create new native thread"></a>OOM—unable to create new native thread</h2><p>在高并发应用场景时，如果创建超过了系统默认的最大线程数，就会抛出该异常。Linux单个进程默认不能超过1024个线程。<strong>解决方法</strong>要么降低程序线程数，要么修改系统最大线程数<code>vim /etc/security/limits.d/90-nproc.conf</code>。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/UnableCreateNewThreadDemo.java">UnableCreateNewThreadDemo</a></p>
<h2 id="OOM—Metaspace"><a href="#OOM—Metaspace" class="headerlink" title="OOM—Metaspace"></a>OOM—Metaspace</h2><p>元空间满了就会抛出这个异常。</p>
<h1 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h1><h2 id="四大垃圾收集算法"><a href="#四大垃圾收集算法" class="headerlink" title="四大垃圾收集算法"></a>四大垃圾收集算法</h2><h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p><img src="./images/JVM//GCbq.png" alt=""></p>
<p><img src="/images/JVM//GCbz.png" alt=""></p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p><img src="/images/JVM//GCbq.png" alt=""></p>
<p><img src="/images/JVM//GCbq2.png" alt=""></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="/images/JVM//GCfz.png" alt=""></p>
<p><img src="/images/JVM//GCfz2.png" alt=""></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>准确来讲，跟前面三种算法有所区别。分代收集算法就是根据对象的年代，采用上述三种算法来收集。</p>
<ol>
<li>对于新生代：每次GC都有大量对象死去，存活的很少，常采用复制算法，只需要拷贝很少的对象。</li>
<li>对于老年代：常采用标整或者标清算法。</li>
</ol>
<h2 id="四种垃圾收集器"><a href="#四种垃圾收集器" class="headerlink" title="四种垃圾收集器"></a>四种垃圾收集器</h2><p>Java 8可以将垃圾收集器分为四类。</p>
<h3 id="串行收集器Serial"><a href="#串行收集器Serial" class="headerlink" title="串行收集器Serial"></a>串行收集器Serial</h3><p>为单线程环境设计且<strong>只使用一个线程</strong>进行GC，会暂停所有用户线程，不适用于服务器。就像去餐厅吃饭，只有一个清洁工在打扫。</p>
<h3 id="并行收集器Parrallel"><a href="#并行收集器Parrallel" class="headerlink" title="并行收集器Parrallel"></a>并行收集器Parrallel</h3><p>使用<strong>多个线程</strong>并行地进行GC，会暂停所有用户线程，适用于科学计算、大数据后台，交互性不敏感的场合。多个清洁工同时在打扫。</p>
<h3 id="并发收集器CMS"><a href="#并发收集器CMS" class="headerlink" title="并发收集器CMS"></a>并发收集器CMS</h3><p>用户线程和GC线程同时执行（不一定是并行，交替执行），GC时不需要停顿用户线程，互联网公司多用，适用对响应时间有要求的场合。清洁工打扫的时候，也可以就餐。</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>对内存的划分与前面3种很大不同，将堆内存分割成不同的区域，然后并发地进行垃圾回收。</p>
<h2 id="默认垃圾收集器"><a href="#默认垃圾收集器" class="headerlink" title="默认垃圾收集器"></a>默认垃圾收集器</h2><h3 id="默认收集器有哪些？"><a href="#默认收集器有哪些？" class="headerlink" title="默认收集器有哪些？"></a>默认收集器有哪些？</h3><p>有<code>Serial</code>、<code>Parallel</code>、<code>ConcMarkSweep</code>（CMS）、<code>ParNew</code>、<code>ParallelOld</code>、<code>G1</code>。还有一个<code>SerialOld</code>，快被淘汰了。</p>
<h3 id="查看默认垃圾修改器"><a href="#查看默认垃圾修改器" class="headerlink" title="查看默认垃圾修改器"></a>查看默认垃圾修改器</h3><p>使用<code>java -XX:+PrintCommandLineFlags</code>即可看到，Java 8默认使用<code>-XX:+UseParallelGC</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=<span class="number">132375936</span> -XX:MaxHeapSize=<span class="number">2118014976</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure>

<h2 id="七大垃圾收集器"><a href="#七大垃圾收集器" class="headerlink" title="七大垃圾收集器"></a>七大垃圾收集器</h2><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p><code>Serial</code>、<code>Parallel Scavenge</code>、<code>ParNew</code>用户回收新生代；<code>SerialOld</code>、<code>ParallelOld</code>、<code>CMS</code>用于回收老年代。而<code>G1</code>收集器，既可以回收新生代，也可以回收老年代。</p>
<p><img src="/images/JVM//GCqi.png" alt=""></p>
<p>连线表示可以搭配使用，红叉表示不推荐一同使用，比如新生代用<code>Serial</code>，老年代用<code>CMS</code>。</p>
<p><img src="/images/JVM//GCqi2.png" alt=""></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>年代最久远，是<code>Client VM</code>模式下的默认新生代收集器，使用<strong>复制算法</strong>。<strong>优点</strong>：单个线程收集，没有线程切换开销，拥有最高的单线程GC效率。<strong>缺点</strong>：收集的时候会暂停用户线程。</p>
<p>使用<code>-XX:+UseSerialGC</code>可以显式开启，开启后默认使用<code>Serial</code>+<code>SerialOld</code>的组合。</p>
<p><img src="/images/JVM//serial.jpeg" alt=""></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>也就是<code>Serial</code>的多线程版本，GC的时候不再是一个线程，而是多个，是<code>Server VM</code>模式下的默认新生代收集器，采用<strong>复制算法</strong>。</p>
<p>使用<code>-XX:+UseParNewGC</code>可以显式开启，开启后默认使用<code>ParNew</code>+<code>SerialOld</code>的组合。但是由于<code>SerialOld</code>已经过时，所以建议配合<code>CMS</code>使用。</p>
<p><img src="/images/JVM//parnew.jpeg" alt=""></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p><code>ParNew</code>收集器仅在新生代使用多线程收集，老年代默认是<code>SerialOld</code>，所以是单线程收集。而<code>Parallel Scavenge</code>在新、老两代都采用多线程收集。<code>Parallel Scavenge</code>还有一个特点就是<strong>吞吐量优先收集器</strong>，可以通过自适应调节，保证最大吞吐量。采用<strong>复制算法</strong>。</p>
<p>使用<code>-XX:+UseParallelGC</code>可以开启， 同时也会使用<code>ParallelOld</code>收集老年代。其它参数，比如<code>-XX:ParallelGCThreads=N</code>可以选择N个线程进行GC，<code>-XX:+UseAdaptiveSizePolicy</code>使用自适应调节策略。</p>
<h3 id="SerialOld收集器"><a href="#SerialOld收集器" class="headerlink" title="SerialOld收集器"></a>SerialOld收集器</h3><p><code>Serial</code>的老年代版本，采用<strong>标整算法</strong>。JDK1.5之前跟<code>Parallel Scavenge</code>配合使用，现在已经不了，作为<code>CMS</code>的后备收集器。</p>
<h3 id="ParallelOld收集器"><a href="#ParallelOld收集器" class="headerlink" title="ParallelOld收集器"></a>ParallelOld收集器</h3><p><code>Parallel</code>的老年代版本，JDK1.6之前，新生代用<code>Parallel</code>而老年代用<code>SerialOld</code>，只能保证新生代的吞吐量。JDK1.8后，老年代改用<code>ParallelOld</code>。</p>
<p>使用<code>-XX:+UseParallelOldGC</code>可以开启， 同时也会使用<code>Parallel</code>收集新生代。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>并发标记清除收集器，是一种以获得<strong>最短GC停顿为</strong>目标的收集器。适用在互联网或者B/S系统的服务器上，这类应用尤其重视服务器的<strong>响应速度</strong>，希望停顿时间最短。是<code>G1</code>收集器出来之前的首选收集器。使用<strong>标清算法</strong>。在GC的时候，会与用户线程并发执行，不会停顿用户线程。但是在<strong>标记</strong>的时候，仍然会<strong>STW</strong>。</p>
<p>使用<code>-XX:+UseConcMarkSweepGC</code>开启。开启过后，新生代默认使用<code>ParNew</code>，同时老年代使用<code>SerialOld</code>作为备用。</p>
<p><img src="/images/JVM//cms.jpeg" alt=""></p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li><strong>初始标记</strong>：只是标记一下GC Roots能直接关联的对象，速度很快，需要<strong>STW</strong>。</li>
<li><strong>并发标记</strong>：主要标记过程，标记全部对象，和用户线程一起工作，不需要STW。</li>
<li><strong>重新标记</strong>：修正在并发标记阶段出现的变动，需要<strong>STW</strong>。</li>
<li><strong>并发清除</strong>：和用户线程一起，清除垃圾，不需要STW。</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong>：停顿时间少，响应速度快，用户体验好。</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>对CPU资源非常敏感：由于需要并发工作，多少会占用系统线程资源。</li>
<li>无法处理浮动垃圾：由于标记垃圾的时候，用户进程仍然在运行，无法有效处理新产生的垃圾。</li>
<li>产生内存碎片：由于使用<strong>标清算法</strong>，会产生内存碎片。</li>
</ol>
<h3 id="G1收集器-1"><a href="#G1收集器-1" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><code>G1</code>收集器与之前垃圾收集器的一个显著区别就是——之前收集器都有三个区域，新、老两代和元空间。而G1收集器只有G1区和元空间。而G1区，不像之前的收集器，分为新、老两代，而是一个一个Region，每个Region既可能包含新生代，也可能包含老年代。</p>
<p><code>G1</code>收集器既可以提高吞吐量，又可以减少GC时间。最重要的是<strong>STW可控</strong>，增加了预测机制，让用户指定停顿时间。</p>
<p>使用<code>-XX:+UseG1GC</code>开启，还有<code>-XX:G1HeapRegionSize=n</code>、<code>-XX:MaxGCPauseMillis=n</code>等参数可调。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><strong>并行和并发</strong>：充分利用多核、多线程CPU，尽量缩短STW。</li>
<li><strong>分代收集</strong>：虽然还保留着新、老两代的概念，但物理上不再隔离，而是融合在Region中。</li>
<li><strong>空间整合</strong>：<code>G1</code>整体上看是<strong>标整</strong>算法，在局部看又是<strong>复制算法</strong>，不会产生内存碎片。</li>
<li><strong>可预测停顿</strong>：用户可以指定一个GC停顿时间，<code>G1</code>收集器会尽量满足。</li>
</ol>
<h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><p>与<code>CMS</code>类似。</p>
<ol>
<li>初始标记。</li>
<li>并发标记。</li>
<li>最终标记。</li>
<li>筛选回收。</li>
</ol>
<h1 id="附—Linux相关指令"><a href="#附—Linux相关指令" class="headerlink" title="附—Linux相关指令"></a>附—Linux相关指令</h1><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>主要查看<code>%CPU</code>、<code>%MEM</code>，还有<code>load average</code>。<code>load average</code>后面的三个数字，表示系统1分钟、5分钟、15分钟的平均负载值。如果三者平均值高于0.6，则复杂比较高了。当然，用<code>uptime</code>也可以查看。</p>
<h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><p>查看进程、内存、I/O等多个系统运行状态。2表示每两秒采样一次，3表示一共采样3次。<code>procs</code>的<code>r</code>表示运行和等待CPU时间片的进程数，原则上1核CPU不要超过2。<code>b</code>是等待资源的进程数，比如磁盘I/O、网络I/O等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ ~]# vmstat -n 2 3</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 2  0      0 173188 239748 1362628    0    0     0     3   17    8  0  0 99  0  0</span><br><span class="line"> 0  0      0 172800 239748 1362636    0    0     0     0  194  485  1  1 99  0  0</span><br><span class="line"> 1  0      0 172800 239748 1362640    0    0     0     0  192  421  1  1 99  0  0</span><br></pre></td></tr></table></figure>

<h2 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h2><p>查看某个进程的运行信息。</p>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>查看内存信息。</p>
<h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>查看磁盘信息。</p>
<h2 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h2><p>查看磁盘I/O信息。比如有时候MySQL在查表的时候，会占用大量磁盘I/O，体现在该指令的<code>%util</code>字段很大。对于死循环的程序，CPU占用固然很高，但是磁盘I/O不高。</p>
<h2 id="ifstat"><a href="#ifstat" class="headerlink" title="ifstat"></a>ifstat</h2><p>查看网络I/O信息，需要安装。</p>
<h1 id="CPU占用过高原因定位"><a href="#CPU占用过高原因定位" class="headerlink" title="CPU占用过高原因定位"></a>CPU占用过高原因定位</h1><p>先用<code>top</code>找到CPU占用最高的进程，然后用<code>ps -mp pid -o THREAD,tid,time</code>，得到该<strong>进程</strong>里面占用最高的<strong>线程</strong>。这个线程是10进制的，将其转成16进制，然后用<code>jstack pid | grep tid</code>可以定位到具体哪一行导致了占用过高。</p>
<h1 id="JVM性能调优和监控工具"><a href="#JVM性能调优和监控工具" class="headerlink" title="JVM性能调优和监控工具"></a>JVM性能调优和监控工具</h1><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>Java版的<code>ps -ef</code>查看所有JVM进程。</p>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>查看JVM中运行线程的状态，比较重要。可以定位CPU占用过高位置，定位死锁位置。</p>
<h2 id="jinfo-jstat"><a href="#jinfo-jstat" class="headerlink" title="jinfo/jstat"></a>jinfo/jstat</h2><p><code>jinfo</code>查看JVM的运行环境参数，比如默认的JVM参数等。<code>jstat</code>统计信息监视工具。</p>
<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>JVM内存映像工具。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识</title>
    <url>/2021/05/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</p>
<span id="more"></span>

<h1 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h1><h2 id="什么是跨平台性？原理是什么"><a href="#什么是跨平台性？原理是什么" class="headerlink" title="什么是跨平台性？原理是什么"></a>什么是跨平台性？原理是什么</h2><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p>
<p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p>
<h2 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h2><ul>
<li>简单易学（Java语言的语法与C语言和C++语言很接近）</li>
<li>面向对象（封装，继承，多态）</li>
<li>平台无关性（Java虚拟机实现平台无关性）</li>
<li>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</li>
<li>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</li>
<li>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</li>
<li>安全性</li>
</ul>
<h2 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="Oracle JDK 和 OpenJDK 的对比"></a>Oracle JDK 和 OpenJDK 的对比</h2><ol>
<li>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全<br> 开源的；</li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</li>
<li>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</li>
<li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</li>
</ol>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h3><p><strong>定义</strong>：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。<br><strong>分类</strong></p>
<ul>
<li>基本数据类型<ul>
<li>数值型<ul>
<li>整数类型(byte,short,int,long)</li>
<li>浮点类型(float,double)</li>
</ul>
</li>
<li>字符型(char)</li>
<li>布尔型(boolean)</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ul>
</li>
</ul>
<p><strong>Java基本数据类型图</strong></p>
<p><img src="/images/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.png" alt="Java基本类型"></p>
<h3 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><a href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上" class="headerlink" title="switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上"></a>switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h3><p>在 Java 5 以前，switch(expr)中，expr 只能是 <code>byte、short、char、int</code>。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是<code>enum</code>类型，从 Java 7 开始，expr 还可以是字符串<code>String</code>，但是长整型<code>long</code>在目前所有的版本中都是不可以的</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h3><ul>
<li>super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li>
<li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li>
<li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li>
<li>super()和this()均需放在构造方法内第一行。</li>
<li>尽管可以用this调用一个构造器，但却不能调用两个。</li>
<li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li>
<li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li>
<li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字</li>
</ul>
<h3 id="static存在的主要意义"><a href="#static存在的主要意义" class="headerlink" title="static存在的主要意义"></a>static存在的主要意义</h3><p>static的主要意义是在于创建独立于具体对象的域变量或者方法。<strong>以致于即使没有创建对象，也能使用属性和调用方法！</strong></p>
<p>static关键字还有一个比较关键的作用就是 <strong>用来形成静态代码块以优化程序性能</strong>。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p>
<p>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p>
<h3 id="static的独特之处"><a href="#static的独特之处" class="headerlink" title="static的独特之处"></a>static的独特之处</h3><ol>
<li>被<code>static</code>修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个<br>实例对象，而是被类的实例对象所共享。</li>
<li>在该类被第一次加载的时候，就会去加载被<code>static</code>修饰的部分，而且只在类第一次使用时加载并进行<br>初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</li>
<li><code>static</code>变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</li>
<li>被<code>static</code>修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</li>
</ol>
<h3 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h3><p>因为static是被类的实例对象所共享，因此<strong>如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。</strong></p>
<p>因此比较常见的static应用场景有：</p>
<ol>
<li>修饰成员变量 </li>
<li>修饰成员方法</li>
<li>静态代码块</li>
<li>修饰类【只能修饰内部类也就是静态内部类】</li>
<li>静态导包</li>
</ol>
<p>static注意事项</p>
<ol>
<li>静态只能访问静态</li>
<li>非静态既可以访问非静态的，也可以访问静态的</li>
</ol>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>面向过程：</p>
<p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</p>
<p>缺点：没有面向对象易维护、易复用、易扩展</p>
<p>面向对象：</p>
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p>
<p>缺点：性能比面向过程低</p>
<p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p>
<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h3 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h3><p><strong>抽象</strong>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>
<p><strong>封装</strong>：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<p><strong>继承</strong>：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p>关于继承如下 3 点请记住：</p>
<ol>
<li>子类拥有父类非 private 的属性和方法。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<p><strong>多态</strong>：所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p>
<p>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</p>
<p>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p>
<h3 id="什么是多态机制？Java语言是如何实现多态的？"><a href="#什么是多态机制？Java语言是如何实现多态的？" class="headerlink" title="什么是多态机制？Java语言是如何实现多态的？"></a>什么是多态机制？Java语言是如何实现多态的？</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p>
<h4 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h4><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p>
<p>继承：在多态中必须存在有继承关系的子类和父类。</p>
<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>
<p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>
<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>
<p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p>
<h3 id="面向对象五大基本原则是什么（可选）"><a href="#面向对象五大基本原则是什么（可选）" class="headerlink" title="面向对象五大基本原则是什么（可选）"></a>面向对象五大基本原则是什么（可选）</h3><ul>
<li><p>单一职责原则SRP(Single Responsibility Principle)</p>
<p>类的功能要单一，不能包罗万象，跟杂货铺似的。</p>
</li>
<li><p>开放封闭原则OCP(Open－Close Principle)</p>
<p>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</p>
</li>
<li><p>里式替换原则LSP(the Liskov Substitution Principle LSP)</p>
<p>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</p>
</li>
<li><p>依赖倒置原则DIP(the Dependency Inversion Principle DIP)</p>
<p>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</p>
</li>
<li><p>接口分离原则ISP(the Interface Segregation Principle ISP)</p>
<p>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</p>
</li>
</ul>
<h2 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h2><h3 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h3><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</p>
<p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<p><strong>相同点</strong></p>
<ul>
<li>接口和抽象类都不能实例化</li>
<li>都位于继承的顶端，用于被其他实现或继承</li>
<li>都包含抽象方法，其子类都必须覆写这些抽象方法</li>
</ul>
<p><strong>不同点</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>声明</td>
<td>抽象类使用<code>abstract</code>关键字声明</td>
<td>接口使用<code>interface</code>关键字声明</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用<code>extends</code>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>
<td>子类使用<code>implements</code>关键字来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象类中的方法可以是任意访问修饰符</td>
<td>接口方法默认修饰符是<code>public</code>。并且不允许定义为<code>private</code>或者<code>protected</code></td>
</tr>
<tr>
<td>多继承</td>
<td>一个类最多只能继承一个抽象类</td>
<td>一个类可以实现多个接口</td>
</tr>
<tr>
<td>字段声明</td>
<td>抽象类的字段声明可以是任意的</td>
<td>接口的字段默认都是<code>static</code>和<code>final</code>的</td>
</tr>
</tbody></table>
<p><strong>备注</strong>：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p>
<p>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</p>
<p>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p>
<ul>
<li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li>
<li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li>
</ul>
<h3 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h3><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。</p>
<p>抽象类不能直接实例化，普通类可以直接实例化。</p>
<h3 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为<code>final</code>该类就不能被继承，这样彼此就会产生矛盾，所以<code>final</code>不能修饰抽象类</p>
<h2 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h2><h3 id="成员变量与局部变量的区别有哪些"><a href="#成员变量与局部变量的区别有哪些" class="headerlink" title="成员变量与局部变量的区别有哪些"></a>成员变量与局部变量的区别有哪些</h3><p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</p>
<p>成员变量：方法外部，类内部定义的变量</p>
<p>局部变量：类的方法中的变量。</p>
<h4 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h4><p>作用域</p>
<ul>
<li>成员变量：针对整个类有效。</li>
<li>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</li>
</ul>
<p>存储位置</p>
<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</li>
<li>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</li>
</ul>
<p>生命周期</p>
<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li>
<li>局部变量：当方法调用完，或者语句结束后，就自动释放。</li>
</ul>
<p>初始值</p>
<ul>
<li>成员变量：有默认初始值。</li>
<li>局部变量：没有默认初始值，使用前必须赋值。</li>
</ul>
<p>使用原则</p>
<ul>
<li>在使用变量时需要遵循的原则为：就近原则</li>
<li>首先在局部范围找，有就使用；接着在成员位置找。</li>
</ul>
<h3 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h3><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<h3 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h3><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h3 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h3><ul>
<li>名字与类名相同；</li>
<li>没有返回值，但不能用void声明构造函数；</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<h3 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h3><p>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</p>
<p>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p>
<h3 id="静态变量与普通变量区别"><a href="#静态变量与普通变量区别" class="headerlink" title="静态变量与普通变量区别"></a>静态变量与普通变量区别</h3><p><code>static</code>变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p>
<p>还有一点就是<code>static</code>成员变量的初始化顺序按照定义的顺序进行初始化。</p>
<h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><p>静态方法和实例方法的区别主要体现在两个方面：</p>
<ol>
<li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li>
</ol>
<h3 id="在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的？"></a>在一个静态方法内调用一个非静态成员为什么是非法的？</h3><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<h3 id="什么是方法的返回值？返回值的作用是什么？"><a href="#什么是方法的返回值？返回值的作用是什么？" class="headerlink" title="什么是方法的返回值？返回值的作用是什么？"></a>什么是方法的返回值？返回值的作用是什么？</h3><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h3><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。</p>
<h3 id="内部类的分类有哪些"><a href="#内部类的分类有哪些" class="headerlink" title="内部类的分类有哪些"></a>内部类的分类有哪些</h3><p>内部类可以分为四种：<strong>静态内部类</strong>、<strong>成员内部类</strong>、<strong>局部内部类</strong>、<strong>匿名内部类</strong>。</p>
<p><strong>静态内部类：</strong></p>
<p>定义在类内部的静态类，就是静态内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static variable:&quot;</span> + radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.StaticInner inner = <span class="keyword">new</span> Outer.StaticInner();</span><br><span class="line">        StaticInner inner2 = <span class="keyword">new</span> StaticInner();</span><br><span class="line">        inner.visit();</span><br><span class="line">        inner2.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式： <code>new 外部类.静态内部类()</code> ,如果在外部类里可以直接<code>StaticInner inner2 = new StaticInner();</code></p>
<p><strong>成员内部类：</strong></p>
<p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count =<span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static variable:&quot;</span> + radius);</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer variable:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        inner.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式：<code>外部类实例.new 内部类()</code></p>
<p><strong>局部内部类：</strong></p>
<p>定义在方法中的内部类，就是局部内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> out_a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> STATIC_b = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunctionClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inner_c = <span class="number">3</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(out_a);</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(inner_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStaticFunctionClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">3</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span></span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内， <code>new 内部类()</code> ，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStaticFunctionClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>匿名内部类：</strong></p>
<p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Service() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;匿名内部类&quot;</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匿名内部类必须继承或实现一个已有的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了没有名字，匿名内部类还有以下特点：</p>
<ul>
<li>匿名内部类必须继承一个抽象类或者实现一个接口。</li>
<li>匿名内部类不能定义任何静态成员和静态方法。</li>
<li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li>
</ul>
<p>匿名内部类创建方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类/接口&#123;</span><br><span class="line">	<span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类的优点"><a href="#内部类的优点" class="headerlink" title="内部类的优点"></a>内部类的优点</h3><ul>
<li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li>
<li>内部类不为同一包的其他类所见，具有很好的封装性；</li>
<li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li>
<li>匿名内部类可以很方便的定义回调。</li>
</ul>
<h3 id="内部类有哪些应用场景"><a href="#内部类有哪些应用场景" class="headerlink" title="内部类有哪些应用场景"></a>内部类有哪些应用场景</h3><ol>
<li>一些多算法场合</li>
<li>解决一些非面向对象的语句块。</li>
<li>适当使用内部类，使得代码更加灵活和富有扩展性。</li>
<li>当某个类除了它的外部类，不再被其他的类使用时。</li>
</ol>
<h3 id="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上<code>final</code>？</h3><p>先看这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">	void outMethod()&#123;</span><br><span class="line">		final int a &#x3D; 10;</span><br><span class="line">		class Inner &#123;</span><br><span class="line">			void innerMethod()&#123;</span><br><span class="line">				System.out.println(a);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上例子，为什么要加<code>final</code>呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非<code>final</code>的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了<code>final</code>，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p>
<h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><h3 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）"></a>构造器（constructor）是否可被重写（override）</h3><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>
<h3 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h3><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<p>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p>
<p>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</p>
<h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><h3 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</h3><p>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p>
<h3 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="为什么 Java 中只有值传递"></a>为什么 Java 中只有值传递</h3><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>
<p>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p>
<h3 id="值传递和引用传递有什么区别"><a href="#值传递和引用传递有什么区别" class="headerlink" title="值传递和引用传递有什么区别"></a>值传递和引用传递有什么区别</h3><p>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>
<p>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h3 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种?"></a>java 中 IO 流分为几种?</h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
<ul>
<li><code>InputStream/Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream/Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>按操作方式分类结构图：</p>
<p><img src="/images/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/IO%E6%B5%81%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86.png" alt="IO流操作方式划分"></p>
<p>按操作对象分类结构图：</p>
<p><img src="/images/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/IO%E6%B5%81%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%92%E5%88%86.png" alt="IO流操作对象划分"></p>
<h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h3><ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
<h3 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h3><ul>
<li>Files. exists()：检测文件路径是否存在。</li>
<li>Files. createFile()：创建文件。</li>
<li>Files. createDirectory()：创建文件夹。</li>
<li>Files. delete()：删除一个文件或目录。</li>
<li>Files. copy()：复制文件。</li>
<li>Files. move()：移动文件。</li>
<li>Files. size()：查看文件个数。</li>
<li>Files. read()：读取文件。</li>
<li>Files. write()：写入文件。</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>静态编译和动态编译</p>
<ul>
<li>静态编译：在编译时确定类型，绑定对象</li>
<li>动态编译：运行时确定类型，绑定对象</li>
</ul>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul>
<li>优点： 运行期类型的判断，动态加载类，提高代码灵活度。</li>
<li>缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA 快捷键</title>
    <url>/2018/11/23/IntelliJ%20IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h3 id="Idea快捷键"><a href="#Idea快捷键" class="headerlink" title="Idea快捷键"></a>Idea快捷键</h3><h4 id="一、跳转"><a href="#一、跳转" class="headerlink" title="一、跳转"></a>一、跳转</h4><p>1.ctrl+Alt+[] 项目之间跳转<br>2.ctrl+e 最近的文件<br>3.ctrl+shift+e 最近编辑的文件<br>4.ctrl+shift+backspace 浏览修改位置的跳转<br>5.ctrl+shift+左箭头（win10会改变屏幕方向） 最新浏览位置的修改<br>6.使用书签进行跳转<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+<span class="built_in">shift</span>+数字或字母 标记书签  </span><br><span class="line">ctrl+数字或者字母 跳转书签  </span><br><span class="line"><span class="built_in">shift</span>+F11 总览书签  </span><br></pre></td></tr></table></figure><br>7.Ctrl+Up/Down 光标中转到当前界面第一行或最后一行下<br>8.Ctrl+[OR] 可以跑到大括号的开头与结尾<br>9.F2 1跳转到错误位置  </p>
<span id="more"></span>
<h4 id="二、高效定位代码"><a href="#二、高效定位代码" class="headerlink" title="二、高效定位代码"></a>二、高效定位代码</h4><p>1.ctrl+n 定位类<br>2.ctrl+shift+n 定位文件<br>3.ctrl+shift+alt+n 定位函数或者属性<br>4.ctrl+shift+f 定位字符串  </p>
<h4 id="三、列操作"><a href="#三、列操作" class="headerlink" title="三、列操作"></a>三、列操作</h4><p>1.ctrl+shift+alt+j 列操作（多行逻辑操作、批量操作）<br>2.Ctrl+←(→) 移动到一个词的开始(结尾)<br>3.Ctrl+Shift+←(→) 从后到前（从前到后）选中一个词<br>4.Ctrl+Home 第一行代码<br>5.Ctrl+End 最后一行代码<br>6.ctrl+alt+l 代码格式化  </p>
<h4 id="四、Livetemplate"><a href="#四、Livetemplate" class="headerlink" title="四、Livetemplate"></a>四、Livetemplate</h4><p>1.Livetemplate 自定义代码模块快捷键和内容  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">位置:ctrl+<span class="built_in">shift</span>+a查找livetemplates,回车  </span><br><span class="line">    <span class="variable">$VAR1</span>第一个值<span class="variable">$VAR2</span>第一个值<span class="variable">$VAR2</span>第二个值  </span><br><span class="line">    $END$鼠标停留位置  </span><br><span class="line">    回车跳转到到下个值</span><br></pre></td></tr></table></figure>

<h4 id="五、Postfix"><a href="#五、Postfix" class="headerlink" title="五、Postfix"></a>五、Postfix</h4><p>1.postfix 参数后面点函数回车，生成代码位置:ctrl+shift+a查找postfix,回车name.field——可自动添加this.name=name以及private String name;<br>  常用：<br>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-foo.fori <span class="keyword">for</span>(int i = 0; i &lt; foo; i++)&#123;&#125;</span><br><span class="line">-foo.return <span class="built_in">return</span> foo;</span><br><span class="line">-foo.sout System.out.println(foo);</span><br><span class="line">-foo.field private Foo foo; this.foo = foo;</span><br><span class="line">-foo.nn <span class="keyword">if</span>(user!=null)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="六、Alter-enter"><a href="#六、Alter-enter" class="headerlink" title="六、Alter+enter"></a>六、Alter+enter</h4><p>1.Alter+enter 智能提示<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-自动创建函数</span><br><span class="line">-list replace 列表替换优化</span><br><span class="line">-字符串format或者build 字符串格式化，build优化减小内存</span><br><span class="line">-接口实现 在接口上回车可自动创建实现类</span><br><span class="line">-单词拼写 波浪线为存在单词问题，可校对单词</span><br><span class="line">-导包</span><br><span class="line">-不知道怎么做就试试Alter+enter</span><br></pre></td></tr></table></figure></p>
<h4 id="七、重构"><a href="#七、重构" class="headerlink" title="七、重构"></a>七、重构</h4><p>1.shift+F6 重构，将某个参数全部修改。<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-重构变量</span><br><span class="line">-重构方法</span><br></pre></td></tr></table></figure></p>
<h4 id="八、抽取"><a href="#八、抽取" class="headerlink" title="八、抽取"></a>八、抽取</h4><p>1.抽取，将常用数据抽取出来变成简单变量或函数。<br>    -抽取变量 Ctrl+Alt+V<br>    -抽取静态变量 Ctrl+Alt+C<br>    -抽取成员变量 Ctrl+Alt+F<br>    -抽取方法参数 Ctrl+Alt+P<br>    -抽取函数 Ctrl+Alt+M  </p>
<h4 id="九、寻找修改轨迹"><a href="#九、寻找修改轨迹" class="headerlink" title="九、寻找修改轨迹"></a>九、寻找修改轨迹</h4><p>1.annotate代码前右击，选中annotate，可以找到代码的所有者，更进一步点击，还可以找到该作者的修改记录<br>2.Ctrl+Alt+Shift+上下箭头 寻找改动的地方<br>3.Ctrl+Alt+Z 撤销，包括单个和项目改动之处<br>4.Local history idea本地历史记录<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Put Label 本地存档说明</span><br><span class="line">Put Label可以用Ctrl+Alt+A的Local History里找到</span><br></pre></td></tr></table></figure></p>
<h4 id="十、关联"><a href="#十、关联" class="headerlink" title="十、关联"></a>十、关联</h4><p>1.spring关联<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl+Alt+Shift+S 中的Facets配置。</span><br><span class="line">可在代码前的行数中看到Spring的关系</span><br></pre></td></tr></table></figure><br>2.与数据库关联<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">添加Database在mapper输入时可以自动提示Database字段。</span><br><span class="line">Shinf+f6重构改表名mapper也可以改。或者直接改。</span><br></pre></td></tr></table></figure></p>
<h4 id="十一、断点调试"><a href="#十一、断点调试" class="headerlink" title="十一、断点调试"></a>十一、断点调试</h4><p>1.Ctrl+F8 添加删除断点<br>2.Shift +f9 dubug运行<br>3.F8 单步运行<br>4.F9 跳到下一个断点<br>5.Ctrl+Shift+F8 查看所有断点位置（在有断点的位置为设置条件断点）<br>6.Alt+F8 查看当前变量值和表达式求值<br>7.Alt+F9 运行到光标位置<br>8.setValue 在debug页面按F2动态设置传递的值<br>9.Ctrl+Shift+f9 运行光标最小上下文<br>10.Shift+Alt+F9 最近运行的历史列表选择运行  </p>
<h4 id="十二、文件操作"><a href="#十二、文件操作" class="headerlink" title="十二、文件操作"></a>十二、文件操作</h4><p>1.Ctrl+Alt+Insert 新建文件<br>2.F5 复制文件<br>3.F6 移动文件  </p>
<h4 id="十三、文本操作"><a href="#十三、文本操作" class="headerlink" title="十三、文本操作"></a>十三、文本操作</h4><p>1.Ctrl+C 复制文件名<br>2.Ctrl+Shift+C 复制文件路径<br>3.Ctrl+Shift+V 剪切板（历史复制）  </p>
<h4 id="十四、结构图"><a href="#十四、结构图" class="headerlink" title="十四、结构图"></a>十四、结构图</h4><p>1.Ctrl+F12 查看当前field,method大纲<br>2.Ctrl+alt+Shift+U查看maven依赖，类图<br>3.Ctrl+H，查看类的继承关系<br>4.Ctrl+Alt+H，查看方法的调用和被调用关系  </p>
<h4 id="十五、其他快捷键"><a href="#十五、其他快捷键" class="headerlink" title="十五、其他快捷键"></a>十五、其他快捷键</h4><p>1.Alt+Q 可以看到当前方法的声明<br>2.Alt+Insert 可以生成构造器/Getter/Setter等<br>3.Ctrl+/或Ctrl+Shift+/ 注释（//或者/**/）<br>4.Ctrl+J 自动代码（例如：serr）<br>5.Ctrl+Shift+J 整合两行<br>6.Ctrl+Shift+U 大小写转化<br>7.Ctrl+Y 删除当前行<br>8.Ctrl+D 复制当前行<br>9.Shift+Enter 向下插入新行<br>10.Ctrl+”+/-”，当前方法展开、折叠<br>11.Ctrl+Shift+”+/-”，全部展开、折叠</p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins环境安装</title>
    <url>/2019/01/11/Jenkins%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>　　Jenkins是一款由Java编写的开源的持续集成工具。<br>　　Jenkins提供了软件开发的持续集成服务。它运行在Servlet容器中（例如Apache Tomcat）。它支持软件配置管理（SCM）工具（包括AccuRev SCM、CVS、Subversion、Git、Perforce、Clearcase和RTC），可以执行基于Apache Ant和Apache Maven的项目，以及任意的Shell脚本和Windows批处理命令。Jenkins的主要开发者是川口耕介。Jenkins是在MIT许可证下发布的自由软件。<br>　　可以通过各种手段触发构建。例如提交给版本控制系统时被触发，也可以通过类似Cron的机制调度，也可以在其他的构建已经完成时，还可以通过一个特定的URL进行请求。</p>
<span id="more"></span>

<h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><h3 id="JDK环境安装"><a href="#JDK环境安装" class="headerlink" title="JDK环境安装"></a>JDK环境安装</h3><p>安装wget，wget是一个从网络上自动下载文件的自由工具，支持通过 HTTP、HTTPS、FTP 三个最常见的 TCP/IP协议 下载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install wget</span><br></pre></td></tr></table></figure>
<p>下载<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JDK</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24&#x3D;http%3A%2F%2Fwww.oracle.com%2F;oraclelicense&#x3D;accept-securebackup-cookie&quot; https:&#x2F;&#x2F;download.oracle.com&#x2F;otn-pub&#x2F;java&#x2F;jdk&#x2F;8u191-b12&#x2F;2787e4a523244c269598db4e85c51e0c&#x2F;jdk-8u191-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u191-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p>配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">#set java environment</span><br><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8</span><br><span class="line">CLASS_PATH&#x3D;$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line">export PATH JAVA_HOME CLASS_PATH</span><br><span class="line"></span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h3 id="Maven安装"><a href="#Maven安装" class="headerlink" title="Maven安装"></a>Maven安装</h3><p>下载<a href="http://mirror.bit.edu.cn/apache/maven/maven-3/">Maven</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://mirror.bit.edu.cn/apache/maven/maven-3/3.6.0/binaries/apache-maven-3.6.0-bin.tar.gz</span><br></pre></td></tr></table></figure>
<p>添加阿里的Maven仓库节点配置<code>conf/settings.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Maven environment</span><br><span class="line">MAVEN_HOME&#x3D;&#x2F;usr&#x2F;maven</span><br><span class="line">PATH&#x3D;$PATH:$MAVEN_HOME&#x2F;bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>
<h3 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h3><p>下载<a href="http://updates.jenkins-ci.org/download/war/">Jenkins</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://updates.jenkins-ci.org/download/war/2.157/jenkins.war</span><br></pre></td></tr></table></figure>
<p>启动Jenkins war包，默认8080端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar jenkins.war</span><br></pre></td></tr></table></figure>
<p>开放端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=8080/tcp --permanent   #添加规则</span><br><span class="line">firewall-cmd --reload                          #重新加载防火墙配置</span><br></pre></td></tr></table></figure>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试题（一）</title>
    <url>/2021/04/12/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><h2 id="1-自增变量"><a href="#1-自增变量" class="headerlink" title="1.自增变量"></a>1.自增变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        i = i++;</span><br><span class="line">        <span class="keyword">int</span> j = i++;</span><br><span class="line">        <span class="keyword">int</span> k = i + ++i * i++;</span><br><span class="line">        System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;j=&quot;</span> + j);</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span> + k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//i=4</span></span><br><span class="line"><span class="comment">//j=1</span></span><br><span class="line"><span class="comment">//k=11</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2、单例模式"><a href="#2、单例模式" class="headerlink" title="2、单例模式"></a>2、单例模式</h2><h3 id="什么是Singleton"><a href="#什么是Singleton" class="headerlink" title="什么是Singleton?"></a>什么是Singleton?</h3><p>Singleton:在Java中 即指单例设置模式，探视软件开发最常用的设置模式之一</p>
<p>单：唯一</p>
<p>例：实例</p>
<p>单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式</p>
<p>例如：代表JVM运行环境的Runtime类</p>
<h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><p>一是某个类只能有一个实例</p>
<ul>
<li>构造器私有化</li>
</ul>
<p>二是他必须自行创建实例</p>
<ul>
<li>含有一个该类的静态变量来保存这个唯一的实例</li>
</ul>
<p>三是它必须自行向整个系统提供这个实例</p>
<p>对外提供获取该类实例对象的方式</p>
<ul>
<li>直接暴露</li>
<li>用静态变量的get方法获取</li>
</ul>
<h3 id="几种常见形式"><a href="#几种常见形式" class="headerlink" title="几种常见形式"></a>几种常见形式</h3><p>饿汉式：直接创建对象，不存在线程安全问题</p>
<ul>
<li>直接实例化饿汉式(简洁直观)</li>
<li>枚举式 (最简洁)</li>
<li>静态代码块饿汉式(适合复杂实例化)</li>
</ul>
<p>懒汉式;延迟创建对象</p>
<ul>
<li><p>线程不安全(使用于单线程)</p>
</li>
<li><p>线程安全(使用于多线程)</p>
</li>
<li><p>静态内部类模式 (适用于多线程)</p>
</li>
</ul>
<h2 id="3、类初始化实例初始化"><a href="#3、类初始化实例初始化" class="headerlink" title="3、类初始化实例初始化"></a>3、类初始化实例初始化</h2><h3 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h3><blockquote>
<p>一个类要创建实例需要先加载并初始化该类</p>
<p>main方法所在的类需要先加载和初始化</p>
<p>一个子类要初始化需要先初始化父类</p>
<p>一个类初始化就是执行 clinit 方法</p>
<p>clinit 方法由静态类变量显示赋值代码和静态代码块组成</p>
<p>类变量显示赋值代码和静态代码块代码从上到下执行</p>
<p>clinit 方法只调用一次</p>
</blockquote>
<h3 id="实例初始化过程"><a href="#实例初始化过程" class="headerlink" title="实例初始化过程"></a>实例初始化过程</h3><blockquote>
<p>实例初始化就是执行 init() 方法</p>
<p>init () 方法可能重载有多个，有几个构造器就有几个 init() 方法</p>
<p>init() 方法由非静态实例变量显示赋值代码和非静态代码块，对应构造器代码组成</p>
<p>非静态实例变量显示赋值代码和非静态代码块从上到下顺序执行，而对应构造器的代码最后执行</p>
<p>每次创建实例对象，调用对应构造器，执行的就是对应的 ini方法</p>
<p>init 方法的首行是super()和super(实参列表) ,即对应父类的 init 方法</p>
</blockquote>
<h3 id="Father-java"><a href="#Father-java" class="headerlink" title="Father.java"></a>Father.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类初始化&lt;clinit&gt;</span></span><br><span class="line"><span class="comment"> * 1、j = method()</span></span><br><span class="line"><span class="comment"> * 2、 父类的静态代码块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 父类实例化方法:</span></span><br><span class="line"><span class="comment"> * 1、super()（最前）</span></span><br><span class="line"><span class="comment"> * 2、i = test() (9)</span></span><br><span class="line"><span class="comment"> * 3、子类的非静态代码块 (3)</span></span><br><span class="line"><span class="comment"> * 4、子类的无参构造（最后）(2)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 非静态方法前面其实有一个默认的对象this</span></span><br><span class="line"><span class="comment"> * this在构造器或&lt;init&gt; 他表示的是正在创建的对象，因为咱们这里是正在创建Son对象，所以</span></span><br><span class="line"><span class="comment"> * test()执行的就是子类重写的代码(面向对象多态)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这里i=test() 执行的就是子类重写的test()方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-04-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(1)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Father() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(2)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(3)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(4)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(5)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Son-java"><a href="#Son-java" class="headerlink" title="Son.java"></a>Son.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类的初始化&lt;clinit&gt;</span></span><br><span class="line"><span class="comment"> * 1、j = method()</span></span><br><span class="line"><span class="comment"> * 2、子类的静态代码块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 先初始化父类 (5)(1)</span></span><br><span class="line"><span class="comment"> * 初始化子类 (10) (6)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 子类实例化方法:</span></span><br><span class="line"><span class="comment"> * 1、super()（最前</span></span><br><span class="line"><span class="comment"> * 2、i = test() (9)</span></span><br><span class="line"><span class="comment"> * 3、子类的非静态代码块 (8)</span></span><br><span class="line"><span class="comment"> * 4、子类的无参构造（最后）(7)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-04-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = method();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(6)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Son() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;(7)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(8)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(9)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(10)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println();</span><br><span class="line">        Son son1 = <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">// out:</span></span><br><span class="line">        <span class="comment">// (5)(1)(10)(6)(9)(3)(2)(9)(8)(7)</span></span><br><span class="line">        <span class="comment">// (9)(3)(2)(9)(8)(7)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、方法参数传递机制"><a href="#4、方法参数传递机制" class="headerlink" title="4、方法参数传递机制"></a>4、方法参数传递机制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-04-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        Integer num = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        MyData my = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        change(i,str,num,arr,my);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;i= &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;str= &quot;</span> + str);</span><br><span class="line">        System.out.println(<span class="string">&quot;num= &quot;</span> + num);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr= &quot;</span> + Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">&quot;my.a= &quot;</span> + my.a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> j, String s, Integer n, <span class="keyword">int</span>[] a, MyData m)</span> </span>&#123;</span><br><span class="line">        j += <span class="number">1</span>;</span><br><span class="line">        s += <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">        m.a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out:</span></span><br><span class="line"><span class="comment">// i= 1</span></span><br><span class="line"><span class="comment">// str= hello</span></span><br><span class="line"><span class="comment">// num= 111</span></span><br><span class="line"><span class="comment">// arr= [2, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// my.a= 11</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、形参是基本数据类型</p>
<ul>
<li>传递数据值</li>
</ul>
<p>2、实参是引用数据类型</p>
<ul>
<li><p>传递地址值</p>
<p>特殊的类型：String、包装类等对象的不可变性</p>
</li>
</ul>
<h2 id="5、递归与迭代"><a href="#5、递归与迭代" class="headerlink" title="5、递归与迭代"></a>5、递归与迭代</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编程题: 有n步台阶，一次只能上1步或2步，共有多少种走法?</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStep</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(f(<span class="number">20</span>));</span><br><span class="line">        System.out.println(loop(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f(n - <span class="number">2</span>) + f(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">loop</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> oneStep = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> twoStep = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum = oneStep + twoStep;</span><br><span class="line">            twoStep = oneStep;</span><br><span class="line">            oneStep = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SSM面试题"><a href="#SSM面试题" class="headerlink" title="SSM面试题"></a>SSM面试题</h1><h2 id="Spring中支持的常用数据库事务传播属性和事务隔离级别"><a href="#Spring中支持的常用数据库事务传播属性和事务隔离级别" class="headerlink" title="Spring中支持的常用数据库事务传播属性和事务隔离级别"></a>Spring中支持的常用数据库事务传播属性和事务隔离级别</h2><h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播，列如方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行，事务传播的行为有传播属性指定，Spring定义了7中类传播行为</p>
<table>
<thead>
<tr>
<th>传播属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>如果有事务在运行，当前的方法就在这个事务内运行，否则就启动一个新的事务，并在自己的事务内运行</td>
</tr>
<tr>
<td>REQUIRED_NEW</td>
<td>当前方法必须启动事务，并在它自己的事务内运行，如果有事务正在运行，应该将他挂起</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>如果有事务在运行，当前的方法就在这个事务内运行，否则他可以不运行在事务中</td>
</tr>
<tr>
<td>NOT_SUPPORTE</td>
<td>当前的方法不应该运行在事务中，如果有运行的事务，将他挂起</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常</td>
</tr>
<tr>
<td>NEVER</td>
<td>当前方法不应该运行在事务中，如果有运行的事务，就抛出异常</td>
</tr>
<tr>
<td>NESTED</td>
<td>如果有事务在运行，当前的方法就应该在这个事物的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行</td>
</tr>
</tbody></table>
<p>事务传播属性可以在@Transactional注解的propagation属性中定义</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><h4 id="数据库事务并发问题"><a href="#数据库事务并发问题" class="headerlink" title="数据库事务并发问题"></a>数据库事务并发问题</h4><p> 假设现在有两个事务：Transaction01和Transaction02并发执行。</p>
<h5 id="1-脏读"><a href="#1-脏读" class="headerlink" title="1) 脏读"></a>1) 脏读</h5><p> ①Transaction01将某条记录的AGE值从20修改为30。</p>
<p> ②Transaction02读取了Transaction01更新后的值：30。</p>
<p> ③Transaction01回滚，AGE值恢复到了20。</p>
<p> ④Transaction02读取到的30就是一个无效的值。</p>
<h5 id="2-不可重复读"><a href="#2-不可重复读" class="headerlink" title="2) 不可重复读"></a>2) 不可重复读</h5><p> ①Transaction01读取了AGE值为20。</p>
<p> ②Transaction02将AGE值修改为30。</p>
<p> ③Transaction01再次读取AGE值为30，和第一次读取不一致。</p>
<h5 id="3-幻读"><a href="#3-幻读" class="headerlink" title="3) 幻读"></a>3) 幻读</h5><p> ①Transaction01读取了STUDENT表中的一部分数据。</p>
<p> ②Transaction02向STUDENT表中插入了新的行。</p>
<p> ③Transaction01读取了STUDENT表时，多出了一些行。</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。</p>
<p>读未提交：READ UNCOMMITTED<br>允许Transaction01读取Transaction02未提交的修改。</p>
<p>读已提交：READ COMMITTED<br> 要求Transaction01只能读取Transaction02已提交的修改。</p>
<p>可重复读：REPEATABLE READ<br> 确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。</p>
<p>串行化：SERIALIZABLE<br> 确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。</p>
<h1 id="JavaEE"><a href="#JavaEE" class="headerlink" title="JavaEE"></a>JavaEE</h1><h2 id="Mysql什么时候建索引、什么时候不适合建索引"><a href="#Mysql什么时候建索引、什么时候不适合建索引" class="headerlink" title="Mysql什么时候建索引、什么时候不适合建索引"></a>Mysql什么时候建索引、什么时候不适合建索引</h2><h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ul>
<li>主键自动建立唯 一 索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询中与其它表关联的字段，外键关系建立索引</li>
<li>频繁更新的字段不适合创建索引，因为每次更新不单是更新了记录还会更新索引</li>
<li>单键组索引的选择问题，who? 在高并发下领向创建组合索引</li>
<li>意询中排序的字段，排序字段若通过索引法访问将大大提高排序速度</li>
<li>查询中统计或者分组字段</li>
</ul>
<h3 id="哪些情况下不要建立索引"><a href="#哪些情况下不要建立索引" class="headerlink" title="哪些情况下不要建立索引"></a>哪些情况下不要建立索引</h3><ul>
<li><p>表记录太少</p>
<p>Why:提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE.</p>
</li>
<li><p>经常增删改的表</p>
<p>因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。<br>注意，如果某个数据列包含许多重复的内容，为它建立索弓就没有太大的实际效果。</p>
</li>
<li><p>where条件里用不到的字段</p>
</li>
<li><p>过滤性不好的字段</p>
</li>
</ul>
<h2 id="JVM垃圾回收机制、GC发生在JVM哪部分，有几种GC，他们的算法是什么"><a href="#JVM垃圾回收机制、GC发生在JVM哪部分，有几种GC，他们的算法是什么" class="headerlink" title="JVM垃圾回收机制、GC发生在JVM哪部分，有几种GC，他们的算法是什么"></a>JVM垃圾回收机制、GC发生在JVM哪部分，有几种GC，他们的算法是什么</h2><blockquote>
<p>GC 发生在JVM的堆里面</p>
</blockquote>
<p><img src="/images/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="JVM体系结构"><br><img src="/images/GC.png" alt="GC"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot使用ELK收集日志</title>
    <url>/2020/01/17/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h3 id="ELK简介"><a href="#ELK简介" class="headerlink" title="ELK简介"></a>ELK简介</h3><p>ELK是有Elastic公司的三个组件配合进行日志收集，分别是：</p>
<ul>
<li><a href="https://www.elastic.co/cn/products/elasticsearch">ElasticSearch</a>:用于存储日志信息。</li>
<li><a href="https://www.elastic.co/cn/products/logstash">Logstash</a>:用于收集、处理和转发日志信息。</li>
<li><a href="https://www.elastic.co/cn/products/kibana">Kibana</a>:提供可搜索的Web可视化界面。</li>
</ul>
<p>ELK也可以配合<a href="https://www.elastic.co/cn/products/beats">Beats</a>进行使用，后续会写一篇文章来介绍。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>之前文章分别介绍了ELK环境的搭建以及Spring Boot与之的整合。</p>
<ul>
<li><a href="https://zhaoyangmushiyi.github.io/2020/01/07/Elasticsearch整合Kibana和Logstash环境搭建/">Elasticsearch整合Kibana和Logstash环境搭建</a></li>
<li><a href="https://zhaoyangmushiyi.github.io/2020/01/16/Spring-boot整合Elasticsearch/">Spring-boot整合Elasticsearch</a></li>
</ul>
<span id="more"></span>

<p>本次教程基于上述两篇教程拓展。</p>
<h3 id="项目修改"><a href="#项目修改" class="headerlink" title="项目修改"></a>项目修改</h3><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><p>添加logstash采集logback日志的相关依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Logback配置"><a href="#Logback配置" class="headerlink" title="Logback配置"></a>Logback配置</h4><p>新建文件<code>logback-spring.xml</code>，放在resource文件夹下面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/console-appender.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--应用名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;APP_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志文件保存路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_FILE_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;&#125;/logs&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>$&#123;APP_NAME&#125;<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--每天记录日志到文件appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_FILE_PATH&#125;/$&#123;APP_NAME&#125;-%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--输出到logstash的appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;LOGSTASH&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--可以访问的logstash日志收集端口--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">destination</span>&gt;</span>localhost:4560<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;LOGSTASH&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Logstash配置"><a href="#Logstash配置" class="headerlink" title="Logstash配置"></a>Logstash配置</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">	jdbc &#123;</span><br><span class="line">		add_field =&gt; &#123;&quot;myid&quot;=&gt;&quot;jdbc&quot;&#125;</span><br><span class="line">		jdbc_connection_string =&gt;</span><br><span class="line">			<span class="string">&quot;&lt;mysql 地址&gt;&quot;</span></span><br><span class="line">		jdbc_user =&gt; &quot;xxxxxxxxxxxxx&quot;</span><br><span class="line">		jdbc_password =&gt; &quot;xxxxxxxxxxxx&quot;</span><br><span class="line">		##数据库驱动的JAR位置</span><br><span class="line">		jdbc_driver_library =&gt; &quot;/usr/share/logstash/config/mysql-connector-java-5.1.47.jar&quot;</span><br><span class="line">		jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">		jdbc_paging_enabled =&gt; &quot;true&quot;</span><br><span class="line">		jdbc_page_size =&gt; &quot;50000&quot;</span><br><span class="line">		statement =&gt; &quot;select id,username,realname,age,birth from tb_user&quot;</span><br><span class="line">		## 每分钟执行一次</span><br><span class="line">		schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	tcp &#123;</span><br><span class="line">		add_field =&gt; &#123;&quot;myid&quot;=&gt;&quot;aptst-log&quot;&#125;</span><br><span class="line">		mode =&gt; &quot;server&quot;</span><br><span class="line">		host =&gt; &quot;0.0.0.0&quot;</span><br><span class="line">		port =&gt; 4560</span><br><span class="line">		codec =&gt; json_lines</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line"></span><br><span class="line">	if [myid] == &quot;jdbc&quot; &#123;</span><br><span class="line">		elasticsearch &#123;</span><br><span class="line">			##elasticsearch 地址</span><br><span class="line">			hosts =&gt; &quot;&lt;elasticsearch 地址&gt;:9200&quot;</span><br><span class="line">			##索引名称</span><br><span class="line">			index =&gt; &quot;index-user&quot;</span><br><span class="line">			document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">			##索引类型</span><br><span class="line">			document_type =&gt; &quot;user&quot;</span><br><span class="line">		&#125;</span><br><span class="line">		stdout &#123;</span><br><span class="line">			codec =&gt; json_lines</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if [myid] == &quot;aptst-log&quot; &#123;</span><br><span class="line">		elasticsearch &#123;</span><br><span class="line">			##elasticsearch 地址</span><br><span class="line">			hosts =&gt; &quot;&lt;elasticsearch 地址&gt;:9200&quot;</span><br><span class="line">			##索引名称</span><br><span class="line">			index =&gt; &quot;springboot-logstash-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Kibana管理"><a href="#Kibana管理" class="headerlink" title="Kibana管理"></a>Kibana管理</h4><p>进入Kibana管理页面</p>
<p><img src="/images/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-1.png" alt="Spring-Boot使用ELK收集日志-1"></p>
<p><img src="/images/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-2.png" alt="Spring-Boot使用ELK收集日志-2"></p>
<p>创建索引模式，输入索引模式名称<code>springboot-logstash-*</code></p>
<p><img src="/images/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-3.png" alt="Spring-Boot使用ELK收集日志-3"></p>
<p>选择时间筛选字段名称为<code>@timestamp</code></p>
<p><img src="/images/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-4.png" alt="Spring-Boot使用ELK收集日志-4"></p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习</title>
    <url>/2021/06/26/Redis%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Redis 是一种开源（BSD 许可）、内存中数据结构存储，用作数据库、缓存和消息代理。Redis 提供了诸如字符串、散列、列表、集合、带范围查询的排序集合、位图、超级日志、地理空间索引和流等数据结构。Redis 内置复制、Lua 脚本、LRU 驱逐、事务和不同级别的磁盘持久化，并通过 Redis Sentinel 和 Redis Cluster 自动分区提供高可用性。</p>
<span id="more"></span>

<h1 id="Docker安装Redis"><a href="#Docker安装Redis" class="headerlink" title="Docker安装Redis"></a>Docker安装Redis</h1><ol>
<li><p>获取镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --name docker-redis -p 6379:6379 redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>redis-cli</code>连接测试使用<code>redis</code>服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it docker-redis /bin/bash</span><br><span class="line">redis-cli</span><br><span class="line">set test 1</span><br><span class="line">get test</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Docker%E5%AE%89%E8%A3%85Redis%E6%B5%8B%E8%AF%95.png" alt="截屏2021-06-26 18.40.43"></p>
</li>
</ol>
<h1 id="Redis键-key"><a href="#Redis键-key" class="headerlink" title="Redis键(key)"></a>Redis键(key)</h1><p>keys * 查看当前库所有key  (匹配：keys *1)</p>
<p>exists key 判断某个key是否存在</p>
<p>type key 查看你的key是什么类型</p>
<p>del key    删除指定的key数据</p>
<p>unlink key  根据value选择非阻塞删除</p>
<p>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</p>
<p>expire key 10  10秒钟：为给定的key设置过期时间</p>
<p>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>
<p>select命令切换数据库</p>
<p>dbsize查看当前数据库的key的数量</p>
<p>flushdb清空当前库</p>
<p>flushall通杀全部库</p>
<h1 id="常用五大数据类型"><a href="#常用五大数据类型" class="headerlink" title="常用五大数据类型"></a>常用五大数据类型</h1><h2 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a>Redis字符串(String)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>set  key value  添加键值对</p>
<p> <img src="/images/Redis%E5%AD%A6%E4%B9%A0/String-set.png" alt="截屏2021-06-26 21.53.41"></p>
<p>*NX：当数据库中key不存在时，可以将key-value添加数据库</p>
<p>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</p>
<p>*EX：key的超时秒数</p>
<p>*PX：key的超时毫秒数，与EX互斥</p>
<p>get  key 查询对应键值</p>
<p>append key value 将给定的value  追加到原值的末尾</p>
<p>strlen key 获得值的长度</p>
<p>setnx key value 只有在 key 不存在时  设置 key 的值</p>
<p>incr key  </p>
<p>将 key 中储存的数字值增1(原子操作，不会被线程调度机制打断)</p>
<p>只能对数字值操作，如果为空，新增值为1</p>
<p>decr key </p>
<p>将 key 中储存的数字值减1</p>
<p>只能对数字值操作，如果为空，新增值为-1</p>
<p>incrby / decrby key 步长 将 key 中储存的数字值增减。自定义步长。</p>
<img src="/images/Redis学习/String-命令1.png" alt="String-命令1.png" style="zoom:50%;" />

<p>mset key1 value1 key2 value2  ….. </p>
<p>同时设置一个或多个 key-value对 </p>
<p>mget key1 key2 key3  …..</p>
<p>同时获取一个或多个 value </p>
<p>msetnx key1 value1 key2 value2  ….. </p>
<p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<strong>原子性，有一个失败则都失败</strong></p>
<p>getrange key 起始位置 结束位置 </p>
<p>获得值的范围，类似java中的substring，<strong>前包，后包</strong></p>
<p>setrange key 起始位置 value </p>
<p>用 value  覆写key 所储存的字符串值，从起始位置 开始(<strong>索引从0开始</strong>)。</p>
<p>setex key 过期时间 value </p>
<p>设置键值的同时，设置过期时间，单位秒。</p>
<p>getset key value </p>
<p>以新换旧，设置了新值同时获得旧值。</p>
<img src="/images/Redis学习/String-命令2.png" alt="String-命令2.png" style="zoom:50%;" />

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/String-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="image-20210626220837603"></p>
<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h2 id="Redis列表-List"><a href="#Redis列表-List" class="headerlink" title="Redis列表(List)"></a><strong>Redis列表(List)</strong></h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>单键多值</p>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/List-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="List-双向链表"></p>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>lpush/rpush  key value1 value2 value3 …. 从左边/右边插入一个或多个值。</p>
<p>lpop/rpop  key从左边/右边吐出一个值。值在键在，值光键亡。</p>
<p>rpoplpush  key1 key2 从key1列表右边吐出一个值，插到 key2列表左边。</p>
<p>lrange key start stop 按照索引下标获得元素(从左到右)</p>
<p>lrange mylist 0 -1  0左边第一个，-1右边第一个，（0 -1表示获取所有）</p>
<p>lindex  key index 按照索引下标获得元素(从左到右)</p>
<p>llen key 获得列表长度 </p>
<p>linsert  key before/after  value newvalue 在 value的后面插入newvalue插入值</p>
<p>lrem key n value 从左边删除n个value(从左到右)</p>
<p>lset key index value 将列表key下标为index的值替换成value</p>
<p> <img src="/images/Redis%E5%AD%A6%E4%B9%A0/List-%E5%91%BD%E4%BB%A4.png" alt="List-命令"></p>
<p><strong>数据结构</strong></p>
<p>List的数据结构为快速链表quickList。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成quicklist。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/List-quicklist.png" alt="List-quicklist"></p>
<p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h2 id="Redis集合-Set"><a href="#Redis集合-Set" class="headerlink" title="Redis集合(Set)"></a><strong>Redis集合(Set)</strong></h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的<strong>复杂度都是**</strong>O(1)**。</p>
<p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p>
<h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>sadd key value1 value2  ….. </p>
<p>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</p>
<p>smembers key 取出该集合的所有值。</p>
<p>sismember key value 判断集合key 是否为含有该value 值，有1，没有0</p>
<p>scard key 返回该集合的元素个数。</p>
<p>srem key value1 value2  …. 删除集合中的某个元素。</p>
<p>spop key <strong>随机从该集合中吐出一个值。</strong></p>
<p>srandmember key n 随机从该集合中取出n个值。不会从集合中删除 。</p>
<p>smove source destination value 把集合中一个值从一个集合移动到另一个集合</p>
<p>sinter key1 key2 返回两个集合的交集元素。</p>
<p>sunion key1 key2 返回两个集合的并集元素。</p>
<p>sdiff key1 key2 返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Set-%E5%91%BD%E4%BB%A4.png" alt="Set-命令"></p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>Set数据结构是dict字典，字典是用哈希表实现的。</p>
<p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h2 id="Redis哈希-Hash"><a href="#Redis哈希-Hash" class="headerlink" title="Redis哈希(Hash)"></a><strong>Redis哈希(Hash)</strong></h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>Redis hash 是一个键值对集合。</p>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>类似Java里面的Map&lt;String,Object&gt;</p>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储</p>
<p>主要有以下2种存储方，然后衍生出我们Hash的存储方式：</p>
<ol>
<li><p>第一种</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Hash-store1-1.png" alt="image-20210627211632603">  </p>
<p>每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。</p>
</li>
<li><p>第二种</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Hash-store1-2.png" alt="image-20210627211728406"></p>
<p>用户ID数据冗余</p>
</li>
<li><p>第三种，Hash</p>
<p><img src="/Users/monochrome/project/blog/hexo-zhaoyangmushiyi/source/images/Redis%E5%AD%A6%E4%B9%A0/Hash-store2.png" alt="image-20210627212109516"></p>
<p>通过 <code>key(用户ID)</code> + <code>field(属性标签)</code>就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题  </p>
</li>
</ol>
<h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>hset key field value 给key 集合中的 field 键赋值value </p>
<p>hget key field 从key集合field取出value </p>
<p>hmset key field1 value1 field2 value2 … 批量设置hash的值</p>
<p>hexists key field 查看哈希表 key 中，给定域 field 是否存在。 </p>
<p>hkeys key 列出该hash集合的所有field</p>
<p>hvals key 列出该hash集合的所有value</p>
<p>hincrby key field increment 为哈希表 key 中的域 field 的值加上增量 1  -1</p>
<p>hsetnx key field value 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</p>
<p>hgetall key 获取该hash集合的所有field以及value</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Hash-%E5%91%BD%E4%BB%A4.png" alt="Hash-命令"></p>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring boot整合Elasticsearch</title>
    <url>/2020/01/16/Spring-boot%E6%95%B4%E5%90%88Elasticsearch/</url>
    <content><![CDATA[<h3 id="环境与版本"><a href="#环境与版本" class="headerlink" title="环境与版本"></a>环境与版本</h3><h4 id="Elasticsearch版本"><a href="#Elasticsearch版本" class="headerlink" title="Elasticsearch版本"></a>Elasticsearch版本</h4><p>服务端：elasticsearch 7.5.1  单节点</p>
<p>客户端：elasticsearch 6.8.5</p>
<h4 id="Logstash获取MySQL数据的配置"><a href="#Logstash获取MySQL数据的配置" class="headerlink" title="Logstash获取MySQL数据的配置"></a>Logstash获取MySQL数据的配置</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">	jdbc &#123;</span><br><span class="line">		add_field =&gt; &#123;&quot;myid&quot;=&gt;&quot;jdbc&quot;&#125;</span><br><span class="line">		jdbc_connection_string =&gt;</span><br><span class="line">			<span class="string">&quot;&lt;mysql 地址&gt;&quot;</span></span><br><span class="line">		jdbc_user =&gt; &quot;xxxxxxxxxxxxx&quot;</span><br><span class="line">		jdbc_password =&gt; &quot;xxxxxxxxxxxx&quot;</span><br><span class="line">		##数据库驱动的JAR位置</span><br><span class="line">		jdbc_driver_library =&gt; &quot;/usr/share/logstash/config/mysql-connector-java-5.1.47.jar&quot;</span><br><span class="line">		jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">		jdbc_paging_enabled =&gt; &quot;true&quot;</span><br><span class="line">		jdbc_page_size =&gt; &quot;50000&quot;</span><br><span class="line">		statement =&gt; &quot;select id,username,realname,age,birth from tb_user&quot;</span><br><span class="line">		## 每分钟执行一次</span><br><span class="line">		schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line"></span><br><span class="line">	if [myid] == &quot;jdbc&quot; &#123;</span><br><span class="line">		elasticsearch &#123;</span><br><span class="line">			##elasticsearch 地址</span><br><span class="line">			hosts =&gt; &quot;&lt;elasticsearch 地址&gt;:9200&quot;</span><br><span class="line">			##索引名称</span><br><span class="line">			index =&gt; &quot;index-user&quot;</span><br><span class="line">			document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">			##索引类型</span><br><span class="line">			document_type =&gt; &quot;user&quot;</span><br><span class="line">		&#125;</span><br><span class="line">		stdout &#123;</span><br><span class="line">			codec =&gt; json_lines</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="Spring-版本"><a href="#Spring-版本" class="headerlink" title="Spring 版本"></a>Spring 版本</h4><p>Spring boot:2.2.2.RELEASE</p>
<p>spring-boot-data-elasticsearch:3.2 对应elasticsearch的版本为6.8.5</p>
<h4 id="完整pom文件"><a href="#完整pom文件" class="headerlink" title="完整pom文件"></a>完整pom文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.monochrome<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>elasticsearch-test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for ElasticSearch<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring-boot-admin.version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">spring-boot-admin.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-admin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>PS：项目用到了Spring Cloud，如果不需要可以去除相关依赖。</p>
<h4 id="Spring-Boot配置文件"><a href="#Spring-Boot配置文件" class="headerlink" title="Spring Boot配置文件"></a>Spring Boot配置文件</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">elasticsearch-test</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&lt;Mysql</span> <span class="string">address&gt;</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">xxxxxxxxxx</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxxxxxxxx</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">cluster-name:</span> <span class="string">docker-cluster</span></span><br><span class="line">      <span class="attr">cluster-nodes:</span> <span class="string">&lt;elasticsearch</span> <span class="string">集群地址&gt;</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">rest:</span></span><br><span class="line">      <span class="attr">uris:</span> [<span class="string">&quot;&lt;elasticsearch 地址&gt;&quot;</span>]</span><br><span class="line">      <span class="attr">ipAddrs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&lt;elasticsearch</span> <span class="string">地址&gt;</span></span><br><span class="line"><span class="comment">#  main:</span></span><br><span class="line"><span class="comment">#    allow-bean-definition-overriding: true</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#客户端注册进eureka服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">&lt;Eureka地址&gt;</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">elasticsearch-test</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment">#访问路径可以显示IP地址</span></span><br><span class="line"><span class="comment">#management.endpoints.web.exposure.include=* #开放所有监控端接口，可以指定开放一些</span></span><br><span class="line"><span class="comment">#management.endpoint.health.show-details=always</span></span><br><span class="line"><span class="comment">#management.endpoints.web.base-path=/monitor</span></span><br><span class="line"><span class="comment">#management.endpoint.shutdown.enabled=true #开启接口优雅关闭 Spring Boot 应用</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8091</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">elasticsearch-test</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><p>定义一个<code>User</code>实体类以及<code>EsUser</code>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity(name = &quot;tb_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy= GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String realname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;index-user&quot;, refreshInterval = &quot;0s&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsUser</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String realname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置Elasticsearch-Rest-High-Level-Client"><a href="#配置Elasticsearch-Rest-High-Level-Client" class="headerlink" title="配置Elasticsearch Rest High Level Client"></a>配置Elasticsearch Rest High Level Client</h4><p>Elasticsearch(ES)有两种连接方式：transport、rest。transport通过TCP方式访问ES(只支持java),rest方式通过http API 访问ES(没有语言限制)。<br>ES官方建议使用rest方式, transport 在7.0版本中不建议使用，在8.X的版本中废弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchRestClientConfig</span> <span class="keyword">extends</span> <span class="title">AbstractElasticsearchConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ES_IP_ADDRESSES_LENGTH = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_SCHEME = <span class="string">&quot;http&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * elasticSearch 服务器地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.elasticsearch.rest.ipAddrs&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ipAddresses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestClientBuilder <span class="title">restClientBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpHost[] hosts = ipAddresses.stream()</span><br><span class="line">                .map(<span class="keyword">this</span>::makeHttpHost)</span><br><span class="line">                .filter(Objects::nonNull)</span><br><span class="line">                .toArray(HttpHost[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">return</span> RestClient.builder(hosts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HttpHost <span class="title">makeHttpHost</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> StringUtils.isNotEmpty(s);</span><br><span class="line">        String[] address = s.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (address.length == ES_IP_ADDRESSES_LENGTH) &#123;</span><br><span class="line">            String ip = address[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> port = Integer.parseInt(address[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HttpHost(ip, port, HTTP_SCHEME);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">elasticsearchClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpHost[] hosts = ipAddresses.stream()</span><br><span class="line">                .map(<span class="keyword">this</span>::makeHttpHost)</span><br><span class="line">                .filter(Objects::nonNull)</span><br><span class="line">                .toArray(HttpHost[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(hosts));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用Spring-data-Jpa-Repository操作数据库"><a href="#使用Spring-data-Jpa-Repository操作数据库" class="headerlink" title="使用Spring data Jpa Repository操作数据库"></a>使用Spring data Jpa Repository操作数据库</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用Spring-Data-Elasticsearch-Repositories操作Elasticsearch"><a href="#使用Spring-Data-Elasticsearch-Repositories操作Elasticsearch" class="headerlink" title="使用Spring Data Elasticsearch Repositories操作Elasticsearch"></a>使用Spring Data Elasticsearch Repositories操作Elasticsearch</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EsUserRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">EsUser</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名为username的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名为username并且真实姓名为realname的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realname</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByUsernameAndRealname</span><span class="params">(String username, String realname)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名为username或者姓名为realname的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByUsernameOrRealname</span><span class="params">(String username, String realname)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名不是username的所有用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByUsernameNot</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询年龄段为ageFrom到ageTo的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ageFrom</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ageTo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByAgeBetween</span><span class="params">(Integer ageFrom, Integer ageTo)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询生日小于birthTo的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByBirthLessThan</span><span class="params">(LocalDateTime birthTo)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询生日段大于birthFrom的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> birthFrom</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByBirthGreaterThan</span><span class="params">(LocalDateTime birthFrom)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询年龄小于或等于ageTo的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByAgeBefore</span><span class="params">(Integer ageTo)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询年龄大于或等于ageFrom的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ageFrom</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByAgeAfter</span><span class="params">(Integer ageFrom)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名模糊查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByUsernameLike</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名以start开头的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByUsernameStartingWith</span><span class="params">(String start)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名以end结尾的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByUsernameEndingWith</span><span class="params">(String end)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名包含word的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByUsernameContaining</span><span class="params">(String word)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询名字属于usernames中的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> usernames</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByUsernameIn</span><span class="params">(Collection&lt;String&gt; usernames)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询名字不属于usernames中的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> usernames</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByUsernameNotIn</span><span class="params">(Collection&lt;String&gt; usernames)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *最后来个复杂点的：查询年龄小于ageTo,姓名以start开头，id大于idTo的用户，并且按照年龄倒序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;EsUser&gt; <span class="title">findByAgeBeforeAndUsernameStartingWithAndIdGreaterThanOrderByAgeDesc</span><span class="params">(Integer ageTo, String start, Long idTo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EsUserRepository esUserRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id:\\d+&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        userRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUsers</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; users)</span> </span>&#123;</span><br><span class="line">        userRepository.saveAll(users);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/username/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;EsUser&gt; <span class="title">getUserByUsername</span><span class="params">(<span class="meta">@PathVariable</span> String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> esUserRepository.findByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/usernameLike/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;EsUser&gt; <span class="title">getUserByUsernameLike</span><span class="params">(<span class="meta">@PathVariable</span> String username)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;get User By Username Like &#123;&#125;&quot;</span>,username);</span><br><span class="line">        <span class="keyword">return</span> esUserRepository.findByUsernameLike(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/ageTo/&#123;ageTo&#125;/name_start/&#123;nameStart&#125;/id/&#123;id:\\d+&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;EsUser&gt; <span class="title">getUserByAgeAndUsernameAndId</span><span class="params">(<span class="meta">@PathVariable</span> Integer ageTo, <span class="meta">@PathVariable</span> String nameStart,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> esUserRepository.findByAgeBeforeAndUsernameStartingWithAndIdGreaterThanOrderByAgeDesc(ageTo, nameStart, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Swagger配置"><a href="#Swagger配置" class="headerlink" title="Swagger配置"></a>Swagger配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.monochrome.elasticsearch&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">&quot;Elasticsearch Demo RESTful APIs&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;服务名：elasticsearch Demo&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式</title>
    <url>/2021/06/09/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p>
<span id="more"></span>

<h1 id="软件设计7大原则"><a href="#软件设计7大原则" class="headerlink" title="软件设计7大原则"></a>软件设计7大原则</h1><table>
<thead>
<tr>
<th>设计原则</th>
<th>一句话归纳</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>开闭原则</td>
<td>对扩展开放，对修改关闭</td>
<td>降低维护带来的新风险</td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td>高层不应该依赖低层，要面向接口编程</td>
<td>更利于代码结构的升级扩展</td>
</tr>
<tr>
<td>单一职责原则</td>
<td>一个类只干一件事，实现类要单一</td>
<td>便于理解，提高代码的可读性</td>
</tr>
<tr>
<td>接口隔离原则</td>
<td>一个接口只干一件事，接口要精简单一</td>
<td>功能解耦，高聚合、低耦合</td>
</tr>
<tr>
<td>迪米特法则</td>
<td>不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td>
<td>只和朋友交流，不和陌生人说话，减少代码臃肿</td>
</tr>
<tr>
<td>里氏替换原则</td>
<td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td>
<td>防止继承泛滥</td>
</tr>
<tr>
<td>合成复用原则</td>
<td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td>
<td>降低代码耦合</td>
</tr>
</tbody></table>
<blockquote>
<p>记忆口诀：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。</p>
</blockquote>
<h1 id="创建型模式的特点和分类"><a href="#创建型模式的特点和分类" class="headerlink" title="创建型模式的特点和分类"></a>创建型模式的特点和分类</h1><p>创建型模式分为以下几种。</p>
<ul>
<li><a href="#单例模式">单例（Singleton）模式</a>：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
</ul>
<p>以上 5 种创建型模式，除了<a href="#工厂方法模式">工厂方法模式</a>属于类创建型模式，其他的全部属于对象创建型模式，我们将在之后的教程中详细地介绍它们的特点、结构与应用。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="什么是Singleton"><a href="#什么是Singleton" class="headerlink" title="什么是Singleton?"></a>什么是Singleton?</h3><p>Singleton:在Java中 即指单例设计模式，探视软件开发最常用的设计模式之一</p>
<p>单：唯一</p>
<p>例：实例</p>
<p>单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式</p>
<p>例如：代表JVM运行环境的Runtime类</p>
<h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><p>一是某个类只能有一个实例</p>
<ul>
<li>构造器私有化</li>
</ul>
<p>二是他必须自行创建实例</p>
<ul>
<li>含有一个该类的静态变量来保存这个唯一的实例</li>
</ul>
<p>三是它必须自行向整个系统提供这个实例</p>
<p>对外提供获取该类实例对象的方式</p>
<ul>
<li>直接暴露</li>
<li>用静态变量的get方法获取</li>
</ul>
<h3 id="几种常见形式"><a href="#几种常见形式" class="headerlink" title="几种常见形式"></a>几种常见形式</h3><p>饿汉式：直接创建对象，不存在线程安全问题</p>
<ul>
<li><p>直接实例化饿汉式(简洁直观)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、构造器私有化</span></span><br><span class="line"><span class="comment"> * 2、自行创建，并且用静态变量保存</span></span><br><span class="line"><span class="comment"> * 3、向外提供实例</span></span><br><span class="line"><span class="comment"> * 4、强调这是一个单例，我们可以用final修改</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 INSTANCE = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>枚举式 (最简洁)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举类型：表示该类型是有限的几个</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>静态代码块饿汉式(适合复杂实例化)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton3 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton3(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>懒汉式：延迟创建对象</p>
<ul>
<li><p>线程不安全(使用于单线程)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> * 线程不安全(使用于单线程)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>线程安全(使用于多线程)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> * 线程安全(使用于多线程)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton5 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton5.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>静态内部类模式 (适用于多线程)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、内部类被加载和初始化时，才创建INSTANCE实例对象</span></span><br><span class="line"><span class="comment"> * 2、静态内部类不会自动创建,随着外部类的加载初始化而初始化，他是要单独去加载和实例化的</span></span><br><span class="line"><span class="comment"> * 3、因为是在内部类加载和初始化时，创建的，因此线程安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton6 INSTANCE = <span class="keyword">new</span> Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="原型模式的定义与特点"><a href="#原型模式的定义与特点" class="headerlink" title="原型模式的定义与特点"></a>原型模式的定义与特点</h3><p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。</p>
<h4 id="原型模式的优点："><a href="#原型模式的优点：" class="headerlink" title="原型模式的优点："></a>原型模式的优点：</h4><ul>
<li><a href="http://c.biancheng.net/java/">Java</a> 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。</li>
<li>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。</li>
</ul>
<h4 id="原型模式的缺点："><a href="#原型模式的缺点：" class="headerlink" title="原型模式的缺点："></a>原型模式的缺点：</h4><ul>
<li>需要为每一个类都配置一个 clone 方法</li>
<li>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。</li>
<li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li>
</ul>
<h3 id="原型模式的结构与实现"><a href="#原型模式的结构与实现" class="headerlink" title="原型模式的结构与实现"></a>原型模式的结构与实现</h3><p>由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。</p>
<h4 id="1-模式的结构"><a href="#1-模式的结构" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h4><p>原型模式包含以下主要角色。</p>
<ol>
<li>抽象原型类：规定了具体原型对象必须实现的接口。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ol>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-2.png" alt="原型模式的结构图"></p>
<h4 id="2-模式的实现"><a href="#2-模式的实现" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h4><p>原型模式的克隆分为浅克隆和深克隆。</p>
<ul>
<li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li>
<li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li>
</ul>
<p>Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    Realizetype() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型模式的测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Realizetype obj1 = <span class="keyword">new</span> Realizetype();</span><br><span class="line">        Realizetype obj2 = (Realizetype) obj1.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;obj1==obj2?&quot;</span> + (obj1 == obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">具体原型创建成功！</span><br><span class="line">具体原型复制成功！</span><br><span class="line">obj1&#x3D;&#x3D;obj2?false</span><br></pre></td></tr></table></figure>

<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="工厂模式的定义"><a href="#工厂模式的定义" class="headerlink" title="工厂模式的定义"></a>工厂模式的定义</h3><p>定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p>
<p>按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是简单工厂模式、工厂方法模式和抽象工厂模式。</p>
<p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。</p>
<p>在简单工厂模式中创建实例的方法通常为静态<code>static</code>方法，因此简单工厂模式<code>Simple Factory Pattern</code>又叫作静态工厂方法模式<code>Static Factory Method Pattern</code>。</p>
<p>简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。</p>
<p>简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。</p>
<blockquote>
<p>“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
</blockquote>
<h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。</li>
<li>客户端无需知道所创建具体产品的类名，只需知道参数即可。</li>
<li>也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。</li>
<li>使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度</li>
<li>系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂</li>
<li>简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。</p>
<h3 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>简单工厂模式的主要角色如下：</p>
<ul>
<li>简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li>
<li>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</li>
<li>具体产品（ConcreteProduct）：是简单工厂模式的创建目标。</li>
</ul>
<p>其结构图如下图所示:</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="简单工厂模式的结构图"></p>
<p>根据上图写出该模式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体产品：ProductA</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体产品：ProductB</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_B = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_C = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">makeProduct</span><span class="params">(<span class="keyword">int</span> kind)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (kind) &#123;</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_A:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_B:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>在《<a href="http://c.biancheng.net/view/8387.html">简单工厂模式</a>》一节我们介绍了简单工厂模式，提到了简单工厂模式违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
<h3 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li>
<li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li>
<li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li>
</ul>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>类的个数容易过多，增加复杂度</li>
<li>增加了系统的抽象性和理解难度</li>
<li>抽象产品只能生产一种产品，此弊端可使用<a href="#抽象工厂模式">抽象工厂模式</a>解决。</li>
</ul>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ul>
<li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li>
<li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li>
<li>客户不关心创建产品的细节，只关心产品的品牌</li>
</ul>
<h3 id="模式的结构与实现-1"><a href="#模式的结构与实现-1" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。本节来分析其基本结构和实现方法。</p>
<h4 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>工厂方法模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
<p>其结构图如图所示：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="工厂方法模式的结构图"></p>
<h4 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>写出该模式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Product a;</span><br><span class="line">            AbstractFactory af;</span><br><span class="line">            af = (AbstractFactory) ReadXML1.getObject();</span><br><span class="line">            a = af.newProduct();</span><br><span class="line">            a.show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品1：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品2：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂：提供了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂1：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂1生成--&gt;具体产品1...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂2：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂2生成--&gt;具体产品2...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadXML1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文档对象</span></span><br><span class="line">            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();</span><br><span class="line">            DocumentBuilder builder = dFactory.newDocumentBuilder();</span><br><span class="line">            Document doc;</span><br><span class="line">            doc = builder.parse(<span class="keyword">new</span> File(<span class="string">&quot;src/FactoryMethod/config1.xml&quot;</span>));</span><br><span class="line">            <span class="comment">//获取包含类名的文本节点</span></span><br><span class="line">            NodeList nl = doc.getElementsByTagName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">            Node classNode = nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            String cName = <span class="string">&quot;FactoryMethod.&quot;</span> + classNode.getNodeValue();</span><br><span class="line">            <span class="comment">//System.out.println(&quot;新类名：&quot;+cName);</span></span><br><span class="line">            <span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">            Class&lt;?&gt; c = Class.forName(cName);</span><br><span class="line">            Object obj = c.newInstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h3><p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>
</ul>
<p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p>
<ul>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>
<li>当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。</li>
<li>抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。</li>
</ul>
<p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。</p>
<h3 id="模式的结构与实现-2"><a href="#模式的结构与实现-2" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。</p>
<h4 id="模式的结构-1"><a href="#模式的结构-1" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>抽象工厂模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li>
</ol>
<p>抽象工厂模式的结构图如图所示：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="抽象工厂模式的结构图"></p>
<h4 id="模式的实现-1"><a href="#模式的实现-1" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>从上图可以看出抽象工厂模式的结构同工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以创建产品的方法也不止一个。下面给出抽象工厂和具体工厂的代码。</p>
<p>(1) 抽象工厂：提供了产品的生成方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product1 <span class="title">newProduct1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product2 <span class="title">newProduct2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体工厂：实现了产品的生成方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product1 <span class="title">newProduct1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂 1 生成--&gt;具体产品 11...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct11();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product2 <span class="title">newProduct2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂 1 生成--&gt;具体产品 21...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct21();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由 CPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。</p>
<p>生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。</p>
<p>以上所有这些产品都是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。</p>
<h3 id="模式的定义与特点-1"><a href="#模式的定义与特点-1" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h3><p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的<a href="http://c.biancheng.net/design_pattern/">设计模式</a>被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
<p>该模式的主要优点如下：</p>
<ol>
<li>封装性好，构建和表示分离。</li>
<li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦。</li>
<li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li>
</ol>
<p>其缺点如下：</p>
<ol>
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li>
</ol>
<p>建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而<a href="http://c.biancheng.net/view/1348.html">工厂方法模式</a>更注重零部件的创建过程，但两者可以结合使用。</p>
<h3 id="模式的结构与实现-3"><a href="#模式的结构与实现-3" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成，现在我们来分析其基本结构和实现方法。</p>
<h4 id="模式的结构-2"><a href="#模式的结构-2" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>建造者（Builder）模式的主要角色如下。</p>
<ol>
<li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。</li>
<li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li>
<li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li>
<li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li>
</ol>
<p>其结构图如图所示：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="建造者模式的结构图"></p>
<h4 id="模式的实现-2"><a href="#模式的实现-2" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>图 1 给出了建造者（Builder）模式的主要结构，其相关类的代码如下。</p>
<p>(1) 产品角色：包含多个组成部件的复杂对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartA</span><span class="params">(String partA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartB</span><span class="params">(String partB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partB = partB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartC</span><span class="params">(String partC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partC = partC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//显示产品的特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(2) 抽象建造者：包含创建产品各个子部件的抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(3) 具体建造者：实现了抽象建造者接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;建造 PartA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartB(<span class="string">&quot;建造 PartB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;建造 PartC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(4) 指挥者：调用建造者中的方法完成复杂对象的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(5) 客户类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product = director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构型模式概述"><a href="#结构型模式概述" class="headerlink" title="结构型模式概述"></a>结构型模式概述</h1><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下 7 种：</p>
<ol>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
</ol>
<p>以上 7 种结构型模式，除了<a href="#适配器模式">适配器模式</a>分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式，下面我们会分别、详细地介绍它们的特点、结构与应用。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。</p>
<p>在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。</p>
<h3 id="代理模式的定义与特点"><a href="#代理模式的定义与特点" class="headerlink" title="代理模式的定义与特点"></a>代理模式的定义与特点</h3><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>代理模式的主要优点有：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</li>
</ul>
<p>其主要缺点是：</p>
<ul>
<li>代理模式会造成系统设计中类的数量增加</li>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
</ul>
<blockquote>
<p>那么如何解决以上提到的缺点呢？答案是可以使用动态代理方式</p>
</blockquote>
<h3 id="代理模式的结构与实现"><a href="#代理模式的结构与实现" class="headerlink" title="代理模式的结构与实现"></a>代理模式的结构与实现</h3><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。</p>
<h4 id="模式的结构-3"><a href="#模式的结构-3" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>代理模式的主要角色如下。</p>
<ol>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ol>
<p>其结构图如图所示：</p>
<p><img src="/Users/monochrome/project/blog/hexo-zhaoyangmushiyi/source/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="代理模式的结构图"></p>
<p>在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。</p>
<p>根据代理的创建时期，代理模式分为静态代理和动态代理。</p>
<ul>
<li>静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</li>
<li>动态：在程序运行时，运用反射机制动态创建而成</li>
</ul>
<h4 id="模式的实现-3"><a href="#模式的实现-3" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>代理模式的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之前的预处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之后的后续处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">访问真实主题之前的预处理。</span><br><span class="line">访问真实主题方法...</span><br><span class="line">访问真实主题之后的后续处理。</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式（Adapter模式）"><a href="#适配器模式（Adapter模式）" class="headerlink" title="适配器模式（Adapter模式）"></a>适配器模式（Adapter模式）</h2><p>在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。</p>
<p>在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。</p>
<h3 id="模式的定义与特点-2"><a href="#模式的定义与特点-2" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h3><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>该模式的主要优点如下。</p>
<ul>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
<li>在很多业务场景中符合开闭原则。</li>
</ul>
<p>其缺点是：</p>
<ul>
<li>适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。</li>
<li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li>
</ul>
<h3 id="模式的结构与实现-4"><a href="#模式的结构与实现-4" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。</p>
<h4 id="模式的结构-4"><a href="#模式的结构-4" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>适配器模式（Adapter）包含以下主要角色。</p>
<ol>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ol>
<p>类适配器模式的结构图：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="类适配器模式的结构图"></p>
<p>对象适配器模式的结构图：</p>
<p><img src="/Users/monochrome/project/blog/hexo-zhaoyangmushiyi/source/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="对象适配器模式的结构图"></p>
<h4 id="模式的实现-4"><a href="#模式的实现-4" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>(1) 类适配器模式的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;适配者中的业务代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapterTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类适配器模式测试：&quot;</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类适配器模式测试：</span><br><span class="line">适配者中的业务代码被调用！</span><br></pre></td></tr></table></figure>

<p>(2)对象适配器模式的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//对象适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapterTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象适配器模式测试：&quot;</span>);</span><br><span class="line">        Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">        Target target = <span class="keyword">new</span> ObjectAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：对象适配器模式中的“目标接口”和“适配者类”的代码同类适配器模式一样，只要修改适配器类和客户端的代码即可。</p>
<p>程序的运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对象适配器模式测试：</span><br><span class="line">适配者中的业务代码被调用！</span><br></pre></td></tr></table></figure>

<h2 id="桥接模式（Bridge模式）"><a href="#桥接模式（Bridge模式）" class="headerlink" title="桥接模式（Bridge模式）"></a>桥接模式（Bridge模式）</h2><p>在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。</p>
<p>当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。如果用桥接模式就能很好地解决这些问题。</p>
<h3 id="桥接模式的定义与特点"><a href="#桥接模式的定义与特点" class="headerlink" title="桥接模式的定义与特点"></a>桥接模式的定义与特点</h3><p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>通过上面的讲解，我们能很好的感觉到桥接模式遵循了里氏替换原则和依赖倒置原则，最终实现了开闭原则，对修改关闭，对扩展开放。这里将桥接模式的优缺点总结如下。</p>
<p>桥接（Bridge）模式的优点是：</p>
<ul>
<li>抽象与实现分离，扩展能力强</li>
<li>符合开闭原则</li>
<li>符合合成复用原则</li>
<li>其实现细节对客户透明</li>
</ul>
<p>缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。</p>
<h3 id="桥接模式的结构与实现"><a href="#桥接模式的结构与实现" class="headerlink" title="桥接模式的结构与实现"></a>桥接模式的结构与实现</h3><p>可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p>
<h4 id="模式的结构-5"><a href="#模式的结构-5" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>桥接（Bridge）模式包含以下主要角色。</p>
<ol>
<li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li>
</ol>
<p>其结构图：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="桥接模式的结构图"></p>
<h4 id="模式的实现-5"><a href="#模式的实现-5" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>桥接模式的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Implementor imple = <span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">        Abstraction abs = <span class="keyword">new</span> RefinedAbstraction(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体实现化(Concrete Implementor)角色被访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor imple;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Abstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imple = imple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展抽象化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(imple);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展抽象化(Refined Abstraction)角色被访问&quot;</span>);</span><br><span class="line">        imple.OperationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">扩展抽象化(Refined Abstraction)角色被访问</span><br><span class="line">具体实现化(Concrete Implementor)角色被访问</span><br></pre></td></tr></table></figure>

<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>上班族大多都有睡懒觉的习惯，每天早上上班时间都很紧张，于是很多人为了多睡一会，就会用方便的方式解决早餐问题。有些人早餐可能会吃煎饼，煎饼中可以加鸡蛋，也可以加香肠，但是不管怎么“加码”，都还是一个煎饼。在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，都是装饰器模式。</p>
<p>在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰器模式来实现。</p>
<h3 id="装饰器模式的定义与特点"><a href="#装饰器模式的定义与特点" class="headerlink" title="装饰器模式的定义与特点"></a>装饰器模式的定义与特点</h3><p>装饰器（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>装饰器模式的主要优点有：</p>
<ul>
<li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用</li>
<li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果</li>
<li>装饰器模式完全遵守开闭原则</li>
</ul>
<p>其主要缺点是：装饰器模式会增加许多子类，过度使用会增加程序得复杂性。</p>
<h3 id="装饰器模式的结构与实现"><a href="#装饰器模式的结构与实现" class="headerlink" title="装饰器模式的结构与实现"></a>装饰器模式的结构与实现</h3><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。下面来分析其基本结构和实现方法。</p>
<h4 id="模式的结构-6"><a href="#模式的结构-6" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>装饰器模式主要包含以下角色。</p>
<ol>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ol>
<p>装饰器模式的结构图:</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%BC%86%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="装饰模式的结构图"></p>
<h4 id="模式的实现-6"><a href="#模式的实现-6" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>装饰器模式的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component p = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        Component d = <span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建具体构件角色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用具体构件角色的方法operation()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;为具体构件角色增加额外的功能addedFunction()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建具体构件角色</span><br><span class="line">调用具体构件角色的方法operation()</span><br><span class="line">---------------------------------</span><br><span class="line">调用具体构件角色的方法operation()</span><br><span class="line">为具体构件角色增加额外的功能addedFunction()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码学习笔记</title>
    <url>/2021/03/25/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Spring源码学习笔记"><a href="#Spring源码学习笔记" class="headerlink" title="Spring源码学习笔记"></a>Spring源码学习笔记</h1><h2 id="Spring-IoC介绍"><a href="#Spring-IoC介绍" class="headerlink" title="Spring IoC介绍"></a>Spring IoC介绍</h2><p>IoC 全称为 <code>Inversion of Control</code>，翻译为 “控制反转”，它还有一个别名为 DI（<code>Dependency Injection</code>）,即依赖注入。</p>
<blockquote>
<p><strong>所谓 IoC ，就是由 Spring IoC 容器来负责对象的生命周期和对象之间的关系</strong></p>
</blockquote>
<ol>
<li><strong>谁控制谁</strong>：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IoC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象</li>
<li><strong>控制什么</strong>：控制对象。</li>
<li><strong>为何是反转</strong>：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li>
<li><strong>哪些方面反转了</strong>：所依赖对象的获取被反转了。</li>
</ol>
<span id="more"></span>

<h2 id="调试环境搭建"><a href="#调试环境搭建" class="headerlink" title="调试环境搭建"></a>调试环境搭建</h2><h3 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h3><ul>
<li>Gradle</li>
<li>Git</li>
<li>JDK1.8+</li>
<li>IntelliJ IDEA</li>
</ul>
<h3 id="源码拉取"><a href="#源码拉取" class="headerlink" title="源码拉取"></a>源码拉取</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/spring-projects/spring-framework.git</span><br></pre></td></tr></table></figure>

<h3 id="预编译-spring-oxm-项目"><a href="#预编译-spring-oxm-项目" class="headerlink" title="预编译 spring-oxm 项目"></a>预编译 <code>spring-oxm</code> 项目</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure>

<h2 id="Spring-统一资源加载策略"><a href="#Spring-统一资源加载策略" class="headerlink" title="Spring 统一资源加载策略"></a>Spring 统一资源加载策略</h2><h3 id="统一资源：Resource"><a href="#统一资源：Resource" class="headerlink" title="统一资源：Resource"></a>统一资源：Resource</h3><p><code>org.springframework.core.io.Resource</code> 为 Spring 框架所有资源的抽象和访问接口，它继承 <code>org.springframework.core.io.InputStreamSource</code>接口。作为所有资源的统一抽象，Resource 定义了一些通用的方法，由子类 <code>AbstractResource</code> 提供统一的默认实现。</p>
<p>如果我们想要实现自定义的 Resource ，记住不要实现 Resource 接口，而应该继承 AbstractResource 抽象类，然后根据当前的具体资源特性覆盖相应的方法即可。</p>
<h3 id="统一资源定位：ResourceLoader"><a href="#统一资源定位：ResourceLoader" class="headerlink" title="统一资源定位：ResourceLoader"></a>统一资源定位：ResourceLoader</h3><p><code>org.springframework.core.io.ResourceLoader</code> 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为统一资源定位器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX; <span class="comment">// CLASSPATH URL 前缀。默认为：&quot;classpath:&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>#getResource(String location)</code>方法，根据所提供资源的路径 location 返回 Resource 实例，但是它不确保该 Resource 一定存在，需要调用<code>Resource#exist()</code>方法来判断。<ul>
<li>该方法支持以下模式的资源加载：<ul>
<li>URL位置资源，如 <code>&quot;file:C:/test.dat&quot;</code> 。</li>
<li>ClassPath位置资源，如 <code>&quot;classpath:test.dat&quot;</code> 。</li>
<li>相对路径资源，如 <code>&quot;WEB-INF/test.dat&quot;</code> ，此时返回的Resource 实例，根据实现不同而不同。</li>
</ul>
</li>
<li>该方法的主要实现是在其子类 DefaultResourceLoader 中实现，具体过程我们在分析 DefaultResourceLoader 时做详细说明。</li>
</ul>
</li>
<li><code>#getClassLoader()</code> 方法，返回 ClassLoader 实例，对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用该方法来获取。在分析 Resource 时，提到了一个类 ClassPathResource ，这个类是可以根据指定的 ClassLoader 来加载资源的。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此 Spring 整个资源记载过程已经分析完毕。下面简要总结下：</p>
<ul>
<li>Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其定位。使得资源与资源的定位有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。</li>
<li>AbstractResource 为 Resource 的默认抽象实现，它对 Resource 接口做了一个统一的实现，子类继承该类后只需要覆盖相应的方法即可，同时对于自定义的 Resource 我们也是继承该类。</li>
<li>DefaultResourceLoader 同样也是 ResourceLoader 的默认实现，在自定 ResourceLoader 的时候我们除了可以继承该类外还可以实现 ProtocolResolver 接口来实现自定资源加载协议。</li>
<li>DefaultResourceLoader 每次只能返回单一的资源，所以 Spring 针对这个提供了另外一个接口 ResourcePatternResolver ，该接口提供了根据指定的 locationPattern 返回多个资源的策略。其子类 PathMatchingResourcePatternResolver 是一个集大成者的 ResourceLoader ，因为它即实现了 <code>Resource getResource(String location)</code> 方法，也实现了 <code>Resource[] getResources(String locationPattern)</code> 方法。</li>
</ul>
<h2 id="加载-BeanDefinition"><a href="#加载-BeanDefinition" class="headerlink" title="加载 BeanDefinition"></a>加载 BeanDefinition</h2><p>先看一段熟悉的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;bean.xml&quot;</span>); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory(); <span class="comment">// &lt;2&gt;</span></span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory); <span class="comment">// &lt;3&gt;</span></span><br><span class="line">reader.loadBeanDefinitions(resource); <span class="comment">// &lt;4&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码是 Spring 中编程式使用 IoC 容器，通过这四段简单的代码，我们可以初步判断 IoC 容器的使用过程。</p>
<ol>
<li>获取资源</li>
<li>获取 BeanFactory</li>
<li>根据新建的 BeanFactory 创建一个 BeanDefinitionReader 对象，该 Reader 对象为资源的<strong>解析器</strong></li>
<li>装载资源</li>
</ol>
<p>整个过程就分为三个步骤：资源定位、装载、注册：</p>
<ul>
<li><strong>资源定位</strong>。我们一般用外部资源来描述 Bean 对象，所以在初始化 IoC 容器的第一步就是需要定位这个外部资源。</li>
<li><strong>装载</strong>。装载就是 BeanDefinition 的载入。BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IoC 容器的内部数据结构：BeanDefinition 。<ul>
<li>在 IoC 容器内部维护着一个 BeanDefinition Map 的数据结构</li>
<li>在配置文件中每一个 <code>&lt;bean&gt;</code> 都对应着一个 BeanDefinition 对象。</li>
<li>本文，我们分享的就是<strong>装载</strong>这个步骤。</li>
</ul>
</li>
<li><strong>注册</strong>。向 IoC 容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistry 接口来实现的。在 IoC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IoC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。<ul>
<li>在这里需要注意的一点是这个过程并没有完成依赖注入（Bean 创建），Bean 创建是发生在应用第一次调用 <code>#getBean(...)</code> 方法，向容器索要 Bean 时。</li>
<li>当然我们可以通过设置预处理，即对某个 Bean 设置 <code>lazyinit = false</code> 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。</li>
</ul>
</li>
</ul>
<blockquote>
<p>简单的说，上面步骤的结果是，XML Resource =&gt; XML Document =&gt; Bean Definition 。</p>
</blockquote>
<h3 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions"></a>loadBeanDefinitions</h3><p>资源定位在前面已经分析了，下面我们直接分析<strong>加载</strong>，上面看到的 <code>reader.loadBeanDefinitions(resource)</code> 代码，才是加载资源的真正实现，所以我们直接从该方法入手。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; XmlBeanDefinitionReader.java</span><br><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从指定的 xml 文件加载 Bean Definition ，这里会先对 Resource 资源封装成 <code>org.springframework.core.io.support.EncodedResource</code> 对象。这里为什么需要将 Resource 封装成 EncodedResource 呢？主要是为了对 Resource 进行编码，保证内容读取的正确性。</li>
<li>然后，再调用 <code>#loadBeanDefinitions(EncodedResource encodedResource)</code> 方法，执行真正的逻辑实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程，正在加载的 EncodedResource 集合。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;EncodedResource&gt;&gt; resourcesCurrentlyBeingLoaded = <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;XML bean definition resources currently being loaded&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &lt;1&gt; 获取已经加载过的资源</span></span><br><span class="line">	Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">	<span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">		currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">		<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123; <span class="comment">// 将当前资源加入记录中。如果已存在，抛出异常</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// &lt;2&gt; 从 EncodedResource 获取封装的 Resource ，并从 Resource 中获取其中的 InputStream</span></span><br><span class="line">		InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">			<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123; <span class="comment">// 设置编码</span></span><br><span class="line">				inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 核心逻辑部分，执行加载 BeanDefinition</span></span><br><span class="line">			<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			inputStream.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 从缓存中剔除该资源 &lt;3&gt;</span></span><br><span class="line">		currentResources.remove(encodedResource);</span><br><span class="line">		<span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;1&gt;</code>处，通过<code>resourcesCurrentlyBeingLoaded.get()</code>代码，来获取已经加载过的资源，然后将<code>encodedResource</code>加入其中，如果<code>resourcesCurrentlyBeingLoaded</code>中已经存在该资源，则抛出 BeanDefinitionStoreException 异常。<ul>
<li>为什么需要这么做呢？答案在 <code>&quot;Detected cyclic loading&quot;</code> ，避免一个 EncodedResource 在加载时，还没加载完成，又加载自身，从而导致<strong>死循环</strong>。</li>
<li>也因此，在 <code>&lt;3&gt;</code> 处，当一个 EncodedResource 加载完成后，需要从缓存中剔除。</li>
</ul>
</li>
<li><code>&lt;2&gt;</code> 处理，从 <code>encodedResource</code> 获取封装的 Resource 资源，并从 Resource 中获取相应的 InputStream ，然后将 InputStream 封装为 InputSource ，最后调用 <code>#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code> 方法，执行加载 Bean Definition 的真正逻辑。</li>
</ul>
<h3 id="doLoadBeanDefinitions"><a href="#doLoadBeanDefinitions" class="headerlink" title="doLoadBeanDefinitions"></a>doLoadBeanDefinitions</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doLoadDocument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerBeanDefinitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// &lt;1&gt; 获取 XML Document 实例</span></span><br><span class="line">		Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">		<span class="comment">// &lt;2&gt; 根据 Document 实例，注册 Bean 信息</span></span><br><span class="line">		<span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                <span class="string">&quot;Line &quot;</span> + ex.getLineNumber() + <span class="string">&quot; in XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Parser configuration exception parsing XML from &quot;</span> + resource, ex);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;IOException parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Unexpected exception parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>&lt;1&gt;</code> 处，调用 <code>#doLoadDocument(InputSource inputSource, Resource resource)</code> 方法，根据 xml 文件，获取 Document 实例。</li>
<li>在 <code>&lt;2&gt;</code> 处，调用 <code>#registerBeanDefinitions(Document doc, Resource resource)</code> 方法，根据获取的 Document 实例，注册 Bean 信息。</li>
</ul>
<h3 id="doLoadDocument"><a href="#doLoadDocument" class="headerlink" title="doLoadDocument"></a>doLoadDocument</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 XML Document 实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Actually load the specified document using the configured DocumentLoader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the DOM Document</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception when thrown from the DocumentLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setDocumentLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DocumentLoader#loadDocument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler,</span><br><span class="line">			getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>调用 <code>#getValidationModeForResource(Resource resource)</code> 方法，获取指定资源（xml）的<strong>验证模式</strong>。详细解析，见 <a href="#获取验证模型-ValidationMode">《获取验证模型》</a> 。</p>
</li>
<li><p>调用 <code>DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，获取 XML Document 实例。详细解析，见 [《获取 Document 对象》](#获取 Document 对象) 。</p>
</li>
</ol>
<h3 id="registerBeanDefinitions"><a href="#registerBeanDefinitions" class="headerlink" title="registerBeanDefinitions"></a>registerBeanDefinitions</h3><p>该方法的详细解析，见 [《注册 BeanDefinition》](#注册 BeanDefinition) 。</p>
<h2 id="获取验证模型-ValidationMode"><a href="#获取验证模型-ValidationMode" class="headerlink" title="获取验证模型(ValidationMode)"></a>获取验证模型(ValidationMode)</h2><p>在核心逻辑方法 <code>#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code> 方法中，中主要是做三件事情：</p>
<ol>
<li>调用 <code>#getValidationModeForResource(Resource resource)</code> 方法，获取指定资源（xml）的<strong>验证模式</strong>。</li>
<li>调用 <code>DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver,ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，获取 XML Document 实例。</li>
<li>调用 <code>#registerBeanDefinitions(Document doc, Resource resource)</code> 方法，根据获取的 Document 实例，注册 Bean 信息。</li>
</ol>
<p>这章主要<strong>第 1 步</strong>，分析获取 xml 文件的验证模式。为什么需要获取验证模式呢？原因如下：</p>
<blockquote>
<p>XML 文件的验证模式保证了 XML 文件的正确性。</p>
</blockquote>
<h3 id="DTD-与-XSD-的区别"><a href="#DTD-与-XSD-的区别" class="headerlink" title="DTD 与 XSD 的区别"></a>DTD 与 XSD 的区别</h3><h4 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h4><p>DTD(Document Type Definition)，即文档类型定义，为 XML 文件的验证机制，属于 XML 文件中组成的一部分。DTD 是一种保证 XML 文档格式正确的有效验证方式，它定义了相关 XML 文档的元素、属性、排列方式、元素的内容类型以及元素的层次结构。其实 DTD 就相当于 XML 中的 “词汇”和“语法”，我们可以通过比较 XML 文件和 DTD 文件 来看文档是否符合规范，元素和标签使用是否正确。</p>
<p>要在 Spring 中使用 DTD，需要在 Spring XML 文件头部声明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">beans</span> <span class="meta-keyword">PUBLIC</span>  <span class="meta-string">&quot;-//SPRING//DTD BEAN//EN&quot;</span>  <span class="meta-string">&quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DTD 在一定的阶段推动了 XML 的发展，但是它本身存在着一些<strong>缺陷</strong>：</p>
<ol>
<li>它没有使用 XML 格式，而是自己定义了一套格式，相对解析器的重用性较差；而且 DTD 的构建和访问没有标准的编程接口，因而解析器很难简单的解析 DTD 文档。</li>
<li>DTD 对元素的类型限制较少；同时其他的约束力也叫弱。</li>
<li>DTD 扩展能力较差。</li>
<li>基于正则表达式的 DTD 文档的描述能力有限。</li>
</ol>
<h4 id="XSD"><a href="#XSD" class="headerlink" title="XSD"></a>XSD</h4><p>针对 DTD 的缺陷，W3C 在 2001 年推出 XSD。XSD（XML Schemas Definition）即 XML Schema 语言。XML Schema 本身就是一个 XML文档，使用的是 XML 语法，因此可以很方便的解析 XSD 文档。相对于 DTD，XSD 具有如下<strong>优势</strong>：</p>
<ol>
<li>XML Schema 基于 XML ，没有专门的语法。</li>
<li>XML Schema 可以象其他 XML 文件一样解析和处理。</li>
<li>XML Schema 比 DTD 提供了更丰富的数据类型。</li>
<li>XML Schema 提供可扩充的数据模型。</li>
<li>XML Schema 支持综合命名空间。</li>
<li>XML Schema 支持属性组。</li>
</ol>
<h3 id="getValidationModeForResource"><a href="#getValidationModeForResource" class="headerlink" title="getValidationModeForResource"></a>getValidationModeForResource</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_NONE = XmlValidationModeDetector.VALIDATION_NONE;</span><br><span class="line"><span class="comment">// 自动获取验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_AUTO = XmlValidationModeDetector.VALIDATION_AUTO;</span><br><span class="line"><span class="comment">// DTD 验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_DTD = XmlValidationModeDetector.VALIDATION_DTD;</span><br><span class="line"><span class="comment">// XSD 验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_XSD = XmlValidationModeDetector.VALIDATION_XSD;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证模式。默认为自动模式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> validationMode = VALIDATION_AUTO;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getValidationModeForResource</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// &lt;1&gt; 获取指定的验证模式</span></span><br><span class="line">	<span class="keyword">int</span> validationModeToUse = getValidationMode();</span><br><span class="line">	<span class="comment">// 首先，如果手动指定，则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (validationModeToUse != VALIDATION_AUTO) &#123;</span><br><span class="line">		<span class="keyword">return</span> validationModeToUse;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 其次，自动获取验证模式</span></span><br><span class="line">	<span class="keyword">int</span> detectedMode = detectValidationMode(resource);</span><br><span class="line">	<span class="keyword">if</span> (detectedMode != VALIDATION_AUTO) &#123;</span><br><span class="line">		<span class="keyword">return</span> detectedMode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后，使用 VALIDATION_XSD 做为默认</span></span><br><span class="line">	<span class="comment">// Hmm, we didn&#x27;t get a clear indication... Let&#x27;s assume XSD,</span></span><br><span class="line">	<span class="comment">// since apparently no DTD declaration has been found up until</span></span><br><span class="line">	<span class="comment">// detection stopped (before finding the document&#x27;s root tag).</span></span><br><span class="line">	<span class="keyword">return</span> VALIDATION_XSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取-Document-对象"><a href="#获取-Document-对象" class="headerlink" title="获取 Document 对象"></a>获取 Document 对象</h2><p>在 <code>XmlBeanDefinitionReader#doLoadDocument(InputSource inputSource, Resource resource)</code> 方法，中做了两件事情：</p>
<ul>
<li>调用<code>#getValidationModeForResource(Resource resource)</code>方法，获取指定资源（xml）的验证模式。</li>
<li>调用 <code>DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，获取 XML Document 实例。</li>
</ul>
<h3 id="DocumentLoader"><a href="#DocumentLoader" class="headerlink" title="DocumentLoader"></a>DocumentLoader</h3><p>获取 Document 的策略，由接口 <code>org.springframework.beans.factory.xml.DocumentLoader</code> 定义。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DocumentLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Document <span class="title">loadDocument</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			InputSource inputSource, EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">			ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>inputSource</code> 方法参数，加载 Document 的 Resource 资源。</li>
<li><code>entityResolver</code> 方法参数，解析文件的解析器。</li>
<li><code>errorHandler</code> 方法参数，处理加载 Document 对象的过程的错误。</li>
<li><code>validationMode</code> 方法参数，验证模式。</li>
<li><code>namespaceAware</code> 方法参数，命名空间支持。如果要提供对 XML 名称空间的支持，则需要值为 <code>true</code> 。</li>
</ul>
<h4 id="DefaultDocumentLoader"><a href="#DefaultDocumentLoader" class="headerlink" title="DefaultDocumentLoader"></a>DefaultDocumentLoader</h4><p>该方法由 DocumentLoader 的默认实现类 <code>org.springframework.beans.factory.xml.DefaultDocumentLoader</code> 实现。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the &#123;<span class="doctag">@link</span> Document&#125; at the supplied &#123;<span class="doctag">@link</span> InputSource&#125; using the standard JAXP-configured</span></span><br><span class="line"><span class="comment"> * XML parser.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="function"><span class="params">		ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// &lt;1&gt; 创建 DocumentBuilderFactory</span></span><br><span class="line">	DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Using JAXP provider [&quot;</span> + factory.getClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// &lt;2&gt; 创建 DocumentBuilder</span></span><br><span class="line">	DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">	<span class="comment">// &lt;3&gt; 解析 XML InputSource 返回 Document 对象</span></span><br><span class="line">	<span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先，调用 #<code>createDocumentBuilderFactory(...)</code> 方法，创建 <code>javax.xml.parsers.DocumentBuilderFactory</code> 对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JAXP attribute used to configure the schema language for validation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCHEMA_LANGUAGE_ATTRIBUTE = <span class="string">&quot;http://java.sun.com/xml/jaxp/properties/schemaLanguage&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JAXP attribute value indicating the XSD schema language.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String XSD_SCHEMA_LANGUAGE = <span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> DocumentBuilderFactory <span class="title">createDocumentBuilderFactory</span><span class="params">(<span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ParserConfigurationException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 DocumentBuilderFactory</span></span><br><span class="line">    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">    factory.setNamespaceAware(namespaceAware); <span class="comment">// 设置命名空间支持</span></span><br><span class="line">    <span class="keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;</span><br><span class="line">        factory.setValidating(<span class="keyword">true</span>); <span class="comment">// 开启校验</span></span><br><span class="line">        <span class="comment">// XSD 模式下，设置 factory 的属性</span></span><br><span class="line">        <span class="keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;</span><br><span class="line">            <span class="comment">// Enforce namespace aware for XSD...</span></span><br><span class="line">            factory.setNamespaceAware(<span class="keyword">true</span>); <span class="comment">// XSD 模式下，强制设置命名空间支持</span></span><br><span class="line">            <span class="comment">// 设置 SCHEMA_LANGUAGE_ATTRIBUTE</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">                ParserConfigurationException pcex = <span class="keyword">new</span> ParserConfigurationException(</span><br><span class="line">                        <span class="string">&quot;Unable to validate using XSD: Your JAXP provider [&quot;</span> + factory +</span><br><span class="line">                        <span class="string">&quot;] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;</span>);</span><br><span class="line">                pcex.initCause(ex);</span><br><span class="line">                <span class="keyword">throw</span> pcex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，调用 <code>#createDocumentBuilder(DocumentBuilderFactory factory, EntityResolver entityResolver,ErrorHandler errorHandler)</code> 方法，创建 <code>javax.xml.parsers.DocumentBuilder</code> 对象。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected DocumentBuilder createDocumentBuilder(DocumentBuilderFactory factory,</span><br><span class="line">		@Nullable EntityResolver entityResolver, @Nullable ErrorHandler errorHandler)</span><br><span class="line">		throws ParserConfigurationException &#123;</span><br><span class="line">	&#x2F;&#x2F; 创建 DocumentBuilder 对象</span><br><span class="line">	DocumentBuilder docBuilder &#x3D; factory.newDocumentBuilder();</span><br><span class="line">	&#x2F;&#x2F; &lt;x&gt; 设置 EntityResolver 属性</span><br><span class="line">	if (entityResolver !&#x3D; null) &#123;</span><br><span class="line">		docBuilder.setEntityResolver(entityResolver);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 设置 ErrorHandler 属性</span><br><span class="line">	if (errorHandler !&#x3D; null) &#123;</span><br><span class="line">		docBuilder.setErrorHandler(errorHandler);</span><br><span class="line">	&#125;</span><br><span class="line">	return docBuilder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>&lt;x&gt;</code> 处，设置 DocumentBuilder 的 <strong>EntityResolver</strong> 属性。</li>
</ul>
</li>
<li><p>最后，调用 <code>DocumentBuilder#parse(InputSource)</code> 方法，解析 InputSource ，返回 Document 对象。</p>
</li>
</ul>
<h2 id="注册-BeanDefinitions"><a href="#注册-BeanDefinitions" class="headerlink" title="注册 BeanDefinitions"></a>注册 BeanDefinitions</h2><p>获取 XML Document 对象后，会根据该对象和 Resource 资源对象调用 <code>XmlBeanDefinitionReader#registerBeanDefinitions(Document doc, Resource resource)</code> 方法，开始注册 BeanDefinitions 之旅。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractBeanDefinitionReader.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="comment">// &lt;1&gt; 创建 BeanDefinitionDocumentReader 对象</span></span><br><span class="line">	BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="comment">// &lt;2&gt; 获取已注册的 BeanDefinition 数量</span></span><br><span class="line">	<span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">	<span class="comment">// &lt;3&gt; 创建 XmlReaderContext 对象</span></span><br><span class="line">	<span class="comment">// &lt;4&gt; 注册 BeanDefinition</span></span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="comment">// 计算新注册的 BeanDefinition 数量</span></span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;1&gt;</code> 处，调用 <code>#createBeanDefinitionDocumentReader()</code> 方法，实例化 BeanDefinitionDocumentReader 对象。</p>
</li>
<li><p><code>&lt;2&gt;</code> 处，调用 <code>BeanDefinitionRegistry#getBeanDefinitionCount()</code> 方法，获取<strong>已注册</strong>的 BeanDefinition 数量。</p>
</li>
<li><p><code>&lt;3&gt;</code> 处，调用 <code>#createReaderContext(Resource resource)</code> 方法，创建 XmlReaderContext 对象。</p>
</li>
<li><p><code>&lt;4&gt;</code> 处，调用 <code>BeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</code> 方法，读取 XML 元素，注册 BeanDefinition 们。</p>
</li>
<li><p><code>&lt;5&gt;</code> 处，计<strong>算新注册</strong>的 BeanDefinition 数量。</p>
</li>
</ul>
<h3 id="createBeanDefinitionDocumentReader"><a href="#createBeanDefinitionDocumentReader" class="headerlink" title="createBeanDefinitionDocumentReader"></a>createBeanDefinitionDocumentReader</h3><p><code>#createBeanDefinitionDocumentReader()</code>，实例化 BeanDefinitionDocumentReader 对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * documentReader 的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #createBeanDefinitionDocumentReader() </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? extends BeanDefinitionDocumentReader&gt; documentReaderClass = DefaultBeanDefinitionDocumentReader.class;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>documentReaderClass</code> 的默认值为 <code>DefaultBeanDefinitionDocumentReader.class</code> 。关于它，我们在后续的文章，详细解析。</li>
</ul>
<h3 id="registerBeanDefinitions-1"><a href="#registerBeanDefinitions-1" class="headerlink" title="registerBeanDefinitions"></a>registerBeanDefinitions</h3><p><code>BeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</code> 方法，注册 BeanDefinition ，在接口 BeanDefinitionDocumentReader 中定义。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionDocumentReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Read bean definitions from the given DOM document and</span></span><br><span class="line"><span class="comment">	 * register them with the registry in the given reader context.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> doc the DOM document</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> readerContext the current context of the reader</span></span><br><span class="line"><span class="comment">	 * (includes the target registry and the resource being parsed)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of parsing errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从给定的 Document 对象中解析定义的 BeanDefinition 并将他们注册到注册表中</strong>。方法接收两个参数：</p>
<ul>
<li><code>doc</code> 方法参数：待解析的 Document 对象。</li>
<li><code>readerContext</code> 方法，解析器的当前上下文，包括目标注册表和被解析的资源。</li>
</ul>
<h4 id="DefaultBeanDefinitionDocumentReader"><a href="#DefaultBeanDefinitionDocumentReader" class="headerlink" title="DefaultBeanDefinitionDocumentReader"></a>DefaultBeanDefinitionDocumentReader</h4><p>BeanDefinitionDocumentReader 有且只有一个默认实现类 DefaultBeanDefinitionDocumentReader 。它对 <code>#registerBeanDefinitions(...)</code> 方法的实现代码如下：</p>
<p>DefaultBeanDefinitionDocumentReader 对该方法提供了实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> XmlReaderContext readerContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> BeanDefinitionParserDelegate delegate;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation parses bean definitions according to the &quot;spring-beans&quot; XSD</span></span><br><span class="line"><span class="comment"> * (or DTD, historically).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Opens a DOM Document; then initializes the default settings</span></span><br><span class="line"><span class="comment"> * specified at the &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; level; then parses the contained bean definitions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">    <span class="comment">// 获得 XML Document Root Element</span></span><br><span class="line">    <span class="comment">// 执行注册 BeanDefinition</span></span><br><span class="line">    doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register each bean definition within the given root &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span>  <span class="comment">// for Environment.acceptsProfiles(String...)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">    <span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">    <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">    <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">    <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">    <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">    <span class="comment">// 记录老的 BeanDefinitionParserDelegate 对象</span></span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="comment">// &lt;1&gt; 创建 BeanDefinitionParserDelegate 对象，并进行设置到 delegate</span></span><br><span class="line">    <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    <span class="comment">// &lt;2&gt; 检查 &lt;beans /&gt; 根标签的命名空间是否为空，或者是 http://www.springframework.org/schema/beans</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        <span class="comment">// &lt;2.1&gt; 处理 profile 属性。可参见《Spring3自定义环境配置 &lt;beans profile=&quot;&quot;&gt;》http://nassir.iteye.com/blog/1535799</span></span><br><span class="line">        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            <span class="comment">// &lt;2.2&gt; 使用分隔符切分，可能有多个 profile 。</span></span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="comment">// &lt;2.3&gt; 如果所有 profile 都无效，则不进行注册</span></span><br><span class="line">            <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">            <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">            <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                            <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;3&gt; 解析前处理</span></span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    <span class="comment">// &lt;4&gt; 解析</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    <span class="comment">// &lt;5&gt; 解析后处理</span></span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 delegate 回老的 BeanDefinitionParserDelegate 对象</span></span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;1&gt;</code> 处，创建 BeanDefinitionParserDelegate 对象，并进行设置到 <code>delegate</code> 。BeanDefinitionParserDelegate 是一个重要的类，它负责<strong>解析 BeanDefinition</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title">createDelegate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        XmlReaderContext readerContext, Element root, <span class="meta">@Nullable</span> BeanDefinitionParserDelegate parentDelegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 BeanDefinitionParserDelegate 对象</span></span><br><span class="line">    BeanDefinitionParserDelegate delegate = <span class="keyword">new</span> BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">    <span class="comment">// 初始化默认</span></span><br><span class="line">    delegate.initDefaults(root, parentDelegate);</span><br><span class="line">    <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;2&gt;</code> 处，检查 <code>&lt;beans /&gt;</code> <strong>根</strong>标签的命名空间是否为空，或者是 <a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a> 。</p>
<ul>
<li><code>&lt;2.1&gt;</code> 处，判断是否 <code>&lt;beans /&gt;</code> 上配置了 <code>profile</code> 属性。</li>
<li><code>&lt;2.2&gt;</code> 处，使用分隔符切分，可能有<strong>多个</strong> profile 。</li>
<li><code>&lt;2.3&gt;</code> 处，判断，如果所有 profile 都无效，则 <code>return</code> 不进行注册。</li>
</ul>
</li>
<li><p><code>&lt;4&gt;</code> 处，调用 <code>#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)</code> 方法，进行解析逻辑。详细解析，见 <a href="http://svip.iocoder.cn/Spring/IoC-register-BeanDefinitions/#">「3.1 parseBeanDefinitions」</a> 。</p>
</li>
<li><p><code>&lt;3&gt;</code> / <code>&lt;5&gt;</code> 处，解析<strong>前后</strong>的处理，目前这两个方法都是空实现，交由子类来实现。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preProcessXml</span><span class="params">(Element root)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessXml</span><span class="params">(Element root)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="parseBeanDefinitions"><a href="#parseBeanDefinitions" class="headerlink" title="parseBeanDefinitions"></a>parseBeanDefinitions</h5><p><code>#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)</code> 方法，进行解析逻辑。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the elements at the root level in the document:</span></span><br><span class="line"><span class="comment"> * &quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root the DOM root element of the document</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;1&gt; 如果根节点使用默认命名空间，执行默认解析</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        <span class="comment">// 遍历子节点</span></span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="comment">// &lt;1&gt; 如果该节点使用默认命名空间，执行默认解析</span></span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                <span class="comment">// 如果该节点非默认命名空间，执行自定义解析</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// &lt;2&gt; 如果根节点非默认命名空间，执行自定义解析</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Spring 有两种Bean 声明方式：</p>
<ul>
<li>配置文件式声明：<code>&lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.StudentService&quot; /&gt;</code> 。对应 <code>&lt;1&gt;</code> 处。</li>
<li>自定义注解方式：<code>&lt;tx:annotation-driven&gt;</code> 。对应 <code>&lt;2&gt;</code> 处。</li>
</ul>
</li>
<li><p><code>&lt;1&gt;</code> 处，如果<strong>根</strong>节点或<strong>子</strong>节点<strong>使用</strong>默认命名空间，调用 <code>#parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate)</code> 方法，执行默认解析。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; <span class="comment">// import</span></span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; <span class="comment">// alias</span></span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; <span class="comment">// bean</span></span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; <span class="comment">// beans</span></span><br><span class="line">		<span class="comment">// recurse</span></span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>详细的解析，见后续文章。</li>
</ul>
</li>
<li><p><code>&lt;2&gt;</code> 处，如果<strong>根</strong>节点或<strong>子</strong>节点<strong>不使用</strong>默认命名空间，调用<code>BeanDefinitionParserDelegate#parseCustomElement(Element ele)</code> 方法，执行<strong>自定义</strong>解析。详细的解析，见后续文章。</p>
</li>
</ul>
<h3 id="createReaderContext"><a href="#createReaderContext" class="headerlink" title="createReaderContext"></a>createReaderContext</h3><p><code>#createReaderContext(Resource resource)</code> 方法，创建 XmlReaderContext 对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ProblemReporter problemReporter = <span class="keyword">new</span> FailFastProblemReporter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ReaderEventListener eventListener = <span class="keyword">new</span> EmptyReaderEventListener();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SourceExtractor sourceExtractor = <span class="keyword">new</span> NullSourceExtractor();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> NamespaceHandlerResolver namespaceHandlerResolver;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the &#123;<span class="doctag">@link</span> XmlReaderContext&#125; to pass over to the document reader.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener,</span><br><span class="line">			<span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 XmlReaderContext 的详细解析，见后续文章。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown使用指南</title>
    <url>/2018/11/23/markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<h2 id="markdown使用指南"><a href="#markdown使用指南" class="headerlink" title="markdown使用指南"></a>markdown使用指南</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>标题能显示出文章的结构。行首插入1-6个 # ，每增加一个 # 表示更深入层次的内容，对应到标题的深度由 1-6 阶。</p>
<pre><code>H1 :# Header 1
H2 :## Header 2
H3 :### Header 3
H4 :#### Header 4
H5 :##### Header 5
H6 :###### Header 6</code></pre><span id="more"></span>
<h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><p>（带“*”星号的文本样式，在原版Markdown标准中不存在，但在其大部分衍生标准中被添加）</p>
<pre><code>链接 :[Title](URL)
加粗 :**Bold**
斜体字 :*Italics*
*高亮 :==text==
段落 : 段落之间空一行
换行符 : 一行结束时输入两个空格
列表 :* 添加星号成为一个新的列表项。
引用 :&gt; 引用内容
内嵌代码 : `alert(&apos;Hello World&apos;);`
画水平线 (HR) :--------
方框：- [ ] -</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>使用Markdown将图像插入文章，你需要在Markdown编辑器输入 <strong><code>![]()</code></strong> 。 这时在预览面板中会自动创建一个图像上传框。你可以从电脑桌面拖放图片(.png, .gif, .jpg)到上传框, 或者点击图片上传框使用标准的图像上传方式。 如果你想通过链接插入网络上已经存在的图片，只要单击图片上传框的左下角的“链接”图标，这时就会呈现图像URL的输入框。想给图片添加一个标题, 你需要做的是将标题文本插图中的方括号， <strong><code>e.g;![This is a title]()</code></strong> .</p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注不存在于标准Markdown中。<br>使用这样的占位符号可以将脚注添加到文本中:[^1]. 另外，你可以使用“n”而不是数字的[^n]所以你可以不必担心使用哪个号码。在您的文章的结尾，你可以如下图所示定义匹配的注脚，URL将变成链接:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里是脚注[^1]</span><br><span class="line">[^1]: 这里是脚注的内容</span><br><span class="line">这里是脚注[^n]</span><br><span class="line">[^n]: 这里是脚注的内容</span><br></pre></td></tr></table></figure></p>
<h3 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h3><p>添加内嵌代码可以使用一对回勾号 <strong>`alert(‘Hello World’)`</strong> .对于插入代码, Ghost支持标准的Markdown代码和GitHub Flavored Markdown (GFM) [4]  。标准Markdown基于缩进代码行或者4个空格位:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\</span><br><span class="line">    insert code</span><br><span class="line">    insert code</span><br><span class="line">    insert code</span><br><span class="line">\</span><br><span class="line"></span><br><span class="line">**删除\**</span><br></pre></td></tr></table></figure></p>
<p>GFM 使用三个回勾号```<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;\&#96;</span><br><span class="line">insert code</span><br><span class="line">insert code</span><br><span class="line">insert code</span><br><span class="line">&#96;&#96;\&#96;</span><br><span class="line"></span><br><span class="line">**删除\**</span><br></pre></td></tr></table></figure></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>链接<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is a paragraph that contains a [link to example]()</span><br></pre></td></tr></table></figure></p>
<p>列表格式<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This paragraph contains a list of items.</span><br><span class="line">* Item 1</span><br><span class="line">* Item 2</span><br><span class="line">* Item three</span><br></pre></td></tr></table></figure></p>
<p>使用Markdown 引用文本：<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This paragraph has a quote</span><br><span class="line"></span><br><span class="line">&gt; That is pulled out like this</span><br><span class="line">from the text my post.</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器 ECS CentOS 7配置默认防火墙 Firewall</title>
    <url>/2019/01/11/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-ECS-CentOS-7%E9%85%8D%E7%BD%AE%E9%BB%98%E8%AE%A4%E9%98%B2%E7%81%AB%E5%A2%99-Firewall/</url>
    <content><![CDATA[<p>阿里云服务器的 CentOS7 下默认的防火墙是 Firewall，替代了之前的 iptables，Firewall 有图形界面管理和命令行管理两种方式，本文简要介绍命令行 Firewall 的使用。</p>
<h3 id="配置-Firewall"><a href="#配置-Firewall" class="headerlink" title="配置 Firewall"></a>配置 Firewall</h3><p>进入系统之后，CentOS7 默认是已安装了 Firewall，但是没有启动的，所以需要先启动下 Firewall，同时设置开机自启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld       ##启动Firewall</span><br><span class="line">systemctl enable firewalld.service  ##设置开机自启动</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#39;&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;firewalld.service&#39; &#39;&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;dbus-org.fedoraproject.FirewallD1.service&#39;</span><br><span class="line">ln -s &#39;&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;firewalld.service&#39; &#39;&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;basic.target.wants&#x2F;firewalld.service&#39;</span><br></pre></td></tr></table></figure>
<h3 id="常用命令介绍"><a href="#常用命令介绍" class="headerlink" title="常用命令介绍"></a>常用命令介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state                           ##查看防火墙状态，是否是running</span><br><span class="line">firewall-cmd --reload                          ##重新载入配置，比如添加规则之后，需要执行此命令</span><br><span class="line">firewall-cmd --get-zones                       ##列出支持的zone</span><br><span class="line">firewall-cmd --get-services                    ##列出支持的服务，在列表中的服务是放行的</span><br><span class="line">firewall-cmd --query-service ftp               ##查看ftp服务是否支持，返回yes或者no</span><br><span class="line">firewall-cmd --add-service&#x3D;ftp                 ##临时开放ftp服务</span><br><span class="line">firewall-cmd --add-service&#x3D;ftp --permanent     ##永久开放ftp服务</span><br><span class="line">firewall-cmd --remove-service&#x3D;ftp --permanent  ##永久移除ftp服务</span><br><span class="line">firewall-cmd --add-port&#x3D;80&#x2F;tcp --permanent     ##永久添加80端口 </span><br><span class="line">iptables -L -n                                 ##查看规则，这个命令是和iptables的相同的</span><br><span class="line">man firewall-cmd                               ##查看帮助</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ECS</category>
      </categories>
      <tags>
        <tag>ECS</tag>
      </tags>
  </entry>
  <entry>
    <title>在Jenkins上创建多分支流水线</title>
    <url>/2019/12/05/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<h3 id="准备Jenkinsfile配置文件"><a href="#准备Jenkinsfile配置文件" class="headerlink" title="准备Jenkinsfile配置文件"></a>准备Jenkinsfile配置文件</h3><h4 id="准备公共配置文件"><a href="#准备公共配置文件" class="headerlink" title="准备公共配置文件"></a>准备公共配置文件</h4><p>新建远程仓库，文件目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 资源文件</span><br><span class="line">|-- resources</span><br><span class="line"># 执行脚本文件</span><br><span class="line">|-- vars</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>新建配置文件<code>build.groovy</code>，放在<code>vars</code>文件夹下:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">#!groovy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> call(Map map) &#123;</span><br><span class="line"></span><br><span class="line">    pipeline &#123;</span><br><span class="line">        agent any</span><br><span class="line"></span><br><span class="line">        environment &#123;</span><br><span class="line">			APP_NAME = <span class="string">&quot;$&#123;map.APP_NAME&#125;&quot;</span></span><br><span class="line">			APP_PORT = <span class="string">&quot;$&#123;map.APP_PORT&#125;&quot;</span></span><br><span class="line">            <span class="comment">//非必要，可以设置用于发版</span></span><br><span class="line">            REMOTE_HOST = <span class="string">&quot;$&#123;map.REMOTE_HOST&#125;&quot;</span></span><br><span class="line">            <span class="comment">//程序远程仓库地址</span></span><br><span class="line">            REPO_URL = <span class="string">&quot;$&#123;map.REPO_URL&#125;&quot;</span></span><br><span class="line">            BRANCH_NAME = <span class="string">&quot;$&#123;map.BRANCH_NAME&#125;&quot;</span></span><br><span class="line">            <span class="comment">//非必要</span></span><br><span class="line">            STACK_NAME = <span class="string">&quot;$&#123;map.STACK_NAME&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stages &#123;</span><br><span class="line">            stage(<span class="string">&#x27;获取代码&#x27;</span>) &#123;</span><br><span class="line">                steps &#123;</span><br><span class="line">                    git([<span class="attr">url:</span> <span class="string">&quot;$&#123;REPO_URL&#125;&quot;</span>, <span class="attr">branch:</span> <span class="string">&quot;$&#123;BRANCH_NAME&#125;&quot;</span>])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stage(<span class="string">&#x27;编译代码&#x27;</span>) &#123;</span><br><span class="line">                steps &#123;</span><br><span class="line">                    withMaven(<span class="attr">maven:</span> <span class="string">&#x27;maven 3.6&#x27;</span>) &#123;</span><br><span class="line">                        sh <span class="string">&quot;mvn -U -am clean package -DskipTests&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stage(<span class="string">&#x27;构建镜像&#x27;</span>) &#123;</span><br><span class="line">                steps &#123;</span><br><span class="line">					sh <span class="string">&quot;cp ./target/*.jar ./&quot;</span></span><br><span class="line">                    sh <span class="string">&quot;docker build -t $&#123;APP_NAME&#125;/$&#123;BRANCH_NAME&#125;:1.0-SNAPSHOT .&quot;</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">			stage(<span class="string">&#x27;运行镜像&#x27;</span>) &#123;</span><br><span class="line">                steps &#123;</span><br><span class="line">					sh <span class="string">&quot;if docker ps -a | grep $&#123;APP_NAME&#125;-$&#123;BRANCH_NAME&#125;;\n then docker rm -f $&#123;APP_NAME&#125;-$&#123;BRANCH_NAME&#125;\n echo Remove Docker Container: $&#123;APP_NAME&#125;-$&#123;BRANCH_NAME&#125;\n fi&quot;</span></span><br><span class="line">					sh <span class="string">&quot;docker run -d -p $&#123;APP_PORT&#125;:$&#123;APP_PORT&#125; --name $&#123;APP_NAME&#125;-$&#123;BRANCH_NAME&#125; $&#123;APP_NAME&#125;/$&#123;BRANCH_NAME&#125;:1.0-SNAPSHOT&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置Jenkins公共Jenkinsfile库的地址"><a href="#配置Jenkins公共Jenkinsfile库的地址" class="headerlink" title="配置Jenkins公共Jenkinsfile库的地址"></a>配置Jenkins公共Jenkinsfile库的地址</h4><p>进入Jenkins的系统管理的系统配置，找到<code>Global Pipeline Libraries</code>，配置远程仓库地址：<br><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-0.png" alt="在Jenkins上创建多分支流水线-0"></p>
<h4 id="准备程序Jenkinsfile配置文件"><a href="#准备程序Jenkinsfile配置文件" class="headerlink" title="准备程序Jenkinsfile配置文件"></a>准备程序Jenkinsfile配置文件</h4><p>程序根目录新建Jenkinsfile文件，填写配置：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">#!groovy</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在多分支构建下，严格规定Jenkinsfile只存在可以发版的分支上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用在jenkins已经全局定义好的library</span></span><br><span class="line">library <span class="string">&#x27;aptst-pipeline-library&#x27;</span></span><br><span class="line"><span class="keyword">def</span> map = [:]</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序名称</span></span><br><span class="line">map.put(<span class="string">&#x27;APP_NAME&#x27;</span>,<span class="string">&#x27;aptst-config-server&#x27;</span>)</span><br><span class="line"><span class="comment">//程序端口</span></span><br><span class="line">map.put(<span class="string">&#x27;APP_PORT&#x27;</span>,<span class="string">&#x27;3344&#x27;</span>)</span><br><span class="line"><span class="comment">// 远程管理节点地址（用于执行发版）</span></span><br><span class="line">map.put(<span class="string">&#x27;REMOTE_HOST&#x27;</span>,<span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>)</span><br><span class="line"><span class="comment">// 项目github代码地址</span></span><br><span class="line">map.put(<span class="string">&#x27;REPO_URL&#x27;</span>,<span class="string">&#x27;XXX&#x27;</span>)</span><br><span class="line"><span class="comment">// 分支名称</span></span><br><span class="line">map.put(<span class="string">&#x27;BRANCH_NAME&#x27;</span>,<span class="string">&#x27;master&#x27;</span>)</span><br><span class="line"><span class="comment">// 服务栈名称，公共配置没配置可以不需要</span></span><br><span class="line">map.put(<span class="string">&#x27;STACK_NAME&#x27;</span>,<span class="string">&#x27;XXX&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用library中vars目录下的build.groovy脚本</span></span><br><span class="line">build(map)</span><br></pre></td></tr></table></figure>

<h3 id="Blue-Ocean"><a href="#Blue-Ocean" class="headerlink" title="Blue Ocean"></a>Blue Ocean</h3><p>首先进入Jenkins的Blue Ocean页面，在Jenkins页面左边找到按钮或输入网址<code>http://&lt;jenkins address&gt;/blue</code></p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-1.png" alt="在Jenkins上创建多分支流水线-1"></p>
<h3 id="创建Pipeline"><a href="#创建Pipeline" class="headerlink" title="创建Pipeline"></a>创建Pipeline</h3><p>点击<code>创建流水线</code>：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-2.png" alt="在Jenkins上创建多分支流水线-2"></p>
<p>选择代码仓库，根据你远程仓库选择对应的：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-3.png" alt="在Jenkins上创建多分支流水线-3"></p>
<p>添加GitHub服务器：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-4.png" alt="在Jenkins上创建多分支流水线-4"></p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-5.png" alt="在Jenkins上创建多分支流水线-5"></p>
<p>选择仓库然后点击创建流水线：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-6.png" alt="在Jenkins上创建多分支流水线-6"></p>
<p>完整步骤图：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-7.png" alt="在Jenkins上创建多分支流水线-7"></p>
<h3 id="配置webhook"><a href="#配置webhook" class="headerlink" title="配置webhook"></a>配置webhook</h3><p>首先让我们看看 <a href="https://developer.github.com/webhooks/">Github官方</a> 关于Github webhooks的解释： </p>
<blockquote>
<p>Webhooks allow you to build or set up integrations which subscribe to certain events on GitHub.com.</p>
</blockquote>
<p>中文意思就是： webhook允许您构建或设置订阅GitHub.com上某些事件的集成。 通过webhook，我们就可以实现自动化部署。</p>
<p>进入项目GitHub仓库地址，进入<strong><code>settings</code></strong>，点击<strong><code>hook</code></strong>，再点击<strong><code>Add webhook</code></strong>：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-8.png" alt="在Jenkins上创建多分支流水线-8"></p>
<p>填写Jenkins接收事件地址<strong><code>Payload URL</code></strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;&lt;Jenkins address&gt;&#x2F;github-webhook&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-9.png" alt="在Jenkins上创建多分支流水线-9"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>Pipeline</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Pipeline</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper极简入门及部署</title>
    <url>/2020/07/12/ZooKeeper%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8%E5%8F%8A%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apache ZooKeeper是Apache软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。ZooKeeper曾经是Hadoop的一个子项目，但现在是一个独立的顶级项目。</p>
<p>ZooKeeper的架构通过冗余服务实现高可用性。因此，如果第一次无应答，客户端就可以询问另一台ZooKeeper主机。ZooKeeper节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。更新是全序的。</p>
<span id="more"></span>

<h2 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h2><h3 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h3><ul>
<li>操作系统: Mac OS 10.15(其他系统一样)</li>
<li>JDK: 11</li>
</ul>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>打开 <a href="https://archive.apache.org/dist/zookeeper/">Zookeeper 下载页面</a>，选择想要安装的版本。我选择的是 <a href="https://archive.apache.org/dist/zookeeper/stable/">stable</a> 稳定版本，版本是3.5.8，选择编译好的包，<a href="https://archive.apache.org/dist/zookeeper/stable/apache-zookeeper-3.5.8-bin.tar.gz">apache-zookeeper-3.5.8-bin.tar.gz</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">wget https://archive.apache.org/dist/zookeeper/stable/apache-zookeeper-3.5.8-bin.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -zxvf apache-zookeeper-3.5.8-bin.tar.gz</span><br><span class="line">cd apache-zookeeper-3.5.8-bin</span><br></pre></td></tr></table></figure>

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>Zookeeper 提供了 <code>conf/zoo_sample.cfg</code> 模版配置文件，作为示例。这里，我们复制一下，复制出一个 <code>conf/zoo.cfg</code>(默认读取的配置文件)，然后在上面进行修改，修改后配置如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line"><span class="comment"># Client-Server 通信心跳时间</span></span><br><span class="line"><span class="comment"># Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。tickTime 以毫秒为单位。</span></span><br><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"># The number of ticks that the initial</span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line"><span class="comment"># Leader-Follower 初始通信时限</span></span><br><span class="line"><span class="comment"># 集群中的 follower 服务器(F)与 leader 服务器(L)之间初始连接时能容忍的最多心跳数（tickTime 的数量）。</span></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># The number of ticks that can pass between</span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line"><span class="comment"># Leader-Follower 同步通信时限</span></span><br><span class="line"><span class="comment"># 集群中的 follower 服务器与 leader 服务器之间请求和应答之间能容忍的最多心跳数（tickTime的数量）。</span></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just</span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="comment"># 数据文件目录</span></span><br><span class="line"><span class="comment"># Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">/Users/monochrome/app/Zookeeper/apache-zookeeper-3.5.8-bin/data</span></span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="comment"># 客户端连接端口</span></span><br><span class="line"><span class="comment"># 客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the</span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to &quot;0&quot; to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br></pre></td></tr></table></figure>

<h4 id="运行Zookeeper-Server"><a href="#运行Zookeeper-Server" class="headerlink" title="运行Zookeeper Server"></a>运行Zookeeper Server</h4><p>执行 <code>bin/zkServer.sh start</code> 命令，启动 Zookeeper Server 服务。此时，控制台会输出如下日志，表示启动成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/zkServer.sh start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下，Zookeeper 开启 JMX</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 conf/zoo.cfg 配置文件</span></span><br><span class="line">Using config: /Users/monochrome/app/Zookeeper/apache-zookeeper-3.5.8-bin/bin/../conf/zoo.cfg</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 Zookeeper Server 成功（实际不一定成功）</span></span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>

<p>注意，Zookeeper 3.5 版本开始，默认会在 8080 端口，启动一个 Zookeeper <strong>AdminServer</strong>。如果 8080 端口已经被其它服务占用，会导致 Zookeeper Server 启动失败。此时，我们有三种解决方案：</p>
<ul>
<li>方式一，可以修改 <code>conf/zoo.cfg</code> 配置文件的 <code>admin.serverPort</code> 配置项，从而修改 Zookeeper AdminServer 的端口。</li>
<li>方式二，可以修改 <code>conf/zoo.cfg</code> 配置文件的 <code>admin.enableServer=false</code> 配置项，从而关闭 Zookeeper AdminServer 的启动。</li>
<li>方式三，关闭占用 8080 端口的服务。</li>
</ul>
<h4 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h4><p>测试连接到 Zookeeper Server 上，看看是否真的启动成功。操作命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 连接 Zookeeper Server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bin/zkCli.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出如下日志信息表示连接成功</span></span><br><span class="line">Welcome to ZooKeeper!</span><br><span class="line">JLine support is enabled</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 Zookeeper 命令行中，执行 ls / 命令，输出根目录</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[zookeeper]</span><br></pre></td></tr></table></figure>

<h3 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h3><p>待续</p>
<h2 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h2><h3 id="pull-image"><a href="#pull-image" class="headerlink" title="pull image"></a>pull image</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="Start-a-Zookeeper-server-instance"><a href="#Start-a-Zookeeper-server-instance" class="headerlink" title="Start a Zookeeper server instance"></a>Start a Zookeeper server instance</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -d zookeeper</span><br></pre></td></tr></table></figure>

<p>This image includes <code>EXPOSE 2181 2888 3888 8080</code> (the zookeeper client port, follower port, election port, AdminServer port respectively), so standard container linking will make it automatically available to the linked containers. Since the Zookeeper “fails fast” it’s better to always restart it.</p>
<h3 id="Connect-to-Zookeeper-from-an-application-in-another-Docker-container"><a href="#Connect-to-Zookeeper-from-an-application-in-another-Docker-container" class="headerlink" title="Connect to Zookeeper from an application in another Docker container"></a>Connect to Zookeeper from an application in another Docker container</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-app --link some-zookeeper:zookeeper -d application-that-uses-zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="Connect-to-Zookeeper-from-the-Zookeeper-command-line-client"><a href="#Connect-to-Zookeeper-from-the-Zookeeper-command-line-client" class="headerlink" title="Connect to Zookeeper from the Zookeeper command line client"></a>Connect to Zookeeper from the Zookeeper command line client</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -it --rm --link some-zookeeper:zookeeper zookeeper zkCli.sh -server zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="…-via-docker-stack-deploy-or-docker-compose"><a href="#…-via-docker-stack-deploy-or-docker-compose" class="headerlink" title="… via docker stack deploy or docker-compose"></a>… via <a href="https://docs.docker.com/engine/reference/commandline/stack_deploy/"><code>docker stack deploy</code></a> or <a href="https://github.com/docker/compose"><code>docker-compose</code></a></h3><p>Example <code>stack.yml</code> for <code>zookeeper</code>:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zoo1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=0.0.0.0:2888:3888;2181</span> <span class="string">server.2=zoo2:2888:3888;2181</span> <span class="string">server.3=zoo3:2888:3888;2181</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zoo2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2182</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888;2181</span> <span class="string">server.2=0.0.0.0:2888:3888;2181</span> <span class="string">server.3=zoo3:2888:3888;2181</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zoo3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2183</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888;2181</span> <span class="string">server.2=zoo2:2888:3888;2181</span> <span class="string">server.3=0.0.0.0:2888:3888;2181</span></span><br></pre></td></tr></table></figure>

<p><a href="http://play-with-docker.com/?stack=https://raw.githubusercontent.com/docker-library/docs/ef162dce5998011e1753c3337dcbe61200c522d2/zookeeper/stack.yml"><img src="https://github.com/play-with-docker/stacks/raw/cff22438cb4195ace27f9b15784bbb497047afa7/assets/images/button.png" alt="Try in PWD"></a></p>
<p>This will start Zookeeper 3.5 in <a href="https://zookeeper.apache.org/doc/current/zookeeperStarted.html#sc_RunningReplicatedZooKeeper">replicated mode</a>. Please note, that Zookeeper 3.4 has slightly different <code>ZOO_SERVERS</code> format. Run <code>docker stack deploy -c stack.yml zookeeper</code> (or <code>docker-compose -f stack.yml up</code>) and wait for it to initialize completely. Ports <code>2181-2183</code> will be exposed.</p>
<blockquote>
<p>Please be aware that setting up multiple servers on a single machine will not create any redundancy. If something were to happen which caused the machine to die, all of the zookeeper servers would be offline. Full redundancy requires that each server have its own machine. It must be a completely separate physical server. Multiple virtual machines on the same physical host are still vulnerable to the complete failure of that host.</p>
</blockquote>
<p>Consider using <a href="https://www.docker.com/products/docker-swarm">Docker Swarm</a> when running Zookeeper in replicated mode.</p>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>Zookeeper configuration is located in <code>/conf</code>. One way to change it is mounting your config file as a volume:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -d -v $(pwd)/zoo.cfg:/conf/zoo.cfg zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="Environment-variables"><a href="#Environment-variables" class="headerlink" title="Environment variables"></a>Environment variables</h3><p>ZooKeeper recommended defaults are used if <code>zoo.cfg</code> file is not provided. They can be overridden using the following environment variables.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -e &quot;ZOO_INIT_LIMIT&#x3D;10&quot; --name some-zookeeper --restart always -d zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="ZOO-TICK-TIME"><a href="#ZOO-TICK-TIME" class="headerlink" title="ZOO_TICK_TIME"></a><code>ZOO_TICK_TIME</code></h3><p>Defaults to <code>2000</code>. ZooKeeper’s <code>tickTime</code></p>
<blockquote>
<p>The length of a single tick, which is the basic time unit used by ZooKeeper, as measured in milliseconds. It is used to regulate heartbeats, and timeouts. For example, the minimum session timeout will be two ticks</p>
</blockquote>
<h3 id="ZOO-INIT-LIMIT"><a href="#ZOO-INIT-LIMIT" class="headerlink" title="ZOO_INIT_LIMIT"></a><code>ZOO_INIT_LIMIT</code></h3><p>Defaults to <code>5</code>. ZooKeeper’s <code>initLimit</code></p>
<blockquote>
<p>Amount of time, in ticks (see tickTime), to allow followers to connect and sync to a leader. Increased this value as needed, if the amount of data managed by ZooKeeper is large.</p>
</blockquote>
<h3 id="ZOO-SYNC-LIMIT"><a href="#ZOO-SYNC-LIMIT" class="headerlink" title="ZOO_SYNC_LIMIT"></a><code>ZOO_SYNC_LIMIT</code></h3><p>Defaults to <code>2</code>. ZooKeeper’s <code>syncLimit</code></p>
<blockquote>
<p>Amount of time, in ticks (see tickTime), to allow followers to sync with ZooKeeper. If followers fall too far behind a leader, they will be dropped.</p>
</blockquote>
<h3 id="ZOO-MAX-CLIENT-CNXNS"><a href="#ZOO-MAX-CLIENT-CNXNS" class="headerlink" title="ZOO_MAX_CLIENT_CNXNS"></a><code>ZOO_MAX_CLIENT_CNXNS</code></h3><p>Defaults to <code>60</code>. ZooKeeper’s <code>maxClientCnxns</code></p>
<blockquote>
<p>Limits the number of concurrent connections (at the socket level) that a single client, identified by IP address, may make to a single member of the ZooKeeper ensemble.</p>
</blockquote>
<h3 id="ZOO-STANDALONE-ENABLED"><a href="#ZOO-STANDALONE-ENABLED" class="headerlink" title="ZOO_STANDALONE_ENABLED"></a><code>ZOO_STANDALONE_ENABLED</code></h3><p>Defaults to <code>true</code>. Zookeeper’s <a href="https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html#sc_reconfig_standaloneEnabled"><code>standaloneEnabled</code></a></p>
<blockquote>
<p>Prior to 3.5.0, one could run ZooKeeper in Standalone mode or in a Distributed mode. These are separate implementation stacks, and switching between them during run time is not possible. By default (for backward compatibility) standaloneEnabled is set to true. The consequence of using this default is that if started with a single server the ensemble will not be allowed to grow, and if started with more than one server it will not be allowed to shrink to contain fewer than two participants.</p>
</blockquote>
<h3 id="ZOO-ADMINSERVER-ENABLED"><a href="#ZOO-ADMINSERVER-ENABLED" class="headerlink" title="ZOO_ADMINSERVER_ENABLED"></a><code>ZOO_ADMINSERVER_ENABLED</code></h3><p>Defaults to <code>true</code>. Zookeeper’s <a href="http://zookeeper.apache.org/doc/r3.5.7/zookeeperAdmin.html#sc_adminserver_config"><code>admin.enableServer</code></a></p>
<blockquote>
<p>New in 3.5.0: The AdminServer is an embedded Jetty server that provides an HTTP interface to the four letter word commands. By default, the server is started on port 8080, and commands are issued by going to the URL “/commands/[command name]”, e.g., <a href="http://localhost:8080/commands/stat">http://localhost:8080/commands/stat</a>.</p>
</blockquote>
<h3 id="ZOO-AUTOPURGE-PURGEINTERVAL"><a href="#ZOO-AUTOPURGE-PURGEINTERVAL" class="headerlink" title="ZOO_AUTOPURGE_PURGEINTERVAL"></a><code>ZOO_AUTOPURGE_PURGEINTERVAL</code></h3><p>Defaults to <code>0</code>. Zookeeper’s <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_advancedConfiguration"><code>autoPurge.purgeInterval</code></a></p>
<blockquote>
<p>The time interval in hours for which the purge task has to be triggered. Set to a positive integer (1 and above) to enable the auto purging. Defaults to 0.</p>
</blockquote>
<h3 id="ZOO-AUTOPURGE-SNAPRETAINCOUNT"><a href="#ZOO-AUTOPURGE-SNAPRETAINCOUNT" class="headerlink" title="ZOO_AUTOPURGE_SNAPRETAINCOUNT"></a><code>ZOO_AUTOPURGE_SNAPRETAINCOUNT</code></h3><p>Defaults to <code>3</code>. Zookeeper’s <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_advancedConfiguration"><code>autoPurge.snapRetainCount</code></a></p>
<blockquote>
<p>When enabled, ZooKeeper auto purge feature retains the autopurge.snapRetainCount most recent snapshots and the corresponding transaction logs in the dataDir and dataLogDir respectively and deletes the rest. Defaults to 3. Minimum value is 3.</p>
</blockquote>
<h3 id="ZOO-4LW-COMMANDS-WHITELIST"><a href="#ZOO-4LW-COMMANDS-WHITELIST" class="headerlink" title="ZOO_4LW_COMMANDS_WHITELIST"></a><code>ZOO_4LW_COMMANDS_WHITELIST</code></h3><p>Defaults to <code>srvr</code>. Zookeeper’s <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_clusterOptions"><code>4lw.commands.whitelist</code></a></p>
<blockquote>
<p>A list of comma separated Four Letter Words commands that user wants to use. A valid Four Letter Words command must be put in this list else ZooKeeper server will not enable the command. By default the whitelist only contains “srvr” command which zkServer.sh uses. The rest of four letter word commands are disabled by default.</p>
</blockquote>
<h2 id="Advanced-configuration"><a href="#Advanced-configuration" class="headerlink" title="Advanced configuration"></a>Advanced configuration</h2><h3 id="ZOO-CFG-EXTRA"><a href="#ZOO-CFG-EXTRA" class="headerlink" title="ZOO_CFG_EXTRA"></a><code>ZOO_CFG_EXTRA</code></h3><p>Not every Zookeeper configuration setting is exposed via the environment variables listed above. These variables are only meant to cover minimum configuration keywords and some often changing options. If <a href="https://hub.docker.com/_/zookeeper#configuration">mounting your custom config file</a> as a volume doesn’t work for you, consider using <code>ZOO_CFG_EXTRA</code> environment variable. You can add arbitrary configuration parameters to Zookeeper configuration file using this variable. The following example shows how to enable Prometheus metrics exporter on port <code>7070</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -e ZOO_CFG_EXTRA=&quot;metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider metricsProvider.httpPort=7070&quot; zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="JVMFLAGS"><a href="#JVMFLAGS" class="headerlink" title="JVMFLAGS"></a><code>JVMFLAGS</code></h3><p>Many of the Zookeeper advanced configuration options can be set there using Java system properties in the form of <code>-Dproperty=value</code>. For example, you can use Netty instead of NIO (default option) as a server communication framework:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -e JVMFLAGS=&quot;-Dzookeeper.serverCnxnFactory=org.apache.zookeeper.server.NettyServerCnxnFactory&quot; zookeeper</span><br></pre></td></tr></table></figure>

<p>See <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_advancedConfiguration">Advanced Configuration</a> for the full list of supported Java system properties.</p>
<p>Another example use case for the <code>JVMFLAGS</code> is setting a maximum JWM heap size of 1 GB:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --name some-zookeeper --restart always -e JVMFLAGS&#x3D;&quot;-Xmx1024m&quot; zookeeper</span><br></pre></td></tr></table></figure>

<h2 id="Replicated-mode"><a href="#Replicated-mode" class="headerlink" title="Replicated mode"></a>Replicated mode</h2><p>Environment variables below are mandatory if you want to run Zookeeper in replicated mode.</p>
<h3 id="ZOO-MY-ID"><a href="#ZOO-MY-ID" class="headerlink" title="ZOO_MY_ID"></a><code>ZOO_MY_ID</code></h3><p>The id must be unique within the ensemble and should have a value between 1 and 255. Do note that this variable will not have any effect if you start the container with a <code>/data</code> directory that already contains the <code>myid</code> file.</p>
<h3 id="ZOO-SERVERS"><a href="#ZOO-SERVERS" class="headerlink" title="ZOO_SERVERS"></a><code>ZOO_SERVERS</code></h3><p>This variable allows you to specify a list of machines of the Zookeeper ensemble. Each entry has the form of <code>server.id=host:port:port</code>. Entries are separated with space. Do note that this variable will not have any effect if you start the container with a <code>/conf</code> directory that already contains the <code>zoo.cfg</code> file.</p>
<p>In 3.5, the syntax of this has changed. Servers should be specified as such: <code>server.id=&lt;address1&gt;:&lt;port1&gt;:&lt;port2&gt;[:role];[&lt;client port address&gt;:]&lt;client port&gt;</code> <a href="https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html">Zookeeper Dynamic Reconfiguration</a></p>
<h2 id="Where-to-store-data"><a href="#Where-to-store-data" class="headerlink" title="Where to store data"></a>Where to store data</h2><p>This image is configured with volumes at <code>/data</code> and <code>/datalog</code> to hold the Zookeeper in-memory database snapshots and the transaction log of updates to the database, respectively.</p>
<blockquote>
<p>Be careful where you put the transaction log. A dedicated transaction log device is key to consistent good performance. Putting the log on a busy device will adversely affect performance.</p>
</blockquote>
<h2 id="How-to-configure-logging"><a href="#How-to-configure-logging" class="headerlink" title="How to configure logging"></a>How to configure logging</h2><p>By default, ZooKeeper redirects stdout/stderr outputs to the console. You can redirect to a file located in <code>/logs</code> by passing environment variable <code>ZOO_LOG4J_PROP</code> as follows:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -e ZOO_LOG4J_PROP=&quot;INFO,ROLLINGFILE&quot; zookeeper</span><br></pre></td></tr></table></figure>

<p>This will write logs to <code>/logs/zookeeper.log</code>. Check <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_logging">ZooKeeper Logging</a> for more details.</p>
<p>This image is configured with a volume at <code>/logs</code> for your convenience.</p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS开启端口转发</title>
    <url>/2020/07/03/MacOS%E5%BC%80%E5%90%AF%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<h3 id="在-etc-pf-anchors-目录下新建一个名为com-pow文件，内容如下"><a href="#在-etc-pf-anchors-目录下新建一个名为com-pow文件，内容如下" class="headerlink" title="在/etc/pf.anchors/目录下新建一个名为com.pow文件，内容如下"></a>在/etc/pf.anchors/目录下新建一个名为com.pow文件，内容如下</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rdr pass on en0 inet proto tcp from any to any port 8080 -&gt; 127.0.0.1 port 8080</span><br><span class="line">rdr pass on en5 inet proto tcp from any to any port 8080 -&gt; 127.0.0.1 port 8080</span><br></pre></td></tr></table></figure>

<p>上面的配置标表示的意思是将从en0和en5，目的端口为8080的包转发到8080端口上</p>
<h3 id="使用pfctl命令检测配置文件"><a href="#使用pfctl命令检测配置文件" class="headerlink" title="使用pfctl命令检测配置文件"></a>使用<code>pfctl</code>命令检测配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pfctl -vnf /etc/pf.anchors/com.pow</span><br></pre></td></tr></table></figure>

<h3 id="修改-etc-pf-conf配置文件"><a href="#修改-etc-pf-conf配置文件" class="headerlink" title="修改/etc/pf.conf配置文件"></a>修改<code>/etc/pf.conf</code>配置文件</h3><p><code>pf</code>启动时会自动装载<code>/etc/pf.conf</code>文件，因此将<code>anchor</code>文件链接到<code>/etc/pf.conf</code>，转发规则就会自动建立了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在rdr-anchor <span class="string">&quot;com.apple/*&quot;</span>下面增加：</span></span><br><span class="line"></span><br><span class="line">rdr-anchor &quot;pow&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">在load anchor <span class="string">&quot;com.apple&quot;</span> from <span class="string">&quot;/etc/pf.anchors/com.apple&quot;</span>后面添加：</span></span><br><span class="line"></span><br><span class="line">load anchor &quot;pow&quot; from &quot;/etc/pf.anchors/com.pow&quot;</span><br></pre></td></tr></table></figure>



<p>修改后的配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrub-anchor &quot;com.apple/*&quot;</span><br><span class="line">nat-anchor &quot;com.apple/*&quot;</span><br><span class="line">rdr-anchor &quot;com.apple/*&quot;</span><br><span class="line">rdr-anchor &quot;pow&quot;</span><br><span class="line">dummynet-anchor &quot;com.apple/*&quot;</span><br><span class="line">anchor &quot;com.apple/*&quot;</span><br><span class="line">load anchor &quot;com.apple&quot; from &quot;/etc/pf.anchors/com.apple&quot;</span><br><span class="line">load anchor &quot;pow&quot; from &quot;/etc/pf.anchors/com.pow&quot;</span><br></pre></td></tr></table></figure>

<p>导入并运行<code>pf</code>命令</p>
<p>一定要导入并允许运行<code>pf</code>的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pfctl -evf /etc/pf.anchors/com.pow</span><br></pre></td></tr></table></figure>


<p>设置<code>pf</code>开机自动打开</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pfctl -e</span><br></pre></td></tr></table></figure>

<p>如果想要关闭<code>pf</code>，命令是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pfctl -d1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Jenkins集群</title>
    <url>/2019/11/28/%E6%90%AD%E5%BB%BAJenkins%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h3 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h3><p>下载<a href="http://updates.jenkins-ci.org/download/war/">Jenkins</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;updates.jenkins-ci.org&#x2F;latest&#x2F;jenkins.war</span><br></pre></td></tr></table></figure>

<p>启动Jenkins war包，默认8080端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar jenkins.war</span><br></pre></td></tr></table></figure>

<p>后台启动Jenkins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup java -jar jenkins.war --httpPort&#x3D;8080 &amp;</span><br></pre></td></tr></table></figure>

<p>查看日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f nohup.out</span><br></pre></td></tr></table></figure>

<p>开放端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看想开的端口是否已开：</span><br><span class="line">firewall-cmd --query-port&#x3D;9090&#x2F;tcp </span><br><span class="line">添加指定需要开放的端口：</span><br><span class="line">firewall-cmd --add-port&#x3D;9090&#x2F;tcp --permanent</span><br><span class="line">重载入添加的端口：</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">查询指定端口是否开启成功：</span><br><span class="line">firewall-cmd --query-port&#x3D;9090&#x2F;tcp</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>

<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>进入系统管理–&gt;节点管理–&gt;新建节点：</p>
<p><img src="/images/%E6%90%AD%E5%BB%BAJenkins%E9%9B%86%E7%BE%A4-1.png" alt="搭建Jenkins集群-1"></p>
<p>写入节点名称，选择固定节点，配置节点：</p>
<p><img src="/images/%E6%90%AD%E5%BB%BAJenkins%E9%9B%86%E7%BE%A4-2.png" alt="搭建Jenkins集群-2"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Hexo framework</title>
    <url>/2019/11/29/%E5%AE%89%E8%A3%85Hexo%20framework/</url>
    <content><![CDATA[<h1 id="安装Hexo-framework"><a href="#安装Hexo-framework" class="headerlink" title="安装Hexo framework"></a>安装Hexo framework</h1><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><ul>
<li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 8.6，建议使用 Node.js 10.0 及以上版本)</li>
<li><a href="http://git-scm.com/">Git</a></li>
</ul>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing index.html from permalinks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Metadata elements</span></span><br><span class="line"><span class="comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span><br><span class="line"><span class="attr">meta_generator:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="comment">## Use post&#x27;s date for updated date unless set in front-matter</span></span><br><span class="line"><span class="attr">use_date_for_updated:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include / Exclude file(s)</span></span><br><span class="line"><span class="comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>title</code></td>
<td align="left">网站标题</td>
</tr>
<tr>
<td align="left"><code>subtitle</code></td>
<td align="left">网站副标题</td>
</tr>
<tr>
<td align="left"><code>description</code></td>
<td align="left">网站描述</td>
</tr>
<tr>
<td align="left"><code>keywords</code></td>
<td align="left">网站的关键词。使用半角逗号 <code>,</code> 分隔多个关键词。</td>
</tr>
<tr>
<td align="left"><code>author</code></td>
<td align="left">您的名字</td>
</tr>
<tr>
<td align="left"><code>language</code></td>
<td align="left">网站使用的语言</td>
</tr>
<tr>
<td align="left"><code>timezone</code></td>
<td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td>
</tr>
</tbody></table>
<p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hexo-site&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;hexo&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hexo&quot;</span>: <span class="string">&quot;^3.8.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-archive&quot;</span>: <span class="string">&quot;^0.1.5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-category&quot;</span>: <span class="string">&quot;^0.1.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-index&quot;</span>: <span class="string">&quot;^0.2.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-generator-tag&quot;</span>: <span class="string">&quot;^0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-renderer-ejs&quot;</span>: <span class="string">&quot;^0.3.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-renderer-stylus&quot;</span>: <span class="string">&quot;^0.3.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-renderer-marked&quot;</span>: <span class="string">&quot;^0.3.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hexo-server&quot;</span>: <span class="string">&quot;^0.3.3&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>
<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p>
<h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ol>
<li><p>Install <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>Add the following configurations to <strong>_config.yml</strong>, (remove existing lines if any)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&lt;username&gt;/&lt;project&gt;</span></span><br><span class="line">  <span class="comment"># example, https://github.com/hexojs/hexojs.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gh-pages</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Run <code>hexo clean &amp;&amp; hexo deploy</code>.</p>
</li>
<li><p>Check the webpage at <em>username</em>.github.io.</p>
</li>
</ol>
<h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><h3 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h3><p>安装NexT主题</p>
<h3 id="开启文章字数统计"><a href="#开启文章字数统计" class="headerlink" title="开启文章字数统计"></a>开启文章字数统计</h3><p>安装 hexo-symbols-count-time：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time</span><br></pre></td></tr></table></figure>

<p>配置next _config.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>

<h3 id="配置背景特效"><a href="#配置背景特效" class="headerlink" title="配置背景特效"></a>配置背景特效</h3><p>安装canvas-nest.js：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save canvas-nest.js</span><br></pre></td></tr></table></figure>

<p>配置next _config.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="attr">canvas_nest:</span> <span class="string">//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js</span></span><br></pre></td></tr></table></figure>

<h3 id="配置背景图片："><a href="#配置背景图片：" class="headerlink" title="配置背景图片："></a>配置背景图片：</h3><p>添加文件到<code>next/source/css/_custom/custom.styl</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  background: url(/images/uploads/background.jpg) no-repeat;</span><br><span class="line">  <span class="comment">/* 背景图垂直、水平均居中 */</span></span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="comment">/* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 */</span></span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">  <span class="comment">/* 让背景图基于容器大小伸缩 */</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="comment">/* 设置背景颜色，背景图加载过程中会显示背景色 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">	background:url(/images/uploads/sidebar.jpg);</span><br><span class="line">	<span class="attribute">background-size</span>: cover;</span><br><span class="line">	<span class="attribute">background-position</span>:center;</span><br><span class="line">	<span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">	<span class="selector-tag">p</span>,<span class="selector-tag">span</span>,<span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">            <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">60px</span> <span class="number">30px</span> <span class="number">60px</span>;</span><br><span class="line">            <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>) none repeat scroll <span class="meta">!important</span>;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="selector-id">#lv-container</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">60px</span> <span class="number">30px</span> <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>) none repeat scroll <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>激活用户自定义配置，打开<code>next/source/css/main.styl</code>，添加配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Custom Layer</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">@import &quot;_custom/custom&quot;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
        <category>NexT</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
