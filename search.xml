<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker安装morunchang/fastdfs</title>
    <url>/2021/03/24/Docker%E5%AE%89%E8%A3%85morunchang-fastdfs/</url>
    <content><![CDATA[<h1 id="Docker安装morunchang-x2F-fastdfs"><a href="#Docker安装morunchang-x2F-fastdfs" class="headerlink" title="Docker安装morunchang&#x2F;fastdfs"></a>Docker安装morunchang&#x2F;fastdfs</h1><h2 id="FastDFS简介"><a href="#FastDFS简介" class="headerlink" title="FastDFS简介"></a>FastDFS简介</h2><p>FastDFS是一款开源的分布式文件系统，功能主要包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了文件大容量存储和高性能访问的问题。FastDFS特别适合以文件为载体的在线服务，如图片、视频、文档等等。</p>
<p>FastDFS作为一款轻量级分布式文件系统，版本V6.01代码量6.3万行。FastDFS用C语言实现，支持Linux、FreeBSD、MacOS等类UNIX系统。FastDFS类似google FS，属于应用级文件系统，不是通用的文件系统，只能通过专有API访问，目前提供了C和Java SDK，以及PHP扩展SDK。</p>
<p>FastDFS为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性。FastDFS可以看做是基于文件的key value存储系统，key为文件ID，value为文件内容，因此称作分布式文件存储服务更为合适。</p>
<span id="more"></span>

<h2 id="FastDFS由跟踪服务器-Tracker-Server-、存储服务器-Storage-Server-和客户端-Client-构成。"><a href="#FastDFS由跟踪服务器-Tracker-Server-、存储服务器-Storage-Server-和客户端-Client-构成。" class="headerlink" title="FastDFS由跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)构成。"></a>FastDFS由跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)构成。</h2><h3 id="Tracker-server-追踪服务器"><a href="#Tracker-server-追踪服务器" class="headerlink" title="Tracker server 追踪服务器"></a>Tracker server 追踪服务器</h3><p>追踪服务器负责接收客户端的请求，选择合适的组合storage server ，tracker server 与 storage server之间也会用心跳机制来检测对方是否活着。<br>Tracker需要管理的信息也都放在内存中，并且里面所有的Tracker都是对等的（每个节点地位相等），很容易扩展客户端访问集群的时候会随机分配一个Tracker来和客户端交互。</p>
<h3 id="Storage-server-储存服务器"><a href="#Storage-server-储存服务器" class="headerlink" title="Storage server 储存服务器"></a>Storage server 储存服务器</h3><p>实际存储数据，分成若干个组（group），实际traker就是管理的storage中的组，而组内机器中则存储数据，group可以隔离不同应用的数据，不同的应用的数据放在不同group里面，</p>
<ul>
<li>优点：<br>海量的存储：主从型分布式存储，存储空间方便拓展,<br>fastDFS对文件内容做hash处理，避免出现重复文件<br>然后fastDFS结合Nginx集成, 提供网站效率</li>
</ul>
<h3 id="客户端Client"><a href="#客户端Client" class="headerlink" title="客户端Client"></a>客户端Client</h3><ul>
<li>主要是上传下载数据的服务器，也就是我们自己的项目所部署在的服务器。</li>
</ul>
<h2 id="FastDFS特点"><a href="#FastDFS特点" class="headerlink" title="FastDFS特点"></a>FastDFS特点</h2><ol>
<li>分组存储，简单灵活；</li>
<li>对等结构，不存在单点；</li>
<li>文件ID由FastDFS生成，作为文件访问凭证。FastDFS不需要传统的name server或meta server；</li>
<li>大、中、小文件均可以很好支持，可以存储海量小文件；</li>
<li>一台storage支持多块磁盘，支持单盘数据恢复；</li>
<li>提供了nginx扩展模块，可以和nginx无缝衔接；</li>
<li>支持多线程方式上传和下载文件，支持断点续传；</li>
<li>存储服务器上可以保存文件附加属性。</li>
</ol>
<h2 id="安装FastDFS"><a href="#安装FastDFS" class="headerlink" title="安装FastDFS"></a>安装FastDFS</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull morunchang/fastdfs;</span><br></pre></td></tr></table></figure>

<h3 id="设置Tracker"><a href="#设置Tracker" class="headerlink" title="设置Tracker"></a>设置Tracker</h3><h4 id="运行-tracker"><a href="#运行-tracker" class="headerlink" title="运行 tracker"></a>运行 tracker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name tracker --net=host morunchang/fastdfs sh tracker.sh</span><br></pre></td></tr></table></figure>

<p>上面的启动命令是在Linux下，如果是Mac或Windows操作系统network&#x3D;host（容器与主机享受相同的network namespace）会失效，此时需要指定对应的端口映射，-p 22122:22122 </p>
<h4 id="进入-tracker"><a href="#进入-tracker" class="headerlink" title="进入 tracker"></a>进入 tracker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it tracker /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h4><p><strong><code>/etc/nginx/conf/nginx.conf</code></strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">server <span class="punctuation">&#123;</span></span><br><span class="line">        listen       <span class="number">21000</span>;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>/etc/fdfs/client.conf</code></strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">tracker_server</span>=<span class="string">127.0.0.1:22122</span></span><br><span class="line"><span class="attr">......</span></span><br><span class="line"><span class="attr">http.tracker_server_port</span>=<span class="string">21000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>/etc/fdfs/tracker.conf</code></strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">port</span>=<span class="string">22122</span></span><br><span class="line"><span class="attr">......</span></span><br><span class="line"><span class="attr">http.server_port</span>=<span class="string">21000</span></span><br></pre></td></tr></table></figure>

<h3 id="设置Storage"><a href="#设置Storage" class="headerlink" title="设置Storage"></a>设置Storage</h3><h4 id="运行-storage"><a href="#运行-storage" class="headerlink" title="**运行 storage **"></a>**运行 storage **</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name storage --net=host -e TRACKER_IP=127.0.0.1:22122 -e GROUP_NAME=group1 morunchang/fastdfs sh storage.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">共享卷</span></span><br><span class="line">docker run -d --name storage --net=host -e TRACKER_IP=127.0.0.1:22122 -v /home/monochrome/app/fastdfs/storage:/data/fast_data -e GROUP_NAME=group1 morunchang/fastdfs sh storage.sh</span><br><span class="line"></span><br><span class="line">docker run -d --name storage -p 22000:22000 -p 23000:23000 -e TRACKER_IP=127.0.0.1:22122 -e GROUP_NAME=group1 morunchang/fastdfs sh storage.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">共享卷</span></span><br><span class="line">docker run -d --name storage -p 22000:22000 -p 23000:23000 -e TRACKER_IP=127.0.0.1:22122 -v /home/monochrome/app/fastdfs/storage:/data/fast_data -e GROUP_NAME=mono morunchang/fastdfs sh storage.sh</span><br></pre></td></tr></table></figure>

<h4 id="进入-storage"><a href="#进入-storage" class="headerlink" title="进入 storage"></a><strong>进入 storage</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it storage /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="修改端口-1"><a href="#修改端口-1" class="headerlink" title="修改端口"></a>修改端口</h4><p><strong><code>/etc/nginx/conf/nginx.conf</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       22000;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>/etc/fdfs/client.conf</code></strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">tracker_server</span>=<span class="string">127.0.0.1:22122</span></span><br><span class="line"><span class="attr">http.tracker_server_port</span>=<span class="string">21000</span></span><br></pre></td></tr></table></figure>

<p><strong><code>/etc/fdfs/storage.conf</code></strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">port</span>=<span class="string">23000</span></span><br><span class="line"><span class="attr">tracker_server</span>=<span class="string">127.0.0.1:22122</span></span><br><span class="line"><span class="attr">http.server_port</span>=<span class="string">22000</span></span><br></pre></td></tr></table></figure>

<h3 id="替换配置文件"><a href="#替换配置文件" class="headerlink" title="替换配置文件"></a>替换配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp nginx.conf tracker:/etc/nginx/conf/nginx.conf</span><br><span class="line">docker cp client.conf tracker:/etc/fdfs/client.conf</span><br><span class="line">docker cp tracker.conf tracker:/etc/fdfs/tracker.conf</span><br><span class="line"></span><br><span class="line">docker cp nginx.conf storage:/etc/nginx/conf/nginx.conf</span><br><span class="line">docker cp client.conf storage:/etc/fdfs/client.conf</span><br><span class="line">docker cp storage.conf storage:/etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure>

<h2 id="通过Spring-Boot使用FastDFS"><a href="#通过Spring-Boot使用FastDFS" class="headerlink" title="通过Spring Boot使用FastDFS"></a>通过Spring Boot使用FastDFS</h2><h3 id="导入Maven依赖"><a href="#导入Maven依赖" class="headerlink" title="导入Maven依赖"></a>导入Maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.tobato<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastdfs-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.27.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>详见作者GitHub：<a href="https://github.com/tobato/FastDFS_Client">https://github.com/tobato/FastDFS_Client</a></p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>FastDFS</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring REST API实体和DTO之间的转换</title>
    <url>/2018/11/26/API%E5%AE%9E%E4%BD%93%E5%92%8CDTO%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="Spring-REST-API实体和DTO之间的转换"><a href="#Spring-REST-API实体和DTO之间的转换" class="headerlink" title="Spring REST API实体和DTO之间的转换"></a>Spring REST API实体和DTO之间的转换</h1><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h2><p>在本教程中，我们将处理在Spring应用程序的内部实体和被发送到客户端的外部DTO（数据传输对象）之间的转换。</p>
<h2 id="2-ModelMapper"><a href="#2-ModelMapper" class="headerlink" title="2. ModelMapper"></a>2. ModelMapper</h2><p>首先，让我们看看用来执行实体-DTO转换的主要类库——ModelMapper。</p>
<p>我们需要在pom.xml中添加这个依赖：</p>
<figure class="highlight plaintext"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.modelmapper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;modelmapper&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>如果需要检查这个库是否有更新的版本， 请<a href="https://search.maven.org/classic/#search|gav|1|g%3A%22org.modelmapper%22%20AND%20a%3A%22modelmapper%22">点击这里</a>。</p>
<p>然后，我们将在Spring配置中定义ModelMapperbean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ModelMapper <span class="title function_">modelMapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelMapper</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-DTO"><a href="#3-DTO" class="headerlink" title="3. DTO"></a>3. DTO</h2><p>话分两头，接下来让我们来看看本例使用的DTO——PostDto。</p>
<figure class="highlight java"><figcaption><span>PostDto.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostDto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDto user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getSubmissionDateConverted</span><span class="params">(String timezone)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        dateFormat.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">        <span class="keyword">return</span> dateFormat.parse(<span class="built_in">this</span>.date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSubmissionDate</span><span class="params">(Date date, String timezone)</span> &#123;</span><br><span class="line">        dateFormat.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">        <span class="built_in">this</span>.date = dateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，上面与日期相关的两个方法，它们是用来处理客户端和服务器之间日期数据转换的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getSubmissionDateConverted()方法将日期字符串转换为服务器所在时区中的日期，以便将其用于持久化Post实体</span><br><span class="line">setSubmissionDate()方法是将DTO的日期设置为当前用户所在时区的Post日期</span><br></pre></td></tr></table></figure>

<h2 id="4-服务层"><a href="#4-服务层" class="headerlink" title="4. 服务层"></a>4. 服务层</h2><p>现在让我们看一下服务层的操作——它显然是与实体（而不是DTO）一起工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Post&gt; <span class="title function_">getPostsList</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> page, <span class="type">int</span> size, String sortDir, String sort)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">PageRequest</span> <span class="variable">pageReq</span></span><br><span class="line">     <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageRequest</span>(page, size, Sort.Direction.fromString(sortDir), sort);</span><br><span class="line"></span><br><span class="line">    Page&lt;Post&gt; posts = postRepository</span><br><span class="line">      .findByUser(userService.getCurrentUser(), pageReq);</span><br><span class="line">    <span class="keyword">return</span> posts.getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-控制器层"><a href="#5-控制器层" class="headerlink" title="5. 控制器层"></a>5. 控制器层</h2><p>下面让我们来看看服务层上面的控制器层，这才是转换操作实际触发的地方。<br>现在，让我们来看一个标准的控制器，一个暴露Post资源的REST API。  </p>
<p>我们将在这里展示一些简单的CRUD操作：创建、更新、获取一条和全部记录。考虑到操作非常简单，并且我们特别感兴趣的是实体-DTO转换方面：  </p>
<figure class="highlight java"><figcaption><span>PostRestController.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostRestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IPostService postService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ModelMapper modelMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;PostDto&gt; <span class="title function_">getPosts</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        List&lt;Post&gt; posts = postService.getPostsList(page, size, sortDir, sort);</span><br><span class="line">        <span class="keyword">return</span> posts.stream()</span><br><span class="line">          .map(post -&gt; convertToDto(post))</span><br><span class="line">          .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CREATED)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> PostDto <span class="title function_">createPost</span><span class="params">(<span class="meta">@RequestBody</span> PostDto postDto)</span> &#123;</span><br><span class="line">        <span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> convertToEntity(postDto);</span><br><span class="line">        <span class="type">Post</span> <span class="variable">postCreated</span> <span class="operator">=</span> postService.createPost(post));</span><br><span class="line">        <span class="keyword">return</span> convertToDto(postCreated);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> PostDto <span class="title function_">getPost</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> convertToDto(postService.getPostById(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.PUT)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePost</span><span class="params">(<span class="meta">@RequestBody</span> PostDto postDto)</span> &#123;</span><br><span class="line">        <span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> convertToEntity(postDto);</span><br><span class="line">        postService.updatePost(post);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我们从Post实体到PostDto的转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> PostDto <span class="title function_">convertToDto</span><span class="params">(Post post)</span> &#123;</span><br><span class="line">    <span class="type">PostDto</span> <span class="variable">postDto</span> <span class="operator">=</span> modelMapper.map(post, PostDto.class);</span><br><span class="line">    postDto.setSubmissionDate(post.getSubmissionDate(), </span><br><span class="line">        userService.getCurrentUser().getPreference().getTimezone());</span><br><span class="line">    <span class="keyword">return</span> postDto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是从DTO到实体的转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Post <span class="title function_">convertToEntity</span><span class="params">(PostDto postDto)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> modelMapper.map(postDto, Post.class);</span><br><span class="line">    post.setSubmissionDate(postDto.getSubmissionDateConverted(</span><br><span class="line">      userService.getCurrentUser().getPreference().getTimezone()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (postDto.getId() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Post</span> <span class="variable">oldPost</span> <span class="operator">=</span> postService.getPostById(postDto.getId());</span><br><span class="line">        post.setRedditID(oldPost.getRedditID());</span><br><span class="line">        post.setSent(oldPost.isSent());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> post;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，正如您所看到的，在modelmapper库的帮助下，转换逻辑是快速且简单的——我们使用了modelMapper的map API，并且在不编写任何转换逻辑的情况下完成了数据转换。</p>
<h2 id="6-单元测试"><a href="#6-单元测试" class="headerlink" title="6. 单元测试"></a>6. 单元测试</h2><p>最后，让我们做一个非常简单的测试，以确保实体和DTO之间的转换可以很好地工作：</p>
<figure class="highlight java"><figcaption><span>PostDtoUnitTest.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostDtoUnitTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ModelMapper</span> <span class="variable">modelMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenConvertPostEntityToPostDto_thenCorrect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Post</span>();</span><br><span class="line">        post.setId(Long.valueOf(<span class="number">1</span>));</span><br><span class="line">        post.setTitle(randomAlphabetic(<span class="number">6</span>));</span><br><span class="line">        post.setUrl(<span class="string">&quot;www.test.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PostDto</span> <span class="variable">postDto</span> <span class="operator">=</span> modelMapper.map(post, PostDto.class);</span><br><span class="line">        assertEquals(post.getId(), postDto.getId());</span><br><span class="line">        assertEquals(post.getTitle(), postDto.getTitle());</span><br><span class="line">        assertEquals(post.getUrl(), postDto.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenConvertPostDtoToPostEntity_thenCorrect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PostDto</span> <span class="variable">postDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PostDto</span>();</span><br><span class="line">        postDto.setId(Long.valueOf(<span class="number">1</span>));</span><br><span class="line">        postDto.setTitle(randomAlphabetic(<span class="number">6</span>));</span><br><span class="line">        postDto.setUrl(<span class="string">&quot;www.test.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> modelMapper.map(postDto, Post.class);</span><br><span class="line">        assertEquals(postDto.getId(), post.getId());</span><br><span class="line">        assertEquals(postDto.getTitle(), post.getTitle());</span><br><span class="line">        assertEquals(postDto.getUrl(), post.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装与常用命令</title>
    <url>/2019/01/11/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><h4 id="卸载老版本的Docker"><a href="#卸载老版本的Docker" class="headerlink" title="卸载老版本的Docker"></a>卸载老版本的Docker</h4><p>　　在CentOS中，老版本Docker名称是<code>docker</code>或<code>docker-engine</code>，而Docker CE的软件包名称是<code>docker-ce</code>。因此，如已安装过老版本的Docker，需使用如下命令卸载。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<p>　　需要注意的是，执行该命令只会卸载Docker本身，而不会删除Docker存储的文件，例如镜像、容器、卷以及网络文件等。这些文件保存在<code>/var/lib/docker</code>目录中，需要手动删除。</p>
<span id="more"></span>
<h4 id="安装仓库"><a href="#安装仓库" class="headerlink" title="安装仓库"></a>安装仓库</h4><p>　　执行以下命令，安装Docker所需的包。其中，<code>yum-utils</code>提供了<code>yum-config-manager</code>工具；<code>device-mapper-persistent-data</code>及<code>lvm2</code>则是<code>devicemapper</code>存储驱动所需的包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
<p>　　执行如下命令，安装<code>stable</code>仓库。必须安装<code>stable</code>仓库，即使你想安装<code>edge</code>或<code>test</code>仓库中的Docker构建版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>　　[可选] 执行如下命令，启用<code>edge</code>及<code>test</code>仓库。<code>edge/test</code>仓库其实也包含在了<code>docker.repo</code>文件中，但默认是禁用的，可使用以下命令来启用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --enable docker-ce-edge    # 启用edge仓库</span><br><span class="line">sudo yum-config-manager --enable docker-ce-test    # 启用test仓库</span><br></pre></td></tr></table></figure>
<p>　　如需再次禁用，可加上<code>--disable</code>标签。例如，执行如下命令即可禁用<code>edge</code>仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --disable docker-ce-edge</span><br></pre></td></tr></table></figure>
<p>　　TIPS：从<code>Docker 17.06</code>起，<code>stable</code>版本也会发布到<code>edge</code>以及<code>test</code>仓库中。</p>
<h4 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h4><p>　　执行以下命令，更新yum的包索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>
<p>　　执行如下命令即可安装最新版本的Docker CE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure>
<p>　　在生产环境中，可能需要指定想要安装的版本，此时可使用如下命令列出当前可用的Docker版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list docker-ce.x86_64  --showduplicates | sort -r</span><br></pre></td></tr></table></figure>
<p>　　这样，列出版本后，可使用如下命令，安装想要安装的Docker CE版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce-&lt;VERSION&gt;</span><br></pre></td></tr></table></figure>
<p>　　启动Docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<p>　　验证安装是否正确。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<p>　　这样，Docker将会下载测试镜像，并使用该镜像启动一个容器。如能够看到类似如下的输出，则说明安装成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">b04784fba78d: Pull complete</span><br><span class="line">Digest: sha256:f3b3b28a45160805bb16542c9531888519430e9e6d6ffc09d72261b0d26ff74f</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://cloud.docker.com/</span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/engine/userguide/</span><br></pre></td></tr></table></figure>
<h4 id="升级Docker-CE"><a href="#升级Docker-CE" class="headerlink" title="升级Docker CE"></a>升级Docker CE</h4><p>　　如需升级Docker CE，只需执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>
<p>　　然后按照安装Docker的步骤，即可升级Docker。</p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p>　　CentOS 7安装Docker官方文档：<a href="https://docs.docker.com/install/linux/docker-ce/centos/">Docker for CentOS</a>，文档中还讲解了在CentOS 7中安装Docker CE的其他方式，本文不作赘述。</p>
<h3 id="shell一键安装"><a href="#shell一键安装" class="headerlink" title="shell一键安装"></a>shell一键安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>
<h2 id="Windows-docker-for-windows"><a href="#Windows-docker-for-windows" class="headerlink" title="Windows(docker for windows)"></a>Windows(docker for windows)</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>　　Windows 10 Professional 或 Windows 10 Enterprise X64 或Windows Home 10(Version 2004 or later，Windows Home can only run the WSL 2 backend)</p>
<p>　　对于Win 7 or 低版本Windows 10 Home，可使用Docker Toolbox（不建议使用）</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>　　前往<a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows">Docker for Windows 10</a>，下载安装包，双击即可安装。</p>
<h4 id="配置Table自动补全"><a href="#配置Table自动补全" class="headerlink" title="配置Table自动补全"></a>配置Table自动补全</h4><ol>
<li><p>启动一个的PowerShell（即以管理员身份运行）。搜索PowerShell，右键单击，然后选择以管理员身份运行。在PowerShell提示符下键入： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查策略设置是否正确，运行：<code>get-executionpolicy</code> ，应该返回RemoteSigned。</p>
</li>
<li><p>安装posh-dockerPowerShell模块以自动完成Docker命令，键入：<code>Install-Module posh-docker</code>或者，要仅为当前用户安装模块，键入： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Install-Module -Scope CurrentUser posh-docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完成后，只能为当前PowerShell启用自动完成功能，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Import-Module posh-docker</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h2><h3 id="阿里云加速器"><a href="#阿里云加速器" class="headerlink" title="阿里云加速器"></a>阿里云加速器</h3><p>　　注册阿里云账号后，进入<a href="https://cr.console.aliyun.com/#/accelerator">阿里云控制台</a>。<br>　　针对Docker客户端版本大于 1.10.0 的用户，可以通过修改daemon配置文件<code>/etc/docker/daemon.json</code>来使用加速器：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://arbzyqhz.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>　　以上内容转载自周立的Docker教程，<a href="http://www.itmuch.com/docker/02-docker-install/">Docker系列教程02-Docker安装(CentOS7&#x2F;Ubuntu&#x2F;macOS&#x2F;Windows)</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item1 考虑静态工厂方法代替构造方法</title>
    <url>/2018/12/06/Effective-Java-Item1-%E8%80%83%E8%99%91%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>一个类允许客户端获取他的一个实例的传统方法是提供一个公有的构造函数。除此之外，还有一个技术，每个程序员都应该掌握。就是一个类提供一个公有的静态工厂方法，这个方法就是一个简单的返回当前类一个实例的静态方法。这里有个来自于<strong>Boolean</strong>（对原生类型<strong>boolean</strong>的装箱）类内部实现的简单的例。下面的方法可以将一个原生<strong>boolean</strong>类型的值转变成一个对<strong>Boolean</strong>对象的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>请注意，上面这个静态工厂方法与设计模式[Gamma95]中的工厂方法模式并不一样。本条款所介绍的静态工厂方法在设计模式一书中并没有直接的等价物。  </p>
<p>除了公有构造方法外，类还可以向其客户端提供静态工厂方法。相比于公有构造方法来说，提供静态工厂方法有利也有弊。</p>
<p><strong>静态工厂方法其中一个好处是，它可以有自己的名字，而构造函数不行</strong>。如果构造函数的参数，他们本身并不能描述返回的对象，那么拥有恰当名字的静态工厂将会更加易于使用，所生成的客户端代码的可读性也更好。举个例子，通过构造函数<strong>BigInteger(int, int, Random)</strong> 返回一个值可能是质数的<strong>BigInteger</strong> 对象，还有更好的方法，就是通<strong>BigInteger.probablePrime</strong> 这个静态工厂方法来实现。（这个方法在java4时加入）</p>
<p>一个类只能有一个指定签名的构造函数。程序员们已经知道如何绕过这个限制了，那就是提供两个构造方法，<br>这两个构造方法之间唯一的差别就是参数列表中参数类型的顺序是不同的。<br>这是一个非常差劲的想法。像这样的API，使用者将永远不能够记住哪个构造函数是哪个的，最终会错误地调用错误的构造函数。<br>人们在读使用了这些构造函数的代码时，如果没有类说明文档，就没有办法知道这些代码是做什么的。</p>
<p>由于拥有名字，因此静态工厂方法不会遇到上面所讨论的限制。当一个类需要多个拥有相同签名的构造方法时，只需使用静态工厂方法来代替构造方法，<br>并精心选择好名字来明确他们之间的差别即可。</p>
<p><strong>静态工厂方法的第二个好处是，它不像构造函数那样，他不需要每次调用都创建一个新的对象</strong>。这样就可以让不变类使用预先构造好的实例，或是在构造时将其缓存起来，从而避免了创建不必要的重复对象的情况。<strong>Boolea.valueOf(boolean)</strong> 这个方法就论证了这个技术：它绝不会创建一个对象。这个技术非常像享元设计模式。如果相同的一个对象经常被请求而且创建这个对象的成本是昂贵的，那么静态工厂方法能极大地提高性能。</p>
<p>静态工厂方法可以在重复调用的情况下返回同一个对象的能力使得类可以在任何时候都能严格控制哪些实例可以存在<br>采取这种做法的类叫做实例控制。这里有几个理由去使用实例化控制的类。<br>实例化控制允许一个类可以保证他是单例的（条目3）或者不可实例化的（条目4）。此外，它允许不可变值类(条目17)保证没有两个相等的实例存在：<br>当且仅当a &#x3D;&#x3D; b时，a.equals(b)才为true。这是享元模式的基础[Gamma95]。<br>枚举类型(条目34)提供了此保证。</p>
<p><strong>静态工厂方法的第三个优点是，与构造函数不同，它们可以返回所声明的返回类型的任何子类型的对象</strong>。这样，在选择返回对象的类型时，给了你很大的灵活性。</p>
<p>这种灵活性的一个应用场景就是API能够在无需将类声明为公有的情况下就可以返回对象。以这种方式隐藏实现类使得API变得非常紧凑。这项技术也被应用到了基于接口的框架（条目20）中，其中接口就为静态工厂方法提供了自然而然的返回类型。</p>
<p>在Java 8之前，接口不能有静态方法。根据约定，针对名为Type的接口的静态工厂方法会被放到名为Types的不可实例化的伴生类（条目4）当中。Java集合框架有接口的45个辅助实现，提供了不可修改的集合、同步集合等等。几乎所有接口的实现都是通过一个不能实例化的类（<strong>java.util.Collections</strong>）的静态工厂方法提供的。返回对象的类型都是非公开的。</p>
<p>集合框架API要比它本来的样子小很多，它公开了了45个独立的公有类，每个类都针对于一个便捷的实现。这并不仅仅只是API的数量少了了，更为重要的是概念上的数量少了。程序员使用API所需掌握的概念的数量和难度都降低了。程序员知道所返回的对象是由其接口API所精确描述的，因此不需要读取额外的关于实现类的文档说明。使用这种静态工厂方法要求客户端引用接口而非实现类所返回的对象，这通常是很好的实践(条目64)。</p>
<p>在Java 8中，接口不能包含静态方法的限制被消除了，这样一般来说，我们就没必要再为接口提供不可实例化的伴生类了。很多本应该位于这种类中的公有静态成员现在应该放到接口自身当中了。不过，值得注意的是，我们还是需要将这些静态方法的实现代码放到单独的包级别的私有类中。这是因为Java 8要求接口的所有静态成员都是公共的。Java 9允许私有静态方法，但是静态字段和静态成员类仍然需要公开。</p>
<p><strong>静态工厂的第四个好处在于，作为输入参数的函数，返回对象所属的类会随着调用的不同而不同</strong>。所声明的返回类型的任何子类型都是允许的。返回对象所属的类也会随着调用的不同而不同</p>
<p>EnumSet类（条款36）没有公有的构造方法，只有静态工厂方法。在OpenJDK的实现当中，它返回其中两个子类中任意一个类的一个实例，这取决于底层枚举类型的大小：如果拥有的元素数量小于等于64个（这也是大多数枚举类型的情况），它的静态工厂方法会返回一个RegularEnumSet实例，其底层是个long类型。如果枚举类型拥有的元素数量大于等于65个，那么工厂返回一个JumboEnumSet实例，其底层是个long类型的数组。</p>
<p>这两个实现类的存在对客户端是透明的。如果RegularEnumSet不再为小型枚举类型提供性能优势，那么它可以在未来的版本中消除，不会有任何不良影响。类似地，将来的版本可以添加第三或第四个EnumSet 实现，只要这些实现被证明对性能有好处。客户端既不知道也不关心他们从工厂返回的对象的类型，它们只在乎它是EnumSet的某个子类就行。</p>
<p><strong>静态工厂的第五个好处在于，在使用包含了了方法的类时，返回对象所属的类不必事先存在。</strong>。这种灵活的静态工厂方法构成了服务提供者框架的基础，如Java 数据库连接API （JDBC）。服务提供者框架是这样一种系统，提供者实现了某个服务，系统将其实现公开给客户端，从而实现了客户端与实现之间的解耦。</p>
<p>服务提供者框架里有3个最基本的组件：</p>
<ul>
<li>服务接口，代表某一个实现。</li>
<li>提供者注册API，提供者通过它来注册实现 。</li>
<li>服务访问API，客户端通过它获取服务实例。</li>
</ul>
<p>客户端可以通过服务访问API来指定标准，从而选择相应的实现 。如果没有指定这样的一个标准，那么API返回一个默认实现的实例，或者允许客户端循环所有可得到的实例。服务访问API是灵活的静态工厂，它构成了服务提供者框架的基础。</p>
<p>服务提供者框架第四个可选的组件是服务提供者接口，它描述了一个生产服务接口实例的工厂对象。在缺少服务提供者接口的情况下，实现必须通过反射的方式去实例化 (项目65)。在JDBC的场景下，Connection扮演这服务接口的角色，DriverManager.registerDriver就是服务提供者注册API，DriverManager.getConnection就是服务访问API，Driver就是服务提供者接口。</p>
<p>服务提供者框架模式有许多变形。比如说，服务访问API可以向客户端返回比提供者所规定的更为宽泛的服务接口 。这就是桥接模式[Gamma95]。依赖注入框架(项目5)可以看作是强大的服务提供者。从Java 6开始，Java平台有一个通用的服务者提供框架，java.util.ServiceLoader，所以通常你不必，也不应该自己去写这个框架了(条目59)。JDBC并未使用ServiceLoader，因为前者出现的时间要更早一些。。</p>
<p><strong>只提供静态工厂方法的主要限制是没有公共或受保护构造函数的类不能被子类化</strong>。例如，在集合框架中不可能子类化任何方便实现类。可以说，这可能是因祸得福，因为它鼓励程序员使用组合而不是继承(条目18)，并且需要不可变类型(条目17)</p>
<p><strong>静态工厂方法的第二个缺点是，程序员很难找到它们</strong>。他们并不像构造方法那样在API文档中有清楚的说明，这样对于只提供静态工厂方法，而没提供构造方法的类来说，我们就很难知晓到底该用那种方式来实例化它。Javadoc工具可能有一天会引起对静态工厂方法的注意。与此同时，你可以多多注意到类或接口文档中的静态工厂并坚持使用常见的命名约定来减少此类问题的发生。下面是一些静态工厂方法的常用名称。这个列表并不是十分详尽:</p>
<ul>
<li>From —— 一种类型转换方法，它接受单个参数并返回该类型的相应实例，例如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> Date.from(instant);</span><br></pre></td></tr></table></figure></li>
<li>Of —— 一个聚合方法，它接受多个参数并返回该类型的实例，该实例包含了它们，例如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</span><br></pre></td></tr></table></figure></li>
<li>valueOf —— from与of的一种更加冗长的替代方案 ，例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">prime</span> <span class="operator">=</span> BigInteger.valueOf(Integer.MAX_VALUE);</span><br></pre></td></tr></table></figure></li>
<li>instance或者getInstance —— 返回一个实例，该实例由其参数(如果有)描述，但不能说具有相同的值，例如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StackWalker</span> <span class="variable">luke</span> <span class="operator">=</span> StackWalker.getInstance(options);</span><br></pre></td></tr></table></figure></li>
<li>create或者newInstance —— 跟instance和getInstance方法有点类似,期望方法能保证每次调用都返回新的实例，例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">newArray</span> <span class="operator">=</span> Array.newInstance(classObject, arrayLen);</span><br></pre></td></tr></table></figure></li>
<li>getType —— 有点像getInstance，但是，是在工厂方法在一个不同的类中时使用。Type就是工厂方法返回的对象类型，比如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileStore</span> <span class="variable">fs</span> <span class="operator">=</span> Files.getFileStore(path);</span><br></pre></td></tr></table></figure></li>
<li>newType —— 有点像newInstance，但是，是在工厂方法在一个不同的类中时使用。Type就是工厂方法返回的对象类型，比如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> Files.newBufferedReader(path);</span><br></pre></td></tr></table></figure></li>
<li>type ——  getType与newType的一个简洁的替代方案，比如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Complaint&gt; litany = Collections.list(legacyLitany);</span><br></pre></td></tr></table></figure>
总结来说，静态工厂方法和构造方法都有他们的用法，我们需要理解他们各自的优点。通常，静态工厂是优先选择的，这样可以避免习惯性地在没有考虑静态工厂的情况下就提供公有构造方法的情况发生 。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item10 覆盖equals时请遵守通用约定</title>
    <url>/2018/12/10/Effective-Java-Item10-%E8%A6%86%E7%9B%96equals%E6%97%B6%E8%AF%B7%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h2><p>　　尽管<code>Object</code>是一个具体类，但是设计它主要是为了扩展。它所有的非<code>final</code>方法(<code>equals</code>、<code>hashCode</code>、<code>toString</code>、<code>clone</code>和<code>finalize</code>)都有明确的通用约定（**<code>general contract</code>**）,因为它们被设计成是要被覆盖（<code>override</code>）的。任何一个类，它在覆盖这些方法的时候，都有责任遵守这些通用约定；如果不能做到这一点，其他依赖于这些约定的类（例如<code>HashMap</code>和<code>HashSet</code>）就无法结合该类一起正常运作。</p>
<p>　　本章将讲述何时以及如何盖这些非<code>final</code>的<code>Object</code>方法。本章不再讨论<code>finalize</code>方法，因为Item 8已经讨论过这个方法了。而<code>Comparable.compareTo</code>虽然不是<code>Object</code>方法，但是本章也对它进行讨论，因为它具有类似的特征。</p>
<span id="more"></span>

<h3 id="Item-10：覆盖equals时请遵守通用约定"><a href="#Item-10：覆盖equals时请遵守通用约定" class="headerlink" title="Item 10：覆盖equals时请遵守通用约定"></a>Item 10：覆盖<code>equals</code>时请遵守通用约定</h3><p> 　　覆盖<code>equals</code>方法看起来似乎很简单，但是有许多覆盖方式会导致错误，并且后果非常严重。最容易避免这类问提的办法就是不覆盖<code>equals</code>方法，在这种情况下，类的每个实例都只与它自身相等。如果满足了以下任何一个条件，这就正是所期望的结果：</p>
<ul>
<li><p><strong>类的每个实例本质上都是唯一的</strong>。对于代表活动实体而不是值(<code>value</code>)的类来说确实如此，例如<code>Thread</code>。<code>Object</code>的<code>equals</code>实现对于这些类来说正是正确的行为。  </p>
</li>
<li><p><strong>不关心类是否提供了“逻辑相等(<code>logical equality</code>)”的测试功能</strong>。例如，<code>java.util.Random</code>覆盖了<code>equals</code>，以检查两个<code>Random</code>实例是否产生相同的随机数序列，但是设计者并不认为客户需要或者期望这样的功能。在这样的情况下，从<code>Object</code>继承得到的<code>equals</code>实现已经足够了。  </p>
</li>
<li><p><strong>超类己经覆盖了equals．从超类继承过来的行为对于子类也是合适的</strong>。例如，大多数的<code>Set</code>实现都从<code>AbstractSet</code>继承<code>equals</code>实现，<code>Map</code>实现从<code>AbstractMap</code>继承<code>equals</code>实现。</p>
</li>
<li><p><strong>类是私有的或是包级私有的，可以确定它的<code>equals</code>方法永远不会被调用</strong>。在这种情况下，无疑是应该覆盖<code>equals</code>方法的，以防它被意外调用：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(); <span class="comment">// Method is never called</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　那么，什么时候应该覆盖<code>Object.equals</code>呢？如果类具有自己特有的“逻辑相等”概念（不同于对象等同的概念),而且超类还没有覆盖<code>equals</code>以实现期望的行为。这时我们就需要覆盖<code>equals</code>方法。这通常属于“值类（<code>value class</code>）”的情形。值类仅仅是一个表示值的类，例如<code>Integer</code>或者<code>Date</code>。程序员在利用<code>equals</code>方法来比较对象的引用时，希望知道它们在逻辑上是否相等，而不是想了解它们是否指向同一个对象。为了满足程序员的要求，不仅必需覆盖<code>equals</code>方法，而且这样做也使得这个类的实例可以被用做映射表(<code>map</code>)的键(<code>key</code>)，或者集合（<code>set</code>）的元素，使映射或者集合表现出预期的行为。</p>
</li>
</ul>
<p>　　有一种“值类”不需要覆盖<code>equals</code>方法，即用实例受控（Item 1）确保“每个值至多只存在一个对象”的类。枚举类型（Item 34）就属于这种类。对于这样的类而言，逻辑相同与对象等同是一回事，因此<code>Object</code>的<code>equals</code>方法等同于逻辑意义上的<code>equals</code>方法。</p>
<p>　　在覆盖<code>equals</code>方法的时候，你必须要遵守它的通用约定。下面是约定的内容，来自<code>Object</code>的规范[JavaSE6]: </p>
<p>　　<code>equals</code>方法实现了等价关系(<code>equivalence relation</code>):</p>
<ul>
<li><p>自反性(<code>reflexive</code>)。对于任何非<code>null</code>的引用值，<code>x.equals(x)</code>必须返回<code>true</code>。</p>
</li>
<li><p>对称性(<code>symmetric</code>)。对于任何非<code>null</code>的引用值x和Y，当且仅当<code>y.equals(x)</code>返回<code>true</code>时，<br><code>x.equals(y)</code>必须返回<code>true</code>。</p>
</li>
<li><p>传递性(<code>transitive</code>)。对于任何非<code>null</code>的引用值x、y和z,如果<code>x.equals(y)</code>返回<code>true</code>，并<br>且<code>y.equals(z)</code>也返回true，那么<code>x.equals(z)</code>也必须返回<code>true</code>。</p>
</li>
<li><p>一致性：(<code>consistent</code>)。对于任何非<code>null</code>的引用值x和y，只要<code>equals</code>的比较操作在对象中<br>所用的信息没有被修改多次调用<code>x.equals(y)</code>就会一致地返回<code>true</code>，或者一致地返回<code>false</code>。</p>
</li>
<li><p>对于任何非<code>null</code>的引用值x，<code>x.equals(null)</code>必须返回<code>false</code>。</p>
<p>  　　除非你对数学特别感兴，否则这些规定看起来可能有点让人感到恐惧，但是绝对不要忽视这些规定！如果你违反了它们，就会发现你的程序将会表现不正常，甚至崩溃，而且很难找到失败的根源。用John Donne的话说，没有哪个类是孤立的。一个类的实例通常会被频繁地传递给另一个类的实例。有许多类，包括所有的集合类（<code>collection class</code>)在内，都依赖于传递给它们的对象是否遵守了<code>equals</code>约定。</p>
</li>
</ul>
<p>　　现在你已经知道了违反<code>equals</code>约定有多么可怕，现在我们就来更细致地讨论这些约定。值得欣慰的是，这些约定虽然看起来很吓人，实际上并不十分复杂。一旦理解了这些约定，要遵守它们并不困难。现在我们按照顺序逐一查看以下5个要求：</p>
<p>　　**自反性（<code>reflexivity</code>)**——第一个要求仅仅说明对象必须等于其自身。很难想像会无意识地违反这一条。假如违背了这一条，然后把该类的实例添加到集合(<code>collection</code>)中，该集合的<code>contain</code>方法将果断地告诉你，该集合不包含你刚刚添加的实例。</p>
<p>　　<strong>对称性(<code>symmetry</code>)<strong>——第二个要求是说，任何两个对象对于“它们是否相等”的问题都必须保持一致。与第一个要求不同，若无意中违反这一条，这种情形倒是不难想像。例如，考虑下面的类，它实现了一个区分大小写的字符串。字符串由<code>toString</code>保存，但在比较操作中被忽略。<br>    <figure class="highlight java"><figcaption><span>CaseInsensitiveString.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - violates symmetry!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CaseInsensitiveString</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CaseInsensitiveString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = Objects.requireNonNull(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Broken - violates symmetry!</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> CaseInsensitiveString)</span><br><span class="line">            <span class="keyword">return</span> s.equalsIgnoreCase(</span><br><span class="line">                    ((CaseInsensitiveString) o).s);</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> String)  <span class="comment">// One-way interoperability!</span></span><br><span class="line">            <span class="keyword">return</span> s.equalsIgnoreCase((String) o);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Demonstration of the problem (Page 40)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CaseInsensitiveString</span> <span class="variable">cis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaseInsensitiveString</span>(<span class="string">&quot;Polish&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;polish&quot;</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;CaseInsensitiveString&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(cis);</span><br><span class="line"></span><br><span class="line">        System.out.println(list.contains(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // Fixed equals method (Page 40)</span></span><br><span class="line"><span class="comment">//    @Override public boolean equals(Object o) &#123;</span></span><br><span class="line"><span class="comment">//        return o instanceof CaseInsensitiveString &amp;&amp;</span></span><br><span class="line"><span class="comment">//                ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　在这个类中，<code>equals</code>方法的意图非常好，它企图与普通的字符串(<code>String</code>)对象进行互操作。假设我们有一个不区分大小写的字符串和一个普通的字符串：<br>    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CaseInsensitiveString</span> <span class="variable">cis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaseInsensitiveString</span>(<span class="string">&quot;PoliSh&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;polish&quot;</span>;</span><br></pre></td></tr></table></figure><br>　　正如所料，<code>cis.equals(s)</code>返回<code>true</code>。问题在于，虽然<code>CaseInsensitiveString</code>类中的<code>equals</code>方法知道普通的字符串(<code>String</code>)对象，但是，<code>String</code>类中的<code>equals</code>方法却并不知道不区分大小写的字符串。因此，<code>s.equals(cis)</code>返回<code>false</code>，显然违反了对称性，假设你把不区分大小写的字符串对象放到一个集合中：<br>    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;CaseInsensitiveString&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CaseInsensitiveString&gt;();</span><br><span class="line">list.add(ics);</span><br></pre></td></tr></table></figure><br>　　此时<code>list.contains(s)</code>会返回什么结果呢？没人知道。在OpenJDK的当前实现中，它碰巧返回<code>false</code>，但这只是这个特定实现得出的结果而已。在其他的实现中，它有可能返回<code>true</code>，或者抛出一个运行时(<code>runtime</code>)异常。</strong>一旦违反了<code>equals</code>约定，当其他对象面对你的对象时，你完全不知道这些对象的行为会怎么样。</strong></p>
<p>　　为了解决这个问题，只需把企图与<code>String</code>互操作的这段代码从<code>equals</code>方法中去掉就可以了。这样做之后，就可以重构该方法，使它变成一条单独的返回句：<br>    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> o <span class="keyword">instanceof</span> CaseInsensitiveString &amp;&amp;</span><br><span class="line">        ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　**传递性(<code>transitivity</code>)**——<code>equals</code>约定的第三个要求是，如果一个对象等于第二个对象，并且第二个对象又等于第三个对象，则第一个对象一定等于第三个对象。同样地，无意识地违反这条规则的情形也不难想像。考虑子类的情形，它将一个新的值组件(<code>value component</code>)添加到了超类中。换句话说，子类增加的信息会影响到<code>equals</code>的比较结果。我们首先以一个简单的不可变的二维整数型<code>Point</code>类作为开始：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Simple immutable two-dimensional integer point class (Page 37)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> (Point)o;</span><br><span class="line">        <span class="keyword">return</span> p.x == x &amp;&amp; p.y == y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    // Broken - violates Liskov substitution principle (page 43)</span></span><br><span class="line"><span class="comment">//    @Override public boolean equals(Object o) &#123;</span></span><br><span class="line"><span class="comment">//        if (o == null || o.getClass() != getClass())</span></span><br><span class="line"><span class="comment">//            return false;</span></span><br><span class="line"><span class="comment">//        Point p = (Point) o;</span></span><br><span class="line"><span class="comment">//        return p.x == x &amp;&amp; p.y == y;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// See Item 11</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　假设你想要扩展这个类，为一个点添加颜色信息：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adds a value component without violating the equals contract (page 44)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColorPoint</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Point point;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ColorPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, Color color)</span> &#123;</span><br><span class="line">        point = <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">        <span class="built_in">this</span>.color = Objects.requireNonNull(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the point-view of this color point.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">asPoint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ColorPoint</span> <span class="variable">cp</span> <span class="operator">=</span> (ColorPoint) o;</span><br><span class="line">        <span class="keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * point.hashCode() + color.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　<code>equals</code>方法会怎么样呢？如果完全不提供<code>equals</code>方法，而是直接从<code>Point</code>继承过来，在<code>equals</code>做比较的时候颜色信息就被忽略掉了，虽然这样做不会违反<code>equals</code>约定，但是很明显这是无法接受的。假设你编写了一个<code>equals</code>方法，只有当它的参数是另一个有色点，并且具有同样的位置和颜色时，它才会返回<code>true</code>：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - violates symmetry!</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　这个方法的问题在于，你在比较普通点和有色点，以及相反的情形时，可能会得到不同的结果。前一种比较忽略了颜色信息，而后一种比较则总是返回<code>false</code>，因为参数的类型不正确。为了直观地说明问题所在，我们创建一个普通点和一个有色点！<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">ColorPoint</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br></pre></td></tr></table></figure><br>　　然后，<code>p.equals(cp)</code>返回<code>true</code>，<code>cp.equals(p)</code>则返回<code>false</code>。你可以做这样的尝试来修正这个问题，让<code>ColorPoint.equals</code>在进行“混合比较”时忽略颜色信息:<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - violates transitivity!</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// If o is a normal Point, do a color-blind comparison</span></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">        <span class="keyword">return</span> o.equals(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// o is a ColorPoint; do a full comparison</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　这种方法确实提供了对称性，但是却牺牲了传递性：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ColorPoint</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line"><span class="type">Point</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">ColorPoint</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</span><br></pre></td></tr></table></figure><br>　　此时，<code>p1.equalS(p2)</code>和<code>p2.equals(p3)</code>都返回<code>true</code>，但是<code>p1.equals(p3)</code>则返回<code>false</code>，很显然违反了传递性。前两种比较不考虑颜色信息（“色盲”），而第三种比较中则考虑了倾色信息。</p>
<p>　　怎么解决呢？事实上，这是面向对象语言中关于等价关系的一个基本问题。<strong>我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留<code>equals</code>约定</strong>，除非愿意放弃面向对象的抽象所带来的优势。</p>
<p>　　你可能听说，在<code>equals</code>方法中用<code>getClass</code>测试代替<code>instanceof</code>测试，可以扩展可实例化的类和增加新的值组件，同时保留<code>equals</code>约定：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - violates Liskov substitution principle (page 43)</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || o.getClass() != getClass())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">    <span class="keyword">return</span> p.x == x &amp;&amp; p.y == y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　这段程序只有当对象具有相同的实现时，才能使对象等同。虽然这样也不算太槽糕，但是结果却是无法接受的。假设我们要编写一个方法，以检验某个整值点是否处在单位圆中。下面是可以采用的其中一种方法，<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize unitCircle to contain all Points on the unit circle</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Point&gt; unitCircle = Set.of(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Point</span>( <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> <span class="title class_">Point</span>( <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Point</span>(-<span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> <span class="title class_">Point</span>( <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">onUnitCircle</span><span class="params">(Point p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unitCircle.contains(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　虽然这可能不是实现这种功能的最快方式，不过它的效果很好。但是假设你通过某种不添加值组件的方式扩展了<code>Point</code>，例如让它的构造器记录创建了多少个实例：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterPoint</span> <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CounterPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(x, y);</span><br><span class="line">        counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numberCreated</span><span class="params">()</span> &#123; <span class="keyword">return</span> counter.get(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　<strong>里氏替换原则（Liskov substitution principle）</strong> 认为，一个类型的任何重要属性也将适用于它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行得很好[Liskov87]。但是假设我们将<code>CounterPoint</code>实例传给了<code>onUnitCircle</code>方法。如果<code>Point</code>类使用了基于<code>getClass</code>的<code>equals</code>方法，无论<code>CounterPoint</code>实例的x和y值是什么，<code>onUnitCircle</code>方法都会返回<code>false</code>。之所以如此，是因为像<code>onUnitCircle</code>方法所用的<code>HashSet</code>这样的集合，利用<code>equals</code>方法检验包含条件，没有任何<code>CounterPoint</code>实例与任何<code>Point</code>对应。但是，如果在<code>Point</code>上使用适当的基于<code>instanceof</code>的<code>equals</code>方法，当遇到<code>Counterpoint</code>时，相同的<code>onUnitCircle</code>方法就会工作得很好。</p>
<p>　　虽然没有一种令人满意的办法可以既扩展不可实例化的类，又增加值组件，但还是有一种不错的权宜之计（<code>workaround</code>)。根据Item 18的建议：复合优先于继承。我们不再让<code>ColorPoint</code>扩展<code>Point</code>，而是在<code>ColorPoint</code>中加人一个私有的<code>Point</code>域，以及一个公有的视图(<code>view</code>)方法（Item 6），此方法返回一个与该有色点处在相同位置的普通<code>Point</code>对象：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adds a value component without violating the equals contract</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColorPoint</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Point point;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ColorPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, Color color)</span> &#123;</span><br><span class="line">        point = <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">        <span class="built_in">this</span>.color = Objects.requireNonNull(color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the point-view of this color point.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">asPoint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ColorPoint</span> <span class="variable">cp</span> <span class="operator">=</span> (ColorPoint) o;</span><br><span class="line">        <span class="keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　在Java平台类库中，有一些类扩展了可实例化的类，并添加了新的值组件。例如，<code>java.sql.Timestamp</code>对<code>java.util.Date</code>进行了扩展，并增加了<code>nanoseconds</code>域，<code>Timestamp</code>的<code>equals</code>实现确实违反了对称性，如果<code>Timestamp</code>和<code>Date</code>对象被用于同一个集合中，或者以其他方式被混合在一起，则会引起不正确的行为。<code>Timestamp</code>类有一个免责声明，告诫程序员不要混合使用<code>Date</code>和<code>Timestamp</code>对象。只要你不把它们混合在一起，就不会有麻烦，除此之外没有其他的措施可以防止你这么做，而且结果导致的错误将很难调试。<code>Timestamp</code>的这种行为是个错误，不值得仿效。</p>
<p>　　注意，你可以在一个抽象(<code>abstract</code>)类的子类中增加新的值组件，而不会违反<code>equals</code>约定。对于Item 23的建议“用类层次(<code>class hierarchies</code>)代替标签类(<code>tagged class</code>)”而得到的那种类层次结构来说，这一点非常重要。例如，你可能有一个抽象的<code>Shape</code>类，它没有任何值组件，<code>Circle</code>子类添加了一个<code>radiust</code>域，<code>Rectangle</code>子类添加了<code>length</code>和<code>width</code>域。只要不可能直接创建超类的实例，前面所述的种种问题就都不会发生。</p>
<ul>
<li><p>一致性(<code>consistency</code>)——<code>equals</code>约定的第四个要求是，如果两个对象相等，它们就必须始终保持相等，除非它们中有一个对象（或者两个都）被修改了。换句话说，可变对象在不同的时候可以与不同的对象相等，而不可变对象则不会这样。当你在写一个类的时候，应该仔细考虑它是否应该是不可变的（Item 17）。如果认为它应该是不可变的，就必须保证<code>equals</code>方法满足这样的限制条件：相等的对象永远相等，不相等的对象永远不相等。</p>
<p>  　　无论类是否是不可变的，都不要使<code>equals</code>方法依赖于不可靠的资源。如果违反了这条禁令，要想满足一致性的要求就十分困难了。例如，<code>java.net.URL</code>的<code>equals</code>方法依赖于对URL中主机IP地址的比较。将一个主机名转变成IP地址可能需要访问网络，随着时间的推移，不确保会产生相同的结果．这样会导致URL的<code>equals</code>方法违反<code>equals</code>约定，在实践中有可能引发一些问题。（遗憾的是，因为兼容性的要求，这一行为无法被改变。）除了极少数的例外情况，<code>equals</code>方法都应该对驻留在内存中的对象执行确定性的计算。</p>
</li>
<li><p>非空性(<code>Non-nullity</code>)——最后一个要求没有名称，我姑且称它为“非空性(<code>Non-nullity</code>)”，意思是指所有的对象都必须不等于<code>null</code>。尽管很难想像什么情况下<code>o.equals(null)</code>调用会意外地返回<code>true</code>，但是意外抛出<code>NullPointerException</code>异常的情形却不难想像。通用约定不允许抛出<code>NullPointerException</code>异常。许多类的<code>equals</code>方法都通过一个显式的null测试来防止这种情况:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    `<span class="keyword">if</span> (o == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  　　这项测试是不必要的。为了测试其参数的等同性，<code>equals</code>方法必须先把参数转换成适当的类型，以便可以调用它的访问方法(<code>accessor</code>),或者访问它的域。在进行转换之前，<code>equals</code>方法必须使用<code>instanceof</code>操作符，检查其参数是否为正确的类型：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> MyType))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">MyType</span> <span class="variable">mt</span> <span class="operator">=</span> (MyType) o;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  　　如果漏掉了这一步的类型检查，并且传递给<code>equals</code>方法的参数又是错误的类型，那么<code>equals</code>方法将会抛出<code>ClassCastException</code>异常，这就违反了<code>equals</code>的约定但是，如果<code>instanceof</code>的第一个操作数为<code>null</code>，那么，不管第二个操作数是哪种类型，<code>instanceof</code>操作符都指定应该返回<code>false</code>[JLS, 15.20.2]。因此，如果把<code>null</code>传给<code>equals</code>方法，类型检查就会返回<code>false</code>，所以不需要单独的<code>null</code>检查。</p>
</li>
</ul>
<p>　　结合所有这些要求，得出了以下实现高质量<code>equals</code>方法的诀窍：</p>
<p>　　1．<strong>使用&#x3D;&#x3D;操作符检查“参數是否为这个对象的引用”</strong>。如果是，则返回<code>true</code>。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。</p>
<p>　　2．<strong>使用<code>instanceof</code>操作符检查“参數是否为正确的类型”</strong>。如果不是、则返回<code>false</code>。一般说来，所谓“正确的类型”是指<code>equals</code>方法所在的那个类。有些情况下，是指该类所实现的某个接口。如果类实现的接口改进了<code>equals</code>约定，允许在实现了该接口的类之间进行比较，那么就使用接口。集合接口(<code>collection interface</code>)如<code>Set</code>、<code>List</code>、<code>Map</code>和<code>MapEntry</code>具有这样的特性。</p>
<p>　　3．<strong>把参数转换成正确的类型</strong>。因为转换之前进行过<code>instanceof</code>测试，所以确保会成功。</p>
<p>　　4．<strong>对于该类中的每个“关键(<code>significant</code>)”域，检查参数中的域是否与该对象中对应的域相匹配</strong>。如果这些测试全部成功，则返回否則返回<code>false</code>。如果第2步中的类型是个接口，就必须通过接口方法访问参数中的域，如果该类型是个类，也许就能够直接访问参数中的域，这要取决干它们的可访问性。</p>
<p>　　对于既不是<code>float</code>也不是<code>double</code>类型的基本类型域，可以使用&#x3D;&#x3D;操作符进行比较；对于对象引用域，可以递归地调用<code>equals</code>这方法；对于<code>float</code>域，可以使用<code>Float.compare</code>方法；对于<code>double</code>域，则使用<code>Double.compare</code>。对<code>float</code>和<code>double</code>域进行特殊的处理是有必要的，因为存在着<code>Float.NaN</code>、<code>-0.0f</code>及类似的<code>double</code>常量；详细信息请参考[JLS 15.21.1]或<code>Float.equals</code>的文档。对于数组域，则要把以上这些指导原则应用到每个元素上。如果数组域中的每个元素都很重要，就可以使用其中一个<code>Arrays.equals</code>方法。</p>
<p>　　有些对象引用域包含<code>null</code>可能是合法的，所以，为了避兔可能导致<code>NullPointerException</code>异常，则使用静态方法<code>Objects.equals(Object, Object)</code>来检查这样的域。</p>
<p>　　对干有些类，比如前面提到的<code>CaseInsensitiveString</code>类，域的比较要比简单的等同性测试复杂得多，如果是这种情况，可能会希望保存该域的一个“范式(<code>canonical form</code>)”，这样<code>equals</code>方法就可以根据这些范式进行低开销的精确比较，而不是高开销的非精确比较。这种方法对于不可变类（Item 17）是最为合适的；如果对象可能发生化，必须使其范式保持最新。</p>
<p>　　域的比较顺序可能会影响到<code>equals</code>方法的性能。为了获得最隹的性能，应该最先比较最有可能不一致的域，或者是开销最低的域，最理想的情况是两个条件同时满足的域，你不应该去比较那些不属于对象逻辑状态的域，例如用于同步操作的<code>Lock</code>域。也不需要比较冗余域(<code>redundant field</code>)，因为这些冗余域可以由“关键域”计算获得，但是这样做有可能提高<code>equals</code>方法的性能。如果冗余域代表了整个对象的综合描述，比较这个域可以节省当比较失败时去比较实际数据所需要的开销。例如，假设有一个<code>Polygon</code>类，并缓存了该区域。如果两个多边形有着不同的区域，就没有必要去比较它们的边和至高点。</p>
<p>　　5.<strong>当你编写完成了<code>equals</code>方法之后，应该问自己三个问题：它是否是对称的、传递的、一致的</strong>？并且不要只是自问，还要编写单元测试来检验这些特性！如果答案是否定的，就要找出原因，再相应地修改<code>equals</code>方法的代码。当然，<code>equals</code>方法也必须满足其他两个特性（自反性和非空性），但是这两种特性通常会自动满足。</p>
<p>　　下面是一个根据上面的诀窍构建的<code>equals</code>方法的具体例子，在一个简单的PhoneNumber类里面：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class with a typical equals method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">short</span> areaCode, prefix, lineNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhoneNumber</span><span class="params">(<span class="type">int</span> areaCode, <span class="type">int</span> prefix, <span class="type">int</span> lineNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.areaCode = rangeCheck(areaCode, <span class="number">999</span>, <span class="string">&quot;area code&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.prefix = rangeCheck(prefix, <span class="number">999</span>, <span class="string">&quot;prefix&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.lineNum = rangeCheck(lineNum, <span class="number">9999</span>, <span class="string">&quot;line num&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> max, String arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; <span class="number">0</span> || val &gt; max)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(arg + <span class="string">&quot;: &quot;</span> + val);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">short</span>) val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PhoneNumber))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">PhoneNumber</span> <span class="variable">pn</span> <span class="operator">=</span> (PhoneNumber) o;</span><br><span class="line">        <span class="keyword">return</span> pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix</span><br><span class="line">                &amp;&amp; pn.areaCode == areaCode;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　下面是最后的一些告诚:</p>
<ul>
<li><p>**覆盖<code>equals</code>时总要覆<code>hashCode</code>**（Item 9）。</p>
</li>
<li><p><strong>不要企图让<code>equals</code>方法过于智能</strong>。如果只是简单地测试域中的值是否相等，则不难做到遵守<code>equals</code>约定。如果想过度地去寻求各种等价关系，则很容易陷人麻烦之中。把任何一种别名形式考虑到等价的范围内，往往不会是个好主意。例如，<code>File</code>类不应该试图把指向同一个文件的符号链接(<code>symbolic link</code>)当作相等的对象来看待。所幸<code>File</code>类没有这样做。</p>
</li>
<li><p><strong>不要将<code>equals</code>声明中的<code>Object</code>对象替换为其他的类型</strong>。程序员编写出下面这样的<code>equals</code>方法并不鲜见，这会使程序员花上数个小时都搞不清为什么它不能正常工作：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - parameter type must be Object!</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(MyClass o)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  　　问题在于，这个方法并没有覆盖<code>Object.equals</code>，因为它的参数应该是<code>Object</code>类型，相反，它重载(<code>overload</code>)了<code>Object.equals</code>（Item 52）。在原有<code>equals</code>方法的基础上，再提供一个“强类型(<code>strongly typed</code>)”的<code>equals</code>方法，即使这两个方法返回同样的结果（没有强制的理由必须这样做），这也是不可以接受的。因为它能导致<code>@Override</code>注解在子类生成误报并提供错误的安全感。</p>
<p>  　　<code>@Override</code>注解的用法一致，就如本条目中所示，可以防止犯这种错误（Item 40）。这个<code>equals</code>方法不能编译，错误消息会告诉你到底哪里出了问题：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Still broken, but won’t compile</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(MyClass o)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  　　编写和测试<code>equals</code>（和<code>hashCode</code>）方法很繁琐，结果代码很平常。手动编写和测试这些方法的一个很好的替代方法是使用Google的开源<code>AutoValue</code>框架，该框架会自动为您生成这些方法，由类中的单个注释触发。在大多数情况下，<code>AutoValue</code>生成的方法与您自己编写的方法基本相同。</p>
<p>  　　IDE也有生成<code>equals</code>和<code>hashCode</code>方法的工具，但生成的源代码比使用<code>AutoValue</code>的代码更冗长，更不易读，不会自动跟踪类中的更改，因此需要测试。也就是说，让IDE生成<code>equals</code>（和<code>hashCode</code>）方法通常比手动实现它们更可取，因为IDE不会造成粗心的错误，大多数人也会这样做。</p>
<p>  　　总之，不要覆盖<code>equals</code>方法，除非你必须：在许多情况下，从<code>Object</code>继承的实现完全符合您的要求。如果你确实覆盖了<code>equals</code>，请确保比较所有类的重要字段，并以保留<code>equals</code>约定的所有五个条款的方式对它们进行比较。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 3</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item2 当遇到许多构造方法参数时，考虑构建器</title>
    <url>/2018/12/06/Effective-Java-Item2-%E5%BD%93%E9%81%87%E5%88%B0%E8%AE%B8%E5%A4%9A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%97%B6%EF%BC%8C%E8%80%83%E8%99%91%E6%9E%84%E5%BB%BA%E5%99%A8/</url>
    <content><![CDATA[<p>静态工厂和构造函数有一个共同的限制:它们不能很好地扩展到大量可选参数。考虑一个代表包装食品上出现的营养成分标签的类的例子。这些标签有一些必要的字段，如分量大小、每瓶容量以及每份的卡路里里数，以及超过20个可选的字段——总脂肪，饱和脂肪，反式脂肪，胆固醇，钠，等等。大多数产品只有少数几个可选字段的值为非零值。</p>
<span id="more"></span>

<p>对于这样一个类来说，你应该编写哪种构造方法或是静态工厂呢？传统上，程序员们会使用重叠构造方法模式，在这种模式中，您只提供了一个只有必需参数的构造函数，然后编写一个接收单个可选参数的构造方法，再编写一个接收两个可选参数的构造方法，以此类推，最后提供一个接收所有可选参数的构造方法。如下代码示例例就说明了了这一点。出于简洁的目的，这里只给出了4个可选字段：</p>
<figure class="highlight java"><figcaption><span>NutritionFacts.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Telescoping constructor pattern - does not scale well!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize; <span class="comment">// (mL) required</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings; <span class="comment">// (per container) required</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories; <span class="comment">// (per serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat; <span class="comment">// (g/serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium; <span class="comment">// (mg/serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate; <span class="comment">// (g/serving) optional</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> calories)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, calories, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> calories, <span class="type">int</span> fat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, calories, fat, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> calories, <span class="type">int</span> fat, <span class="type">int</span> sodium)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(servingSize, servings, calories, fat, sodium, <span class="number">0</span>);</span><br><span class="line">    &#125;                                                            </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> calories, <span class="type">int</span> fat, <span class="type">int</span> sodium, <span class="type">int</span> carbohydrate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.servingSize = servingSize;</span><br><span class="line">        <span class="built_in">this</span>.servings = servings;</span><br><span class="line">        <span class="built_in">this</span>.calories = calories;</span><br><span class="line">        <span class="built_in">this</span>.fat = fat;</span><br><span class="line">        <span class="built_in">this</span>.sodium = sodium;</span><br><span class="line">        <span class="built_in">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当您想要创建一个实例时，您可以使用包含您想要设置的所有参数的最短参数列表的构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NutritionFacts</span> <span class="variable">cocaCola</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>(<span class="number">240</span>, <span class="number">8</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">35</span>, <span class="number">27</span>);</span><br></pre></td></tr></table></figure>

<p>通常，这个构造函数调用需要许多您不想设置的参数，但是您必须为它们传递一个值。在本例中，我们传递了一个值为0的<code>fat</code>。“只有”6个参数可能看起来不那么糟糕，但是随着参数数量的增加，很快你就数不过来了。</p>
<p><strong>简而言之，构造函数模式是有效的，但是当有许多参数时，客户端的代码很难写，而且可读性更差</strong>。读者不知道这些值是什么意思，必须仔细地计算参数的个数来找出答案。长长的同类型参数序列会导致非常隐秘的Bug。。如果客户端不小心将两个这样的参数位置颠倒，编译器是不会报错的，但是程序在运行时将会出错(Item 51)。</p>
<p>当你遇到一个构造函数中有许多可选参数时，第二个替代方法是<strong>JavaBeans</strong>模式，在这个模式中，你调用一个无参数的构造函数来创建对象，然后调用<strong>setter</strong>方法来设置每个必需的参数和每个可选的参数:</p>
<figure class="highlight java"><figcaption><span>NutritionFacts.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaBeans Pattern - allows inconsistency, mandates mutability</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="comment">// Parameters initialized to default values (if any)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">servingSize</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// Required; no default value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">servings</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// Required; no default value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">calories</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fat</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sodium</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">carbohydrate</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// Setters</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServingSize</span><span class="params">(<span class="type">int</span> val)</span> &#123; servingSize = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServings</span><span class="params">(<span class="type">int</span> val)</span> &#123; servings = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCalories</span><span class="params">(<span class="type">int</span> val)</span> &#123; calories = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFat</span><span class="params">(<span class="type">int</span> val)</span> &#123; fat = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSodium</span><span class="params">(<span class="type">int</span> val)</span> &#123; sodium = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCarbohydrate</span><span class="params">(<span class="type">int</span> val)</span> &#123; carbohydrate = val; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模式没有重叠构造函数模式的缺点。通过这种方式可以轻松创建实例例（就是稍微有点冗长），并且代码读起来也比较容易：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NutritionFacts</span> <span class="variable">cocaCola</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>();</span><br><span class="line">cocaCola.setServingSize(<span class="number">240</span>);</span><br><span class="line">cocaCola.setServings(<span class="number">8</span>);</span><br><span class="line">cocaCola.setCalories(<span class="number">100</span>);</span><br><span class="line">cocaCola.setSodium(<span class="number">35</span>);</span><br><span class="line">cocaCola.setCarbohydrate(<span class="number">27</span>);</span><br></pre></td></tr></table></figure>

<p>不幸的是，JavaBeans模式本身有严重的缺点。由于构造方法在多个调用中被拆分，所以JavaBean可能在其构建过程中处于不一致的状态。仅仅通过检查构造函数参数的有效性，该类没法实现一致性。在不一致的状态下尝试使用对象可能会导致与包含bug的代码相去甚远的错误，因此很难进行调试。与此相关的一个缺点是，JavaBeans模式排除了使类不可变的可能性(见Item 17)，并要求程序员为确保线程安全而增加工作。</p>
<p>当构造完毕时，我们可以通过手工『冻结』对象并且直到冻结后才允许使用对象来消除这些缺陷，不过这种做法很少使用。此外，这么做会导致运行期错误，因为编译器无法确保程序员在使用对象前会调用对象的冻结方法。</p>
<p>幸运的是，还有第三种选择，它将伸缩构造函数模式的安全性与JavaBeans模式的可读性相结合。它就是构建器模式的形式。客户端调用一个构造方法（或是静态工厂），并附上它需要的参数来获得一个构建器对象，来代替直接创造所需的目标对象。然后客户端调用构建起对象上的类似setter的方法去设置每一个感兴趣的可选的参数。最后，客户端调用无参的build方法去生成目标对象，通常它是不可变的。一般来说，这个构建器类是它构建的类的静态成员类。在实践中它通常看起来就是下面的样子：</p>
<figure class="highlight java"><figcaption><span>NutritionFacts.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Builder Pattern</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="comment">// Required parameters</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">        <span class="comment">// Optional parameters - initialized to default values</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">calories</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fat</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sodium</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">carbohydrate</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="built_in">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">calories</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">        &#123; calories = val; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">fat</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">        &#123; fat = val; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">sodium</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">        &#123; sodium = val; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">carbohydrate</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">        &#123; carbohydrate = val; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> NutritionFacts <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NutritionFacts</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        servingSize = builder.servingSize;</span><br><span class="line">        servings = builder.servings;</span><br><span class="line">        calories = builder.calories;</span><br><span class="line">        fat = builder.fat;</span><br><span class="line">        sodium = builder.sodium;</span><br><span class="line">        carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NutritionFacts</code>类是不可变的，所有参数默认值都在一个位置。构建器的<code>setter</code>方法返回构建器本身，这样调用就可以链接起来，形成一种流式API 。客户端代码是这样的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NutritionFacts</span> <span class="variable">cocaCola</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>.Builder(<span class="number">240</span>, <span class="number">8</span>)</span><br><span class="line">                            .calories(<span class="number">100</span>)</span><br><span class="line">                            .sodium(<span class="number">35</span>)</span><br><span class="line">                            .carbohydrate(<span class="number">27</span>)</span><br><span class="line">                            .build();</span><br></pre></td></tr></table></figure>

<p>该客户端代码易于编写，更重要的是易于阅读。构建器模式模拟了在Python和Scala中找到的命名可选参数。</p>
<p>为简便起见，省略了有效性检查。要检查构建器的构造函数和方法中的参数有效性，为了尽快检查出无效参数。检查<code>build</code>方法调用的构造函数中涉及多个参数的不变量。要确保这些不变量没被篡改，请在复制构造器参数(Item 50)之后对对象字段进行检查。如果检查失败，会抛出一个<code>IllegalArgumentException</code>（Item 72），它的详细消息会指示出哪些参数无效(Item 75)。</p>
<p>构建器模式非常适合类的层次结构。使用并行的构建器层次结构，每个构建器嵌套在相应的类中。抽象类有抽象的构建器;具体类有具体的构建器。例如，将一个抽象类当做代表了不同种类披萨的层次结构的根类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Builder pattern for class hierarchies</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Topping</span> &#123; HAM, MUSHROOM, ONION, PEPPER, SAUSAGE &#125;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;Topping&gt; toppings;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Builder</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">addTopping</span><span class="params">(Topping topping)</span> &#123;</span><br><span class="line">            toppings.add(Objects.requireNonNull(topping));</span><br><span class="line">            <span class="keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">abstract</span> Pizza <span class="title function_">build</span><span class="params">()</span>;</span><br><span class="line">        <span class="comment">// Subclasses must override this method to return &quot;this&quot;</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">self</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pizza(Builder&lt;?&gt; builder) &#123;</span><br><span class="line">        toppings = builder.toppings.clone(); <span class="comment">// See Item 50</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>Pizza.Builder</code>是个泛型类型，它有一个递归的类型参数（Item 30）。通过该参数以及抽象的<code>self</code>方法可以让方法在子类中恰当地链接起来，而无需进行类型转换。这种对于Java缺乏自我类型问题的解决方案叫做模拟的自我类型。</p>
<p>这里有两个具体的披萨子类，一个是标准的纽约风格披萨，另一个是奶酪馅饼式披萨。前者有一个必填的<code>size</code>参数 ，而后者可以让你指定酱汁是在里面还是在外面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NyPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span> &#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span>.Builder&lt;Builder&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(Size size)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.size = Objects.requireNonNull(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="keyword">public</span> NyPizza <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NyPizza</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="keyword">protected</span> Builder <span class="title function_">self</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NyPizza</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(builder);</span><br><span class="line">        size = builder.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calzone</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> sauceInside;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span>.Builder&lt;Builder&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">sauceInside</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Default</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">sauceInside</span><span class="params">()</span> &#123;</span><br><span class="line">            sauceInside = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Calzone <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Calzone</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Builder <span class="title function_">self</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Calzone</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(builder);</span><br><span class="line">        sauceInside = builder.sauceInside;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意每个子类的<code>builder</code>的<code>build()</code>方法都被声明成返回一个具类： <code>NyPizza.Builder</code>的<code>build</code>方法返回<code>NyPizza</code>类，而<code>Calzone.Builder</code>的<code>build</code>方法返回<code>Calzone</code>类，这种子类方法返回父类中声明的返回类型的子类型的技术，称为协变返回类型 。它允许客户端使用这些构建器，而不需要强制转换。</p>
<p>这些“层次化的构建器”的客户端代码本质上等价于简单的<code>NutritionFacts</code>的构建器的代码。如下的示例客户端代码假设已经静态导入了枚举常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NyPizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NyPizza</span>.Builder(SMALL)</span><br><span class="line">                    .addTopping(SAUSAGE)</span><br><span class="line">                    .addTopping(ONION)</span><br><span class="line">                    .build();</span><br><span class="line"><span class="type">Calzone</span> <span class="variable">calzone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calzone</span>.Builder()</span><br><span class="line">                    .addTopping(HAM)</span><br><span class="line">                    .sauceInside()</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure>

<p>与构造函数相比，构建器的一个小小的优势是，构建器可以有多个可变的参数，因为每个参数都在自己的方法中指定。或者，构建器可以把多次调用所需要的参数聚合到一个方法里的一个单一字段上，正如前面<code>addTopping</code>方法所展示的那样。</p>
<p>构建器模式非常灵活。一个构建器可以重复使用建立多个对象。构建器的参数可以在调用构建方法时进行调整，以改变创建的对象。构建器可以在对象创建时自动填充一些字段，比如说每次创建一个对象时递增的序列号等。</p>
<p>构建器模式也有缺点。为了能创建一个对象，你必须先创建它的构建器。虽然创建这个构建器的成本在实践中不太可能被注意到，但是在对性能要求很高的场景下这可能是个问题。此外，构建器模式比可伸缩构造器模式更加冗长，因此，只有当有足够多的参数时，使用它才有价值，比如4个以上的参数时。但如果一开始使用的是构造方法或是静态工厂，当参数量变得很多时，想要切换到构建器，那么显而易见，会遗留很多废弃的构造方法或是静态工厂。因此，更好的做法则是一开始就使用构建器器。</p>
<p>总之，在设计类时，如果类的构造方法或是静态工厂有很多参数，那么构建器模式是一个很好的选择，特别是如果许多参数是可选的或类型相同的情况下更是如此。 与重叠构造函数相比，使用构建器模式的客户端代码更容易读写，而且构建器比JavaBeans要安全得多。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item0 引言</title>
    <url>/2018/12/06/Effective-Java-Item0-%E5%BC%95%E8%A8%80/</url>
    <content><![CDATA[<p>这本书的目的是帮助你高效地使用java这门编程语言和它的基本类库：java.lang ,  java.util, and java.io<br>和这些包子包下的：java.util.concurrent 和java.util.function 。其它的类库也会时不时地被讨论到。</p>
<p>这本书有90个小项，每一项都表达了一个准则。这些准则是由那些最优秀、最有经验的程序员总结出来的最佳实践。<br>这些小项松散地被分到11个章节下面，每个章节都涵盖了软件设计的一个广泛的方面。这本书不需要一页一页地读，每一项都是独立的，正正好好。<br>这些项目被大量交叉引用，因此您可以轻松地在书中计划自己的课程。</p>
<span id="more"></span>

<p>自从这本书第二版出版后，Java平台又增添了很多新特性。这本书大部分都或多或少地用到了这些特性。这张表向您展示了主要覆盖了的关键特性:</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>所在条目</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Lambdas</td>
<td>第42~44条</td>
<td>Java8</td>
</tr>
<tr>
<td>Streams</td>
<td>第45~48条</td>
<td>Java8</td>
</tr>
<tr>
<td>Optionals</td>
<td>第55条</td>
<td>Java8</td>
</tr>
<tr>
<td>Default methods in interfaces</td>
<td>第21条</td>
<td>Java8</td>
</tr>
<tr>
<td>try -with-resources</td>
<td>第9条</td>
<td>Java7</td>
</tr>
<tr>
<td>@SafeVarargs</td>
<td>第32条</td>
<td>Java7</td>
</tr>
<tr>
<td>Modules</td>
<td>第15条</td>
<td>Java9</td>
</tr>
</tbody></table>
<p>大多数项目都用程序示例进行说明的。<br>这本书的一个重要特点是它通过一些代码示例，来阐明许多设计模式和习惯用法。<br>在适当的情况下，它们被交叉引用到这个领域的标准参考工作[Gamma95]。</p>
<p>很多项目都包含了一个或多个程序示例，来说明有些行为是可以避免的。<br>这种例子，被称为反例，然后被清楚地加上了注释，如“Never do this!”。<br>在每种情况下，该项目解释了为什么这个例子不好，并提出了另一种方法。</p>
<p>这本书不适合初学者:它假定您已经熟悉Java。<br>因为effective java是为那些有这门语言工作经验的人阅读的，所以它应该给那些高级开发人员提供更高级的使用。</p>
<p>这本书中的大部分规则都源于一些基本原则。简单明了就是是很重要的原则之一。组件的使用者不会对它的行为感到惊讶。<br>组件应该尽可能地小，但又不能太小。（就像这本书中提到的，这里的术语“组件”是指可重用的软件元素，即从一个独立的方法到一个由多个模块组成的复杂的框架，<br>都可以被称为“组件”）。<br>代码应该能重复使用而不是到处复制。组建之间的依赖应该保持低耦合。代码在完成之后错误应该尽快被检测出来，最好是在编译时期。</p>
<p>虽然这本书中的规则并不是100%的适用，但在绝大多数情况下它们确实都是最佳的编程实践。<br>你不应该盲目地遵循这些规则，如果有充分的理由，你也可以不遵循这些规则。<br>学习编程的艺术，就跟其它大多数学科一样，先要学习规则，然后要知道什么时候去打破规则。</p>
<p>大部分情况下，这本书并没有涉及性能方面。它指导我们如何写出清晰的，正确的，可重用的，健壮的，可维护的代码。如果你能做到这点，那么提升你想要的性能就是一件相对简单的事情了(Item 67)。<br>有些项目确实讨论了所关心的性能问题，有些项目还给出了有关性能的数据。这些数据在被介绍时，都提前说明是在“我的机器上”。这种描述是被认为最恰当的。</p>
<p>当讨论Java编程语言的特性和它的类库时，有时候需要引用特定版本。为了方便起见，这本书用别名来指定官方版本名。<br>下面的表展示了官方版本名和别名之间的映射关系。</p>
<table>
<thead>
<tr>
<th>官方版本名</th>
<th>别名</th>
</tr>
</thead>
<tbody><tr>
<td>JDK 1.0.x</td>
<td>Java 1.0</td>
</tr>
<tr>
<td>JDK 1.1.x</td>
<td>Java 1.1</td>
</tr>
<tr>
<td>Java 2 Platform, Standard Edition, v1.2</td>
<td>Java 2</td>
</tr>
<tr>
<td>Java 2 Platform, Standard Edition, v1.3</td>
<td>Java 3</td>
</tr>
<tr>
<td>Java 2 Platform, Standard Edition, v1.4</td>
<td>Java 4</td>
</tr>
<tr>
<td>Java 2 Platform, Standard Edition, v5.0</td>
<td>Java 5</td>
</tr>
<tr>
<td>Java Platform, Standard Edition 6</td>
<td>Java 6</td>
</tr>
<tr>
<td>Java Platform, Standard Edition 7</td>
<td>Java 7</td>
</tr>
<tr>
<td>Java Platform, Standard Edition 8</td>
<td>Java 8</td>
</tr>
<tr>
<td>Java Platform, Standard Edition 9</td>
<td>Java 9</td>
</tr>
</tbody></table>
<p>书中的例子都已经相当完整了，但是比完整性跟重要的是可读性。程序员们大量地使用java.util和java.io包下的类。为了成功编译书中的示例，您可能需要添加一个或多个导入声明，或其他这样的样板文件。<br>这本书的网址上<a href="http://joshbloch.com/effectivejava">Effective Java</a>，包含了每个示例的一个完整版本，你可以下载下来编译并运行它。</p>
<p>大多数情况下，这本书里用到的技术术语都在Java SE 8这个版本的Java语言规范中定义的。其中有一些术语特别值得提出来。比如说，Java支持四种类型:接口(包括注解)、类(包括枚举)、数组和原生类型。前三种被称为引用类型。类的实例化和数组叫做对象，<br>而原生类型的值不是对象。类的成员包括它的字段、方法、成员类和成员接口。方法的签名包括它的名字和形参的类型；签名不包括方法的返回类型。</p>
<p>本书使用了一些与Java语言规范不同的术语。与Java语言规范不同，本书使用继承作为子类化的同义词。与使用术语继承来实现接口不同，这本书简单地说明了一个类实现了一个接口，或者一个接口继承了另一个接口。本书使用了传统的包私有的（package-private）访问级别，<br>而不是技术上正确的包访问（package access），来描述没有指定的访问级别。</p>
<p>这本书用到了一些《Java语言规范》没有定义的技术术语。API暴露出的术语(简称API)指程序员访问类、接口或包里面的的类、接口、构造函数、成员和序列化形式。术语API是application programming interface的简称，它更倾向于使用其他更好的术语接口，<br>以避免与该名称的语言结构混淆。编写使用API的程序的程序员被称为API的用户。通过API来实现的类叫做API的客户端。</p>
<p>类、接口、构造函数、成员和序列化形式统称为API元素。<br>一个暴露出来的API是由可以在定义该API的包外访问到的API元素组成。这些API元素可以给任意客户端使用，并且API的作者提供支持。不凑巧的是，它们也是Javadoc实用程序在其默认的操作模式中生成文档的元素。宽泛地说，一个包的对外API由公共和受保护的成员和包中的每个公共类或接口的构造函数组成。<br>在Java9中，模块系统被添加到平台里。如果一个库使用了模块系统，它对外的API是该模块系统声明对外包下的对外API的联和。<br>最后，提供一下<a href="https://github.com/jbloch/effective-java-3e-source-code">Effective Java源码</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 1</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item6 避免创建不必要的对象</title>
    <url>/2018/12/07/Effective-Java-Item6-%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>在需要一个对象时，恰当的做法是尽可能重用这个对象而非创建一个功能完全一样的新对象。重用既比较快又比较流行。如果一个对象是不可变的(Item 17)，那么它总是可以被重用的。</p>
<span id="more"></span>

<p>作为一个绝对不要这么做的极端示例，考虑如下语句：	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;bikini&quot;</span>); <span class="comment">// DON&#x27;T DO THIS!</span></span><br></pre></td></tr></table></figure>

<p>这个语句在每次执行时都会创建一个新的字符串实例，而这些对象创建其实都是不必要的。<code>String</code>构造方法的参数(“<code>bikini</code>“)本身就是个<code>String</code>实例，与构造函数创建的所有对象功能相同。如果这种用法出现在一个循环语句中或一个被频繁调用的方法中，那么可能会创建百万个没必要的<code>String</code>实例。</p>
<p>改进后的版本简单如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;bikini&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这个版本使用单个的字符串实例，而不是每次执行时创建一个新的。此外，它还确保了运行在同一个虚拟机中并且包含了相同字符串字面值的其他代码能够重用该对象 。如果不变类既提供了静态工厂方法（Item 1），也提供了构造方法，那么你就可以通过前者来避免创建不必要的对象。例如，工厂方法<code>Boolean.valueOf(String)</code>比构造函数<code>Boolean(String)</code>更可取，后者在Java 9中已经被弃用。每一次调用构造方法，一定会创建一个新的对象，然而工厂方法完全没必要这么做，而且实践当中也不会这么做。除了重用不可变对象之外，如果你知道不会修改这个可变对象，那么你也可以重用这个可变对象。</p>
<p>有些对象创建要比其他对象昂贵得多。如果你以后会反复需要这样一个“昂贵的对象”，那么最好将其缓存以供重用。不幸的是，在创建这样的对象时，并不总是显而易见的。假设你想写一个方法来确定字符串是否是有效的罗马数字。这里有个最简单的方法就是，使用正则表达式来做这件事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Performance can be greatly improved!</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRomanNumeral</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span></span><br><span class="line">            + <span class="string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现的问题在于它依赖于<code>String.matches</code>方法。<strong>虽然<code>String.matches</code>是检查一个字符串是否匹配这个正则表达式最简单的方法，但是在性能要求苛刻的场景下，他并不适合重复使用</strong>。这样做的问题是，它会在内部为正则表达式创建一个<code>Pattern</code>实例，并且仅仅使用它一次，之后它就可以进行垃圾收集了。创建一个<code>Pattern</code>实例非常昂贵，因为它需要将正则表达式编译成一个有限状态机。</p>
<p>为了改进性能，请在类的初始化过程中手动将正则表达式编译为<code>Pattern</code>实例（它是不可变的），然后将其缓存起来，并在每次调用<code>isRomanNumeral</code>方法时重用这个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reusing expensive object for improved performance</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RomanNumerals</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">ROMAN</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span></span><br><span class="line">    		+ <span class="string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRomanNumeral</span><span class="params">(String s)</span> &#123;</span><br><span class="line">   	 	<span class="keyword">return</span> ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进版本的<code>isRomanNumeral</code>在频繁调用的情况下极大提升了性能 。在我的机器上，当输入长度为8的字符串时，第一版的方法执行了1.1微秒，而改进版的方法执行了0.17微秒，比原来快了6.5倍。不仅性能得到了改善，而且可以认为代码也变得更清晰了。使用一个静态<code>final</code>字段来表示原本不可见的Pattern的实例，这样允许我们给这个字段取个名字，这样做比正则表达式本身可读性高多了。</p>
<p>如果包含改进版的<code>isRomanNumeral</code>方法的类被初始化了，但是没有主动调用这个方法，那么字段<code>ROMAN</code>依然会被没必要地初始化。当第一次调用<code>isRomanNumeral</code>方法时，我们可以通过惰性初始化字段的方法来消除上面的没必要地初始化。但是不推荐这样做。因为对于延迟初始化来说，它常常会导致实现变得复杂，并且不能带来很大的性能提升。当一个对象是不可变的时，很明显它可以安全地被重用，但是在其他情况下，它就不那么明显了，甚至是违反直觉的。考虑适配器的情况，也称为视图。所谓适配器，指的是委托给支撑对象的对象，并提供了另外的接口。由于适配器除了支撑对象的状态外，它自身是没有状态的，因此对于给定的对象来说，没必要为其创建多个适配器实例 。</p>
<p>例如，<code>Map</code>接口的<code>keySet</code>方法返回<code>Map</code>对象的<code>Set</code>视图，其中包含映射中的所有键。直觉上，似乎每个对<code>keySet</code>的调用都必须创建一个新的<code>Set</code>实例，不过实际情况却是，每次调用给定<code>Map</code>对象的<code>keySet</code>都只会返回同一个<code>Set</code>实例 。虽然返回的Set实例通常是可变的，但所有返回的对象在功能上是相同的: 当其中一个返回的对象发生更改时，其他的对象也会发生变化，因为它们都是由同一个<code>Map</code>实例支持的。虽然创建<code>keySet</code>视图对象的多个实例基本上是无害的，但它是不必要的，没有任何好处。</p>
<p>另一种创建不必要对象的方法是自动装箱 ，它允许程序员把原生类型和原生类型的包装类混合用，并且会根据需要自动地拆箱和装箱。<strong>自动装箱使原生类型和包装类之间界限变得模糊，但是并没有消除原生类型和原生类型的包装类之间的区别</strong>。这里存在一些微小的语义上的差别以及稍微有点大的性能上的差别（Item 61)。考虑如下方法，它会计算所有正整型int值的和。为了做到这一点，程序需要使用<code>long</code>运算，因为<code>int</code>不足以容纳所有正整型<code>int</code>值的和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hideously slow! Can you spot the object creation?</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">    	sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序会得到正确的答案，不过要比预计慢很多，原因在于一个字符拼写上的错误 。变量sum被声明为Long型而不是long型，这就意味着这个程序要构造2^31个不必要的<code>Long</code>实例（大概每一次<code>long</code>型<code>i</code>与<code>Long</code>类型的<code>sum</code>相加都会创建一个实例）。在我的机器上，将<code>sum</code>声明由<code>Long</code>改为<code>long</code>则会将运行时间由6.3s减少到0.59s。这个例子很清楚：<strong>相对包装类型，优先使用原生类型，并且注意无意识地自动装箱</strong>。</p>
<p>不应该误解该条款，以为对象创建是非常昂贵的，应该避免。相反地，小对象的创建和回收是廉价的，因为他们的构造函数没有做什么明显的工作，特别是在现代JVM实现中 。创建额外的对象来增强程序的清晰度、简单性或程序的能力通常是一件好事。相反，除非池中的对象非常重量级，否则通过维护自己的对象池来避免对象创建是一个坏主意。真正需要对象池的对象的一个典型示例就是数据库连接。建立连接的成本非常高，因此重用这些对象是有意义的。然而，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代JVM实现具有高度优化的垃圾收集器，它们在轻量级对象上轻松胜过此类对象池。 </p>
<p>与本条款对应的是关于<strong>防御式拷贝</strong>的Item 50。当前的条款说，“当应该重用一个已经存在的对象时，就不应该创建新的对象”。然而，第50条说，“当您应该创建一个新的对象时，不要重用现有的对象。”注意，在需要进行防御性复制时重用对象的惩罚远远大于不必要地创建重复对象的惩罚。如果不能在需要的地方创建防御复制，可能会导致潜在的bug和安全漏洞;而不必要地创建对象只会影响样式和性能。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item5 优先使用依赖注入而非硬编码资源的关联关系</title>
    <url>/2018/12/07/Effective-Java-Item5-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%80%8C%E9%9D%9E%E7%A1%AC%E7%BC%96%E7%A0%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>很多类都会依赖于一个或多个底层资源。比如说，拼写检查器会依赖于字典。我们常常会看<br>到这种类被实现为了静态辅助类（Item 4）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inappropriate use of static utility - inflexible &amp; untestable!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpellChecker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lexicon</span> <span class="variable">dictionary</span> <span class="operator">=</span> ...;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SpellChecker</span><span class="params">()</span> &#123;&#125; <span class="comment">// Noninstantiable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String word)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">suggestions</span><span class="params">(String typo)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>同样地，将他们以单例的形式来实现也很常见(Item 3)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inappropriate use of singleton - inflexible &amp; untestable!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpellChecker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lexicon</span> <span class="variable">dictionary</span> <span class="operator">=</span> ...;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SpellChecker</span><span class="params">(...)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpellChecker</span>(...);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String word)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">suggestions</span><span class="params">(String typo)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方法都不令人满意，因为它们假定只有一个字典值得使用。实际上，每种语言都有自己的字典，特殊的字典用于特殊的词汇表。此外，我们还需要一个特殊的字典用于测试。想当然地认为一本字典就足够了，这是一厢情愿的想法。</p>
<p>你可以尝试让<strong>拼写检查器</strong>支持多个字典，方法是使<code>dictionary</code>字段成为非<code>final</code>类型，并在现有的拼写检查器中添加一个方法来更改<code>dictionary</code>的引用，不过这么做有些笨拙、易出错，并且在并发设置下无法正常工作。<strong>如果一个类的行为是通过底层资源来参数化的，那么静态辅助类与单例就不适合这种情况</strong>。</p>
<p>我们所需要的是支持类的多个实例的能力(在我们的例子中，<code>SpellChecker</code>)，每个实例都使用客户机所希望的资源(在我们的例子中，是字典)。满足此需求的一个简单模式是在<strong>创建新实例时将资源传递给它的构造函数</strong>。这是依赖注入的一种形式：字典是拼写检查器器的依赖，在创建拼写检查器时会将字典注入到其中 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dependency injection provides flexibility and testability</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpellChecker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lexicon dictionary;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SpellChecker</span><span class="params">(Lexicon dictionary)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.dictionary = Objects.requireNonNull(dictionary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String word)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">suggestions</span><span class="params">(String typo)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依赖注入模式如此简单，以至于许多程序员使用了多年，却不知道它的名字。 虽然我们的拼写检查的示例只有一个资源(字典)，但是依赖项注入可以处理任意数量的资源和任意依赖图。它保持了不可变性(Item 17)，因此多个客户机可以共享依赖对象(假设客户机需要相同的底层资源)。依赖项注入同样适用于构造函数、静态工厂(Item 1)和构建器(Item 2)。</p>
<p>这个模式的有一个有用的变换是将资源工厂传递给构造函数。工厂是一个对象，可以反复调用它来创建同一类型的实例。这些工厂体现了一种设计模式，即<strong>工厂方法模式</strong>。Java 8中引入的<code>Supplier&lt;T&gt;</code>接口非常适合表示工厂。将<code>Supplier&lt;T&gt;</code>作为输入的方法会通过绑定的<strong>通配符类型</strong>（item 31）来限制工厂的类型参数。比如说，如下方法会通过客户端提供的用于生成每个瓷砖的工厂来创建一个马赛克：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mosaic <span class="title function_">create</span><span class="params">(Supplier&lt;? extends Tile&gt; tileFactory)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>尽管依赖注入极大地提高了灵活性和可测试性，但它可能会使大型项目变得混乱，而大型项目通常包含数千个依赖项。如果我们使用依赖注入框架(如Dagger [Dagger]、Guice [Guice]或Spring [Spring])，几乎可以消除这种混乱。这些框架的使用介绍超出了本书的范围，不过请注意，针对手工进行依赖管理所设计的APIs也是适合于这些框架的 。</p>
<p>总结一下，如果一个类依赖于一个或多个底层资源，而这些资源的行为会影响到类的行为，那么请不要使用单例或是静态辅助类来实现，也不要让类直接创建这些资源。替代的方法是，将该资源或生产这个资源的工厂传递给构造方法(或者是静态工厂或者是构建器)。这种实践叫做依赖注入，它会极大增强类的灵活性、重用性与可测试性。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item7 消除废弃的对象引用</title>
    <url>/2018/12/07/Effective-Java-Item7-%E6%B6%88%E9%99%A4%E5%BA%9F%E5%BC%83%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>如果您从使用手动管理内存的语言(如C或c++)切换到使用垃圾收集语言(如Java)，那么你作为程序员的工作就会变得容易得多，因为你的对象在使用完后会自动被回收。 当你第一次体验这种编程的时候，它看起来就像是魔术一般。它很容易给人留下这样的印象：你不必考虑内存管理，但这并不完全正确。 </p>
<span id="more"></span>

<p>思考下面这个简单的堆栈实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Can you spot the &quot;memory leak&quot;?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;</span><br><span class="line">   		elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Ensure space for at least one more element, roughly</span></span><br><span class="line"><span class="comment">    * doubling the capacity each time the array needs to grow.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">        	elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序并没有明显的错误（不过请查看Item 29来了解更加通用的版本）。你可以不断测试该程序，程序也会顺利通过每个测试，不过有一个潜伏的问题。大致来说，该程序存在一处『内存泄露』，其性能会逐步降低，这是因为不断增加的垃圾收集器活动与内存占用问题。在极端情况下，这种内存泄露会导致磁盘分页，甚至会因<code>OutOfMemoryError</code>造成程序失败，不过这种失败的情况是非常少见的。</p>
<p>所以，内存泄漏在哪呢？如果栈不断增长，然后再收缩，那么出站的数据并不会被垃圾回收。即便使用了栈的程序不再引用他们亦如此。这是因为堆栈维护着对他们的<em><strong>过时的引用</strong></em>。废弃的引用指的是永远不会被解引用的引用。在该示例中，位于元素数组『活动部分』之外的任何引用都是废弃的。活动部分包含了索引小于<code>size</code>的元素。</p>
<p>垃圾收集语言中的内存泄露（更恰当的叫法是无意的对象保持）是非常不易察觉的。如果对象引用被无意保持了，那么不仅该对象会从垃圾收集中排除出去，该对象所引用的其他对象也会被排除出去，以此类推。即便只有少量的对象引用被无意保持了，造成的后果就是会有很多、很多对象会从垃圾收集中排除出去，这会对性能造成很严重的影响。</p>
<p>这类问题的解决方案很简单：一旦引用变成废弃状态，立刻将其置为<code>null</code>。对于我们的<code>Stack</code>类来说，如果元素从栈中弹出，那么对其的引用就变成废弃状态了。<code>pop</code>方法的正确版本如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> elements[--size];</span><br><span class="line">    elements[size] = <span class="literal">null</span>; <span class="comment">// Eliminate obsolete reference</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将过时的引用指向<code>null</code>的另一个好处是，如果他们后面被错误地取消引用了，程序会立刻报<code>NullPointerException</code>的错误，而不是静静地做错误的事情。尽可能快地发现程序的错误总是有益的。</p>
<p>当程序员初次遇到这个问题时，他们会采取矫枉过正的措施：当程序使用完对象后，会将每个对象引用都设为<code>null</code>。这么做既没必要，也不值得；它会毫无必要地将程序搞乱。取消对象引用应该是例外而不是规范。消除废弃引用的最佳方式是让包含了引用的变量离开作用域。如果在最小的作用域内定义每个变量，那么这就是自然而然的事情了（Item 57）。</p>
<p>那么应该在何时将引用置为<code>null</code>呢？<code>Stack</code>类的哪个地方使得它容易出现内存泄露问题呢？简而言之，它来管理自己的内存。存储池包含了<code>elements</code>数组的元素（对象引用单元，而非对象自身）。位于数组活跃部分中的元素（如之前所定义的那样）会被分配，而数组其他部分的元素则是空闲的。垃圾收集器并不知晓这一点；对于垃圾收集器器来说，<code>elements</code>数组中的所有对象引用都是有效的。程序员可以与垃圾收集器就这个事实进行高效的沟通，方式是当数组元素进入到非活跃部分中时就立刻将其手工置为<code>null</code>。</p>
<p>一般来说，<strong>当类管理自己的内存时，程序员应该警惕内存泄露问题</strong>。当元素释放时，包含在该元素中的任何对象引用都应该被置为<code>null</code>。</p>
<p><strong>另一个常见的内存泄漏源是缓存</strong>。一旦将对象引用放入缓存中，就很容易忘记它的存在，然后当缓存失效后它就会一直在那儿。这里有几个解决该问题的办法。如果实现了一个缓存，只要缓存外有引用指向缓存的键，缓存就处于有效状态时，那么缓存就可以使用<code>WeakHashMap</code>来表示;当变为废弃状态时，缓存中的条目就会自动移除。请记住，只有在缓存条目的生命周期是由对其键（而非值）的外部引用所决定时，<code>WeakHashMap</code>才是适合的。</p>
<p>更为常见的情况则是，缓存条目的生命周期不是那么明确的，随着时间的流逝，缓存条目的价值也变得越来越低。在这些情况下，我们应该适时清理那些不再使用的缓存条目。这可以通过后台线程（也许是<code>ScheduledThreadPoolExecutor</code>）来实现，或是在将新的条目添加到缓存中时顺便完成。<code>LinkedHashMap</code>类通过其<code>removeEldestEntry</code>方法可以简化后者的操作。对于更加复杂的缓存来说，你可能需要直接使用<code>java.lang.ref</code>。</p>
<p><strong>内存泄漏的第三个常见来源是监听器和其他回调</strong>。如果实现了一个API，客户端在该API上注册了回调，但却没有显式取消注册，那么他们就会不断累积，除非采取一些行动。确保回调会立刻被垃圾收集的一种方式是只存储对其的弱引用，比如说，在<code>WeakHashMap</code>中只将其以键的形式存储。</p>
<p>由于内存泄露通常并不会导致立刻失败，因此它们可能会在系统中保留多年。他们通常是通过精心的代码检查或是借助于调试工具（<strong>heap profiler</strong>）的帮助才能发现。因此，你需要学习如何在内存泄露出现前就能预测到问题，并防止他们发生。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item8 避免使用终结器与清理器</title>
    <url>/2018/12/07/Effective-Java-Item8-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%BB%88%E7%BB%93%E5%99%A8%E4%B8%8E%E6%B8%85%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p><strong>终结器是不可预测的、常常会很危险，而且通常没必要。使用终结器会导致奇怪的行为、孱弱的性能以及可移植性问题</strong>。终结器有一些有效的用途，我们将在后面的条款中介绍，但是作为一个规则，你应该避免他们。在Java 9中，终结器已经被弃用，但是Java库仍然在使用它们。Java 9中，替代终结器的是清除器（<strong>cleaner</strong>）。<strong>清除器比终结器危险小，但仍然不可预测、效率慢，而且通常没有必要</strong>。 </p>
<span id="more"></span>

<p>C++程序员们不要将Java中的终结器或是清理器当作是C++中的析构函数。在C++中，析构函数是回收与对象所关联的资源的常规方式，它是与构造函数必要的一个对应之物。 在Java中，当与对象所关联的存储变得不可达时，垃圾收集器就会将其回收，不需要程序员做任何额外的事情。 c++析构函数也可以用于回收其他非内存资源。在Java中，<code>try-with-resources</code>或<code>try-finally</code>代码块就是用于此目的(Item 9)。</p>
<p>终结器与清理器的一个缺点在于，没有人可以保证他们会立刻执行[JLS, 12.6]。在对象变得不可及与终结器或是清理器开始运行之间可能会间隔任意长的时间。这意味着你永远不要在终结器或是清理器中做任何时间关键的事情。例如，依赖于终结器或清除器来关闭文件就是一个严重的错误，因为打开的文件描述符是有限的资源。如果由于系统运行终结器或是清理器产生了延迟而导致很多文件处于打开的状态，那么程序就有可能失败，因为它无法再打开文件了。</p>
<p>到底哪个终结器和清理器会执行主要是由垃圾回收算法来决定的，而算法在不同的实现间存在着较大的差别 。依赖于终结器或是清理器的立刻执行的程序行为也存在着较大的差别。因此，同样一个程序在你测试的JVM中完美运行，然后却在你最重要的客户上的机器上不幸地失败了，这种情况是完全有可能发生的。</p>
<p>终结器不会立刻执行并不仅仅是个理论上的问题 。为类提供终结器可能会随意地延迟自己的实例的回收。一位同事调试了一个长期运行的GUI应用程序，该应用程序因<code>OutOfMemoryError</code>而奇怪地崩溃过。分析显示，在应用程序崩溃的时候，它的终结器队列中有数千个图形对象等待被终结并回收。遗憾的是，终结器运行所在的线程要比另一个应用线程的优先级低，这样对象被终止的速度远远跟不上其进入到终止状态的速度。Java语言规范没有明确说明哪个线程将执行终结器，因此除了避免使用终结器之外，没有其他更方便的方法来防止这类问题。这个问题上，清洁器在这方面要比终结器好一些，因为类的创建者可以控制自己的清洁器线程，不过，清洁器依然运行在后台，在垃圾收集器的控制之下，因此对于立刻清洁这个问题也没有提供任何保证。</p>
<p>规范不仅没有提供终结器或是清理器会立刻运行的保证，也没有对其一定会运行提供任何保证。完全有可能出现这样的情况，当程序终止时，它并没有对早就处于不可达的对象运行其终结器和清理器。因此，你<strong>永远都不应该依赖于终结器或是清理器来更新持久化状态</strong>。比如说，依赖于终结器或是清理器来释放如数据库等共享资源上的持久化锁可能会导致整个分布式系统陷入瘫痪状态。</p>
<p>不要被<code>System.gc</code>和<code>System.runFinalization</code>方法所诱惑。它们可能会增加终结器或清除器被执行的几率，但他们并不能保证一定如此。曾经有两个方法做过这个保证：<code>System.runFinalizersOnExit</code>及其搭档<code>Runtime.runFinalizersOnExit</code>。这两个方法存在严重的问题，早就已经不建议使用了[ThreadStop]。</p>
<p>终结器的另一个问题是在执行终结时，未捕获的异常会被忽略掉，这时对象的终结会被终止[JLS, 12.6]。未捕获的异常会导致其他对象的状态被破坏掉。如果另一个线程试图使用这样一个已损坏的对象，则可能导致任意的不确定性行为。正常情况下，未捕获的异常会终止线程并打印堆栈信息，但如果在终结器中就不会这样——它甚至不会打印出任何警告信息。清理器不存在这个问题，因为使用了清理器的库会自己控制其线程。。</p>
<p><strong>使用终结方法和清除方法会有严重的性能损失</strong>。在我的机器上，创建一个简单的<code>AutoCloseable</code>对象，使用<code>try-with-resources</code>关闭它，然后让垃圾收集器对其进行回收，大约需要花费12ns。使用终结器可以将时间增加到550纳秒。换句话说，使用终结器创建和销毁对象的速度要慢50倍。这主要是因为终结器阻碍了高效的垃圾回收。如果使用清理器来清除类的所有实例（在我的机器上每个实例大约需要花费500ns），它在速度上与终结器大致相同；不过，如果只是将清理器作为一个安全网（后续将会介绍），那么其速度将会快很多。如下所述。在这些情况下，我的机器上创建、清理与销毁一个对象所花费的时间大约需要66ns，这意味着你为安全网的使用需要付出5倍因子（不是50倍）的代价。</p>
<p><strong>终结方法有一个严重的安全问题：他们会使你的类遭遇到终结器攻击</strong>。终结器攻击背后的想法非常简单：如果异常是从构造方法或是序列化方法<code>readObject</code>与<code>readResolve</code>中抛出的（chapter 12），那么恶意的子类终结器就会运行在部分构建完毕的对象上，而这个对象本应该『中途夭折的』。这个终结器会将对对象的引用记录在一个静态字段中，防止其被垃圾回收掉。一旦将这个不完整的对象记录下来后，我们就可以轻松调用这个对象上的任意方法，而这个对象原本是不应该存在的。<strong>从构造方法中抛出异常足以禁止对象的创建；但在使用终结器的情况下，却并非如此</strong>。 这种攻击还会产生非常严重的后果。终态类不受终结器攻击的影响，因为没人可以创建终态类的恶意子类。若想保护非终态类免受终结器攻击，<strong>请编写一个什么都不做的<code>final</code>的<code>finalize</code>方法</strong>。</p>
<p>那么，对于封装了需要终止的资源（如文件或是线程）的对象来说，如果不为类编写终结器或是清理器，那该怎么办呢？只需让类实现<code>AutoCloseable</code>即可，并让其客户端在不需要其实例时调用其<code>close</code>方法，通常我们会使用<code>try-with-resources</code>来确保终止，即便在异常的情况下亦如此（Item 9）。值得提及的一个细节是，实例必须要追踪其是否已经关闭了：<code>close</code>方法必须要在一个字段中记录下对象已经不再有效了，其他方法则必须要检查该字段，如果当对象已经关闭后还调用这些方法，那就需要抛出<code>IllegalStateException</code>异常。</p>
<p>那么，清理器与终结器到底有什么好处呢？他们有两个合理的用途。一是作为安全网，防止资源所有者忘记调用其<code>close</code>方法。虽然没人能够保证清理器或是终结器会立刻运行（或是否运行），不过如果客户端忘记释放资源，那么迟做总比不做强。如果考虑编写这样的安全网终结器，那么请仔细考虑，这种保护是否真的值得。一些Java库类（如<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>ThreadPoolExecutor</code>及<code>java.sql.Connection</code>）都将终结器作为安全网。</p>
<p>清理器的第二个合理使用场景与拥有本地对端（<code>native peers</code>）的对象有关。所谓本地对端指的是本地对象（非Java对象），常规对象通过本地方法将调用委托给它由于本地对端并非常规对象，因此垃圾收集器并不知晓它，当其Java对端被回收时，也并不会对其进行回收。清理器或是终结器是完成这个任务的恰当工具，假设性能是可接受的，并且本地对端并没有持有关键资源。如果性能是不可接受的，或是本地对端持有必须要立刻回收的资源，那么类就应该拥有一个<code>close</code>方法，如前所示。</p>
<p>清理器的使用有一些棘手。如下是个简单的<code>Room</code>类，演示了其使用方式。假设房间在被回收前必须要清理。<code>Room</code>类实现了<code>AutoCloseable</code>；其自动清理安全网使用了清理器这个事实只不过是个实现细节而已。与终结器不同，清理器不会污染类的公有API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An autocloseable class using a cleaner as a safety net</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Cleaner</span> <span class="variable">cleaner</span> <span class="operator">=</span> Cleaner.create();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Resource that requires cleaning. Must not refer to Room!</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">State</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="type">int</span> numJunkPiles; <span class="comment">// Number of junk piles in this room</span></span><br><span class="line">        </span><br><span class="line">        State(<span class="type">int</span> numJunkPiles) &#123;</span><br><span class="line">            <span class="built_in">this</span>.numJunkPiles = numJunkPiles;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Invoked by close method or cleaner</span></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Cleaning room&quot;</span>);</span><br><span class="line">            numJunkPiles = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The state of this room, shared with our cleanable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> State state;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Our cleanable. Cleans the room when it’s eligible for gc</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cleaner.Cleanable cleanable;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Room</span><span class="params">(<span class="type">int</span> numJunkPiles)</span> &#123;</span><br><span class="line">        state = <span class="keyword">new</span> <span class="title class_">State</span>(numJunkPiles);</span><br><span class="line">        cleanable = cleaner.register(<span class="built_in">this</span>, state);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类<code>State</code>持有清洁器清洁房间所需的资源。在这个例子中，资源就是字段<code>numJunkPiles</code>，表示房间中的混乱程度。更为现实的情况，它可以是个<code>final long</code>字段，包含着一个指针，指向了本地对端。<code>State</code>实现了<code>Runnable</code>，其<code>run</code>方法至多会被<code>Cleanable</code>调用一次，<code>Cleanable</code>则是我们在<code>Room</code>构造方法中将<code>State</code>实例注册到清理器上所得到的。对<code>run</code>方法的调用会被两个动作所触发：通常，它会被<code>Room</code>的<code>close</code>方法调用，<code>close</code>方法又会调用<code>Cleanable</code>的<code>clean</code>方法。如果在<code>Room</code>实例可以被垃圾回收时，客户端没有调用<code>close</code>方法，那么清理器就会（希望如此）调用<code>State</code>的<code>run</code>方法。</p>
<p><code>state</code>实例不持有对它的<code>Room</code>实例的引用，这一点很重要。如果它持有引用，那么它会创造一个死循环，阻止<code>Room</code>实例被垃圾收集器回收（以及自动清理）。因此，<code>State</code>必须是一个静态内部类，因为非静态内部类包含对其外部类实例的引用(item 24)。同样不建议使用<code>lambda</code>，因为它们可以很容易地捕获对外部类对象的引用。 </p>
<p>如前所述，<code>Room</code>的清理器只用作安全网。如果客户端在<code>try-with-resource</code>块中完成了所有的<code>Room</code>实例化动作，那么自动化清理就永远不需要了。如下行为良好的客户端演示了该行为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adult</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Room</span> <span class="variable">myRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="number">7</span>)) &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;Goodbye&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所想，运行<code>Adult</code>程序会打印出<code>Goodbye</code>，然后是<code>Cleaning room</code>。不过，下面这个有问题的程序呢，它永远不会清理房间？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teenager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="keyword">new</span> <span class="title class_">Room</span>(<span class="number">99</span>);</span><br><span class="line">    	System.out.println(<span class="string">&quot;Peace out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能觉得它会打印出<code>Peace out</code>，然后是<code>Cleaning room</code>，不过在我的机器上，它永远不会打印出<code>Cleaning room</code>；它只不过退出了而已。这就是我们之前提到的不可预测性。<strong>Cleaner</strong>规范说到：『在<code>System.exit</code>时清理器的行为是特定于实现的』。没有人可以保证清理动作是否会被调用。虽然规范没这么说，但对于正常的程序退出来说就是如此。在我的机器上，往<code>Teenager</code>类的<code>main</code>方法里添加一行<code> System.gc()</code>，能让程序在退出前打印“<code>Cleaning room</code>”，但是不保证在你的机器上就能看到相同的结果。</p>
<p>总结一下，不要使用清理器，或者说不要在Java 9之前的版本使用终结器，除非将其作为安全网或是用来终止不重要的本地资源。即便如此，也请小心其不确定性和性能影响。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch整合Kibana和Logstash环境搭建</title>
    <url>/2020/01/07/Elasticsearch%E6%95%B4%E5%90%88Kibana%E5%92%8CLogstash%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="Install-Elasticsearch-with-Docker"><a href="#Install-Elasticsearch-with-Docker" class="headerlink" title="Install Elasticsearch with Docker"></a>Install Elasticsearch with Docker</h3><h4 id="Pulling-the-image"><a href="#Pulling-the-image" class="headerlink" title="Pulling the image"></a>Pulling the image</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch</span><br></pre></td></tr></table></figure>

<h4 id="Starting-a-single-node-cluster-with-Docker"><a href="#Starting-a-single-node-cluster-with-Docker" class="headerlink" title="Starting a single node cluster with Docker"></a>Starting a single node cluster with Docker</h4><p>采用Docker启动一个单节点的<code>Elasticsearch</code>集群:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d：后台启动 -p：开放端口 --name：设置名称</span></span><br><span class="line">docker -d run -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; --name elasticsearch-monochrome docker.elastic.co/elasticsearch/elasticsearch:7.5.1</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="Starting-a-multi-node-cluster-with-Docker-Compose"><a href="#Starting-a-multi-node-cluster-with-Docker-Compose" class="headerlink" title="Starting a multi-node cluster with Docker Compose"></a>Starting a multi-node cluster with Docker Compose</h4><p>通过<code>Docker Compose</code>创建一个包含3个节点的<code>Elasticsearch</code>集群 :</p>
<ol>
<li><p>创建一个 <code>docker-compose.yml</code> file:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">es01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.5.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es01</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data01:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.5.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es02</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data02:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.5.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es03</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data03:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">data01:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data02:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data03:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">elastic:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>Run <code>docker-compose</code> 来启动集群:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Install-Kibana-with-Docker"><a href="#Install-Kibana-with-Docker" class="headerlink" title="Install Kibana with Docker"></a>Install Kibana with Docker</h3><h4 id="Pulling-the-image-1"><a href="#Pulling-the-image-1" class="headerlink" title="Pulling the image"></a>Pulling the image</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/kibana/kibana</span><br></pre></td></tr></table></figure>

<h4 id="Configuring-Kibana"><a href="#Configuring-Kibana" class="headerlink" title="Configuring Kibana"></a>Configuring Kibana</h4><p>新建配置文件<code>kibana.yml</code>，很多默认的配置，只需要修改几个配置即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Kibana is served by a back end server. This setting specifies the port to use.</span></span><br><span class="line"><span class="comment">#server.port: 5601</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.</span></span><br><span class="line"><span class="comment"># The default is &#x27;localhost&#x27;, which usually means remote machines will not be able to connect.</span></span><br><span class="line"><span class="comment"># To allow connections from remote users, set this parameter to a non-loopback address.</span></span><br><span class="line"><span class="comment"># 允许远程访问</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="comment">#server.host: &quot;localhost&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enables you to specify a path to mount Kibana at if you are running behind a proxy.</span></span><br><span class="line"><span class="comment"># Use the `server.rewriteBasePath` setting to tell Kibana if it should remove the basePath</span></span><br><span class="line"><span class="comment"># from requests it receives, and to prevent a deprecation warning at startup.</span></span><br><span class="line"><span class="comment"># This setting cannot end in a slash.</span></span><br><span class="line"><span class="comment">#server.basePath: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies whether Kibana should rewrite requests that are prefixed with</span></span><br><span class="line"><span class="comment"># `server.basePath` or require that they are rewritten by your reverse proxy.</span></span><br><span class="line"><span class="comment"># This setting was effectively always `false` before Kibana 6.3 and will</span></span><br><span class="line"><span class="comment"># default to `true` starting in Kibana 7.0.</span></span><br><span class="line"><span class="comment">#server.rewriteBasePath: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The maximum payload size in bytes for incoming server requests.</span></span><br><span class="line"><span class="comment">#server.maxPayloadBytes: 1048576</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Kibana server&#x27;s name.  This is used for display purposes.</span></span><br><span class="line"><span class="comment">#server.name: &quot;your-hostname&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The URLs of the Elasticsearch instances to use for all your queries.</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> [<span class="string">&quot;http://localhost:9200&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># When this setting&#x27;s value is true Kibana uses the hostname specified in the server.host</span></span><br><span class="line"><span class="comment"># setting. When the value of this setting is false, Kibana uses the hostname of the host</span></span><br><span class="line"><span class="comment"># that connects to this Kibana instance.</span></span><br><span class="line"><span class="comment">#elasticsearch.preserveHost: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kibana uses an index in Elasticsearch to store saved searches, visualizations and</span></span><br><span class="line"><span class="comment"># dashboards. Kibana creates a new index if the index doesn&#x27;t already exist.</span></span><br><span class="line"><span class="comment">#kibana.index: &quot;.kibana&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The default application to load.</span></span><br><span class="line"><span class="comment">#kibana.defaultAppId: &quot;home&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If your Elasticsearch is protected with basic authentication, these settings provide</span></span><br><span class="line"><span class="comment"># the username and password that the Kibana server uses to perform maintenance on the Kibana</span></span><br><span class="line"><span class="comment"># index at startup. Your Kibana users still need to authenticate with Elasticsearch, which</span></span><br><span class="line"><span class="comment"># is proxied through the Kibana server.</span></span><br><span class="line"><span class="comment">#elasticsearch.username: &quot;kibana&quot;</span></span><br><span class="line"><span class="comment">#elasticsearch.password: &quot;pass&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enables SSL and paths to the PEM-format SSL certificate and SSL key files, respectively.</span></span><br><span class="line"><span class="comment"># These settings enable SSL for outgoing requests from the Kibana server to the browser.</span></span><br><span class="line"><span class="comment">#server.ssl.enabled: false</span></span><br><span class="line"><span class="comment">#server.ssl.certificate: /path/to/your/server.crt</span></span><br><span class="line"><span class="comment">#server.ssl.key: /path/to/your/server.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional settings that provide the paths to the PEM-format SSL certificate and key files.</span></span><br><span class="line"><span class="comment"># These files validate that your Elasticsearch backend uses the same key files.</span></span><br><span class="line"><span class="comment">#elasticsearch.ssl.certificate: /path/to/your/client.crt</span></span><br><span class="line"><span class="comment">#elasticsearch.ssl.key: /path/to/your/client.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional setting that enables you to specify a path to the PEM file for the certificate</span></span><br><span class="line"><span class="comment"># authority for your Elasticsearch instance.</span></span><br><span class="line"><span class="comment">#elasticsearch.ssl.certificateAuthorities: [ &quot;/path/to/your/CA.pem&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To disregard the validity of SSL certificates, change this setting&#x27;s value to &#x27;none&#x27;.</span></span><br><span class="line"><span class="comment">#elasticsearch.ssl.verificationMode: full</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time in milliseconds to wait for Elasticsearch to respond to pings. Defaults to the value of</span></span><br><span class="line"><span class="comment"># the elasticsearch.requestTimeout setting.</span></span><br><span class="line"><span class="comment">#elasticsearch.pingTimeout: 1500</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time in milliseconds to wait for responses from the back end or Elasticsearch. This value</span></span><br><span class="line"><span class="comment"># must be a positive integer.</span></span><br><span class="line"><span class="comment">#elasticsearch.requestTimeout: 30000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Kibana client-side headers to send to Elasticsearch. To send *no* client-side</span></span><br><span class="line"><span class="comment"># headers, set this value to [] (an empty list).</span></span><br><span class="line"><span class="comment">#elasticsearch.requestHeadersWhitelist: [ authorization ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Header names and values that are sent to Elasticsearch. Any custom headers cannot be overwritten</span></span><br><span class="line"><span class="comment"># by client-side headers, regardless of the elasticsearch.requestHeadersWhitelist configuration.</span></span><br><span class="line"><span class="comment">#elasticsearch.customHeaders: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time in milliseconds for Elasticsearch to wait for responses from shards. Set to 0 to disable.</span></span><br><span class="line"><span class="comment">#elasticsearch.shardTimeout: 30000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time in milliseconds to wait for Elasticsearch at Kibana startup before retrying.</span></span><br><span class="line"><span class="comment">#elasticsearch.startupTimeout: 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logs queries sent to Elasticsearch. Requires logging.verbose set to true.</span></span><br><span class="line"><span class="comment">#elasticsearch.logQueries: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies the path where Kibana creates the process ID file.</span></span><br><span class="line"><span class="comment">#pid.file: /var/run/kibana.pid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enables you specify a file where Kibana stores log output.</span></span><br><span class="line"><span class="comment">#logging.dest: stdout</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the value of this setting to true to suppress all logging output.</span></span><br><span class="line"><span class="comment">#logging.silent: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the value of this setting to true to suppress all logging output other than error messages.</span></span><br><span class="line"><span class="comment">#logging.quiet: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the value of this setting to true to log all events, including system usage information</span></span><br><span class="line"><span class="comment"># and all requests.</span></span><br><span class="line"><span class="comment">#logging.verbose: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the interval in milliseconds to sample system and process performance</span></span><br><span class="line"><span class="comment"># metrics. Minimum is 100ms. Defaults to 5000.</span></span><br><span class="line"><span class="comment">#ops.interval: 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies locale to be used for all localizable strings, dates and number formats.</span></span><br><span class="line"><span class="comment"># Supported languages are the following: English - en , by default , Chinese - zh-CN .</span></span><br><span class="line"><span class="comment"># 默认语言设置为中文</span></span><br><span class="line"><span class="attr">i18n.locale:</span> <span class="string">&quot;zh-CN&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="编排docker-compose"><a href="#编排docker-compose" class="headerlink" title="编排docker-compose"></a>编排docker-compose</h4><p>新建文件<code>docker-compose.yml</code>，配置特权方式和端口，映射配置kibana.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/kibana/kibana:7.5.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5601:5601&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./kibana.yml:/usr/share/kibana/config/kibana.yml</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="启动Kibana"><a href="#启动Kibana" class="headerlink" title="启动Kibana"></a>启动Kibana</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h3 id="Install-Logstash-with-Docker-and-Auto-Sync-Mysql-data"><a href="#Install-Logstash-with-Docker-and-Auto-Sync-Mysql-data" class="headerlink" title="Install Logstash with Docker and Auto-Sync Mysql data"></a>Install Logstash with Docker and Auto-Sync Mysql data</h3><h4 id="Pulling-the-image-2"><a href="#Pulling-the-image-2" class="headerlink" title="Pulling the image"></a>Pulling the image</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/logstash/logstash:7.5.1</span><br></pre></td></tr></table></figure>

<h4 id="自定义docker镜像"><a href="#自定义docker镜像" class="headerlink" title="自定义docker镜像"></a>自定义docker镜像</h4><ol>
<li><p>新建<code>Dockerfile</code>文件</p>
</li>
<li><p>配置<code>Dockerfile</code></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> docker.elastic.co/logstash/logstash:<span class="number">7.5</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装input插件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> logstash-plugin install logstash-input-jdbc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装output插件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> logstash-plugin install logstash-output-elasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装json_lines插件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> logstash-plugin install logstash-codec-json_lines</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#容器启动时执行的命令.(CMD 能够被 docker run 后面跟的命令行参数替换)</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;-f&quot;</span>,<span class="string">&quot;/usr/share/logstash/config/mysql.conf&quot;</span>]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t my_logstash .</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="创建配置相关的文件"><a href="#创建配置相关的文件" class="headerlink" title="创建配置相关的文件"></a>创建配置相关的文件</h4><ol>
<li><p>创建配置文件夹，所有配置文件都放在这个文件夹下面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /data/logstash/config</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>logstash.yml (空文件就行)</strong></p>
</li>
<li><p><strong>log4j2.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logger.elasticsearchoutput.name</span> = <span class="string">logstash.outputs.elasticsearch</span></span><br><span class="line"><span class="attr">logger.elasticsearchoutput.level</span> = <span class="string">debug</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>pipelines.yml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- pipeline.id: my-logstash</span><br><span class="line">  path.config: &quot;/usr/share/logstash/config/*.conf&quot;</span><br><span class="line">  pipeline.workers: 3</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mysql.conf</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">input <span class="punctuation">&#123;</span></span><br><span class="line">	jdbc <span class="punctuation">&#123;</span></span><br><span class="line">		jdbc_connection_string =&gt;</span><br><span class="line">			<span class="string">&quot;jdbc:mysql://localhost:3306/&lt;database_name&gt;?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true&quot;</span></span><br><span class="line">        ## 数据库账号和密码</span><br><span class="line">		jdbc_user =&gt; <span class="string">&quot;root&quot;</span></span><br><span class="line">		jdbc_password =&gt; <span class="string">&quot;root&quot;</span></span><br><span class="line">		## 数据库驱动的JAR位置</span><br><span class="line">		jdbc_driver_library =&gt; <span class="string">&quot;/usr/share/logstash/config/mysql-connector-java-5.1.47.jar&quot;</span></span><br><span class="line">		jdbc_driver_class =&gt; <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">		jdbc_paging_enabled =&gt; <span class="string">&quot;true&quot;</span></span><br><span class="line">		jdbc_page_size =&gt; <span class="string">&quot;50000&quot;</span></span><br><span class="line">        ## 查询的数据，根据数据库自己定义</span><br><span class="line">		statement =&gt; <span class="string">&quot;select * from tb_user&quot;</span></span><br><span class="line">		## 每分钟执行一次</span><br><span class="line">		schedule =&gt; <span class="string">&quot;* * * * *&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">output <span class="punctuation">&#123;</span></span><br><span class="line">	elasticsearch <span class="punctuation">&#123;</span></span><br><span class="line">		## elasticsearch 地址</span><br><span class="line">		hosts =&gt; <span class="string">&quot;localhost:9200&quot;</span></span><br><span class="line">		## 索引名称</span><br><span class="line">		index =&gt; <span class="string">&quot;index-user&quot;</span></span><br><span class="line">        ## 主键</span><br><span class="line">		document_id =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line">		## 索引类型</span><br><span class="line">		document_type =&gt; <span class="string">&quot;user&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line">	stdout <span class="punctuation">&#123;</span></span><br><span class="line">		codec =&gt; json_lines</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库驱动jar包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://repo1.maven.org/maven2/mysql/mysql-connector-java/5.1.47/mysql-connector-java-5.1.47.jar</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="特权方式启动Logstash"><a href="#特权方式启动Logstash" class="headerlink" title="特权方式启动Logstash"></a>特权方式启动<code>Logstash</code></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --privileged=true -p 4560:4560 -p 9600:9600 -it --name=my_logstash -v /data/logstash/config/:/usr/share/logstash/config/   my_logstash</span><br></pre></td></tr></table></figure>

<p>查看日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f -t --tail 10 my_logstash</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Kibana</category>
        <category>Logstash</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>Kibana</tag>
        <tag>Logstash</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item3 通过私有的构造方法或者一个枚举类型来使用单例属性</title>
    <url>/2018/12/06/Effective-Java-Item3-%E9%80%9A%E8%BF%87%E7%A7%81%E6%9C%89%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E4%B8%80%E4%B8%AA%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E4%BD%BF%E7%94%A8%E5%8D%95%E4%BE%8B%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p><strong>单例</strong>对象是一个仅仅只会实例化一次的类。单例对象通常表示一个无状态对象，例如一个函数(Item 24)或一个本质上惟一的系统组件。<strong>使类成为单例会使测试它的客户端变得困难</strong>，因为不可能用模拟实现代替单例，除非它实现一个接口作为它的类型。</p>
<span id="more"></span>
<p>实现单例有两种常见的方法。两者都基于保持构造函数为私有，并对外提供公共静态成员以提供对唯一实例的访问。在第一种方式中，成员是个<code>final</code>字段:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singleton with public final field</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**只调用私有构造函数一次，以初始化公共静态<code>final</code>字段<code>Elvi.instance</code>**。不提供公有的或者受保护的构造函数保证了全局“唯一性”：当Elvis类初始化的时候，仅仅只会有一个<code>Elvis</code>实例存在——不多也不少 。无论客户端怎么做都无法改变这一点，只不过我还是要警告一下 ：授权的客户端可以通过反射来调用私有构造方法（Item 65），借助于<code>AccessibleObject.setAccessible</code>方法即可做到 。如果需要防范这种攻击，请修改构造函数，使其在被要求创建第二个实例时抛出异常。</p>
<p><strong>第二种实现单例模式的方法是，提供一个公有的静态工厂方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singleton with static factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有调用<code>Elvis</code>类的<code>getInstance</code>方法，返回相同的对象引用，并且不会有其它的<code>Elvis</code>对象被创建。（但同样有上面提到的警告）</p>
<p>公共字段方法的主要优点是，通过API我们就可以很清晰地看到类是个单例 ：<code>public static</code>字段是<code>final</code>的，所以它将始终包含相同的对象引用。 第二个优点是它更简单。静态工厂方法的一个优点是它可以让你灵活地改变你的想法，即当你想要改变类的单例特性时，你无需修改其API 。工厂方法返回唯一的实例，但可以修改它，使得每个线程调用它时都返回一个单独的实例。所以，如果你的项目需要，你可以定义一个通用的单例工厂。使用静态工厂方法最后一个好处就是，方法引用可以当做一个提供者，例如，<code>Elvis::instance</code>就是一个<code>Supplier&lt;Elvis&gt;</code>的实例。除非上述这些好处存在一定程度的相关性 ，不然提供公有字段的方法更适合。</p>
<p>要想让上述两种方式实现的单例类能够序列化（Chapter 12），仅仅在声明中添加实现Serializable接口是不够的。为了保证单例，将所有实例字段声明为<code>transient</code>，并提供一个<code>readResolve</code>方法(Item 89)。否则，每次反序列化一个序列化的实例时，都会创建一个新的实例，在我们的示例中，就会出现另一个<code>Elvise</code>。为了阻止这样的事发生，给<code>Elvis</code>类添加一个<code>readResolve</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readResolve method to preserve singleton property</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return the one true Elvis and let the garbage collector</span></span><br><span class="line">    <span class="comment">// take care of the Elvis impersonator.</span></span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三种实现单例的方式是，声明一个单元素的枚举类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法跟提供公有的字段方法很类似，但它更简洁，提供天然的可序列化机制和能够强有力地保证不会出现多次实例化的情况 ，甚至面对复杂的序列化和反射的攻击下。这种方法可能看起来不太自然，但是<strong>拥有单元素的枚举类型可能是实现单例模式的最佳实践</strong>。注意，如果单例必须要继承一个父类而非枚举的情况下是无法使用该方式的（不过可以声明一个实现了接口的枚举）。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item9 优先使用“try-with-resources”来代替“try-finally”</title>
    <url>/2018/12/07/Effective-Java-Item9-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E2%80%9Ctry-with-resources%E2%80%9D%E6%9D%A5%E4%BB%A3%E6%9B%BF%E2%80%9Ctry-finally%E2%80%9D/</url>
    <content><![CDATA[<p>Java库包含许多必须通过手动调用<code>close</code>方法关闭的资源。其中包括：<code>InputStream</code>，<code>OutputStream</code>和<code>java.sql.Connection</code>。关闭资源常常会被客户端所忽视，这会导致可怕的性能问题。虽然很多资源使用了终结器来作为安全网，不过终结器却并不那么尽如人意（Item 8）。</p>
<span id="more"></span>

<p>纵观历史，<code>try-finally</code>语句是保证资源被正确关闭的最好方法，即便在遇到异常或是返回语句时亦如此：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try-finally - No longer the best way to close resources!</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> br.readLine();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		br.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来还不错，不过当添加了第二个资源时情况就变得有些糟糕了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try-finally is ugly when used with more than one resource!</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">	 <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dst);</span><br><span class="line">	 <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];</span><br><span class="line">	     <span class="type">int</span> n;</span><br><span class="line">	     <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">		 out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">	 &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	     out.close();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	 in.close();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可能难以置信，但即使是优秀的程序员也有犯这个错误的时候。对于初学者来说，我在<strong>Java Puzzlers</strong>[Bloch05]的第88页指出了问题，但多年来没人注意到。事实上，2007年，在Java库中对<code>close</code>方法的使用有2&#x2F;3是错误的。</p>
<p>即使使用<code>try-finally</code>语句关闭资源的正确代码(如前两个代码示例所示)也有一个细微的缺陷。<code>try</code>块和<code>finally</code>块中的代码都能够抛出异常。例如，在<code>firstLineOfFile</code>方法中，由于底层物理设备发生故障，对<code>readLine</code>的调用可能会抛出异常，而<code>close</code>的调用也可能出于同样的原因而失败。在这种情况下，第二个异常完全把第一个异常给覆盖了。异常堆栈跟踪中没有第一个异常的记录，这可能会使实际系统中的调试变得非常复杂——通常这是你希望看到的第一个异常，以便诊断问题。虽然可以通过编写代码来抑制第二个异常而支持第一个异常，但实际上没有人会这样做，因为它太过啰嗦。</p>
<p>当Java 7引入了<code>try-with-resources</code>语句[JLS，14.20.3]时，所有这些问题都被一举解决了。要想使用这个结构，资源必须实现<code>AutoCloseable</code>接口，该接口包含了唯一一个返回<code>void</code>类型的<code>close</code>方法。现在Java库和第三方库中的许多类和接口去实现或继承了<code>AutoCloseable</code>接口。如果你要编写一个代表必须关闭的资源的类，那么你的类也应该实现<code>AutoCloseable</code>接口。</p>
<p>如下代码使用<code>try-with-resources</code>改写了上面第一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try-with-resources - the the best way to close resources!</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path))) &#123;</span><br><span class="line">    	<span class="keyword">return</span> br.readLine();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下代码使用<code>try-with-resources</code>改写了上面第二个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try-with-resources on multiple resources - short and sweet</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">    		<span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dst)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">        	out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与以前的版本相比，<code>try-with-resources</code>版本不仅更短，可读性更好，而且提供了更好的诊断。仔细想想<code>firstLineOfFile</code>方法。如果<code>firstLineOfFile</code>和<code>close</code>方法（不可见）都抛出了异常，则后一个异常将被抑制，来支持前一个异常。 实际上，可能会抑制多个异常，而保留你实际希望看到的异常。这些被压制的异常并不是被丢弃掉；它们会被打印到堆栈信息里，并用一个标记来说明它们是被抑制的。在程序中你可以用<code>getSuppressed</code>方法来访问它们，该方法是在Java 7中被添加到<code>Throwable</code>中的。</p>
<p>你可以将<code>catch</code>从句放到<code>try-with-resources</code>语句上，就像在正常的<code>try-finally</code>语句中那样。这样就可以在处理异常的同时又不会在另一个嵌套层次上搞乱代码了。举个例子，举个例子下面是不抛出异常的<code>firstLineOfFile</code>方法版本，不过如果无法打开文件或是无法读取文件，那么它会接收一个默认值来返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/ <span class="keyword">try</span>-with-resources with a <span class="keyword">catch</span> clause</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">firstLineOfFile</span><span class="params">(String path, String defaultVal)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path))) &#123;</span><br><span class="line">    	<span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    	<span class="keyword">return</span> defaultVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论很明显：当使用了必须关闭的资源时，总是优先使用<code>try-with-resources</code>，来代替<code>try-finally</code>。结果代码更短、也更清晰，它所生成的异常也更加有用。<code>try-with-resources</code>语句使得编写使用了必须要关闭的资源的代码更加轻松，而这是<code>try-finally</code>所做不到的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA 快捷键</title>
    <url>/2018/11/23/IntelliJ%20IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h3 id="Idea快捷键"><a href="#Idea快捷键" class="headerlink" title="Idea快捷键"></a>Idea快捷键</h3><h4 id="一、跳转"><a href="#一、跳转" class="headerlink" title="一、跳转"></a>一、跳转</h4><p>1.ctrl+Alt+[] 项目之间跳转<br>2.ctrl+e 最近的文件<br>3.ctrl+shift+e 最近编辑的文件<br>4.ctrl+shift+backspace 浏览修改位置的跳转<br>5.ctrl+shift+左箭头（win10会改变屏幕方向） 最新浏览位置的修改<br>6.使用书签进行跳转<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+<span class="built_in">shift</span>+数字或字母 标记书签  </span><br><span class="line">ctrl+数字或者字母 跳转书签  </span><br><span class="line"><span class="built_in">shift</span>+F11 总览书签  </span><br></pre></td></tr></table></figure><br>7.Ctrl+Up&#x2F;Down 光标中转到当前界面第一行或最后一行下<br>8.Ctrl+[OR] 可以跑到大括号的开头与结尾<br>9.F2 1跳转到错误位置  </p>
<span id="more"></span>
<h4 id="二、高效定位代码"><a href="#二、高效定位代码" class="headerlink" title="二、高效定位代码"></a>二、高效定位代码</h4><p>1.ctrl+n 定位类<br>2.ctrl+shift+n 定位文件<br>3.ctrl+shift+alt+n 定位函数或者属性<br>4.ctrl+shift+f 定位字符串  </p>
<h4 id="三、列操作"><a href="#三、列操作" class="headerlink" title="三、列操作"></a>三、列操作</h4><p>1.ctrl+shift+alt+j 列操作（多行逻辑操作、批量操作）<br>2.Ctrl+←(→) 移动到一个词的开始(结尾)<br>3.Ctrl+Shift+←(→) 从后到前（从前到后）选中一个词<br>4.Ctrl+Home 第一行代码<br>5.Ctrl+End 最后一行代码<br>6.ctrl+alt+l 代码格式化  </p>
<h4 id="四、Livetemplate"><a href="#四、Livetemplate" class="headerlink" title="四、Livetemplate"></a>四、Livetemplate</h4><p>1.Livetemplate 自定义代码模块快捷键和内容  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">位置:ctrl+<span class="built_in">shift</span>+a查找livetemplates,回车  </span><br><span class="line">    <span class="variable">$VAR1</span>第一个值<span class="variable">$VAR2</span>第一个值<span class="variable">$VAR2</span>第二个值  </span><br><span class="line">    $END$鼠标停留位置  </span><br><span class="line">    回车跳转到到下个值</span><br></pre></td></tr></table></figure>
<h4 id="五、Postfix"><a href="#五、Postfix" class="headerlink" title="五、Postfix"></a>五、Postfix</h4><p>1.postfix 参数后面点函数回车，生成代码位置:ctrl+shift+a查找postfix,回车name.field——可自动添加this.name&#x3D;name以及private String name;<br>  常用：<br>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-foo.fori <span class="keyword">for</span>(int i = 0; i &lt; foo; i++)&#123;&#125;</span><br><span class="line">-foo.return <span class="built_in">return</span> foo;</span><br><span class="line">-foo.sout System.out.println(foo);</span><br><span class="line">-foo.field private Foo foo; this.foo = foo;</span><br><span class="line">-foo.nn <span class="keyword">if</span>(user!=null)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="六、Alter-enter"><a href="#六、Alter-enter" class="headerlink" title="六、Alter+enter"></a>六、Alter+enter</h4><p>1.Alter+enter 智能提示<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-自动创建函数</span><br><span class="line">-list replace 列表替换优化</span><br><span class="line">-字符串format或者build 字符串格式化，build优化减小内存</span><br><span class="line">-接口实现 在接口上回车可自动创建实现类</span><br><span class="line">-单词拼写 波浪线为存在单词问题，可校对单词</span><br><span class="line">-导包</span><br><span class="line">-不知道怎么做就试试Alter+enter</span><br></pre></td></tr></table></figure></p>
<h4 id="七、重构"><a href="#七、重构" class="headerlink" title="七、重构"></a>七、重构</h4><p>1.shift+F6 重构，将某个参数全部修改。<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-重构变量</span><br><span class="line">-重构方法</span><br></pre></td></tr></table></figure></p>
<h4 id="八、抽取"><a href="#八、抽取" class="headerlink" title="八、抽取"></a>八、抽取</h4><p>1.抽取，将常用数据抽取出来变成简单变量或函数。<br>    -抽取变量 Ctrl+Alt+V<br>    -抽取静态变量 Ctrl+Alt+C<br>    -抽取成员变量 Ctrl+Alt+F<br>    -抽取方法参数 Ctrl+Alt+P<br>    -抽取函数 Ctrl+Alt+M  </p>
<h4 id="九、寻找修改轨迹"><a href="#九、寻找修改轨迹" class="headerlink" title="九、寻找修改轨迹"></a>九、寻找修改轨迹</h4><p>1.annotate代码前右击，选中annotate，可以找到代码的所有者，更进一步点击，还可以找到该作者的修改记录<br>2.Ctrl+Alt+Shift+上下箭头 寻找改动的地方<br>3.Ctrl+Alt+Z 撤销，包括单个和项目改动之处<br>4.Local history idea本地历史记录<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Put Label 本地存档说明</span><br><span class="line">Put Label可以用Ctrl+Alt+A的Local History里找到</span><br></pre></td></tr></table></figure></p>
<h4 id="十、关联"><a href="#十、关联" class="headerlink" title="十、关联"></a>十、关联</h4><p>1.spring关联<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl+Alt+Shift+S 中的Facets配置。</span><br><span class="line">可在代码前的行数中看到Spring的关系</span><br></pre></td></tr></table></figure><br>2.与数据库关联<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">添加Database在mapper输入时可以自动提示Database字段。</span><br><span class="line">Shinf+f6重构改表名mapper也可以改。或者直接改。</span><br></pre></td></tr></table></figure></p>
<h4 id="十一、断点调试"><a href="#十一、断点调试" class="headerlink" title="十一、断点调试"></a>十一、断点调试</h4><p>1.Ctrl+F8 添加删除断点<br>2.Shift +f9 dubug运行<br>3.F8 单步运行<br>4.F9 跳到下一个断点<br>5.Ctrl+Shift+F8 查看所有断点位置（在有断点的位置为设置条件断点）<br>6.Alt+F8 查看当前变量值和表达式求值<br>7.Alt+F9 运行到光标位置<br>8.setValue 在debug页面按F2动态设置传递的值<br>9.Ctrl+Shift+f9 运行光标最小上下文<br>10.Shift+Alt+F9 最近运行的历史列表选择运行  </p>
<h4 id="十二、文件操作"><a href="#十二、文件操作" class="headerlink" title="十二、文件操作"></a>十二、文件操作</h4><p>1.Ctrl+Alt+Insert 新建文件<br>2.F5 复制文件<br>3.F6 移动文件  </p>
<h4 id="十三、文本操作"><a href="#十三、文本操作" class="headerlink" title="十三、文本操作"></a>十三、文本操作</h4><p>1.Ctrl+C 复制文件名<br>2.Ctrl+Shift+C 复制文件路径<br>3.Ctrl+Shift+V 剪切板（历史复制）  </p>
<h4 id="十四、结构图"><a href="#十四、结构图" class="headerlink" title="十四、结构图"></a>十四、结构图</h4><p>1.Ctrl+F12 查看当前field,method大纲<br>2.Ctrl+alt+Shift+U查看maven依赖，类图<br>3.Ctrl+H，查看类的继承关系<br>4.Ctrl+Alt+H，查看方法的调用和被调用关系  </p>
<h4 id="十五、其他快捷键"><a href="#十五、其他快捷键" class="headerlink" title="十五、其他快捷键"></a>十五、其他快捷键</h4><p>1.Alt+Q 可以看到当前方法的声明<br>2.Alt+Insert 可以生成构造器&#x2F;Getter&#x2F;Setter等<br>3.Ctrl+&#x2F;或Ctrl+Shift+&#x2F; 注释（&#x2F;&#x2F;或者&#x2F;**&#x2F;）<br>4.Ctrl+J 自动代码（例如：serr）<br>5.Ctrl+Shift+J 整合两行<br>6.Ctrl+Shift+U 大小写转化<br>7.Ctrl+Y 删除当前行<br>8.Ctrl+D 复制当前行<br>9.Shift+Enter 向下插入新行<br>10.Ctrl+”+&#x2F;-”，当前方法展开、折叠<br>11.Ctrl+Shift+”+&#x2F;-”，全部展开、折叠</p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Git开发规范</title>
    <url>/2019/12/20/Git%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h3 id="分支介绍及命名规则"><a href="#分支介绍及命名规则" class="headerlink" title="分支介绍及命名规则"></a>分支介绍及命名规则</h3><h4 id="master-分支"><a href="#master-分支" class="headerlink" title="master 分支"></a><strong>master 分支</strong></h4><ul>
<li>master 为主分支，也是用于部署生产环境的分支，一定要确保master分支稳定性</li>
<li>master 分支一般从develop或bugfix分支合并，任何时间都不能直接修改master分支的代码</li>
</ul>
<h4 id="develop-分支"><a href="#develop-分支" class="headerlink" title="develop 分支"></a><strong>develop 分支</strong></h4><ul>
<li>develop 为开发分支，始终保持最新完成以及bug修复后的代码，</li>
<li>一般开发的新功能时，feature分支都是基于develop分支下创建的</li>
</ul>
<h4 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a><strong>feature 分支</strong></h4><ul>
<li>feature 为开发新功能时创建的分支，并且一般是由develop为基础来创建feature分支</li>
<li>分支命名: feature&#x2F; 开头的为特性分支， 命名示例: feature&#x2F;user_module、 feature&#x2F;vacation_plan_module</li>
</ul>
<span id="more"></span>

<h4 id="release-分支"><a href="#release-分支" class="headerlink" title="release 分支"></a><strong>release 分支</strong></h4><ul>
<li>release 为预上线分支，发布提测阶段，会以release分支代码为基准提测，因为项目组实际情况，人数不够的情况下可以不需要此分支。</li>
</ul>
<h4 id="bugfix-分支"><a href="#bugfix-分支" class="headerlink" title="bugfix 分支"></a><strong>bugfix 分支</strong></h4><ul>
<li>bugfix 为修复分支，它的命名规则与 feature 分支类似，例如bugfix&#x2F;xxx</li>
<li>线上出现紧急问题时，需要及时修复，以master或develop分支为基线，创建bugfix分支，修复完成后，需要合并到master分支和develop分支</li>
</ul>
<h3 id="操作步骤及命令"><a href="#操作步骤及命令" class="headerlink" title="操作步骤及命令"></a>操作步骤及命令</h3><h4 id="管理员「项目负责人」创建master及develop分支"><a href="#管理员「项目负责人」创建master及develop分支" class="headerlink" title="管理员「项目负责人」创建master及develop分支"></a>管理员「项目负责人」创建master及develop分支</h4><p>一般master分支在创建项目是会默认创建，现在只需要创建develop分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b develop #git checkout命令加上-b参数表示创建并切换，相当于git branch develop与git checkout develop</span><br></pre></td></tr></table></figure>

<p>用<code>git branch</code>命令查看当前分支，命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* develop</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>

<h4 id="项目成员「开发者」clone-项目，在本地建立自己的功能分支"><a href="#项目成员「开发者」clone-项目，在本地建立自己的功能分支" class="headerlink" title="项目成员「开发者」clone 项目，在本地建立自己的功能分支"></a>项目成员「开发者」clone 项目，在本地建立自己的功能分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone &lt;项目 git 地址&gt;</span><br><span class="line">git checkout -b develop origin/develop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建本地功能分支</span></span><br><span class="line">git checkout -b feature/[feature-name] develop</span><br></pre></td></tr></table></figure>

<p>在自己的本地feature分支上进行开发 ： <code>git add</code> ，<code>git commit</code> 等，注意此时不要 push 到远程分支（origin）。</p>
<p>功能完成后可以直接合并本地的 <code>feature</code> 分支到本地的 <code>develop</code> 分支后 push 到远程仓库，合并的时候很大几率发生冲突，此时需要 <code>merge</code> ，<code>merge</code> 的时候确保不影响项目其他成员，如果多个人都操作了同一个类，最好当面确认后在进行修改。等合并完成确认无误后，删除本地开发分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout develop </span><br><span class="line">git pull origin develop #确保本地 developer 分支为最新的</span><br><span class="line">git merge feature/[feature-name] #合并本地的 `feature` 分支到本地的 `develop` 分支</span><br><span class="line">git push #确保你当前在develop分支下面push</span><br><span class="line">git branch -d feature/[feature-name] #删除本地分支</span><br></pre></td></tr></table></figure>

<h4 id="发布分支"><a href="#发布分支" class="headerlink" title="发布分支"></a>发布分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b release-0.1 develop #从develop分支迁出预发布分支</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">一旦准备好了发版，合并修改到 master 分支和 developer 分支上，删除发布分支</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">合并修改到 master 分支</span></span><br><span class="line">git checkout master </span><br><span class="line">git merge release-0.1 </span><br><span class="line">git push </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">合并修改到 develop 分支</span></span><br><span class="line">git checkout develop </span><br><span class="line">git merge release-0.1 </span><br><span class="line">git push </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除发布分支</span></span><br><span class="line">git branch -d release-0.1</span><br></pre></td></tr></table></figure>

<h4 id="为-master-分支打发版-tag"><a href="#为-master-分支打发版-tag" class="headerlink" title="为 master 分支打发版 tag"></a>为 master 分支打发版 tag</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git tag -a 0.1 -m &quot;Initial public release&quot; master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<h4 id="修复-bug"><a href="#修复-bug" class="headerlink" title="修复 bug"></a>修复 bug</h4><p>如果正在开发功能的同时，发现了线上 bug，或者未上线的 bug，我们可以开一个 bugfix 分支来修复 bug，然后将修复后的代码发布到线上以及正在开发的分支上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b bugfix/[bug-name] master（或 develop）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">when fixed bug，合并修改好的代码到master以及develop分支</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge bugfix/[bug-name]</span><br><span class="line">git checkout develop</span><br><span class="line">git merge bugfix/[bug-name]</span><br><span class="line"></span><br><span class="line">git push</span><br><span class="line">git branch -d bugfix/[bug-name]</span><br></pre></td></tr></table></figure>

<h4 id="特别提示"><a href="#特别提示" class="headerlink" title="特别提示"></a>特别提示</h4><p>项目中存在很多配置文件，不同分支配置文件可能不同，因此在merge时需要忽略配置文件合并</p>
<ol>
<li><p>首先，需要创建自定义的 <code>merge driver</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global merge.ours.driver true</span><br></pre></td></tr></table></figure>
</li>
<li><p>在要被<code>merge</code>的分支上创建<code>.gitattributes</code>文件,并且在文件中置顶不<code>merge</code>的文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;Jenkinsfile merge=ours&#x27; &gt;&gt; .gitattributes</span><br><span class="line">git add .gitattributes</span><br><span class="line">git commit -m &#x27;chore: Preserve Jenkinsfile during merges&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>回到要合并到的分支<code>master</code>,执行<code>merge</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge xxxx</span><br></pre></td></tr></table></figure></li>
</ol>
<p>PS：只能<code>master</code>合并<code>其他分支</code>时忽略<code>其他分支</code>上的文件, <code>其他分支</code>合并<code>master</code>无法忽略<code>master</code>上的文件</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC并发编程</title>
    <url>/2022/05/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="一把锁"><a href="#一把锁" class="headerlink" title="一把锁"></a>一把锁</h2><p>synchronized</p>
<h2 id="两个并（并发、并行）"><a href="#两个并（并发、并行）" class="headerlink" title="两个并（并发、并行）"></a>两个并（并发、并行）</h2><p>并发：</p>
<ul>
<li>是在同一实体上的多个事件</li>
<li>是在一合处理器上“同时”处理多个任务</li>
<li>同一时刻，其实是只有一个事件在发生</li>
</ul>
<p>并行：</p>
<ul>
<li>是在不同实体上的多个事件</li>
<li>是在多台处理器上同时处理多个任务</li>
<li>同一时刻，大家真的都在做事情</li>
</ul>
<h2 id="三个程（进程、线程、管程）"><a href="#三个程（进程、线程、管程）" class="headerlink" title="三个程（进程、线程、管程）"></a>三个程（进程、线程、管程）</h2><p>进程：简单的说，在系统中运行的一个应用程序就是一个进程，每一个进程都有它自己的内存空间和系统资源。</p>
<p>线程：也被称为轻量级进程，在同一个进程内会有1个或多个线程，是大多数操作系统进行时序调度的基本单元。</p>
<p>管程：Monitor(监视器），也就是我们平时所说的锁，Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。JVM中同步是基于进入和退出监视器对象(Monitor，管程对象)来实现的，每个对象实例都会有一个Monitor对象。Monitor对象会和Java对象一同创建并销毁。</p>
<h2 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h2><p>执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成 （无论是正當完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。</p>
<p>如果一个同步方法执行期间拋出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虛拟机的指令集中有monitorenter和monitorext 两条指令来支持synchronized关键字的语义，正确实现synchronized关键宇需要Javac编译器与Java虛拟机两者共同协作支持。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item4 通过私有的构造方法来阻止类的实例化</title>
    <url>/2018/12/06/Effective-Java-Item4-%E9%80%9A%E8%BF%87%E7%A7%81%E6%9C%89%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9D%A5%E9%98%BB%E6%AD%A2%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96/</url>
    <content><![CDATA[<p>有时，你想要编写一个只包含一组静态方法和静态字段的类。这种类有一个不太好的名声，因为有些人会滥用他们，不从对象的角度来思考，而是坚信他们的想法是正确无误的 。他们可以把原生类型的值或数组相关的方法分一组，就像<code>java.lang.Math</code>或<code>java.util.Arrays</code>的方式。还可以将静态方法划分到一起，包括工厂（Item 1），用于实现了某个接口的对象，就想<code>java.util.Collections</code>一样。（从Java 8开始，如果想要自己修改，那么你还可以将这类方法放到接口中）最后，还可以将针对终态类的方法划分到一起，因为你无法再将他们放到子类中了 。</p>
<span id="more"></span>

<p>把这样的公共类设计成不可实例化，是因为它的实例化是没有意义地。然而，在没有显式构造函数的情况下，编译器提供一个公共的、无参数的默认构造函数。对使用者来说，这个构造函数跟其它的没什么区别。我们常常会在已发布的APIs中看到无意中被实例化的类 。</p>
<p><strong>通过将一个类设置为抽象类来强制禁止类的实例化是行不通的</strong>。这个抽象类可以有子类，然后子类可以实例化。而且这会误导使用者去想要去设计一个类，然后继承这个抽象类（Item 19）。然后这里有一个简单的做法来保证非实例化。只有在类不包含显示构造函数时候，默认的构造函数才会生成。所以，一个类可以通过提供私有的构造函数来做到非实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Noninstantiable utility class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UtilityClass</span> &#123;</span><br><span class="line">    <span class="comment">// Suppress default constructor for noninstantiability</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">UtilityClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为显示指定构造函数是私有的，所有无法在类外面访问到。<code>AssertionError</code>不是必须的，但它提供了一个保障，防止构造函数在类的内部被意外调用。它保证了类在任何情况都不会被实例化。这种做法有点反常识，因为提供构造方法的目的仅仅是为了自己不能被调用 。所以，更好的做法则是加上一些注释说明，正如上述代码所做的那样。</p>
<p>这样做的副作用是，阻止了类被子类化。所有构造函数都必须显式或隐式地调用父类构造函数，但是子类将没有可访问的父类构造函数来调用。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
        <category>chapter 2</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识补充</title>
    <url>/2021/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><h2 id="1-自增变量"><a href="#1-自增变量" class="headerlink" title="1.自增变量"></a>1.自增变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        i = i++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + ++i * i++;</span><br><span class="line">        System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;j=&quot;</span> + j);</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span> + k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//i=4</span></span><br><span class="line"><span class="comment">//j=1</span></span><br><span class="line"><span class="comment">//k=11</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2、单例模式"><a href="#2、单例模式" class="headerlink" title="2、单例模式"></a>2、单例模式</h2><h3 id="什么是Singleton"><a href="#什么是Singleton" class="headerlink" title="什么是Singleton?"></a>什么是Singleton?</h3><p>Singleton:在Java中 即指单例设置模式，探视软件开发最常用的设置模式之一</p>
<p>单：唯一</p>
<p>例：实例</p>
<p>单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式</p>
<p>例如：代表JVM运行环境的Runtime类</p>
<h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><p>一是某个类只能有一个实例</p>
<ul>
<li>构造器私有化</li>
</ul>
<p>二是他必须自行创建实例</p>
<ul>
<li>含有一个该类的静态变量来保存这个唯一的实例</li>
</ul>
<p>三是它必须自行向整个系统提供这个实例</p>
<p>对外提供获取该类实例对象的方式</p>
<ul>
<li>直接暴露</li>
<li>用静态变量的get方法获取</li>
</ul>
<h3 id="几种常见形式"><a href="#几种常见形式" class="headerlink" title="几种常见形式"></a>几种常见形式</h3><p>饿汉式：直接创建对象，不存在线程安全问题</p>
<ul>
<li>直接实例化饿汉式(简洁直观)</li>
<li>枚举式 (最简洁)</li>
<li>静态代码块饿汉式(适合复杂实例化)</li>
</ul>
<p>懒汉式;延迟创建对象</p>
<ul>
<li><p>线程不安全(使用于单线程)</p>
</li>
<li><p>线程安全(使用于多线程)</p>
</li>
<li><p>静态内部类模式 (适用于多线程)</p>
</li>
</ul>
<h2 id="3、类初始化实例初始化"><a href="#3、类初始化实例初始化" class="headerlink" title="3、类初始化实例初始化"></a>3、类初始化实例初始化</h2><h3 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h3><blockquote>
<p>一个类要创建实例需要先加载并初始化该类</p>
<p>main方法所在的类需要先加载和初始化</p>
<p>一个子类要初始化需要先初始化父类</p>
<p>一个类初始化就是执行 clinit 方法</p>
<p>clinit 方法由静态类变量显示赋值代码和静态代码块组成</p>
<p>类变量显示赋值代码和静态代码块代码从上到下执行</p>
<p>clinit 方法只调用一次</p>
</blockquote>
<h3 id="实例初始化过程"><a href="#实例初始化过程" class="headerlink" title="实例初始化过程"></a>实例初始化过程</h3><blockquote>
<p>实例初始化就是执行 init() 方法</p>
<p>init () 方法可能重载有多个，有几个构造器就有几个 init() 方法</p>
<p>init() 方法由非静态实例变量显示赋值代码和非静态代码块，对应构造器代码组成</p>
<p>非静态实例变量显示赋值代码和非静态代码块从上到下顺序执行，而对应构造器的代码最后执行</p>
<p>每次创建实例对象，调用对应构造器，执行的就是对应的 ini方法</p>
<p>init 方法的首行是super()和super(实参列表) ,即对应父类的 init 方法</p>
</blockquote>
<h3 id="Father-java"><a href="#Father-java" class="headerlink" title="Father.java"></a>Father.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类初始化&lt;clinit&gt;</span></span><br><span class="line"><span class="comment"> * 1、j = method()</span></span><br><span class="line"><span class="comment"> * 2、 父类的静态代码块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 父类实例化方法:</span></span><br><span class="line"><span class="comment"> * 1、super()（最前）</span></span><br><span class="line"><span class="comment"> * 2、i = test() (9)</span></span><br><span class="line"><span class="comment"> * 3、子类的非静态代码块 (3)</span></span><br><span class="line"><span class="comment"> * 4、子类的无参构造（最后）(2)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 非静态方法前面其实有一个默认的对象this</span></span><br><span class="line"><span class="comment"> * this在构造器或&lt;init&gt; 他表示的是正在创建的对象，因为咱们这里是正在创建Son对象，所以</span></span><br><span class="line"><span class="comment"> * test()执行的就是子类重写的代码(面向对象多态)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这里i=test() 执行的就是子类重写的test()方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-04-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(1)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Father() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(2)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(3)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(4)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(5)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Son-java"><a href="#Son-java" class="headerlink" title="Son.java"></a>Son.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类的初始化&lt;clinit&gt;</span></span><br><span class="line"><span class="comment"> * 1、j = method()</span></span><br><span class="line"><span class="comment"> * 2、子类的静态代码块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 先初始化父类 (5)(1)</span></span><br><span class="line"><span class="comment"> * 初始化子类 (10) (6)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 子类实例化方法:</span></span><br><span class="line"><span class="comment"> * 1、super()（最前</span></span><br><span class="line"><span class="comment"> * 2、i = test() (9)</span></span><br><span class="line"><span class="comment"> * 3、子类的非静态代码块 (8)</span></span><br><span class="line"><span class="comment"> * 4、子类的无参构造（最后）(7)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-04-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> method();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(6)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Son() &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;(7)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(8)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(9)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(10)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="comment">// out:</span></span><br><span class="line">        <span class="comment">// (5)(1)(10)(6)(9)(3)(2)(9)(8)(7)</span></span><br><span class="line">        <span class="comment">// (9)(3)(2)(9)(8)(7)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、方法参数传递机制"><a href="#4、方法参数传递机制" class="headerlink" title="4、方法参数传递机制"></a>4、方法参数传递机制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-04-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exam4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">MyData</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line"></span><br><span class="line">        change(i,str,num,arr,my);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;i= &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;str= &quot;</span> + str);</span><br><span class="line">        System.out.println(<span class="string">&quot;num= &quot;</span> + num);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr= &quot;</span> + Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">&quot;my.a= &quot;</span> + my.a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> j, String s, Integer n, <span class="type">int</span>[] a, MyData m)</span> &#123;</span><br><span class="line">        j += <span class="number">1</span>;</span><br><span class="line">        s += <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">        m.a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out:</span></span><br><span class="line"><span class="comment">// i= 1</span></span><br><span class="line"><span class="comment">// str= hello</span></span><br><span class="line"><span class="comment">// num= 111</span></span><br><span class="line"><span class="comment">// arr= [2, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// my.a= 11</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、形参是基本数据类型</p>
<ul>
<li>传递数据值</li>
</ul>
<p>2、实参是引用数据类型</p>
<ul>
<li>传递地址值</li>
</ul>
<p> 特殊的类型：String、包装类等对象的不可变性</p>
<h2 id="5、递归与迭代"><a href="#5、递归与迭代" class="headerlink" title="5、递归与迭代"></a>5、递归与迭代</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编程题: 有n步台阶，一次只能上1步或2步，共有多少种走法?</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStep</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">20</span>));</span><br><span class="line">        System.out.println(loop(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f(n - <span class="number">2</span>) + f(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">loop</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">oneStep</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">twoStep</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum = oneStep + twoStep;</span><br><span class="line">            twoStep = oneStep;</span><br><span class="line">            oneStep = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SSM面试题"><a href="#SSM面试题" class="headerlink" title="SSM面试题"></a>SSM面试题</h1><h2 id="Spring中支持的常用数据库事务传播属性和事务隔离级别"><a href="#Spring中支持的常用数据库事务传播属性和事务隔离级别" class="headerlink" title="Spring中支持的常用数据库事务传播属性和事务隔离级别"></a>Spring中支持的常用数据库事务传播属性和事务隔离级别</h2><h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播，列如方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行，事务传播的行为有传播属性指定，Spring定义了7中类传播行为</p>
<table>
<thead>
<tr>
<th>传播属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>如果有事务在运行，当前的方法就在这个事务内运行，否则就启动一个新的事务，并在自己的事务内运行</td>
</tr>
<tr>
<td>REQUIRED_NEW</td>
<td>当前方法必须启动事务，并在它自己的事务内运行，如果有事务正在运行，应该将他挂起</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>如果有事务在运行，当前的方法就在这个事务内运行，否则他可以不运行在事务中</td>
</tr>
<tr>
<td>NOT_SUPPORTE</td>
<td>当前的方法不应该运行在事务中，如果有运行的事务，将他挂起</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常</td>
</tr>
<tr>
<td>NEVER</td>
<td>当前方法不应该运行在事务中，如果有运行的事务，就抛出异常</td>
</tr>
<tr>
<td>NESTED</td>
<td>如果有事务在运行，当前的方法就应该在这个事物的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行</td>
</tr>
</tbody></table>
<p>事务传播属性可以在@Transactional注解的propagation属性中定义</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><h4 id="数据库事务并发问题"><a href="#数据库事务并发问题" class="headerlink" title="数据库事务并发问题"></a>数据库事务并发问题</h4><p> 假设现在有两个事务：Transaction01和Transaction02并发执行。</p>
<h5 id="1-脏读"><a href="#1-脏读" class="headerlink" title="1) 脏读"></a>1) 脏读</h5><p> ①Transaction01将某条记录的AGE值从20修改为30。</p>
<p> ②Transaction02读取了Transaction01更新后的值：30。</p>
<p> ③Transaction01回滚，AGE值恢复到了20。</p>
<p> ④Transaction02读取到的30就是一个无效的值。</p>
<h5 id="2-不可重复读"><a href="#2-不可重复读" class="headerlink" title="2) 不可重复读"></a>2) 不可重复读</h5><p> ①Transaction01读取了AGE值为20。</p>
<p> ②Transaction02将AGE值修改为30。</p>
<p> ③Transaction01再次读取AGE值为30，和第一次读取不一致。</p>
<h5 id="3-幻读"><a href="#3-幻读" class="headerlink" title="3) 幻读"></a>3) 幻读</h5><p> ①Transaction01读取了STUDENT表中的一部分数据。</p>
<p> ②Transaction02向STUDENT表中插入了新的行。</p>
<p> ③Transaction01读取了STUDENT表时，多出了一些行。</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。</p>
<p>读未提交：READ UNCOMMITTED<br>允许Transaction01读取Transaction02未提交的修改。</p>
<p>读已提交：READ COMMITTED<br> 要求Transaction01只能读取Transaction02已提交的修改。</p>
<p>可重复读：REPEATABLE READ<br> 确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。</p>
<p>串行化：SERIALIZABLE<br> 确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。</p>
<h1 id="JavaEE"><a href="#JavaEE" class="headerlink" title="JavaEE"></a>JavaEE</h1><h2 id="Mysql什么时候建索引、什么时候不适合建索引"><a href="#Mysql什么时候建索引、什么时候不适合建索引" class="headerlink" title="Mysql什么时候建索引、什么时候不适合建索引"></a>Mysql什么时候建索引、什么时候不适合建索引</h2><h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ul>
<li>主键自动建立唯 一 索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询中与其它表关联的字段，外键关系建立索引</li>
<li>频繁更新的字段不适合创建索引，因为每次更新不单是更新了记录还会更新索引</li>
<li>单键组索引的选择问题，who? 在高并发下领向创建组合索引</li>
<li>意询中排序的字段，排序字段若通过索引法访问将大大提高排序速度</li>
<li>查询中统计或者分组字段</li>
</ul>
<h3 id="哪些情况下不要建立索引"><a href="#哪些情况下不要建立索引" class="headerlink" title="哪些情况下不要建立索引"></a>哪些情况下不要建立索引</h3><ul>
<li><p>表记录太少</p>
<p>Why:提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE.</p>
</li>
<li><p>经常增删改的表</p>
<p>因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。<br>注意，如果某个数据列包含许多重复的内容，为它建立索弓就没有太大的实际效果。</p>
</li>
<li><p>where条件里用不到的字段</p>
</li>
<li><p>过滤性不好的字段</p>
</li>
</ul>
<h2 id="JVM垃圾回收机制、GC发生在JVM哪部分，有几种GC，他们的算法是什么"><a href="#JVM垃圾回收机制、GC发生在JVM哪部分，有几种GC，他们的算法是什么" class="headerlink" title="JVM垃圾回收机制、GC发生在JVM哪部分，有几种GC，他们的算法是什么"></a>JVM垃圾回收机制、GC发生在JVM哪部分，有几种GC，他们的算法是什么</h2><blockquote>
<p>GC 发生在JVM的堆里面</p>
</blockquote>
<p><img src="/images/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="JVM体系结构"><br><img src="/images/GC.png" alt="GC"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识</title>
    <url>/2021/05/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</p>
<span id="more"></span>

<h1 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h1><h2 id="什么是跨平台性？原理是什么"><a href="#什么是跨平台性？原理是什么" class="headerlink" title="什么是跨平台性？原理是什么"></a>什么是跨平台性？原理是什么</h2><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p>
<p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p>
<h2 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h2><ul>
<li>简单易学（Java语言的语法与C语言和C++语言很接近）</li>
<li>面向对象（封装，继承，多态）</li>
<li>平台无关性（Java虚拟机实现平台无关性）</li>
<li>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</li>
<li>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</li>
<li>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</li>
<li>安全性</li>
</ul>
<h2 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="Oracle JDK 和 OpenJDK 的对比"></a>Oracle JDK 和 OpenJDK 的对比</h2><ol>
<li>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全<br> 开源的；</li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</li>
<li>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</li>
<li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</li>
</ol>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h3><p><strong>定义</strong>：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。<br><strong>分类</strong></p>
<ul>
<li>基本数据类型<ul>
<li>数值型</li>
<li>整数类型(byte,short,int,long)</li>
<li>浮点类型(float,double)</li>
<li>字符型(char)</li>
<li>布尔型(boolean)</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ul>
</li>
</ul>
<p><strong>Java基本数据类型图</strong></p>
<p><img src="/images/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.png" alt="Java基本类型"></p>
<h3 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><a href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上" class="headerlink" title="switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上"></a>switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h3><p>在 Java 5 以前，switch(expr)中，expr 只能是 <code>byte、short、char、int</code>。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是<code>enum</code>类型，从 Java 7 开始，expr 还可以是字符串<code>String</code>，但是长整型<code>long</code>在目前所有的版本中都是不可以的</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h3><ul>
<li>super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li>
<li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li>
<li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li>
<li>super()和this()均需放在构造方法内第一行。</li>
<li>尽管可以用this调用一个构造器，但却不能调用两个。</li>
<li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li>
<li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li>
<li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字</li>
</ul>
<h3 id="static存在的主要意义"><a href="#static存在的主要意义" class="headerlink" title="static存在的主要意义"></a>static存在的主要意义</h3><p>static的主要意义是在于创建独立于具体对象的域变量或者方法。<strong>以致于即使没有创建对象，也能使用属性和调用方法！</strong></p>
<p>static关键字还有一个比较关键的作用就是 <strong>用来形成静态代码块以优化程序性能</strong>。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p>
<p>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p>
<h3 id="static的独特之处"><a href="#static的独特之处" class="headerlink" title="static的独特之处"></a>static的独特之处</h3><ol>
<li>被<code>static</code>修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个<br>实例对象，而是被类的实例对象所共享。</li>
<li>在该类被第一次加载的时候，就会去加载被<code>static</code>修饰的部分，而且只在类第一次使用时加载并进行<br>初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</li>
<li><code>static</code>变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</li>
<li>被<code>static</code>修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</li>
</ol>
<h3 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h3><p>因为static是被类的实例对象所共享，因此<strong>如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。</strong></p>
<p>因此比较常见的static应用场景有：</p>
<ol>
<li>修饰成员变量 </li>
<li>修饰成员方法</li>
<li>静态代码块</li>
<li>修饰类【只能修饰内部类也就是静态内部类】</li>
<li>静态导包</li>
</ol>
<p>static注意事项</p>
<ol>
<li>静态只能访问静态</li>
<li>非静态既可以访问非静态的，也可以访问静态的</li>
</ol>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>面向过程：</p>
<p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，性能是最重要的因素。</p>
<p>缺点：没有面向对象易维护、易复用、易扩展</p>
<p>面向对象：</p>
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p>
<p>缺点：性能比面向过程低</p>
<p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p>
<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h3 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h3><p><strong>抽象</strong>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>
<p><strong>封装</strong>：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<p><strong>继承</strong>：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p>关于继承如下 3 点请记住：</p>
<ol>
<li>子类拥有父类非 private 的属性和方法。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<p><strong>多态</strong>：所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p>
<p>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</p>
<p>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p>
<h3 id="什么是多态机制？Java语言是如何实现多态的？"><a href="#什么是多态机制？Java语言是如何实现多态的？" class="headerlink" title="什么是多态机制？Java语言是如何实现多态的？"></a>什么是多态机制？Java语言是如何实现多态的？</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p>
<h4 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h4><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p>
<p>继承：在多态中必须存在有继承关系的子类和父类。</p>
<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>
<p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>
<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>
<p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p>
<h3 id="面向对象五大基本原则是什么（可选）"><a href="#面向对象五大基本原则是什么（可选）" class="headerlink" title="面向对象五大基本原则是什么（可选）"></a>面向对象五大基本原则是什么（可选）</h3><ul>
<li><p>单一职责原则SRP(Single Responsibility Principle)</p>
<p>类的功能要单一，不能包罗万象，跟杂货铺似的。</p>
</li>
<li><p>开放封闭原则OCP(Open－Close Principle)</p>
<p>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</p>
</li>
<li><p>里式替换原则LSP(the Liskov Substitution Principle LSP)</p>
<p>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</p>
</li>
<li><p>依赖倒置原则DIP(the Dependency Inversion Principle DIP)</p>
<p>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</p>
</li>
<li><p>接口分离原则ISP(the Interface Segregation Principle ISP)</p>
<p>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</p>
</li>
</ul>
<h2 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h2><h3 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h3><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</p>
<p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<p><strong>相同点</strong></p>
<ul>
<li>接口和抽象类都不能实例化</li>
<li>都位于继承的顶端，用于被其他实现或继承</li>
<li>都包含抽象方法，其子类都必须覆写这些抽象方法</li>
</ul>
<p><strong>不同点</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>声明</td>
<td>抽象类使用<code>abstract</code>关键字声明</td>
<td>接口使用<code>interface</code>关键字声明</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用<code>extends</code>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>
<td>子类使用<code>implements</code>关键字来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象类中的方法可以是任意访问修饰符</td>
<td>接口方法默认修饰符是<code>public</code>。并且不允许定义为<code>private</code>或者<code>protected</code></td>
</tr>
<tr>
<td>多继承</td>
<td>一个类最多只能继承一个抽象类</td>
<td>一个类可以实现多个接口</td>
</tr>
<tr>
<td>字段声明</td>
<td>抽象类的字段声明可以是任意的</td>
<td>接口的字段默认都是<code>static</code>和<code>final</code>的</td>
</tr>
</tbody></table>
<p><strong>备注</strong>：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p>
<p>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</p>
<p>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p>
<ul>
<li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li>
<li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li>
</ul>
<h3 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h3><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。</p>
<p>抽象类不能直接实例化，普通类可以直接实例化。</p>
<h3 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为<code>final</code>该类就不能被继承，这样彼此就会产生矛盾，所以<code>final</code>不能修饰抽象类</p>
<h2 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h2><h3 id="成员变量与局部变量的区别有哪些"><a href="#成员变量与局部变量的区别有哪些" class="headerlink" title="成员变量与局部变量的区别有哪些"></a>成员变量与局部变量的区别有哪些</h3><p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</p>
<p>成员变量：方法外部，类内部定义的变量</p>
<p>局部变量：类的方法中的变量。</p>
<h4 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h4><p>作用域</p>
<ul>
<li>成员变量：针对整个类有效。</li>
<li>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</li>
</ul>
<p>存储位置</p>
<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</li>
<li>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</li>
</ul>
<p>生命周期</p>
<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li>
<li>局部变量：当方法调用完，或者语句结束后，就自动释放。</li>
</ul>
<p>初始值</p>
<ul>
<li>成员变量：有默认初始值。</li>
<li>局部变量：没有默认初始值，使用前必须赋值。</li>
</ul>
<p>使用原则</p>
<ul>
<li>在使用变量时需要遵循的原则为：就近原则</li>
<li>首先在局部范围找，有就使用；接着在成员位置找。</li>
</ul>
<h3 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h3><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<h3 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h3><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h3 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h3><ul>
<li>名字与类名相同；</li>
<li>没有返回值，但不能用void声明构造函数；</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<h3 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h3><p>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</p>
<p>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p>
<h3 id="静态变量与普通变量区别"><a href="#静态变量与普通变量区别" class="headerlink" title="静态变量与普通变量区别"></a>静态变量与普通变量区别</h3><p><code>static</code>变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p>
<p>还有一点就是<code>static</code>成员变量的初始化顺序按照定义的顺序进行初始化。</p>
<h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><p>静态方法和实例方法的区别主要体现在两个方面：</p>
<ol>
<li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li>
</ol>
<h3 id="在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的？"></a>在一个静态方法内调用一个非静态成员为什么是非法的？</h3><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<h3 id="什么是方法的返回值？返回值的作用是什么？"><a href="#什么是方法的返回值？返回值的作用是什么？" class="headerlink" title="什么是方法的返回值？返回值的作用是什么？"></a>什么是方法的返回值？返回值的作用是什么？</h3><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h3><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。</p>
<h3 id="内部类的分类有哪些"><a href="#内部类的分类有哪些" class="headerlink" title="内部类的分类有哪些"></a>内部类的分类有哪些</h3><p>内部类可以分为四种：<strong>静态内部类</strong>、<strong>成员内部类</strong>、<strong>局部内部类</strong>、<strong>匿名内部类</strong>。</p>
<p><strong>静态内部类：</strong></p>
<p>定义在类内部的静态类，就是静态内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static variable:&quot;</span> + radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">StaticInner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner();</span><br><span class="line">        <span class="type">StaticInner</span> <span class="variable">inner2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInner</span>();</span><br><span class="line">        inner.visit();</span><br><span class="line">        inner2.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式： <code>new 外部类.静态内部类()</code> ,如果在外部类里可以直接<code>StaticInner inner2 = new StaticInner();</code></p>
<p><strong>成员内部类：</strong></p>
<p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static variable:&quot;</span> + radius);</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer variable:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式：<code>外部类实例.new 内部类()</code></p>
<p><strong>局部内部类：</strong></p>
<p>定义在方法中的内部类，就是局部内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">out_a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">STATIC_b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFunctionClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inner_c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(out_a);</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(inner_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStaticFunctionClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span></span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内， <code>new 内部类()</code> ，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStaticFunctionClass</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>匿名内部类：</strong></p>
<p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;匿名内部类&quot;</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匿名内部类必须继承或实现一个已有的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了没有名字，匿名内部类还有以下特点：</p>
<ul>
<li>匿名内部类必须继承一个抽象类或者实现一个接口。</li>
<li>匿名内部类不能定义任何静态成员和静态方法。</li>
<li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li>
</ul>
<p>匿名内部类创建方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类/接口&#123;</span><br><span class="line">	<span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类的优点"><a href="#内部类的优点" class="headerlink" title="内部类的优点"></a>内部类的优点</h3><ul>
<li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li>
<li>内部类不为同一包的其他类所见，具有很好的封装性；</li>
<li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li>
<li>匿名内部类可以很方便的定义回调。</li>
</ul>
<h3 id="内部类有哪些应用场景"><a href="#内部类有哪些应用场景" class="headerlink" title="内部类有哪些应用场景"></a>内部类有哪些应用场景</h3><ol>
<li>一些多算法场合</li>
<li>解决一些非面向对象的语句块。</li>
<li>适当使用内部类，使得代码更加灵活和富有扩展性。</li>
<li>当某个类除了它的外部类，不再被其他的类使用时。</li>
</ol>
<h3 id="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上<code>final</code>？</h3><p>先看这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">	void outMethod()&#123;</span><br><span class="line">		final int a = 10;</span><br><span class="line">		class Inner &#123;</span><br><span class="line">			void innerMethod()&#123;</span><br><span class="line">				System.out.println(a);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上例子，为什么要加<code>final</code>呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非<code>final</code>的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了<code>final</code>，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p>
<h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><h3 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）"></a>构造器（constructor）是否可被重写（override）</h3><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>
<h3 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h3><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<p>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p>
<p>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</p>
<h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><h3 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</h3><p>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p>
<h3 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="为什么 Java 中只有值传递"></a>为什么 Java 中只有值传递</h3><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>
<p>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p>
<h3 id="值传递和引用传递有什么区别"><a href="#值传递和引用传递有什么区别" class="headerlink" title="值传递和引用传递有什么区别"></a>值传递和引用传递有什么区别</h3><p>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>
<p>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h3 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种?"></a>java 中 IO 流分为几种?</h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
<ul>
<li><code>InputStream/Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream/Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>按操作方式分类结构图：</p>
<p><img src="/images/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/IO%E6%B5%81%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86.png" alt="IO流操作方式划分"></p>
<p>按操作对象分类结构图：</p>
<p><img src="/images/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/IO%E6%B5%81%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%92%E5%88%86.png" alt="IO流操作对象划分"></p>
<h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h3><ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
<h3 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h3><ul>
<li>Files. exists()：检测文件路径是否存在。</li>
<li>Files. createFile()：创建文件。</li>
<li>Files. createDirectory()：创建文件夹。</li>
<li>Files. delete()：删除一个文件或目录。</li>
<li>Files. copy()：复制文件。</li>
<li>Files. move()：移动文件。</li>
<li>Files. size()：查看文件个数。</li>
<li>Files. read()：读取文件。</li>
<li>Files. write()：写入文件。</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>静态编译和动态编译</p>
<ul>
<li>静态编译：在编译时确定类型，绑定对象</li>
<li>动态编译：运行时确定类型，绑定对象</li>
</ul>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul>
<li>优点： 运行期类型的判断，动态加载类，提高代码灵活度。</li>
<li>缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS开启端口转发</title>
    <url>/2020/07/03/MacOS%E5%BC%80%E5%90%AF%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<h3 id="在-x2F-etc-x2F-pf-anchors-x2F-目录下新建一个名为com-pow文件，内容如下"><a href="#在-x2F-etc-x2F-pf-anchors-x2F-目录下新建一个名为com-pow文件，内容如下" class="headerlink" title="在&#x2F;etc&#x2F;pf.anchors&#x2F;目录下新建一个名为com.pow文件，内容如下"></a>在&#x2F;etc&#x2F;pf.anchors&#x2F;目录下新建一个名为com.pow文件，内容如下</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rdr pass on en0 inet proto tcp from any to any port 8080 -&gt; 127.0.0.1 port 8080</span><br><span class="line">rdr pass on en5 inet proto tcp from any to any port 8080 -&gt; 127.0.0.1 port 8080</span><br></pre></td></tr></table></figure>

<p>上面的配置标表示的意思是将从en0和en5，目的端口为8080的包转发到8080端口上</p>
<h3 id="使用pfctl命令检测配置文件"><a href="#使用pfctl命令检测配置文件" class="headerlink" title="使用pfctl命令检测配置文件"></a>使用<code>pfctl</code>命令检测配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pfctl -vnf /etc/pf.anchors/com.pow</span><br></pre></td></tr></table></figure>

<h3 id="修改-etc-pf-conf配置文件"><a href="#修改-etc-pf-conf配置文件" class="headerlink" title="修改/etc/pf.conf配置文件"></a>修改<code>/etc/pf.conf</code>配置文件</h3><p><code>pf</code>启动时会自动装载<code>/etc/pf.conf</code>文件，因此将<code>anchor</code>文件链接到<code>/etc/pf.conf</code>，转发规则就会自动建立了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在rdr-anchor <span class="string">&quot;com.apple/*&quot;</span>下面增加：</span></span><br><span class="line"></span><br><span class="line">rdr-anchor &quot;pow&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在load anchor <span class="string">&quot;com.apple&quot;</span> from <span class="string">&quot;/etc/pf.anchors/com.apple&quot;</span>后面添加：</span></span><br><span class="line"></span><br><span class="line">load anchor &quot;pow&quot; from &quot;/etc/pf.anchors/com.pow&quot;</span><br></pre></td></tr></table></figure>



<p>修改后的配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrub-anchor &quot;com.apple/*&quot;</span><br><span class="line">nat-anchor &quot;com.apple/*&quot;</span><br><span class="line">rdr-anchor &quot;com.apple/*&quot;</span><br><span class="line">rdr-anchor &quot;pow&quot;</span><br><span class="line">dummynet-anchor &quot;com.apple/*&quot;</span><br><span class="line">anchor &quot;com.apple/*&quot;</span><br><span class="line">load anchor &quot;com.apple&quot; from &quot;/etc/pf.anchors/com.apple&quot;</span><br><span class="line">load anchor &quot;pow&quot; from &quot;/etc/pf.anchors/com.pow&quot;</span><br></pre></td></tr></table></figure>

<p>导入并运行<code>pf</code>命令</p>
<p>一定要导入并允许运行<code>pf</code>的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pfctl -evf /etc/pf.anchors/com.pow</span><br></pre></td></tr></table></figure>


<p>设置<code>pf</code>开机自动打开</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pfctl -e</span><br></pre></td></tr></table></figure>

<p>如果想要关闭<code>pf</code>，命令是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pfctl -d1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins环境安装</title>
    <url>/2019/01/11/Jenkins%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>　　Jenkins是一款由Java编写的开源的持续集成工具。<br>　　Jenkins提供了软件开发的持续集成服务。它运行在Servlet容器中（例如Apache Tomcat）。它支持软件配置管理（SCM）工具（包括AccuRev SCM、CVS、Subversion、Git、Perforce、Clearcase和RTC），可以执行基于Apache Ant和Apache Maven的项目，以及任意的Shell脚本和Windows批处理命令。Jenkins的主要开发者是川口耕介。Jenkins是在MIT许可证下发布的自由软件。<br>　　可以通过各种手段触发构建。例如提交给版本控制系统时被触发，也可以通过类似Cron的机制调度，也可以在其他的构建已经完成时，还可以通过一个特定的URL进行请求。</p>
<span id="more"></span>

<h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><h3 id="JDK环境安装"><a href="#JDK环境安装" class="headerlink" title="JDK环境安装"></a>JDK环境安装</h3><p>安装wget，wget是一个从网络上自动下载文件的自由工具，支持通过 HTTP、HTTPS、FTP 三个最常见的 TCP&#x2F;IP协议 下载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install wget</span><br></pre></td></tr></table></figure>
<p>下载<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JDK</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F;oraclelicense=accept-securebackup-cookie&quot; https://download.oracle.com/otn-pub/java/jdk/8u191-b12/2787e4a523244c269598db4e85c51e0c/jdk-8u191-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u191-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p>配置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">#set java environment</span><br><span class="line">JAVA_HOME=/usr/java/jdk1.8</span><br><span class="line">CLASS_PATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export PATH JAVA_HOME CLASS_PATH</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h3 id="Maven安装"><a href="#Maven安装" class="headerlink" title="Maven安装"></a>Maven安装</h3><p>下载<a href="http://mirror.bit.edu.cn/apache/maven/maven-3/">Maven</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://mirror.bit.edu.cn/apache/maven/maven-3/3.6.0/binaries/apache-maven-3.6.0-bin.tar.gz</span><br></pre></td></tr></table></figure>
<p>添加阿里的Maven仓库节点配置<code>conf/settings.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>配置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Maven environment</span><br><span class="line">MAVEN_HOME=/usr/maven</span><br><span class="line">PATH=$PATH:$MAVEN_HOME/bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>
<h3 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h3><p>下载<a href="http://updates.jenkins-ci.org/download/war/">Jenkins</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://updates.jenkins-ci.org/download/war/2.157/jenkins.war</span><br></pre></td></tr></table></figure>
<p>启动Jenkins war包，默认8080端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar jenkins.war</span><br></pre></td></tr></table></figure>
<p>开放端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=8080/tcp --permanent   #添加规则</span><br><span class="line">firewall-cmd --reload                          #重新加载防火墙配置</span><br></pre></td></tr></table></figure>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM核心知识点</title>
    <url>/2021/06/01/JVM%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="Java8-JVM内存结构"><a href="#Java8-JVM内存结构" class="headerlink" title="Java8  JVM内存结构"></a>Java8  JVM内存结构</h1><p>基本结构与之前类似，只是Java8取消了之前的“永久代”，取而代之的是“元空间”——<strong>Metaspace</strong>，两者本质是一样的。“永久代”使用的是JVM的堆内存，而“元空间”是直接使用的本机物理内存。</p>
<p><img src="/./images/JVM/JVMMem.png"></p>
<span id="more"></span>

<h1 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h1><h2 id="如果判断一个对象可以被回收？"><a href="#如果判断一个对象可以被回收？" class="headerlink" title="如果判断一个对象可以被回收？"></a>如果判断一个对象可以被回收？</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>维护一个计数器，如果有对该对象的引用，计数器+1，反之-1。无法解决循环引用的问题。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>从一组名为“GC Roots”的根节点对象出发，向下遍历。那些没有被遍历到、与GC Roots形成通路的对象，会被标记为“回收”。</p>
<h2 id="哪些对象可以作为GC-Roots？"><a href="#哪些对象可以作为GC-Roots？" class="headerlink" title="哪些对象可以作为GC Roots？"></a>哪些对象可以作为GC Roots？</h2><ol>
<li>虚拟机栈（栈帧中的局部变量）中引用的对象。</li>
<li>本地方法栈（native）中引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
</ol>
<h1 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h1><h2 id="JVM-三种类型参数"><a href="#JVM-三种类型参数" class="headerlink" title="JVM 三种类型参数"></a>JVM 三种类型参数</h2><h3 id="标配参数"><a href="#标配参数" class="headerlink" title="标配参数"></a>标配参数</h3><p>比如<code>-version</code>、<code>-help</code>、<code>-showversion</code>等，几乎不会改变。</p>
<h3 id="X参数"><a href="#X参数" class="headerlink" title="X参数"></a>X参数</h3><p>用得不多，比如<code>-Xint</code>，解释执行模式；<code>-Xcomp</code>，编译模式；<code>-Xmixed</code>，开启混合模式（默认）。</p>
<p><img src="/./images/JVM/InkedJVMXParam_LI.jpg"></p>
<h3 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h3><p>重要，用于JVM调优。</p>
<h2 id="JVM-XX参数"><a href="#JVM-XX参数" class="headerlink" title="JVM XX参数"></a>JVM XX参数</h2><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p><strong>公式</strong>：<code>-XX:+某个属性</code>、<code>-XX:-某个属性</code>，开启或关闭某个功能。比如<code>-XX:+PrintGCDetails</code>，开启GC详细信息。</p>
<h3 id="KV键值类型"><a href="#KV键值类型" class="headerlink" title="KV键值类型"></a>KV键值类型</h3><p><strong>公式</strong>：<code>-XX:属性key=值value</code>。比如<code>-XX:Metaspace=128m</code>、<code>-XX:MaxTenuringThreshold=15</code>。</p>
<h2 id="JVM-Xms-x2F-Xmx参数"><a href="#JVM-Xms-x2F-Xmx参数" class="headerlink" title="JVM Xms&#x2F;Xmx参数"></a>JVM Xms&#x2F;Xmx参数</h2><p><code>-Xms</code>和<code>-Xmx</code>十分常见，用于设置<strong>初始堆大小</strong>和<strong>最大堆大小</strong>。第一眼看上去，既不像X参数，也不像XX参数。实际上<code>-Xms</code>等价于<code>-XX:InitialHeapSize</code>，<code>-Xmx</code>等价于<code>-XX:MaxHeapSize</code>。所以<code>-Xms</code>和<code>-Xmx</code>属于XX参数。</p>
<h2 id="JVM-查看参数"><a href="#JVM-查看参数" class="headerlink" title="JVM 查看参数"></a>JVM 查看参数</h2><h3 id="查看某个参数"><a href="#查看某个参数" class="headerlink" title="查看某个参数"></a>查看某个参数</h3><p>使用<code>jps -l</code>配合<code>jinfo -flag JVM参数 pid</code> 。先用<code>jsp -l</code>查看java进程，选择某个进程号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">17888</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class="line"><span class="number">5360</span> org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line"><span class="number">18052</span> demo3.demo3</span><br></pre></td></tr></table></figure>

<p><code>jinfo -flag PrintGCDetails 18052</code>可以查看18052 Java进程的<code>PrintGCDetails</code>参数信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:-PrintGCDetails</span><br></pre></td></tr></table></figure>

<h3 id="查看所有参数"><a href="#查看所有参数" class="headerlink" title="查看所有参数"></a>查看<strong>所有</strong>参数</h3><p>使用<code>jps -l</code>配合<code>jinfo -flags pid</code>可以查看所有参数。</p>
<p>也可以使用<code>java -XX:+PrintFlagsInitial</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">     <span class="type">intx</span> <span class="variable">ActiveProcessorCount</span>                      <span class="operator">=</span> -<span class="number">1</span>            &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveSizeDecrementScaleFactor</span>          <span class="operator">=</span> <span class="number">4</span>             &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveSizeMajorGCDecayTimeScale</span>         <span class="operator">=</span> <span class="number">10</span>            &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveSizePausePolicy</span>                   <span class="operator">=</span> <span class="number">0</span>             &#123;product&#125;</span><br><span class="line">······</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">YoungPLABSize</span>                             <span class="operator">=</span> <span class="number">4096</span>          &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">ZeroTLAB</span>                                  <span class="operator">=</span> <span class="literal">false</span>         &#123;product&#125;</span><br><span class="line">     <span class="type">intx</span> <span class="variable">hashCode</span>                                  <span class="operator">=</span> <span class="number">5</span>             &#123;product&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查看修改后的参数"><a href="#查看修改后的参数" class="headerlink" title="查看修改后的参数"></a>查看<strong>修改</strong>后的参数</h3><p>使用<code>java -XX:PrintFlagsFinal</code>可以查看修改后的参数，与上面类似。只是修改过后是<code>:=</code>而不是<code>=</code>。</p>
<h3 id="查看常见参数"><a href="#查看常见参数" class="headerlink" title="查看常见参数"></a>查看<strong>常见</strong>参数</h3><p>如果不想查看所有参数，可以用<code>-XX:+PrintCommandLineFlags</code>查看常用参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=<span class="number">132375936</span> -XX:MaxHeapSize=<span class="number">2118014976</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure>

<h2 id="JVM-常用参数"><a href="#JVM-常用参数" class="headerlink" title="JVM 常用参数"></a>JVM 常用参数</h2><h3 id="Xmx-x2F-Xms"><a href="#Xmx-x2F-Xms" class="headerlink" title="-Xmx&#x2F;-Xms"></a>-Xmx&#x2F;-Xms</h3><p>最大和初始堆大小。最大默认为物理内存的1&#x2F;4，初始默认为物理内存的1&#x2F;64。</p>
<h3 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h3><p>等价于<code>-XX:ThresholdStackSize</code>。用于设置单个栈的大小，系统默认值是0，<strong>不代表栈大小为0</strong>。而是根据操作系统的不同，有不同的值。比如64位的Linux系统是1024K，而Windows系统依赖于虚拟内存。</p>
<h3 id="Xmn"><a href="#Xmn" class="headerlink" title="-Xmn"></a>-Xmn</h3><p>新生代大小，一般不调。</p>
<h3 id="XX-MetaspaceSize"><a href="#XX-MetaspaceSize" class="headerlink" title="-XX:MetaspaceSize"></a>-XX:MetaspaceSize</h3><p>设置元空间大小。</p>
<h3 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a>-XX:+PrintGCDetails</h3><p>输出GC收集信息，包含<code>GC</code>和<code>Full GC</code>信息。</p>
<h3 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h3><p>新生代中，<code>Eden</code>区和两个<code>Survivor</code>区的比例，默认是<code>8:1:1</code>。通过<code>-XX:SurvivorRatio=4</code>改成<code>4:1:1</code></p>
<h3 id="XX-NewRatio"><a href="#XX-NewRatio" class="headerlink" title="-XX:NewRatio"></a>-XX:NewRatio</h3><p>老生代和新年代的比列，默认是2，即老年代占2，新生代占1。如果改成<code>-XX:NewRatio=4</code>，则老年代占4，新生代占1。</p>
<h3 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h3><p>新生代设置进入老年代的时间，默认是新生代逃过15次GC后，进入老年代。如果改成0，那么对象不会在新生代分配，直接进入老年代。</p>
<h1 id="四大引用"><a href="#四大引用" class="headerlink" title="四大引用"></a>四大引用</h1><p>以下Demo都需要设置<code>-Xmx</code>和<code>-Xms</code>，不然系统默认很大，很难演示。</p>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>使用<code>new</code>方法创造出来的对象，默认都是强引用。GC的时候，就算<strong>内存不够</strong>，抛出<code>OutOfMemoryError</code>也不会回收对象，<strong>死了也不回收</strong>。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/StrongReferenceDemo.java">StrongReferenceDemo</a>。</p>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>需要用<code>Object.Reference.SoftReference</code>来显示创建。<strong>如果内存够</strong>，GC的时候<strong>不回收</strong>。<strong>内存不够</strong>，<strong>则回收</strong>。常用于内存敏感的应用，比如高速缓存。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/SoftReferenceDemo.java">SoftReferenceDemo</a>。</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>需要用<code>Object.Reference.WeakReference</code>来显示创建。<strong>无论内存够不够，GC的时候都回收</strong>，也可以用在高速缓存上。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/WeakReferenceDemo.java">WeakReferenceDemo</a></p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>传统的<code>HashMap</code>就算<code>key==null</code>了，也不会回收键值对。但是如果是<code>WeakHashMap</code>，一旦内存不够用时，且<code>key==null</code>时，会回收这个键值对。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/WeakHashMapDemo.java">WeakHashMapDemo</a>。</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>软应用和弱引用可以通过<code>get()</code>方法获得对象，但是虚引用不行。虚引形同虚设，在任何时候都可能被GC，不能单独使用，必须配合<strong>引用队列（ReferenceQueue）</strong>来使用。设置虚引用的<strong>唯一目的</strong>，就是在这个对象被回收时，收到一个<strong>通知</strong>以便进行后续操作，有点像<code>Spring</code>的后置通知。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/PhantomReferenceDemo.java">PhantomReferenceDemo</a>。</p>
<h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><p>弱引用、虚引用被回收后，会被放到引用队列里面，通过<code>poll</code>方法可以得到。关于引用队列和弱、虚引用的配合使用，见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/ReferenceQueueDemo.java">ReferenceQueueDemo</a>。</p>
<h1 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h1><h2 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h2><p>栈满会抛出该错误。无限递归就会导致StackOverflowError，是<code>java.lang.Throwable</code>→<code>java.lang.Error</code>→<code>java.lang.VirtualMachineError</code>下的错误。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/StackOverflowErrorDemo.java">StackOverflowErrorDemo</a>。</p>
<h2 id="OOM—Java-head-space"><a href="#OOM—Java-head-space" class="headerlink" title="OOM—Java head space"></a>OOM—Java head space</h2><p>栈满会抛出该错误。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/JavaHeapSpaceDemo.java">JavaHeapSpaceDemo</a>。</p>
<h2 id="OOM—GC-overhead-limit-exceeded"><a href="#OOM—GC-overhead-limit-exceeded" class="headerlink" title="OOM—GC overhead limit exceeded"></a>OOM—GC overhead limit exceeded</h2><p>这个错误是指：GC的时候会有“Stop the World”，STW越小越好，正常情况是GC只会占到很少一部分时间。但是如果用超过98%的时间来做GC，而且收效甚微，就会被JVM叫停。下例中，执行了多次<code>Full GC</code>，但是内存回收很少，最后抛出了<code>OOM:GC overhead limit exceeded</code>错误。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/GCOverheadDemo.java">GCOverheadDemo</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;496K(2560K)] 2048K-&gt;960K(9728K), <span class="number">0.0036555</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2544K-&gt;489K(2560K)] 3008K-&gt;2689K(9728K), <span class="number">0.0060306</span> secs] [Times: user=<span class="number">0.08</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2537K-&gt;512K(2560K)] 4737K-&gt;4565K(9728K), <span class="number">0.0050620</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2560K-&gt;496K(2560K)] 6613K-&gt;6638K(9728K), <span class="number">0.0064025</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2048K-&gt;860K(2560K)] [ParOldGen: 6264K-&gt;7008K(7168K)] 8312K-&gt;7869K(9728K), [Metaspace: 3223K-&gt;3223K(1056768K)], <span class="number">0.1674947</span> secs] [Times: user=<span class="number">0.63</span> sys=<span class="number">0.00</span>, real=<span class="number">0.17</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2048K-&gt;2006K(2560K)] [ParOldGen: 7008K-&gt;7008K(7168K)] 9056K-&gt;9015K(9728K), [Metaspace: 3224K-&gt;3224K(1056768K)], <span class="number">0.1048666</span> secs] [Times: user=<span class="number">0.45</span> sys=<span class="number">0.00</span>, real=<span class="number">0.10</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7082K-&gt;7082K(7168K)] 9130K-&gt;9130K(9728K), [Metaspace: 3313K-&gt;3313K(1056768K)], <span class="number">0.0742516</span> secs] [Times: user=<span class="number">0.28</span> sys=<span class="number">0.00</span>, real=<span class="number">0.07</span> secs] </span><br><span class="line"></span><br><span class="line">·······</span><br><span class="line"></span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7084K-&gt;7084K(7168K)] 9132K-&gt;9132K(9728K), [Metaspace: 3313K-&gt;3313K(1056768K)], <span class="number">0.0738461</span> secs] [Times: user=<span class="number">0.36</span> sys=<span class="number">0.02</span>, real=<span class="number">0.07</span> secs] </span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> [Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2047K-&gt;0K(2560K)] [ParOldGen: 7119K-&gt;647K(7168K)] 9167K-&gt;647K(9728K), [Metaspace: 3360K-&gt;3360K(1056768K)], <span class="number">0.0129597</span> secs] [Times: user=<span class="number">0.11</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">	at java.lang.Integer.toString(Integer.java:<span class="number">401</span>)</span><br><span class="line">	at java.lang.String.valueOf(String.java:<span class="number">3099</span>)</span><br><span class="line">	at jvm.GCOverheadDemo.main(GCOverheadDemo.java:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<h2 id="OOM—GC-Direct-buffer-memory"><a href="#OOM—GC-Direct-buffer-memory" class="headerlink" title="OOM—GC Direct buffer memory"></a>OOM—GC Direct buffer memory</h2><p>在写<code>NIO</code>程序的时候，会用到<code>ByteBuffer</code>来读取和存入数据。与Java堆的数据不一样，<code>ByteBuffer</code>使用<code>native</code>方法，直接在<strong>堆外分配内存</strong>。当堆外内存（也即本地物理内存）不够时，就会抛出这个异常。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/DirectBufferMemoryDemo.java">DirectBufferMemoryDemo</a>。</p>
<h2 id="OOM—unable-to-create-new-native-thread"><a href="#OOM—unable-to-create-new-native-thread" class="headerlink" title="OOM—unable to create new native thread"></a>OOM—unable to create new native thread</h2><p>在高并发应用场景时，如果创建超过了系统默认的最大线程数，就会抛出该异常。Linux单个进程默认不能超过1024个线程。<strong>解决方法</strong>要么降低程序线程数，要么修改系统最大线程数<code>vim /etc/security/limits.d/90-nproc.conf</code>。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/UnableCreateNewThreadDemo.java">UnableCreateNewThreadDemo</a></p>
<h2 id="OOM—Metaspace"><a href="#OOM—Metaspace" class="headerlink" title="OOM—Metaspace"></a>OOM—Metaspace</h2><p>元空间满了就会抛出这个异常。</p>
<h1 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h1><h2 id="四大垃圾收集算法"><a href="#四大垃圾收集算法" class="headerlink" title="四大垃圾收集算法"></a>四大垃圾收集算法</h2><h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p><img src="/./images/JVM/GCbq.png"></p>
<p><img src="/images/JVM/GCbz.png"></p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p><img src="/images/JVM/GCbq.png"></p>
<p><img src="/images/JVM/GCbq2.png"></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="/images/JVM/GCfz.png"></p>
<p><img src="/images/JVM/GCfz2.png"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>准确来讲，跟前面三种算法有所区别。分代收集算法就是根据对象的年代，采用上述三种算法来收集。</p>
<ol>
<li>对于新生代：每次GC都有大量对象死去，存活的很少，常采用复制算法，只需要拷贝很少的对象。</li>
<li>对于老年代：常采用标整或者标清算法。</li>
</ol>
<h2 id="四种垃圾收集器"><a href="#四种垃圾收集器" class="headerlink" title="四种垃圾收集器"></a>四种垃圾收集器</h2><p>Java 8可以将垃圾收集器分为四类。</p>
<h3 id="串行收集器Serial"><a href="#串行收集器Serial" class="headerlink" title="串行收集器Serial"></a>串行收集器Serial</h3><p>为单线程环境设计且<strong>只使用一个线程</strong>进行GC，会暂停所有用户线程，不适用于服务器。就像去餐厅吃饭，只有一个清洁工在打扫。</p>
<h3 id="并行收集器Parrallel"><a href="#并行收集器Parrallel" class="headerlink" title="并行收集器Parrallel"></a>并行收集器Parrallel</h3><p>使用<strong>多个线程</strong>并行地进行GC，会暂停所有用户线程，适用于科学计算、大数据后台，交互性不敏感的场合。多个清洁工同时在打扫。</p>
<h3 id="并发收集器CMS"><a href="#并发收集器CMS" class="headerlink" title="并发收集器CMS"></a>并发收集器CMS</h3><p>用户线程和GC线程同时执行（不一定是并行，交替执行），GC时不需要停顿用户线程，互联网公司多用，适用对响应时间有要求的场合。清洁工打扫的时候，也可以就餐。</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>对内存的划分与前面3种很大不同，将堆内存分割成不同的区域，然后并发地进行垃圾回收。</p>
<h2 id="默认垃圾收集器"><a href="#默认垃圾收集器" class="headerlink" title="默认垃圾收集器"></a>默认垃圾收集器</h2><h3 id="默认收集器有哪些？"><a href="#默认收集器有哪些？" class="headerlink" title="默认收集器有哪些？"></a>默认收集器有哪些？</h3><p>有<code>Serial</code>、<code>Parallel</code>、<code>ConcMarkSweep</code>（CMS）、<code>ParNew</code>、<code>ParallelOld</code>、<code>G1</code>。还有一个<code>SerialOld</code>，快被淘汰了。</p>
<h3 id="查看默认垃圾修改器"><a href="#查看默认垃圾修改器" class="headerlink" title="查看默认垃圾修改器"></a>查看默认垃圾修改器</h3><p>使用<code>java -XX:+PrintCommandLineFlags</code>即可看到，Java 8默认使用<code>-XX:+UseParallelGC</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=<span class="number">132375936</span> -XX:MaxHeapSize=<span class="number">2118014976</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure>

<h2 id="七大垃圾收集器"><a href="#七大垃圾收集器" class="headerlink" title="七大垃圾收集器"></a>七大垃圾收集器</h2><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p><code>Serial</code>、<code>Parallel Scavenge</code>、<code>ParNew</code>用户回收新生代；<code>SerialOld</code>、<code>ParallelOld</code>、<code>CMS</code>用于回收老年代。而<code>G1</code>收集器，既可以回收新生代，也可以回收老年代。</p>
<p><img src="/images/JVM/GCqi.png"></p>
<p>连线表示可以搭配使用，红叉表示不推荐一同使用，比如新生代用<code>Serial</code>，老年代用<code>CMS</code>。</p>
<p><img src="/images/JVM/GCqi2.png"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>年代最久远，是<code>Client VM</code>模式下的默认新生代收集器，使用<strong>复制算法</strong>。<strong>优点</strong>：单个线程收集，没有线程切换开销，拥有最高的单线程GC效率。<strong>缺点</strong>：收集的时候会暂停用户线程。</p>
<p>使用<code>-XX:+UseSerialGC</code>可以显式开启，开启后默认使用<code>Serial</code>+<code>SerialOld</code>的组合。</p>
<p><img src="/images/JVM/serial.jpeg"></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>也就是<code>Serial</code>的多线程版本，GC的时候不再是一个线程，而是多个，是<code>Server VM</code>模式下的默认新生代收集器，采用<strong>复制算法</strong>。</p>
<p>使用<code>-XX:+UseParNewGC</code>可以显式开启，开启后默认使用<code>ParNew</code>+<code>SerialOld</code>的组合。但是由于<code>SerialOld</code>已经过时，所以建议配合<code>CMS</code>使用。</p>
<p><img src="/images/JVM/parnew.jpeg"></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p><code>ParNew</code>收集器仅在新生代使用多线程收集，老年代默认是<code>SerialOld</code>，所以是单线程收集。而<code>Parallel Scavenge</code>在新、老两代都采用多线程收集。<code>Parallel Scavenge</code>还有一个特点就是<strong>吞吐量优先收集器</strong>，可以通过自适应调节，保证最大吞吐量。采用<strong>复制算法</strong>。</p>
<p>使用<code>-XX:+UseParallelGC</code>可以开启， 同时也会使用<code>ParallelOld</code>收集老年代。其它参数，比如<code>-XX:ParallelGCThreads=N</code>可以选择N个线程进行GC，<code>-XX:+UseAdaptiveSizePolicy</code>使用自适应调节策略。</p>
<h3 id="SerialOld收集器"><a href="#SerialOld收集器" class="headerlink" title="SerialOld收集器"></a>SerialOld收集器</h3><p><code>Serial</code>的老年代版本，采用<strong>标整算法</strong>。JDK1.5之前跟<code>Parallel Scavenge</code>配合使用，现在已经不了，作为<code>CMS</code>的后备收集器。</p>
<h3 id="ParallelOld收集器"><a href="#ParallelOld收集器" class="headerlink" title="ParallelOld收集器"></a>ParallelOld收集器</h3><p><code>Parallel</code>的老年代版本，JDK1.6之前，新生代用<code>Parallel</code>而老年代用<code>SerialOld</code>，只能保证新生代的吞吐量。JDK1.8后，老年代改用<code>ParallelOld</code>。</p>
<p>使用<code>-XX:+UseParallelOldGC</code>可以开启， 同时也会使用<code>Parallel</code>收集新生代。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>并发标记清除收集器，是一种以获得<strong>最短GC停顿为</strong>目标的收集器。适用在互联网或者B&#x2F;S系统的服务器上，这类应用尤其重视服务器的<strong>响应速度</strong>，希望停顿时间最短。是<code>G1</code>收集器出来之前的首选收集器。使用<strong>标清算法</strong>。在GC的时候，会与用户线程并发执行，不会停顿用户线程。但是在<strong>标记</strong>的时候，仍然会<strong>STW</strong>。</p>
<p>使用<code>-XX:+UseConcMarkSweepGC</code>开启。开启过后，新生代默认使用<code>ParNew</code>，同时老年代使用<code>SerialOld</code>作为备用。</p>
<p><img src="/images/JVM/cms.jpeg"></p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li><strong>初始标记</strong>：只是标记一下GC Roots能直接关联的对象，速度很快，需要<strong>STW</strong>。</li>
<li><strong>并发标记</strong>：主要标记过程，标记全部对象，和用户线程一起工作，不需要STW。</li>
<li><strong>重新标记</strong>：修正在并发标记阶段出现的变动，需要<strong>STW</strong>。</li>
<li><strong>并发清除</strong>：和用户线程一起，清除垃圾，不需要STW。</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong>：停顿时间少，响应速度快，用户体验好。</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>对CPU资源非常敏感：由于需要并发工作，多少会占用系统线程资源。</li>
<li>无法处理浮动垃圾：由于标记垃圾的时候，用户进程仍然在运行，无法有效处理新产生的垃圾。</li>
<li>产生内存碎片：由于使用<strong>标清算法</strong>，会产生内存碎片。</li>
</ol>
<h3 id="G1收集器-1"><a href="#G1收集器-1" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><code>G1</code>收集器与之前垃圾收集器的一个显著区别就是——之前收集器都有三个区域，新、老两代和元空间。而G1收集器只有G1区和元空间。而G1区，不像之前的收集器，分为新、老两代，而是一个一个Region，每个Region既可能包含新生代，也可能包含老年代。</p>
<p><code>G1</code>收集器既可以提高吞吐量，又可以减少GC时间。最重要的是<strong>STW可控</strong>，增加了预测机制，让用户指定停顿时间。</p>
<p>使用<code>-XX:+UseG1GC</code>开启，还有<code>-XX:G1HeapRegionSize=n</code>、<code>-XX:MaxGCPauseMillis=n</code>等参数可调。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><strong>并行和并发</strong>：充分利用多核、多线程CPU，尽量缩短STW。</li>
<li><strong>分代收集</strong>：虽然还保留着新、老两代的概念，但物理上不再隔离，而是融合在Region中。</li>
<li><strong>空间整合</strong>：<code>G1</code>整体上看是<strong>标整</strong>算法，在局部看又是<strong>复制算法</strong>，不会产生内存碎片。</li>
<li><strong>可预测停顿</strong>：用户可以指定一个GC停顿时间，<code>G1</code>收集器会尽量满足。</li>
</ol>
<h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><p>与<code>CMS</code>类似。</p>
<ol>
<li>初始标记。</li>
<li>并发标记。</li>
<li>最终标记。</li>
<li>筛选回收。</li>
</ol>
<h1 id="附—Linux相关指令"><a href="#附—Linux相关指令" class="headerlink" title="附—Linux相关指令"></a>附—Linux相关指令</h1><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>主要查看<code>%CPU</code>、<code>%MEM</code>，还有<code>load average</code>。<code>load average</code>后面的三个数字，表示系统1分钟、5分钟、15分钟的平均负载值。如果三者平均值高于0.6，则复杂比较高了。当然，用<code>uptime</code>也可以查看。</p>
<h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><p>查看进程、内存、I&#x2F;O等多个系统运行状态。2表示每两秒采样一次，3表示一共采样3次。<code>procs</code>的<code>r</code>表示运行和等待CPU时间片的进程数，原则上1核CPU不要超过2。<code>b</code>是等待资源的进程数，比如磁盘I&#x2F;O、网络I&#x2F;O等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ ~]# vmstat -n 2 3</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 2  0      0 173188 239748 1362628    0    0     0     3   17    8  0  0 99  0  0</span><br><span class="line"> 0  0      0 172800 239748 1362636    0    0     0     0  194  485  1  1 99  0  0</span><br><span class="line"> 1  0      0 172800 239748 1362640    0    0     0     0  192  421  1  1 99  0  0</span><br></pre></td></tr></table></figure>

<h2 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h2><p>查看某个进程的运行信息。</p>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>查看内存信息。</p>
<h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>查看磁盘信息。</p>
<h2 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h2><p>查看磁盘I&#x2F;O信息。比如有时候MySQL在查表的时候，会占用大量磁盘I&#x2F;O，体现在该指令的<code>%util</code>字段很大。对于死循环的程序，CPU占用固然很高，但是磁盘I&#x2F;O不高。</p>
<h2 id="ifstat"><a href="#ifstat" class="headerlink" title="ifstat"></a>ifstat</h2><p>查看网络I&#x2F;O信息，需要安装。</p>
<h1 id="CPU占用过高原因定位"><a href="#CPU占用过高原因定位" class="headerlink" title="CPU占用过高原因定位"></a>CPU占用过高原因定位</h1><p>先用<code>top</code>找到CPU占用最高的进程，然后用<code>ps -mp pid -o THREAD,tid,time</code>，得到该<strong>进程</strong>里面占用最高的<strong>线程</strong>。这个线程是10进制的，将其转成16进制，然后用<code>jstack pid | grep tid</code>可以定位到具体哪一行导致了占用过高。</p>
<h1 id="JVM性能调优和监控工具"><a href="#JVM性能调优和监控工具" class="headerlink" title="JVM性能调优和监控工具"></a>JVM性能调优和监控工具</h1><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>Java版的<code>ps -ef</code>查看所有JVM进程。</p>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>查看JVM中运行线程的状态，比较重要。可以定位CPU占用过高位置，定位死锁位置。</p>
<h2 id="jinfo-x2F-jstat"><a href="#jinfo-x2F-jstat" class="headerlink" title="jinfo&#x2F;jstat"></a>jinfo&#x2F;jstat</h2><p><code>jinfo</code>查看JVM的运行环境参数，比如默认的JVM参数等。<code>jstat</code>统计信息监视工具。</p>
<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>JVM内存映像工具。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试题小结</title>
    <url>/2021/07/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a><strong>java基础</strong></h1><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a><strong>接口和抽象类的区别</strong></h2><p>抽象类可以存在普通成员函数，而接口中只能存在public abstract 方法。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的。 抽象类只能继承一个，接口可以实现多个。</p>
<p>接口的设计目的，是对类的行为进行约束(更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行为)，也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无， 但不对如何实现行为进行限制。</p>
<p>而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行 为的实现方式一致时(A的非真子集，记为B)，可以让这些类都派生于一个抽象类。在这个抽象类中实 现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己 实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来(否则当调用到A-B时，无法执 行)。</p>
<p>抽象类是对类本质的抽象，表达的是 is a 的关系，比如: BMW is a Car 。抽象类包含并实现子类的通 用特性，将子类存在差异化的特性进行抽象，交由子类去实现。</p>
<p>而接口是对行为的抽象，表达的是 like a 的关系。比如: Bird like a Aircraft (像飞行器一样可以 飞)，但其本质上 is a Bird 。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、 是如何实现的，接口并不关心。</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用场景:当你关注一个事物的本质的时候，用抽象类;当你关注一个操作的时候，用接口。</span><br><span class="line">抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说(从实际设计上来说也是)每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度</span><br></pre></td></tr></table></figure>

<h2 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a><strong>List和Set的区别</strong></h2><p>List:有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出 所有元素，在逐一遍历，还可以使用get(int index)获取指定下标的元素</p>
<p>Set:无序，不可重复，最多允许有一个Null元素对象，取元素时只能用Iterator接口取得所有元 素，在逐一遍历各个元素</p>
<h2 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a><strong>ArrayList和LinkedList区别</strong></h2><p>ArrayList:基于动态数组，连续内存存储，适合下标访问(随机访问)，扩容机制:因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会 涉及到元素的移动(往后复制一份，插入新元素)，使用尾插法并指定初始容量可以极大提升性能、甚至超过linkedList(需要创建大量的node对象)</p>
<p>LinkedList:基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询:需要逐 一遍历</p>
<p>遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时都需 要对list重新进行遍历，性能消耗极大。 另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结果为空时会遍历整个列表。</p>
<h2 id="HashMap和HashTable有什么区别-其底层实现是什么"><a href="#HashMap和HashTable有什么区别-其底层实现是什么" class="headerlink" title="HashMap和HashTable有什么区别?其底层实现是什么?"></a><strong>HashMap和HashTable有什么区别?其底层实现是什么?</strong></h2><p>区别：</p>
<ol>
<li>HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全; </li>
<li>HashMap允许key和value为null，而HashTable不允许</li>
</ol>
<p>底层实现：</p>
<p>数组+链表实现         jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在</p>
<ul>
<li>计算key的hash值，二次hash然后对数组长度取模，对应到数组下标</li>
<li>如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组</li>
<li>如果产生hash冲突，先进行equal比较，相同则取代该元素，不同，则判断链表高度插入链表，链表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表</li>
<li>key为null，存在下标0的位置</li>
</ul>
<h2 id="ConcurrentHashMap原理，jdk7和jdk8版本的区别"><a href="#ConcurrentHashMap原理，jdk7和jdk8版本的区别" class="headerlink" title="ConcurrentHashMap原理，jdk7和jdk8版本的区别"></a><strong>ConcurrentHashMap原理，jdk7和jdk8版本的区别</strong></h2><h3 id="jdk7"><a href="#jdk7" class="headerlink" title="jdk7:"></a>jdk7:</h3><p>数据结构：ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEntry数组，每个 HashEntry又是一个链表结构</p>
<p>元素查询：二次hash，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部 锁：Segment分段锁 Segment继承了ReentrantLock，锁定操作的Segment，其他的Segment不受影响，并发度为segment个数，可以通过构造函数指定，数组扩容不会影响其他的segment</p>
<p>get方法无需加锁，volatile保证</p>
<h3 id="jdk8："><a href="#jdk8：" class="headerlink" title="jdk8："></a>jdk8：</h3><p>数据结构：synchronized+CAS+Node+红黑树，Node的val和next都用volatile修饰，保证可见性</p>
<p>查找，替换，赋值操作都使用CAS</p>
<p>锁：锁链表的head节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写 操作、并发扩容</p>
<p>读操作无锁： Node的val和next使用volatile修饰，读写线程对该变量互相可见 数组用volatile修饰，保证扩容时被读线程感知</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h2><ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>
<li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li>
<li>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供 了Phant omReference类来实现虚引用。</li>
</ul>
<h2 id="Java类加载器"><a href="#Java类加载器" class="headerlink" title="Java类加载器"></a><strong>Java类加载器</strong></h2><p>JDK自带有三个类加载器:bootstrap ClassLoader、ExtClassLoader、AppClassLoader。 </p>
<ul>
<li>BootStrapClassLoader是ExtClassLoader的父类加载器，默认负责加载%JAVA_HOME%lib下的jar包和 class文件。 </li>
<li>ExtClassLoader是AppClassLoader的父类加载器，负责加载%JAVA_HOME%&#x2F;lib&#x2F;ext文件夹下的jar包和 class类。 </li>
<li>AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件。系统类加载器，线程上下 文加载器</li>
</ul>
<p>继承ClassLoader实现自定义类加载器</p>
<h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%B0%8F%E7%BB%93/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F.png" alt="类加载子系统"></p>
<p>类加载子系统负责从指定的文件或者网络中加载Class文件，每一个class文件在开头都有特定的文件标识。</p>
<p>类加载器Classloader只负责class文件的加载，能否运行则由Execution Engine（<strong>执行引擎</strong>）执行。</p>
<p>类加载器加载的class文件存放于<strong>方法区</strong>中，除了类信息，方法区中还会存在<strong>运行时常量池信息</strong>，可能还包括<strong>字符串字面量</strong>和<strong>数字常量</strong></p>
<p>加载过程：</p>
<h3 id="加载："><a href="#加载：" class="headerlink" title="加载："></a>加载：</h3><ol>
<li>通过一个类的全限定名，来获取此类的二进制文件字节流。</li>
<li>将此字节流文件所代表的<strong>静态储存结构</strong>转化为方法区的<strong>运行时数据</strong>。</li>
<li>在内存中生成一个<strong>java.lang.Class</strong>对象，作为<strong>方法区</strong>内这个类的各种数据访问入口，也就是反射</li>
</ol>
<h3 id="链接：验证、准备、解析"><a href="#链接：验证、准备、解析" class="headerlink" title="链接：验证、准备、解析"></a>链接：验证、准备、解析</h3><p>验证：保证class文件信息符合虚拟机要求，保证被加载类的正确性、不会危害虚拟机的自身安全</p>
<p>准备：</p>
<ol>
<li>为类变量分配内存，并设置默认值为0，int a &#x3D; 88;这段代码在准备阶段，赋的值并不是88，而是0，在初始化的时候，才会赋值为88</li>
<li>final static int a &#x3D; 88;在准备阶段之前的值就是88，并不会为0，因为final修饰的static，在编译阶段就会进行分配内存，在准备阶段只是进行显式初始化。</li>
</ol>
<p>解析：将常量池内的<strong>符号引用转化为直接引用</strong>的过程。</p>
<p>​	符号引用：符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的<strong>目标对象并不一定已经加载到内存中</strong>。</p>
<p>​	直接引用：直接引用可以是直接<strong>指向目标对象的指针</strong>、<strong>相对偏移量</strong>或是一个能<strong>间接定位到目标的句柄</strong>。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
<p>初始化：</p>
<p>初始化阶段就是构造器执行类构造器方法<clinit>()的过程</p>
<p>以下四种情况下初始化过程会被触发执行：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需先触发其初始化。生成这4条指令的最常见的java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段(被final修饰的static变量除外)的时候，以及调用类的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法对类进行<strong>反射调用</strong>的时候。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先对其父类的初始化。</li>
<li>jvm启动时，用户指定一个执行的主类(包含main方法的那个类)，虚拟机会先初始化这个类。</li>
</ol>
<h2 id="双亲委托模型"><a href="#双亲委托模型" class="headerlink" title="双亲委托模型"></a><strong>双亲委托模型</strong></h2><p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%B0%8F%E7%BB%93/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="双亲委托模型"></p>
<p>双亲委派模型的好处:</p>
<ul>
<li>主要是为了安全性，避免用户自己编写的类动态替换 Java的一些核心类，比如 String。 </li>
<li>同时也避免了类的重复加载，因为 JVM中区分不同类，不仅仅是根据类名，相同的 class文件被不 同的 ClassLoader加载就是不同的两个类</li>
</ul>
<h2 id="GC如何判断对象可以被回收"><a href="#GC如何判断对象可以被回收" class="headerlink" title="GC如何判断对象可以被回收"></a><strong>GC如何判断对象可以被回收</strong></h2><ul>
<li>引用计数法:每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收</li>
<li>可达性分析法:从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。</li>
</ul>
<p>引用计数法，可能会出现A引用了B，B又引用了A，这时候就算他们都不再使用了，但因为相互引用 <code>计数器=1</code>永远无法被回收。</p>
<p>GC Roots的对象有:</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(即一般说的Native方法)引用的对象</li>
</ul>
<p>可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会。对象被系统宣告死亡至 少要经历两次标记过程:第一次是经过可达性分析发现没有与GC Roots相连接的引用链，第二次是在由 虚拟机自动建立的Finalizer队列中判断是否需要执行finalize()方法。</p>
<p>当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”</p>
<p>每个对象只能触发一次finalize()方法 由于finalize()方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，不推荐大家使用，建议遗忘它。</p>
<h1 id="线程、并发相关"><a href="#线程、并发相关" class="headerlink" title="线程、并发相关"></a><strong>线程、并发相关</strong></h1><h2 id="线程的生命周期-线程有几种状态"><a href="#线程的生命周期-线程有几种状态" class="headerlink" title="线程的生命周期?线程有几种状态"></a><strong>线程的生命周期?线程有几种状态</strong></h2><p>线程通常有五种状态，创建，就绪，运行、阻塞和死亡状态。</p>
<ol>
<li>新建状态(New):新创建了一个线程对象。 </li>
<li>就绪状态(Runnable):线程对象创建后，其他线程调用了该对象的start方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</li>
<li>运行状态(Running):就绪状态的线程获取了CPU，执行程序代码。</li>
<li>阻塞状态(Blocked):阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进 入就绪状态，才有机会转到运行状态。</li>
<li>死亡状态(Dead):线程执行完了或者因异常退出了run方法，该线程结束生命周期。</li>
</ol>
<p>阻塞的情况又分为三种:</p>
<ol>
<li>等待阻塞:运行的线程执行wait方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待 池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify或notifyAll方法才能被唤 醒，wait是object类的方法</li>
<li>同步阻塞:运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放 入“锁池”中。</li>
<li>其他阻塞:运行的线程执行sleep或join方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状 态。当sleep状态超时、join等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。 sleep是Thread类的方法</li>
</ol>
<h2 id="sleep-、wait-、join-、ield-的区别"><a href="#sleep-、wait-、join-、ield-的区别" class="headerlink" title="sleep()、wait()、join()、ield()的区别"></a><strong>sleep()、wait()、join()、ield()的区别</strong></h2><p>锁池：</p>
<p>所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线 程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到 后会进入就绪队列进行等待cpu资源分配。</p>
<p>等待池：</p>
<p>当我们调用wait()方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了 notify()或notifyAll()后等待池的线程才会开始去竞争锁，notify()是随机从等待池选出一个线程放 到锁池，而notifyAll()是将等待池的所有线程放到锁池当中</p>
<ol>
<li><p>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。</p>
</li>
<li><p>sleep方法不会释放lock，但是wait会释放，而且会加入到等待队列中。</p>
<blockquote>
<p>sleep就是把cpu的执行资格和执行权释放出去，不再运行此线程，当定时时间结束再取回cpu资源，参与cpu 的调度，获取到cpu资源后就可以继续运行了。而如果sleep时该线程有锁，那么sleep不会释放这个锁，而 是把锁带着进入了冻结状态，也就是说其他需要这个锁的线程根本不可能获取到这个锁。也就是说无法执行程 序。如果在睡眠期间其他线程调用了这个线程的interrupt方法，那么这个线程也会抛出 interruptexception异常返回，这点和wait是一样的。</p>
</blockquote>
</li>
<li><p>sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。</p>
</li>
<li><p>sleep不需要被唤醒(休眠之后推出阻塞)，但是wait需要(不指定时间需要被别人中断)。</p>
</li>
<li><p>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。</p>
</li>
<li><p>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞 争到锁继续执行的。</p>
</li>
</ol>
<p>yield()执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格， 所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行</p>
<p>join()执行后线程进入阻塞状态，例如在线程B中调用线程A的join()，那线程B会进入到阻塞队列，直到线程A结束或中断线程</p>
<h2 id="为什么用线程池？解释下线程池参数？"><a href="#为什么用线程池？解释下线程池参数？" class="headerlink" title="为什么用线程池？解释下线程池参数？"></a>为什么用线程池？解释下线程池参数？</h2><ol>
<li>降低资源消耗;提高线程利用率，降低创建和销毁线程的消耗。 </li>
<li>提高响应速度;任务来了，直接有线程可用可执行，而不是先创建线程，再执行。 3、提高线程的可管理性;线程是稀缺资源，使用线程池可以统一分配调优监控。</li>
</ol>
<ul>
<li><code>corePoolSize</code>代表核心线程数，也就是正常情况下创建工作的线程数，这些线程创建后并不会 消除，而是一种常驻线程</li>
<li><code>maxinumPoolSize</code>代表的是最大线程数，它与核心线程数相对应，表示最大允许被创建的线程 数，比如当前任务较多，将核心线程数都用完了，还无法满足需求时，此时就会创建新的线程，但 是线程池内线程总数不会超过最大线程数</li>
<li><code>keepAliveTime</code>、<code>unit</code>表示超出核心线程数之外的线程的空闲存活时间，也就是核心线程不会 消除，但是超出核心线程数的部分线程如果空闲一定的时间则会被消除,我们可以通过<code>setKeepAliveTime</code>来设置空闲时间</li>
<li><code>workQueue</code>用来存放待执行的任务，假设我们现在核心线程都已被使用，还有任务进来则全部放 入队列，直到整个队列被放满但任务还再持续进入则会开始创建新的线程</li>
<li><code>threadFactory</code>实际上是一个线程工厂，用来生产线程执行任务。我们可以选择使用默认的创建 工厂，产生的线程都在同一个组内，拥有相同的优先级，且都不是守护线程。当然我们也可以选择 自定义线程工厂，一般我们会根据业务来制定不同的线程工厂</li>
<li><code>handler</code>任务拒绝策略，有两种情况，第一种是当我们调用shutdown 等方法关闭线程池后，这时候即使线程池内部还有没执行完的任务正在执行，但是由于线程池已经关闭，我们再继续想线程 池提交任务就会遭到拒绝。另一种情况就是当达到最大线程数，线程池已经没有能力继续处理新提 交的任务时，这是也就拒绝</li>
</ul>
<p>同步队列：</p>
<p><strong>ArrayBlockingQueue</strong></p>
<p>　　基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p>
<p>　　ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>
<p><strong>LinkedBlockingQueue</strong></p>
<p>　　基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），默认为Integer.MAX_VALUE，才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p>
<p><strong>DelayQueue</strong></p>
<p>　　DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p>
<p>　　使用场景：</p>
<p>　　DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。</p>
<p><strong>PriorityBlockingQueue</strong></p>
<p>　　 基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p>
<p><strong>SynchronousQueue</strong></p>
<p>　　 一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。</p>
<p>　　声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:</p>
<p>　　如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；</p>
<p>　　但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>
<h2 id="ThreadLocal的原理和使用场景"><a href="#ThreadLocal的原理和使用场景" class="headerlink" title="ThreadLocal的原理和使用场景"></a><strong>ThreadLocal的原理和使用场景</strong></h2><p>每一个<code>Thread</code>对象均含有一个<code>ThreadLocalMap</code>类型的成员变量<code>threadLocals</code>，它存储本线程中所有<code>ThreadLocal</code>对象及其对应的值</p>
<p><code>ThreadLocalMap</code>由一个个<code>Entry</code>对象构成</p>
<p><code>Entry</code>继承自<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，一个<code>Entry</code>由<code>ThreadLocal</code>对象和<code>Object</code>构成。由此可见，<code>Entry</code>的<code>key</code>是<code>ThreadLocal</code>对象，并且是一个弱引用。当没指向<code>key</code>的强引用后，该<code>key</code>就会被垃圾收集器回收</p>
<p>当执行<code>set</code>方法时，<code>ThreadLocal</code>首先会获取当前线程对象，然后获取当前线程的<code>ThreadLocalMap</code>对象。再以当前<code>ThreadLocal</code>对象为<code>key</code>，将值存储进<code>ThreadLocalMap</code>对象中。</p>
<p><code>get</code>方法执行过程类似。<code>ThreadLocal</code>首先会获取当前线程对象，然后获取当前线程的<code>ThreadLocalMap</code>对象。再以当前<code>ThreadLocal</code>对象为<code>key</code>，获取对应的<code>value</code>。</p>
<p>由于每一条线程均含有各自<strong>私有的</strong><code>ThreadLocalMap</code>容器，这些容器相互独立互不影响，因此不会存在线程安全性问题，从而也无需使用同步机制来保证多条线程访问容器的互斥性。</p>
<p>使用场景:</p>
<ol>
<li>在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li>
<li>线程间数据隔离</li>
<li>进行事务操作，用于存储线程事务信息。</li>
<li>数据库连接，Session会话管理。</li>
</ol>
<blockquote>
<p>Spring框架在事务开始时会给当前线程绑定一个Jdbc Connection，在整个事务过程都是使用该线程绑定的connection来执行数据库操作，实现了事务的隔离性。Spring框架里面就是用的ThreadLocal来实现这种隔离</p>
</blockquote>
<p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%B0%8F%E7%BB%93/ThreadLocal%E5%8E%9F%E7%90%86.png" alt="ThreadLocal原理"></p>
<h2 id="ThreadLocal内存泄露原因，如何避免"><a href="#ThreadLocal内存泄露原因，如何避免" class="headerlink" title="ThreadLocal内存泄露原因，如何避免"></a><strong>ThreadLocal内存泄露原因，如何避免</strong></h2><p>内存泄露为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露</p>
<p>堆积后果很严重，无论多少内存，迟早会被占光，不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</p>
<p>强引用:使用最普遍的引用(new)，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足， Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</p>
<p>如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时 间就会回收该对象。</p>
<p>弱引用:JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用 java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。</p>
<p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用<strong>弱引用</strong>的ThreadLocal 实例，value为线程变量的副本</p>
<p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%B0%8F%E7%BB%93/ThreadLocal%E5%8E%9F%E7%90%86.png" alt="ThreadLocal原理"></p>
<p>hreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部<strong>强引用</strong>时， Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null， 而value还存在着强 引用，只有thead线程退出以后,value的强引用链条才会断掉，但如果当前线程再迟迟不结束的话，这 些key为null的Entry的value就会一直存在一条强引用链(红色链条)</p>
<p>key 使用强引用 当hreadLocalMap的key为强引用回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。 key 使用弱引用</p>
<p>当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱 引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用 set(),get()，remove()方法的时候会被清除value值。</p>
<p>因此，ThreadLocal内存泄漏的根源是:由于ThreadLocalMap的生命周期跟Thread一样长，如果没有 手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p>
<p>ThreadLocal正确的使用方法：</p>
<ol>
<li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li>
<li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任 何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h2><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>BeanFactory定义了IOC容器的最基本形式，并提供了IOC容器应遵守的的最基本的接口，也就是Spring IOC所遵守的最底层和最基本的编程规范。在Spring代码中，BeanFactory只是个接口，并不是IOC容器的具体实现，但是Spring容器给出了很多种实现，如 DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等，都是附加了某种功能的实现。</p>
<h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>一般情况下，Spring通过反射机制利用<bean>的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在<bean>中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean，它的实现与设计模式中的工厂模式和修饰器模式类似。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式</title>
    <url>/2021/06/09/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p>
<span id="more"></span>

<h1 id="软件设计7大原则"><a href="#软件设计7大原则" class="headerlink" title="软件设计7大原则"></a>软件设计7大原则</h1><table>
<thead>
<tr>
<th>设计原则</th>
<th>一句话归纳</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>开闭原则</td>
<td>对扩展开放，对修改关闭</td>
<td>降低维护带来的新风险</td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td>高层不应该依赖低层，要面向接口编程</td>
<td>更利于代码结构的升级扩展</td>
</tr>
<tr>
<td>单一职责原则</td>
<td>一个类只干一件事，实现类要单一</td>
<td>便于理解，提高代码的可读性</td>
</tr>
<tr>
<td>接口隔离原则</td>
<td>一个接口只干一件事，接口要精简单一</td>
<td>功能解耦，高聚合、低耦合</td>
</tr>
<tr>
<td>迪米特法则</td>
<td>不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td>
<td>只和朋友交流，不和陌生人说话，减少代码臃肿</td>
</tr>
<tr>
<td>里氏替换原则</td>
<td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td>
<td>防止继承泛滥</td>
</tr>
<tr>
<td>合成复用原则</td>
<td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td>
<td>降低代码耦合</td>
</tr>
</tbody></table>
<blockquote>
<p>记忆口诀：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。</p>
</blockquote>
<h1 id="创建型模式的特点和分类"><a href="#创建型模式的特点和分类" class="headerlink" title="创建型模式的特点和分类"></a>创建型模式的特点和分类</h1><p>创建型模式分为以下几种。</p>
<ul>
<li><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例（Singleton）模式</a>：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
</ul>
<p>以上 5 种创建型模式，除了<a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">工厂方法模式</a>属于类创建型模式，其他的全部属于对象创建型模式，我们将在之后的教程中详细地介绍它们的特点、结构与应用。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="什么是Singleton"><a href="#什么是Singleton" class="headerlink" title="什么是Singleton?"></a>什么是Singleton?</h3><p>Singleton:在Java中 即指单例设计模式，探视软件开发最常用的设计模式之一</p>
<p>单：唯一</p>
<p>例：实例</p>
<p>单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式</p>
<p>例如：代表JVM运行环境的Runtime类</p>
<h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><p>一是某个类只能有一个实例</p>
<ul>
<li>构造器私有化</li>
</ul>
<p>二是他必须自行创建实例</p>
<ul>
<li>含有一个该类的静态变量来保存这个唯一的实例</li>
</ul>
<p>三是它必须自行向整个系统提供这个实例</p>
<p>对外提供获取该类实例对象的方式</p>
<ul>
<li>直接暴露</li>
<li>用静态变量的get方法获取</li>
</ul>
<h3 id="几种常见形式"><a href="#几种常见形式" class="headerlink" title="几种常见形式"></a>几种常见形式</h3><p>饿汉式：直接创建对象，不存在线程安全问题</p>
<ul>
<li><p>直接实例化饿汉式(简洁直观)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、构造器私有化</span></span><br><span class="line"><span class="comment"> * 2、自行创建，并且用静态变量保存</span></span><br><span class="line"><span class="comment"> * 3、向外提供实例</span></span><br><span class="line"><span class="comment"> * 4、强调这是一个单例，我们可以用final修改</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>枚举式 (最简洁)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举类型：表示该类型是有限的几个</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>静态代码块饿汉式(适合复杂实例化)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton3 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton3</span>(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">(String info)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>懒汉式：延迟创建对象</p>
<ul>
<li><p>线程不安全(使用于单线程)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> * 线程不安全(使用于单线程)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>线程安全(使用于多线程)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> * 线程安全(使用于多线程)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton5 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton5.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>静态内部类模式 (适用于多线程)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、内部类被加载和初始化时，才创建INSTANCE实例对象</span></span><br><span class="line"><span class="comment"> * 2、静态内部类不会自动创建,随着外部类的加载初始化而初始化，他是要单独去加载和实例化的</span></span><br><span class="line"><span class="comment"> * 3、因为是在内部类加载和初始化时，创建的，因此线程安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton6</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton6</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton6</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="原型模式的定义与特点"><a href="#原型模式的定义与特点" class="headerlink" title="原型模式的定义与特点"></a>原型模式的定义与特点</h3><p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。</p>
<h4 id="原型模式的优点："><a href="#原型模式的优点：" class="headerlink" title="原型模式的优点："></a>原型模式的优点：</h4><ul>
<li><a href="http://c.biancheng.net/java/">Java</a> 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。</li>
<li>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。</li>
</ul>
<h4 id="原型模式的缺点："><a href="#原型模式的缺点：" class="headerlink" title="原型模式的缺点："></a>原型模式的缺点：</h4><ul>
<li>需要为每一个类都配置一个 clone 方法</li>
<li>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。</li>
<li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li>
</ul>
<h3 id="原型模式的结构与实现"><a href="#原型模式的结构与实现" class="headerlink" title="原型模式的结构与实现"></a>原型模式的结构与实现</h3><p>由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。</p>
<h4 id="1-模式的结构"><a href="#1-模式的结构" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h4><p>原型模式包含以下主要角色。</p>
<ol>
<li>抽象原型类：规定了具体原型对象必须实现的接口。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ol>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-2.png" alt="原型模式的结构图"></p>
<h4 id="2-模式的实现"><a href="#2-模式的实现" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h4><p>原型模式的克隆分为浅克隆和深克隆。</p>
<ul>
<li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li>
<li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li>
</ul>
<p>Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Realizetype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    Realizetype() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型模式的测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Realizetype</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Realizetype</span>();</span><br><span class="line">        <span class="type">Realizetype</span> <span class="variable">obj2</span> <span class="operator">=</span> (Realizetype) obj1.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;obj1==obj2?&quot;</span> + (obj1 == obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">具体原型创建成功！</span><br><span class="line">具体原型复制成功！</span><br><span class="line">obj1==obj2?false</span><br></pre></td></tr></table></figure>

<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="工厂模式的定义"><a href="#工厂模式的定义" class="headerlink" title="工厂模式的定义"></a>工厂模式的定义</h3><p>定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p>
<p>按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是简单工厂模式、工厂方法模式和抽象工厂模式。</p>
<p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。</p>
<p>在简单工厂模式中创建实例的方法通常为静态<code>static</code>方法，因此简单工厂模式<code>Simple Factory Pattern</code>又叫作静态工厂方法模式<code>Static Factory Method Pattern</code>。</p>
<p>简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。</p>
<p>简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。</p>
<blockquote>
<p>“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
</blockquote>
<h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。</li>
<li>客户端无需知道所创建具体产品的类名，只需知道参数即可。</li>
<li>也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。</li>
<li>使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度</li>
<li>系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂</li>
<li>简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。</p>
<h3 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>简单工厂模式的主要角色如下：</p>
<ul>
<li>简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li>
<li>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</li>
<li>具体产品（ConcreteProduct）：是简单工厂模式的创建目标。</li>
</ul>
<p>其结构图如下图所示:</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="简单工厂模式的结构图"></p>
<p>根据上图写出该模式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体产品：ProductA</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体产品：ProductB</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Const</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRODUCT_A</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRODUCT_B</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRODUCT_C</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">makeProduct</span><span class="params">(<span class="type">int</span> kind)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (kind) &#123;</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_A:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_B:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>在《<a href="http://c.biancheng.net/view/8387.html">简单工厂模式</a>》一节我们介绍了简单工厂模式，提到了简单工厂模式违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
<h3 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li>
<li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li>
<li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li>
</ul>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>类的个数容易过多，增加复杂度</li>
<li>增加了系统的抽象性和理解难度</li>
<li>抽象产品只能生产一种产品，此弊端可使用<a href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">抽象工厂模式</a>解决。</li>
</ul>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ul>
<li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li>
<li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li>
<li>客户不关心创建产品的细节，只关心产品的品牌</li>
</ul>
<h3 id="模式的结构与实现-1"><a href="#模式的结构与实现-1" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。本节来分析其基本结构和实现方法。</p>
<h4 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>工厂方法模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
<p>其结构图如图所示：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="工厂方法模式的结构图"></p>
<h4 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>写出该模式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractFactoryTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Product a;</span><br><span class="line">            AbstractFactory af;</span><br><span class="line">            af = (AbstractFactory) ReadXML1.getObject();</span><br><span class="line">            a = af.newProduct();</span><br><span class="line">            a.show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品1：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品2：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂：提供了厂品的生成方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">newProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂1：实现了厂品的生成方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">newProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂1生成--&gt;具体产品1...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂2：实现了厂品的生成方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">newProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂2生成--&gt;具体产品2...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadXML1</span> &#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文档对象</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">            Document doc;</span><br><span class="line">            doc = builder.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/FactoryMethod/config1.xml&quot;</span>));</span><br><span class="line">            <span class="comment">//获取包含类名的文本节点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">classNode</span> <span class="operator">=</span> nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            <span class="type">String</span> <span class="variable">cName</span> <span class="operator">=</span> <span class="string">&quot;FactoryMethod.&quot;</span> + classNode.getNodeValue();</span><br><span class="line">            <span class="comment">//System.out.println(&quot;新类名：&quot;+cName);</span></span><br><span class="line">            <span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">            Class&lt;?&gt; c = Class.forName(cName);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h3><p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>
</ul>
<p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p>
<ul>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>
<li>当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。</li>
<li>抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。</li>
</ul>
<p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。</p>
<h3 id="模式的结构与实现-2"><a href="#模式的结构与实现-2" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。</p>
<h4 id="模式的结构-1"><a href="#模式的结构-1" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>抽象工厂模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li>
</ol>
<p>抽象工厂模式的结构图如图所示：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="抽象工厂模式的结构图"></p>
<h4 id="模式的实现-1"><a href="#模式的实现-1" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>从上图可以看出抽象工厂模式的结构同工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以创建产品的方法也不止一个。下面给出抽象工厂和具体工厂的代码。</p>
<p>(1) 抽象工厂：提供了产品的生成方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product1 <span class="title function_">newProduct1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Product2 <span class="title function_">newProduct2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体工厂：实现了产品的生成方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product1 <span class="title function_">newProduct1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂 1 生成--&gt;具体产品 11...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct11</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Product2 <span class="title function_">newProduct2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂 1 生成--&gt;具体产品 21...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct21</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由 CPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。</p>
<p>生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。</p>
<p>以上所有这些产品都是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。</p>
<h3 id="模式的定义与特点-1"><a href="#模式的定义与特点-1" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h3><p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的<a href="http://c.biancheng.net/design_pattern/">设计模式</a>被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
<p>该模式的主要优点如下：</p>
<ol>
<li>封装性好，构建和表示分离。</li>
<li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦。</li>
<li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li>
</ol>
<p>其缺点如下：</p>
<ol>
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li>
</ol>
<p>建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而<a href="http://c.biancheng.net/view/1348.html">工厂方法模式</a>更注重零部件的创建过程，但两者可以结合使用。</p>
<h3 id="模式的结构与实现-3"><a href="#模式的结构与实现-3" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成，现在我们来分析其基本结构和实现方法。</p>
<h4 id="模式的结构-2"><a href="#模式的结构-2" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>建造者（Builder）模式的主要角色如下。</p>
<ol>
<li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。</li>
<li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li>
<li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li>
<li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li>
</ol>
<p>其结构图如图所示：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="建造者模式的结构图"></p>
<h4 id="模式的实现-2"><a href="#模式的实现-2" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>图 1 给出了建造者（Builder）模式的主要结构，其相关类的代码如下。</p>
<p>(1) 产品角色：包含多个组成部件的复杂对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartA</span><span class="params">(String partA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartB</span><span class="params">(String partB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.partB = partB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartC</span><span class="params">(String partC)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.partC = partC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//显示产品的特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(2) 抽象建造者：包含创建产品各个子部件的抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartB</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartC</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(3) 具体建造者：实现了抽象建造者接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartA</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;建造 PartA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartB</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartB(<span class="string">&quot;建造 PartB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartC</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;建造 PartC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(4) 指挥者：调用建造者中的方法完成复杂对象的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(5) 客户类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteBuilder</span>();</span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构型模式概述"><a href="#结构型模式概述" class="headerlink" title="结构型模式概述"></a>结构型模式概述</h1><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下 7 种：</p>
<ol>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
</ol>
<p>以上 7 种结构型模式，除了<a href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a>分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式，下面我们会分别、详细地介绍它们的特点、结构与应用。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。</p>
<p>在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。</p>
<h3 id="代理模式的定义与特点"><a href="#代理模式的定义与特点" class="headerlink" title="代理模式的定义与特点"></a>代理模式的定义与特点</h3><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>代理模式的主要优点有：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</li>
</ul>
<p>其主要缺点是：</p>
<ul>
<li>代理模式会造成系统设计中类的数量增加</li>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
</ul>
<blockquote>
<p>那么如何解决以上提到的缺点呢？答案是可以使用动态代理方式</p>
</blockquote>
<h3 id="代理模式的结构与实现"><a href="#代理模式的结构与实现" class="headerlink" title="代理模式的结构与实现"></a>代理模式的结构与实现</h3><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。</p>
<h4 id="模式的结构-3"><a href="#模式的结构-3" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>代理模式的主要角色如下。</p>
<ol>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ol>
<p>其结构图如图所示：</p>
<p><img src="/Users/monochrome/project/blog/hexo-zhaoyangmushiyi/source/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="代理模式的结构图"></p>
<p>在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。</p>
<p>根据代理的创建时期，代理模式分为静态代理和动态代理。</p>
<ul>
<li>静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</li>
<li>动态：在程序运行时，运用反射机制动态创建而成</li>
</ul>
<h4 id="模式的实现-3"><a href="#模式的实现-3" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>代理模式的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="literal">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之前的预处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之后的后续处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问真实主题之前的预处理。</span><br><span class="line">访问真实主题方法...</span><br><span class="line">访问真实主题之后的后续处理。</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式（Adapter模式）"><a href="#适配器模式（Adapter模式）" class="headerlink" title="适配器模式（Adapter模式）"></a>适配器模式（Adapter模式）</h2><p>在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。</p>
<p>在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。</p>
<h3 id="模式的定义与特点-2"><a href="#模式的定义与特点-2" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h3><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>该模式的主要优点如下。</p>
<ul>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
<li>在很多业务场景中符合开闭原则。</li>
</ul>
<p>其缺点是：</p>
<ul>
<li>适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。</li>
<li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li>
</ul>
<h3 id="模式的结构与实现-4"><a href="#模式的结构与实现-4" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。</p>
<h4 id="模式的结构-4"><a href="#模式的结构-4" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>适配器模式（Adapter）包含以下主要角色。</p>
<ol>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ol>
<p>类适配器模式的结构图：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="类适配器模式的结构图"></p>
<p>对象适配器模式的结构图：</p>
<p><img src="/Users/monochrome/project/blog/hexo-zhaoyangmushiyi/source/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="对象适配器模式的结构图"></p>
<h4 id="模式的实现-4"><a href="#模式的实现-4" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>(1) 类适配器模式的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Target</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span></span><br><span class="line">    &#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;适配者中的业务代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassAdapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassAdapterTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类适配器模式测试：&quot;</span>);</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassAdapter</span>();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类适配器模式测试：</span><br><span class="line">适配者中的业务代码被调用！</span><br></pre></td></tr></table></figure>

<p>(2)对象适配器模式的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//对象适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectAdapterTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象适配器模式测试：&quot;</span>);</span><br><span class="line">        <span class="type">Adaptee</span> <span class="variable">adaptee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adaptee</span>();</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectAdapter</span>(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：对象适配器模式中的“目标接口”和“适配者类”的代码同类适配器模式一样，只要修改适配器类和客户端的代码即可。</p>
<p>程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对象适配器模式测试：</span><br><span class="line">适配者中的业务代码被调用！</span><br></pre></td></tr></table></figure>

<h2 id="桥接模式（Bridge模式）"><a href="#桥接模式（Bridge模式）" class="headerlink" title="桥接模式（Bridge模式）"></a>桥接模式（Bridge模式）</h2><p>在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。</p>
<p>当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。如果用桥接模式就能很好地解决这些问题。</p>
<h3 id="桥接模式的定义与特点"><a href="#桥接模式的定义与特点" class="headerlink" title="桥接模式的定义与特点"></a>桥接模式的定义与特点</h3><p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>通过上面的讲解，我们能很好的感觉到桥接模式遵循了里氏替换原则和依赖倒置原则，最终实现了开闭原则，对修改关闭，对扩展开放。这里将桥接模式的优缺点总结如下。</p>
<p>桥接（Bridge）模式的优点是：</p>
<ul>
<li>抽象与实现分离，扩展能力强</li>
<li>符合开闭原则</li>
<li>符合合成复用原则</li>
<li>其实现细节对客户透明</li>
</ul>
<p>缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。</p>
<h3 id="桥接模式的结构与实现"><a href="#桥接模式的结构与实现" class="headerlink" title="桥接模式的结构与实现"></a>桥接模式的结构与实现</h3><p>可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p>
<h4 id="模式的结构-5"><a href="#模式的结构-5" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>桥接（Bridge）模式包含以下主要角色。</p>
<ol>
<li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li>
</ol>
<p>其结构图：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="桥接模式的结构图"></p>
<h4 id="模式的实现-5"><a href="#模式的实现-5" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>桥接模式的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BridgeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Implementor</span> <span class="variable">imple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteImplementorA</span>();</span><br><span class="line">        <span class="type">Abstraction</span> <span class="variable">abs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefinedAbstraction</span>(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OperationImpl</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现化角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OperationImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体实现化(Concrete Implementor)角色被访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor imple;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Abstraction</span><span class="params">(Implementor imple)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.imple = imple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展抽象化角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RefinedAbstraction</span><span class="params">(Implementor imple)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(imple);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展抽象化(Refined Abstraction)角色被访问&quot;</span>);</span><br><span class="line">        imple.OperationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">扩展抽象化(Refined Abstraction)角色被访问</span><br><span class="line">具体实现化(Concrete Implementor)角色被访问</span><br></pre></td></tr></table></figure>

<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>上班族大多都有睡懒觉的习惯，每天早上上班时间都很紧张，于是很多人为了多睡一会，就会用方便的方式解决早餐问题。有些人早餐可能会吃煎饼，煎饼中可以加鸡蛋，也可以加香肠，但是不管怎么“加码”，都还是一个煎饼。在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，都是装饰器模式。</p>
<p>在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰器模式来实现。</p>
<h3 id="装饰器模式的定义与特点"><a href="#装饰器模式的定义与特点" class="headerlink" title="装饰器模式的定义与特点"></a>装饰器模式的定义与特点</h3><p>装饰器（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>装饰器模式的主要优点有：</p>
<ul>
<li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用</li>
<li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果</li>
<li>装饰器模式完全遵守开闭原则</li>
</ul>
<p>其主要缺点是：装饰器模式会增加许多子类，过度使用会增加程序得复杂性。</p>
<h3 id="装饰器模式的结构与实现"><a href="#装饰器模式的结构与实现" class="headerlink" title="装饰器模式的结构与实现"></a>装饰器模式的结构与实现</h3><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。下面来分析其基本结构和实现方法。</p>
<h4 id="模式的结构-6"><a href="#模式的结构-6" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>装饰器模式主要包含以下角色。</p>
<ol>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ol>
<p>装饰器模式的结构图:</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%BC%86%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="装饰模式的结构图"></p>
<h4 id="模式的实现-6"><a href="#模式的实现-6" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>装饰器模式的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Component</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDecorator</span>(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteComponent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建具体构件角色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用具体构件角色的方法operation()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addedFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;为具体构件角色增加额外的功能addedFunction()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建具体构件角色</span><br><span class="line">调用具体构件角色的方法operation()</span><br><span class="line">---------------------------------</span><br><span class="line">调用具体构件角色的方法operation()</span><br><span class="line">为具体构件角色增加额外的功能addedFunction()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot使用ELK收集日志</title>
    <url>/2020/01/17/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h3 id="ELK简介"><a href="#ELK简介" class="headerlink" title="ELK简介"></a>ELK简介</h3><p>ELK是有Elastic公司的三个组件配合进行日志收集，分别是：</p>
<ul>
<li><a href="https://www.elastic.co/cn/products/elasticsearch">ElasticSearch</a>:用于存储日志信息。</li>
<li><a href="https://www.elastic.co/cn/products/logstash">Logstash</a>:用于收集、处理和转发日志信息。</li>
<li><a href="https://www.elastic.co/cn/products/kibana">Kibana</a>:提供可搜索的Web可视化界面。</li>
</ul>
<p>ELK也可以配合<a href="https://www.elastic.co/cn/products/beats">Beats</a>进行使用，后续会写一篇文章来介绍。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>之前文章分别介绍了ELK环境的搭建以及Spring Boot与之的整合。</p>
<ul>
<li><a href="https://zhaoyangmushiyi.github.io/2020/01/07/Elasticsearch%E6%95%B4%E5%90%88Kibana%E5%92%8CLogstash%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">Elasticsearch整合Kibana和Logstash环境搭建</a></li>
<li><a href="https://zhaoyangmushiyi.github.io/2020/01/16/Spring-boot%E6%95%B4%E5%90%88Elasticsearch/">Spring-boot整合Elasticsearch</a></li>
</ul>
<span id="more"></span>

<p>本次教程基于上述两篇教程拓展。</p>
<h3 id="项目修改"><a href="#项目修改" class="headerlink" title="项目修改"></a>项目修改</h3><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><p>添加logstash采集logback日志的相关依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Logback配置"><a href="#Logback配置" class="headerlink" title="Logback配置"></a>Logback配置</h4><p>新建文件<code>logback-spring.xml</code>，放在resource文件夹下面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/console-appender.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--应用名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;APP_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志文件保存路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_FILE_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;&#125;/logs&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>$&#123;APP_NAME&#125;<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--每天记录日志到文件appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_FILE_PATH&#125;/$&#123;APP_NAME&#125;-%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--输出到logstash的appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;LOGSTASH&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--可以访问的logstash日志收集端口--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">destination</span>&gt;</span>localhost:4560<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;LOGSTASH&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Logstash配置"><a href="#Logstash配置" class="headerlink" title="Logstash配置"></a>Logstash配置</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">input <span class="punctuation">&#123;</span></span><br><span class="line">	jdbc <span class="punctuation">&#123;</span></span><br><span class="line">		add_field =&gt; <span class="punctuation">&#123;</span><span class="string">&quot;myid&quot;</span>=&gt;<span class="string">&quot;jdbc&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">		jdbc_connection_string =&gt;</span><br><span class="line">			<span class="string">&quot;&lt;mysql 地址&gt;&quot;</span></span><br><span class="line">		jdbc_user =&gt; <span class="string">&quot;xxxxxxxxxxxxx&quot;</span></span><br><span class="line">		jdbc_password =&gt; <span class="string">&quot;xxxxxxxxxxxx&quot;</span></span><br><span class="line">		##数据库驱动的JAR位置</span><br><span class="line">		jdbc_driver_library =&gt; <span class="string">&quot;/usr/share/logstash/config/mysql-connector-java-5.1.47.jar&quot;</span></span><br><span class="line">		jdbc_driver_class =&gt; <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">		jdbc_paging_enabled =&gt; <span class="string">&quot;true&quot;</span></span><br><span class="line">		jdbc_page_size =&gt; <span class="string">&quot;50000&quot;</span></span><br><span class="line">		statement =&gt; <span class="string">&quot;select id,username,realname,age,birth from tb_user&quot;</span></span><br><span class="line">		## 每分钟执行一次</span><br><span class="line">		schedule =&gt; <span class="string">&quot;* * * * *&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line">	tcp <span class="punctuation">&#123;</span></span><br><span class="line">		add_field =&gt; <span class="punctuation">&#123;</span><span class="string">&quot;myid&quot;</span>=&gt;<span class="string">&quot;aptst-log&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">		mode =&gt; <span class="string">&quot;server&quot;</span></span><br><span class="line">		host =&gt; <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">		port =&gt; <span class="number">4560</span></span><br><span class="line">		codec =&gt; json_lines</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">output <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">	if <span class="punctuation">[</span>myid<span class="punctuation">]</span> == <span class="string">&quot;jdbc&quot;</span> <span class="punctuation">&#123;</span></span><br><span class="line">		elasticsearch <span class="punctuation">&#123;</span></span><br><span class="line">			##elasticsearch 地址</span><br><span class="line">			hosts =&gt; <span class="string">&quot;&lt;elasticsearch 地址&gt;:9200&quot;</span></span><br><span class="line">			##索引名称</span><br><span class="line">			index =&gt; <span class="string">&quot;index-user&quot;</span></span><br><span class="line">			document_id =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line">			##索引类型</span><br><span class="line">			document_type =&gt; <span class="string">&quot;user&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">		stdout <span class="punctuation">&#123;</span></span><br><span class="line">			codec =&gt; json_lines</span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line">	if <span class="punctuation">[</span>myid<span class="punctuation">]</span> == <span class="string">&quot;aptst-log&quot;</span> <span class="punctuation">&#123;</span></span><br><span class="line">		elasticsearch <span class="punctuation">&#123;</span></span><br><span class="line">			##elasticsearch 地址</span><br><span class="line">			hosts =&gt; <span class="string">&quot;&lt;elasticsearch 地址&gt;:9200&quot;</span></span><br><span class="line">			##索引名称</span><br><span class="line">			index =&gt; <span class="string">&quot;springboot-logstash-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line">	</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Kibana管理"><a href="#Kibana管理" class="headerlink" title="Kibana管理"></a>Kibana管理</h4><p>进入Kibana管理页面</p>
<p><img src="/images/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-1.png" alt="Spring-Boot使用ELK收集日志-1"></p>
<p><img src="/images/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-2.png" alt="Spring-Boot使用ELK收集日志-2"></p>
<p>创建索引模式，输入索引模式名称<code>springboot-logstash-*</code></p>
<p><img src="/images/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-3.png" alt="Spring-Boot使用ELK收集日志-3"></p>
<p>选择时间筛选字段名称为<code>@timestamp</code></p>
<p><img src="/images/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-4.png" alt="Spring-Boot使用ELK收集日志-4"></p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring boot整合Elasticsearch</title>
    <url>/2020/01/16/Spring-boot%E6%95%B4%E5%90%88Elasticsearch/</url>
    <content><![CDATA[<h3 id="环境与版本"><a href="#环境与版本" class="headerlink" title="环境与版本"></a>环境与版本</h3><h4 id="Elasticsearch版本"><a href="#Elasticsearch版本" class="headerlink" title="Elasticsearch版本"></a>Elasticsearch版本</h4><p>服务端：elasticsearch 7.5.1  单节点</p>
<p>客户端：elasticsearch 6.8.5</p>
<h4 id="Logstash获取MySQL数据的配置"><a href="#Logstash获取MySQL数据的配置" class="headerlink" title="Logstash获取MySQL数据的配置"></a>Logstash获取MySQL数据的配置</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">input <span class="punctuation">&#123;</span></span><br><span class="line">	jdbc <span class="punctuation">&#123;</span></span><br><span class="line">		add_field =&gt; <span class="punctuation">&#123;</span><span class="string">&quot;myid&quot;</span>=&gt;<span class="string">&quot;jdbc&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">		jdbc_connection_string =&gt;</span><br><span class="line">			<span class="string">&quot;&lt;mysql 地址&gt;&quot;</span></span><br><span class="line">		jdbc_user =&gt; <span class="string">&quot;xxxxxxxxxxxxx&quot;</span></span><br><span class="line">		jdbc_password =&gt; <span class="string">&quot;xxxxxxxxxxxx&quot;</span></span><br><span class="line">		##数据库驱动的JAR位置</span><br><span class="line">		jdbc_driver_library =&gt; <span class="string">&quot;/usr/share/logstash/config/mysql-connector-java-5.1.47.jar&quot;</span></span><br><span class="line">		jdbc_driver_class =&gt; <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">		jdbc_paging_enabled =&gt; <span class="string">&quot;true&quot;</span></span><br><span class="line">		jdbc_page_size =&gt; <span class="string">&quot;50000&quot;</span></span><br><span class="line">		statement =&gt; <span class="string">&quot;select id,username,realname,age,birth from tb_user&quot;</span></span><br><span class="line">		## 每分钟执行一次</span><br><span class="line">		schedule =&gt; <span class="string">&quot;* * * * *&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">output <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">	if <span class="punctuation">[</span>myid<span class="punctuation">]</span> == <span class="string">&quot;jdbc&quot;</span> <span class="punctuation">&#123;</span></span><br><span class="line">		elasticsearch <span class="punctuation">&#123;</span></span><br><span class="line">			##elasticsearch 地址</span><br><span class="line">			hosts =&gt; <span class="string">&quot;&lt;elasticsearch 地址&gt;:9200&quot;</span></span><br><span class="line">			##索引名称</span><br><span class="line">			index =&gt; <span class="string">&quot;index-user&quot;</span></span><br><span class="line">			document_id =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line">			##索引类型</span><br><span class="line">			document_type =&gt; <span class="string">&quot;user&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">		stdout <span class="punctuation">&#123;</span></span><br><span class="line">			codec =&gt; json_lines</span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line">	</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="Spring-版本"><a href="#Spring-版本" class="headerlink" title="Spring 版本"></a>Spring 版本</h4><p>Spring boot:2.2.2.RELEASE</p>
<p>spring-boot-data-elasticsearch:3.2 对应elasticsearch的版本为6.8.5</p>
<h4 id="完整pom文件"><a href="#完整pom文件" class="headerlink" title="完整pom文件"></a>完整pom文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.monochrome<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>elasticsearch-test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for ElasticSearch<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring-boot-admin.version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">spring-boot-admin.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-admin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>PS：项目用到了Spring Cloud，如果不需要可以去除相关依赖。</p>
<h4 id="Spring-Boot配置文件"><a href="#Spring-Boot配置文件" class="headerlink" title="Spring Boot配置文件"></a>Spring Boot配置文件</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">elasticsearch-test</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&lt;Mysql</span> <span class="string">address&gt;</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">xxxxxxxxxx</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxxxxxxxx</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">cluster-name:</span> <span class="string">docker-cluster</span></span><br><span class="line">      <span class="attr">cluster-nodes:</span> <span class="string">&lt;elasticsearch</span> <span class="string">集群地址&gt;</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">rest:</span></span><br><span class="line">      <span class="attr">uris:</span> [<span class="string">&quot;&lt;elasticsearch 地址&gt;&quot;</span>]</span><br><span class="line">      <span class="attr">ipAddrs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&lt;elasticsearch</span> <span class="string">地址&gt;</span></span><br><span class="line"><span class="comment">#  main:</span></span><br><span class="line"><span class="comment">#    allow-bean-definition-overriding: true</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#客户端注册进eureka服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">&lt;Eureka地址&gt;</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">elasticsearch-test</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment">#访问路径可以显示IP地址</span></span><br><span class="line"><span class="comment">#management.endpoints.web.exposure.include=* #开放所有监控端接口，可以指定开放一些</span></span><br><span class="line"><span class="comment">#management.endpoint.health.show-details=always</span></span><br><span class="line"><span class="comment">#management.endpoints.web.base-path=/monitor</span></span><br><span class="line"><span class="comment">#management.endpoint.shutdown.enabled=true #开启接口优雅关闭 Spring Boot 应用</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8091</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">elasticsearch-test</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><p>定义一个<code>User</code>实体类以及<code>EsUser</code>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity(name = &quot;tb_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy= GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String realname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;index-user&quot;, refreshInterval = &quot;0s&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EsUser</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String realname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置Elasticsearch-Rest-High-Level-Client"><a href="#配置Elasticsearch-Rest-High-Level-Client" class="headerlink" title="配置Elasticsearch Rest High Level Client"></a>配置Elasticsearch Rest High Level Client</h4><p>Elasticsearch(ES)有两种连接方式：transport、rest。transport通过TCP方式访问ES(只支持java),rest方式通过http API 访问ES(没有语言限制)。<br>ES官方建议使用rest方式, transport 在7.0版本中不建议使用，在8.X的版本中废弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticsearchRestClientConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractElasticsearchConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ES_IP_ADDRESSES_LENGTH</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HTTP_SCHEME</span> <span class="operator">=</span> <span class="string">&quot;http&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * elasticSearch 服务器地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.elasticsearch.rest.ipAddrs&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ipAddresses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestClientBuilder <span class="title function_">restClientBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        HttpHost[] hosts = ipAddresses.stream()</span><br><span class="line">                .map(<span class="built_in">this</span>::makeHttpHost)</span><br><span class="line">                .filter(Objects::nonNull)</span><br><span class="line">                .toArray(HttpHost[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">return</span> RestClient.builder(hosts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpHost <span class="title function_">makeHttpHost</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> StringUtils.isNotEmpty(s);</span><br><span class="line">        String[] address = s.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (address.length == ES_IP_ADDRESSES_LENGTH) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> address[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> Integer.parseInt(address[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpHost</span>(ip, port, HTTP_SCHEME);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">elasticsearchClient</span><span class="params">()</span> &#123;</span><br><span class="line">        HttpHost[] hosts = ipAddresses.stream()</span><br><span class="line">                .map(<span class="built_in">this</span>::makeHttpHost)</span><br><span class="line">                .filter(Objects::nonNull)</span><br><span class="line">                .toArray(HttpHost[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(hosts));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用Spring-data-Jpa-Repository操作数据库"><a href="#使用Spring-data-Jpa-Repository操作数据库" class="headerlink" title="使用Spring data Jpa Repository操作数据库"></a>使用Spring data Jpa Repository操作数据库</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用Spring-Data-Elasticsearch-Repositories操作Elasticsearch"><a href="#使用Spring-Data-Elasticsearch-Repositories操作Elasticsearch" class="headerlink" title="使用Spring Data Elasticsearch Repositories操作Elasticsearch"></a>使用Spring Data Elasticsearch Repositories操作Elasticsearch</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EsUserRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;EsUser, Long&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名为username的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名为username并且真实姓名为realname的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realname</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameAndRealname</span><span class="params">(String username, String realname)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名为username或者姓名为realname的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameOrRealname</span><span class="params">(String username, String realname)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名不是username的所有用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameNot</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询年龄段为ageFrom到ageTo的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ageFrom</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ageTo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByAgeBetween</span><span class="params">(Integer ageFrom, Integer ageTo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询生日小于birthTo的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByBirthLessThan</span><span class="params">(LocalDateTime birthTo)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询生日段大于birthFrom的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> birthFrom</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByBirthGreaterThan</span><span class="params">(LocalDateTime birthFrom)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询年龄小于或等于ageTo的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByAgeBefore</span><span class="params">(Integer ageTo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询年龄大于或等于ageFrom的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ageFrom</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByAgeAfter</span><span class="params">(Integer ageFrom)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名模糊查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameLike</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名以start开头的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameStartingWith</span><span class="params">(String start)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名以end结尾的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameEndingWith</span><span class="params">(String end)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名包含word的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameContaining</span><span class="params">(String word)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询名字属于usernames中的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> usernames</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameIn</span><span class="params">(Collection&lt;String&gt; usernames)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询名字不属于usernames中的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> usernames</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameNotIn</span><span class="params">(Collection&lt;String&gt; usernames)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *最后来个复杂点的：查询年龄小于ageTo,姓名以start开头，id大于idTo的用户，并且按照年龄倒序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByAgeBeforeAndUsernameStartingWithAndIdGreaterThanOrderByAgeDesc</span><span class="params">(Integer ageTo, String start, Long idTo)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EsUserRepository esUserRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id:\\d+&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        userRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUsers</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; users)</span> &#123;</span><br><span class="line">        userRepository.saveAll(users);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/username/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;EsUser&gt; <span class="title function_">getUserByUsername</span><span class="params">(<span class="meta">@PathVariable</span> String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> esUserRepository.findByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/usernameLike/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;EsUser&gt; <span class="title function_">getUserByUsernameLike</span><span class="params">(<span class="meta">@PathVariable</span> String username)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;get User By Username Like &#123;&#125;&quot;</span>,username);</span><br><span class="line">        <span class="keyword">return</span> esUserRepository.findByUsernameLike(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/ageTo/&#123;ageTo&#125;/name_start/&#123;nameStart&#125;/id/&#123;id:\\d+&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;EsUser&gt; <span class="title function_">getUserByAgeAndUsernameAndId</span><span class="params">(<span class="meta">@PathVariable</span> Integer ageTo, <span class="meta">@PathVariable</span> String nameStart,</span></span><br><span class="line"><span class="params">                                                     <span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> esUserRepository.findByAgeBeforeAndUsernameStartingWithAndIdGreaterThanOrderByAgeDesc(ageTo, nameStart, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Swagger配置"><a href="#Swagger配置" class="headerlink" title="Swagger配置"></a>Swagger配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.monochrome.elasticsearch&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;Elasticsearch Demo RESTful APIs&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;服务名：elasticsearch Demo&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Elasticsearch</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习</title>
    <url>/2021/06/26/Redis%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Redis 是一种开源（BSD 许可）、内存中数据结构存储，用作数据库、缓存和消息代理。Redis 提供了诸如字符串、散列、列表、集合、带范围查询的排序集合、位图、超级日志、地理空间索引和流等数据结构。Redis 内置复制、Lua 脚本、LRU 驱逐、事务和不同级别的磁盘持久化，并通过 Redis Sentinel 和 Redis Cluster 自动分区提供高可用性。</p>
<span id="more"></span>

<h1 id="Docker安装Redis"><a href="#Docker安装Redis" class="headerlink" title="Docker安装Redis"></a>Docker安装Redis</h1><ol>
<li><p>获取镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --name docker-redis -p 6379:6379 redis</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定配置文件</span></span><br><span class="line">docker run -d --privileged=true -p 6379:6379 -v /Users/monochrome/app/redis/redis.conf:/usr/local/etc/redis.conf --name docker-redis redis redis-server /usr/local/etc/redis.conf --appendonly yes </span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>redis-cli</code>连接测试使用<code>redis</code>服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it docker-redis /bin/bash</span><br><span class="line">redis-cli</span><br><span class="line">set test 1</span><br><span class="line">get test</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Docker%E5%AE%89%E8%A3%85Redis%E6%B5%8B%E8%AF%95.png" alt="截屏2021-06-26 18.40.43"></p>
</li>
</ol>
<h1 id="Redis键-key"><a href="#Redis键-key" class="headerlink" title="Redis键(key)"></a>Redis键(key)</h1><p>keys * 查看当前库所有key  (匹配：keys *1)</p>
<p>exists key 判断某个key是否存在</p>
<p>type key 查看你的key是什么类型</p>
<p>del key    删除指定的key数据</p>
<p>unlink key  根据value选择非阻塞删除</p>
<p>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</p>
<p>expire key 10  10秒钟：为给定的key设置过期时间</p>
<p>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>
<p>select命令切换数据库</p>
<p>dbsize查看当前数据库的key的数量</p>
<p>flushdb清空当前库</p>
<p>flushall通杀全部库</p>
<h1 id="常用五大数据类型"><a href="#常用五大数据类型" class="headerlink" title="常用五大数据类型"></a>常用五大数据类型</h1><h2 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a>Redis字符串(String)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>set  key value  添加键值对</p>
<p> <img src="/images/Redis%E5%AD%A6%E4%B9%A0/String-set.png" alt="截屏2021-06-26 21.53.41"></p>
<p>*NX：当数据库中key不存在时，可以将key-value添加数据库</p>
<p>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</p>
<p>*EX：key的超时秒数</p>
<p>*PX：key的超时毫秒数，与EX互斥</p>
<p>get  key 查询对应键值</p>
<p>append key value 将给定的value  追加到原值的末尾</p>
<p>strlen key 获得值的长度</p>
<p>setnx key value 只有在 key 不存在时  设置 key 的值</p>
<p>incr key  </p>
<p>将 key 中储存的数字值增1(原子操作，不会被线程调度机制打断)</p>
<p>只能对数字值操作，如果为空，新增值为1</p>
<p>decr key </p>
<p>将 key 中储存的数字值减1</p>
<p>只能对数字值操作，如果为空，新增值为-1</p>
<p>incrby &#x2F; decrby key 步长 将 key 中储存的数字值增减。自定义步长。</p>
<img src="/images/Redis学习/String-命令1.png" alt="String-命令1.png" style="zoom:50%;" />

<p>mset key1 value1 key2 value2  ….. </p>
<p>同时设置一个或多个 key-value对 </p>
<p>mget key1 key2 key3  …..</p>
<p>同时获取一个或多个 value </p>
<p>msetnx key1 value1 key2 value2  ….. </p>
<p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<strong>原子性，有一个失败则都失败</strong></p>
<p>getrange key 起始位置 结束位置 </p>
<p>获得值的范围，类似java中的substring，<strong>前包，后包</strong></p>
<p>setrange key 起始位置 value </p>
<p>用 value  覆写key 所储存的字符串值，从起始位置 开始(<strong>索引从0开始</strong>)。</p>
<p>setex key 过期时间 value </p>
<p>设置键值的同时，设置过期时间，单位秒。</p>
<p>getset key value </p>
<p>以新换旧，设置了新值同时获得旧值。</p>
<img src="/images/Redis学习/String-命令2.png" alt="String-命令2.png" style="zoom:50%;" />

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/String-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="image-20210626220837603"></p>
<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h2 id="Redis列表-List"><a href="#Redis列表-List" class="headerlink" title="Redis列表(List)"></a><strong>Redis列表(List)</strong></h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>单键多值</p>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/List-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="List-双向链表"></p>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>lpush&#x2F;rpush  key value1 value2 value3 …. 从左边&#x2F;右边插入一个或多个值。</p>
<p>lpop&#x2F;rpop  key从左边&#x2F;右边吐出一个值。值在键在，值光键亡。</p>
<p>rpoplpush  key1 key2 从key1列表右边吐出一个值，插到 key2列表左边。</p>
<p>lrange key start stop 按照索引下标获得元素(从左到右)</p>
<p>lrange mylist 0 -1  0左边第一个，-1右边第一个，（0 -1表示获取所有）</p>
<p>lindex  key index 按照索引下标获得元素(从左到右)</p>
<p>llen key 获得列表长度 </p>
<p>linsert  key before&#x2F;after  value newvalue 在 value的后面插入newvalue插入值</p>
<p>lrem key n value 从左边删除n个value(从左到右)</p>
<p>lset key index value 将列表key下标为index的值替换成value</p>
<p> <img src="/images/Redis%E5%AD%A6%E4%B9%A0/List-%E5%91%BD%E4%BB%A4.png" alt="List-命令"></p>
<p><strong>数据结构</strong></p>
<p>List的数据结构为快速链表quickList。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成quicklist。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/List-quicklist.png" alt="List-quicklist"></p>
<p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h2 id="Redis集合-Set"><a href="#Redis集合-Set" class="headerlink" title="Redis集合(Set)"></a><strong>Redis集合(Set)</strong></h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的*<em>复杂度都是</em>***O(1)**。</p>
<p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p>
<h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>sadd key value1 value2  ….. </p>
<p>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</p>
<p>smembers key 取出该集合的所有值。</p>
<p>sismember key value 判断集合key 是否为含有该value 值，有1，没有0</p>
<p>scard key 返回该集合的元素个数。</p>
<p>srem key value1 value2  …. 删除集合中的某个元素。</p>
<p>spop key <strong>随机从该集合中吐出一个值。</strong></p>
<p>srandmember key n 随机从该集合中取出n个值。不会从集合中删除 。</p>
<p>smove source destination value 把集合中一个值从一个集合移动到另一个集合</p>
<p>sinter key1 key2 返回两个集合的交集元素。</p>
<p>sunion key1 key2 返回两个集合的并集元素。</p>
<p>sdiff key1 key2 返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Set-%E5%91%BD%E4%BB%A4.png" alt="Set-命令"></p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>Set数据结构是dict字典，字典是用哈希表实现的。</p>
<p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h2 id="Redis哈希-Hash"><a href="#Redis哈希-Hash" class="headerlink" title="Redis哈希(Hash)"></a><strong>Redis哈希(Hash)</strong></h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>Redis hash 是一个键值对集合。</p>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>类似Java里面的Map&lt;String,Object&gt;</p>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key&#x2F;value结构来存储</p>
<p>主要有以下2种存储方，然后衍生出我们Hash的存储方式：</p>
<ol>
<li><p>第一种</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Hash-store1-1.png" alt="image-20210627211632603">  </p>
<p>每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。</p>
</li>
<li><p>第二种</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Hash-store1-2.png" alt="image-20210627211728406"></p>
<p>用户ID数据冗余</p>
</li>
<li><p>第三种，Hash</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Hash-store2.png" alt="image-20210627212109516"></p>
<p>通过 <code>key(用户ID)</code> + <code>field(属性标签)</code>就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</p>
</li>
</ol>
<h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>hset key field value 给key 集合中的 field 键赋值value </p>
<p>hget key field 从key集合field取出value </p>
<p>hmset key field1 value1 field2 value2 … 批量设置hash的值</p>
<p>hexists key field 查看哈希表 key 中，给定域 field 是否存在。 </p>
<p>hkeys key 列出该hash集合的所有field</p>
<p>hvals key 列出该hash集合的所有value</p>
<p>hincrby key field increment 为哈希表 key 中的域 field 的值加上增量 1  -1</p>
<p>hsetnx key field value 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</p>
<p>hgetall key 获取该hash集合的所有field以及value</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Hash-%E5%91%BD%E4%BB%A4.png" alt="Hash-命令"></p>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
<h2 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a><strong>Redis有序集合Zset(sorted set)</strong></h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>Redis有序集合zset与普通集合set非常相似，是一个<strong>没有重复元素</strong>的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。<strong>集合的成员是唯一的，但是评分可以是重复了 。</strong></p>
<p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>zadd key score1 value1 score2 value2 …</p>
<p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p>
<p><strong>zrange key start stop  [WITHSCORES]</strong>  </p>
<p>返回有序集 key 中，下标在start stop之间的元素，带WITHSCORES，可以让分数一起和值返回到结果集。</p>
<p>zrangebyscore key minmax [withscores] [limit offset count]</p>
<p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </p>
<p>zrevrangebyscore key maxmin [withscores] [limit offset count]        </p>
<p>同上，改为从大到小排列。 </p>
<p>zincrby key increment value    为元素的score加上增量</p>
<p>zrem key value 删除该集合下，指定值的元素</p>
<p>zcount key min max 统计该集合，分数区间内的元素个数 </p>
<p>zrank key value 返回该值在集合中的排名，从0开始。</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Zset-%E5%91%BD%E4%BB%A4.png" alt="截屏2021-06-28 15.23.53"></p>
<p>案例：如何利用zset实现一个文章访问量的排行榜？</p>
<h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层使用了两个数据结构</p>
<p>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p>
<p>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
<h3 id="跳跃表（跳表）"><a href="#跳跃表（跳表）" class="headerlink" title="跳跃表（跳表）"></a><strong>跳跃表（跳表）</strong></h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p>  有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>  对比有序链表和跳跃表，从链表中查询出51</p>
<p>（1） 有序链表</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Zset-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.png" alt="Zset-有序链表">                               </p>
<p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p>
<p>（2） 跳跃表</p>
<p> <img src="/images/Redis%E5%AD%A6%E4%B9%A0/Zset-%E8%B7%B3%E8%B7%83%E8%A1%A8.png" alt="Zset-跳跃表"></p>
<p>从第2层开始，1节点比51节点小，向后比较。</p>
<p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</p>
<p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p>
<p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p>
<p>从此可以看出跳跃表比有序链表效率要高</p>
<h1 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a><strong>Redis的发布和订阅</strong></h1><h2 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a><strong>什么是发布和订阅</strong></h2><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<h2 id="Redis的发布和订阅-1"><a href="#Redis的发布和订阅-1" class="headerlink" title="Redis的发布和订阅"></a><strong>Redis的发布和订阅</strong></h2><p><strong>发布订阅命令行实现</strong></p>
<p>1、 打开一个客户端订阅channel1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">subscribe channel1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85-%E8%AE%A2%E9%98%85channel1.png" alt="Redis发布和订阅-订阅channel1">     </p>
<p>2、打开另一个客户端，给channel1发布消息hello</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">publish channel1 hello</span><br></pre></td></tr></table></figure>

<p> <img src="/images/Redis%E5%AD%A6%E4%B9%A0/Redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85-%E7%BB%99channel1%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF.png" alt="Redis发布和订阅-给channel1发布消息"></p>
<p>返回的1是订阅者数量</p>
<p>3、打开第一个客户端可以看到发送的消息</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85-%E4%BB%8Echannel1%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF.png" alt="Redis发布和订阅-从channel1接收消息"></p>
<p>注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息</p>
<h1 id="Redis与Spring-Boot整合"><a href="#Redis与Spring-Boot整合" class="headerlink" title="Redis与Spring Boot整合"></a><strong>Redis与Spring Boot整合</strong></h1><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="application-yml配置Redis配置"><a href="#application-yml配置Redis配置" class="headerlink" title="application.yml配置Redis配置"></a>application.yml配置Redis配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">#Redis服务器地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span> <span class="comment">#Redis服务器连接端口</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">18000000</span> <span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">20</span> <span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span> <span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">5</span> <span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#连接池中的最小空闲连接</span></span><br></pre></td></tr></table></figure>

<h2 id="添加redis配置类"><a href="#添加redis配置类" class="headerlink" title="添加redis配置类"></a>添加redis配置类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonTypeInfo;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><span class="comment">//我们可以自定义一个RedisTemplate来替换默认的</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        serializer.setObjectMapper(mapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hash的key也采用StringRedisSerializer的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span><span class="comment">//由于String是redis中最常使用的类型，所以单独提出了一个bean!</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">StringRedisTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(mapper);</span><br><span class="line">        <span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="完成一个手机验证码功能"><a href="#完成一个手机验证码功能" class="headerlink" title="完成一个手机验证码功能"></a><strong>完成一个手机验证码功能</strong></h2><p>要求：</p>
<ol>
<li><p>输入手机号，点击发送后随机生成6位数字码，30分钟有效</p>
<p>用Random类</p>
</li>
<li><p>输入验证码，点击验证，返回成功或失败</p>
<p>把验证码放到Redis里面，设置过期时间为30分钟</p>
</li>
<li><p>每个手机号每天只能输入3次</p>
<p>把发送验证码的数量也放到Redis里面，设置过期时间为1天</p>
<p>incr每次发送后+1</p>
<p>大于2(也就是已经发送3次后)不能再发送</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getVerificationCode</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">verifyCodeCountKey</span> <span class="operator">=</span> <span class="string">&quot;verifyCode&quot;</span> + phone + <span class="string">&quot;:count&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">verifyCodeKey</span> <span class="operator">=</span> <span class="string">&quot;verifyCode&quot;</span> + phone + <span class="string">&quot;:code&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForValue().get(verifyCodeCountKey);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(verifyCodeCountKey, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.parseInt(count) &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        redisTemplate.opsForValue().increment(verifyCodeCountKey);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;今天输入次数已超过3次！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">verificationCode</span> <span class="operator">=</span> getRandomVerificationCode();</span><br><span class="line">    log.info(verifyCodeKey + <span class="string">&quot;------&quot;</span> + verificationCode);</span><br><span class="line">    redisTemplate.opsForValue().set(verifyCodeKey, verificationCode, <span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;验证码已发送到手机，请尽快输入，验证码将于30分钟后失效！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">verifyPhoneAndVerificationCode</span><span class="params">(String phone, String verificationCode)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">verifyCodeKey</span> <span class="operator">=</span> <span class="string">&quot;verifyCode&quot;</span> + phone + <span class="string">&quot;:code&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">verifyCodeKeyByRedis</span> <span class="operator">=</span> redisTemplate.opsForValue().get(verifyCodeKey);</span><br><span class="line">    <span class="keyword">if</span> (verificationCode.equals(verifyCodeKeyByRedis)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;验证成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;验证失败！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getRandomVerificationCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">verificationCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        verificationCode.append(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> verificationCode.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Redis-事务-锁机制-秒杀"><a href="#Redis-事务-锁机制-秒杀" class="headerlink" title="Redis_事务_锁机制_秒杀"></a><strong>Redis_事务_锁机制_秒杀</strong></h1><h2 id="Redis的事务定义"><a href="#Redis的事务定义" class="headerlink" title="Redis的事务定义"></a><strong>Redis的事务定义</strong></h2><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>Redis事务的主要作用就是<strong>串联多个命令</strong>防止别的命令插队。</p>
<h2 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a><strong>Multi</strong>、<strong>Exec</strong>、<strong>discard</strong></h2><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。</p>
<p>组队的过程中可以通过discard来放弃组队。 </p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1-%E6%AD%A3%E5%B8%B8.png" alt="事务-正常"></p>
<h2 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a><strong>事务的错误处理</strong></h2><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1-%E7%BB%84%E9%98%9F%E6%97%B6%E9%94%99%E8%AF%AF.png" alt="事务-组队时错误"></p>
<p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1-%E6%89%A7%E8%A1%8C%E6%97%B6%E5%87%BA%E9%94%99.png" alt="事务-执行时出错"></p>
<h3 id="WATCH-key-key-…"><a href="#WATCH-key-key-…" class="headerlink" title="WATCH key [key …]"></a><strong>WATCH</strong> <strong>key</strong> <strong>[key …]</strong></h3><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key被其他命令所改动，那么事务将被打断。</strong>                              </p>
<h3 id="unwatch"><a href="#unwatch" class="headerlink" title="unwatch"></a><strong>unwatch</strong></h3><p>取消 WATCH 命令对所有 key 的监视。</p>
<p>如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a><strong>Redis持久化</strong></h1><p>Redis 提供了2个不同形式的持久化方式。</p>
<ul>
<li>RDB（Redis DataBase）</li>
<li>AOF（Append Of File）</li>
</ul>
<h2 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a><strong>RDB(Redis DataBase)</strong></h2><p>在指定的<strong>时间间隔</strong>内将内存中的数据集<strong>快照</strong>写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<h3 id="备份是如何执行的"><a href="#备份是如何执行的" class="headerlink" title="备份是如何执行的"></a>备份是如何执行的</h3><p>Redis会单独创建（fork）一个子进程来进行持久化，会<strong>先</strong>将数据<strong>写</strong>入到 一个<strong>临时文件</strong>中，待持久化过程都结束了，再用这个<strong>临时文件替换</strong>上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是<strong>最后一次持久化后的数据可能丢失</strong>。</p>
<h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><ul>
<li>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为<strong>原进程的子进程</strong></li>
<li>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”</li>
<li>一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li>
</ul>
<h3 id="RDB持久化流程"><a href="#RDB持久化流程" class="headerlink" title="RDB持久化流程"></a>RDB持久化流程</h3><p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/RDB%E6%8C%81%E4%B9%85%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt="RDB持久化流程"></p>
<h3 id="如何触发RDB快照；保持策略"><a href="#如何触发RDB快照；保持策略" class="headerlink" title="如何触发RDB快照；保持策略"></a><strong>如何触发RDB快照；保持策略</strong></h3><h4 id="配置文件中默认的快照配置"><a href="#配置文件中默认的快照配置" class="headerlink" title="配置文件中默认的快照配置"></a><strong>配置文件中默认的快照配置</strong></h4><p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/%E9%BB%98%E8%AE%A4%E5%BF%AB%E7%85%A7%E9%85%8D%E7%BD%AE.png" alt="默认快照配置"></p>
<h4 id="命令save-VS-bgsave"><a href="#命令save-VS-bgsave" class="headerlink" title="命令save VS bgsave"></a>命令save VS bgsave</h4><p>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。<br>bgsave：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。<br>可以通过 lastsave 命令获取最后一次成功执行快照的时间</p>
<h4 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h4><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p>
<h4 id="SNAPSHOTTING快照"><a href="#SNAPSHOTTING快照" class="headerlink" title="###SNAPSHOTTING快照###"></a>###SNAPSHOTTING快照###</h4><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>格式：save 秒钟 写操作次数</p>
<p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。</p>
<p>禁用：不设置save指令，或者给save传入空字符串</p>
<h4 id="stop-writes-on-bgsave-error"><a href="#stop-writes-on-bgsave-error" class="headerlink" title="stop-writes-on-bgsave-error"></a>stop-writes-on-bgsave-error</h4><p>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</p>
<h4 id="rdbcompression-压缩文件"><a href="#rdbcompression-压缩文件" class="headerlink" title="rdbcompression 压缩文件"></a>rdbcompression 压缩文件</h4><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。<br>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p>
<h4 id="rdbchecksum-检查完整性"><a href="#rdbchecksum-检查完整性" class="headerlink" title="rdbchecksum 检查完整性"></a>rdbchecksum 检查完整性</h4><p>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。推荐yes.</p>
<h4 id="rdb的备份"><a href="#rdb的备份" class="headerlink" title="rdb的备份"></a>rdb的备份</h4><ul>
<li>先通过config get dir  查询rdb文件的目录 </li>
<li>将*.rdb的文件拷贝到别的地方</li>
</ul>
<h4 id="rdb的恢复"><a href="#rdb的恢复" class="headerlink" title="rdb的恢复"></a>rdb的恢复</h4><ul>
<li>关闭Redis</li>
<li>先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb</li>
<li>启动Redis, 备份数据会直接加载</li>
</ul>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高更适合使用</li>
<li>节省磁盘空间</li>
<li>恢复速度快</li>
</ul>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
<li>虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能</li>
<li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改</li>
</ul>
<h4 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h4><p>动态停止RDB：redis-cli config set save “”   #save后给空值，表示禁用保存策略</p>
<h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/RDB-%E5%B0%8F%E6%80%BB%E7%BB%93.png" alt="RDB-小总结"></p>
<h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a><strong>AOF(Append Only File)</strong></h3><p>以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<h4 id="AOF持久化流程"><a href="#AOF持久化流程" class="headerlink" title="AOF持久化流程"></a>AOF持久化流程</h4><ol>
<li>客户端的请求写命令会被append追加到AOF缓冲区内；</li>
<li>AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</li>
<li>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</li>
<li>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；</li>
</ol>
<h4 id="AOF默认不开启"><a href="#AOF默认不开启" class="headerlink" title="AOF默认不开启"></a>AOF默认不开启</h4><p>可以在redis.conf中配置文件名称，默认为 appendonly.aof<br>AOF文件的保存路径，同RDB的路径一致。</p>
<h4 id="AOF和RDB同时开启，redis听谁的？"><a href="#AOF和RDB同时开启，redis听谁的？" class="headerlink" title="AOF和RDB同时开启，redis听谁的？"></a>AOF和RDB同时开启，redis听谁的？</h4><p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</p>
<h4 id="AOF启动-x2F-修复-x2F-恢复"><a href="#AOF启动-x2F-修复-x2F-恢复" class="headerlink" title="AOF启动&#x2F;修复&#x2F;恢复"></a>AOF启动&#x2F;修复&#x2F;恢复</h4><p>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p>
<p>正常恢复</p>
<ul>
<li>修改默认的appendonly no，改为yes</li>
<li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li>
<li>恢复：重启redis然后重新加载</li>
</ul>
<p>异常恢复</p>
<ul>
<li>修改默认的appendonly no，改为yes</li>
<li>如遇到AOF文件损坏，通过&#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-check-aof–fix appendonly.aof进行恢复</li>
<li>备份被写坏的AOF文件</li>
<li>恢复：重启redis，然后重新加载</li>
</ul>
<h4 id="AOF同步频率设置"><a href="#AOF同步频率设置" class="headerlink" title="AOF同步频率设置"></a>AOF同步频率设置</h4><p>appendfsync always 始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好<br>appendfsync everysec 每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。<br>appendfsync no redis不主动进行同步，把同步时机交给操作系统。</p>
<h4 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a>Rewrite压缩</h4><p>1.是什么：</p>
<p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p>
<p>2.重写原理，如何实现重写<br>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。<br>no-appendfsync-on-rewrite：<br>如果 no-appendfsync-on-rewrite&#x3D;yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）<br>    如果 no-appendfsync-on-rewrite&#x3D;no,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）<br>触发机制，何时重写<br>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发<br>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。<br>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）<br>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。<br>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB<br>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,<br>如果Redis的AOF当前大小&gt;&#x3D; base_size +base_size*100% (默认)且当前大小&gt;&#x3D;64mb(默认)的情况下，Redis会对AOF进行重写。 </p>
<p>3、重写流程<br>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。<br>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。<br>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。<br>（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。<br>（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p>
<img src="/images/Redis学习/AOF-重写流程.png" alt="AOF-重写流程" style="zoom:50%;" />

<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul>
<li>备份机制更稳健，丢失数据概率更低。</li>
<li>可读的日志文本，通过操作AOF稳健，可以处理误操作。</li>
</ul>
<h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li>比起RDB占用更多的磁盘空间。</li>
<li>恢复备份速度要慢。</li>
<li>每次读写都同步的话，有一定的性能压力。</li>
<li>存在个别Bug，造成恢复不能。</li>
</ul>
<h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/AOF-%E5%B0%8F%E6%80%BB%E7%BB%93.png" alt="AOF-小总结"></p>
<h4 id="用哪个好"><a href="#用哪个好" class="headerlink" title="用哪个好"></a>用哪个好</h4><p>官方推荐两个都启用。<br>如果对数据不敏感，可以选单独用RDB。<br>不建议单独用 AOF，因为可能会出现Bug。<br>如果只是做纯内存缓存，可以都不用。</p>
<h4 id="官网建议"><a href="#官网建议" class="headerlink" title="官网建议"></a><strong>官网建议</strong></h4><ul>
<li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li>
<li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. </li>
<li>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</li>
<li>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li>
</ul>
<p>同时开启两种持久化方式</p>
<ul>
<li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li>
</ul>
<p>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ </p>
<ul>
<li>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li>
</ul>
<p>l 性能建议</p>
<blockquote>
<p>因为RDB文件只用作后备用途，建议只在<strong>Slave上持久化RDB文件</strong>，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。     如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。  代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。  只要硬盘许可，应该尽量减少AOF  rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。  默认超过原大小100%大小时重写可以改到适当的数值。  </p>
</blockquote>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h2><ol>
<li>纯内存操作</li>
<li>数据结构简单，底层深度优化</li>
<li>单线程操作，无锁竞争，避免了频繁的上下文切换</li>
<li>采用了非阻塞I&#x2F;O多路复用机制</li>
</ol>
<h2 id="为什么Redis是单线程的"><a href="#为什么Redis是单线程的" class="headerlink" title="为什么Redis是单线程的"></a><strong>为什么Redis是单线程的</strong></h2><p><strong>1.官方答案</strong></p>
<p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<p><strong>2.性能指标</strong></p>
<p>关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>
<p><strong>3.详细原因</strong></p>
<p><strong>1）不需要各种锁的性能消耗</strong></p>
<p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除</p>
<p>一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p>
<p>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p>
<p><strong>2）单线程多进程集群方案</strong></p>
<p>单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p>
<p><strong>所以单线程、多进程的集群不失为一个时髦的解决方案。</strong></p>
<p><strong>3）CPU消耗</strong></p>
<p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p>
<p>但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p>
<p>可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p>
<h2 id="Redis有哪些优缺点"><a href="#Redis有哪些优缺点" class="headerlink" title="Redis有哪些优缺点"></a>Redis有哪些优缺点</h2><p>优点</p>
<ul>
<li>读写性能优异， Redis能读的速度是110000次&#x2F;s，写的速度是81000次&#x2F;s。</li>
<li>支持数据持久化，支持AOF和RDB两种持久化方式。</li>
<li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li>
<li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
<p>缺点</p>
<ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h2 id="Redis-默认支持多少个数据库？怎么修改？"><a href="#Redis-默认支持多少个数据库？怎么修改？" class="headerlink" title="Redis 默认支持多少个数据库？怎么修改？"></a>Redis 默认支持多少个数据库？怎么修改？</h2><p>Redis 默认支持 16 个数据库。</p>
<p>可以通过修改 Redis 配置文件 redis.conf 中的 databases 一值进行变更。</p>
<h2 id="最大Key大小"><a href="#最大Key大小" class="headerlink" title="最大Key大小"></a>最大Key大小</h2><p>512MB，最大value是String的话也是512MB</p>
<h2 id="为什么要用-Redis-x2F-为什么要用缓存"><a href="#为什么要用-Redis-x2F-为什么要用缓存" class="headerlink" title="为什么要用 Redis &#x2F;为什么要用缓存"></a>为什么要用 Redis &#x2F;为什么要用缓存</h2><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<h3 id="高性能："><a href="#高性能：" class="headerlink" title="高性能："></a>高性能：</h3><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<h3 id="高并发："><a href="#高并发：" class="headerlink" title="高并发："></a>高并发：</h3><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<h2 id="Redis有哪些数据类型"><a href="#Redis有哪些数据类型" class="headerlink" title="Redis有哪些数据类型"></a>Redis有哪些数据类型</h2><p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求</p>
<h2 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h2><ul>
<li>计数器</li>
</ul>
<p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<ul>
<li>缓存</li>
</ul>
<p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<ul>
<li>会话缓存</li>
</ul>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<ul>
<li>全页缓存（FPC）</li>
</ul>
<p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
<ul>
<li>查找表</li>
</ul>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<ul>
<li>消息队列(发布&#x2F;订阅功能)</li>
</ul>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<ul>
<li>分布式锁实现</li>
</ul>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<ul>
<li>其它</li>
</ul>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
<h2 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h2><h3 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h3><p>我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<p>过期策略通常有以下三种：</p>
<ul>
<li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</li>
</ul>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h3 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h3><p>EXPIRE和PERSIST命令。</p>
<h3 id="我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢"><a href="#我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢" class="headerlink" title="我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?"></a>我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h2><h3 id="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</h3><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h3 id="Redis的内存淘汰策略有哪些"><a href="#Redis的内存淘汰策略有哪些" class="headerlink" title="Redis的内存淘汰策略有哪些"></a>Redis的内存淘汰策略有哪些</h3><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<p>全局的键空间选择性移除</p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
</ul>
<p>设置过期时间的键空间选择性移除</p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p>
<h3 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h3><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<h3 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h3><p>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面</p>
<h2 id="事务相关"><a href="#事务相关" class="headerlink" title="事务相关"></a>事务相关</h2><h3 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h3><p>Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<h3 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
<h3 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h3><p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h2 id="集群相关"><a href="#集群相关" class="headerlink" title="集群相关"></a>集群相关</h2><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="哨兵模式结构图"></p>
<p>哨兵的介绍</p>
<p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<p>哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<ul>
<li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li>
</ul>
<p>哨兵的核心知识</p>
<ul>
<li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li>
<li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</li>
<li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
</ul>
<h3 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h3><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。</p>
<p>redis-master-slave</p>
<p>redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p>
<p>redis replication 的核心机制</p>
<ul>
<li>redis 采用异步方式复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li>
<li>一个 master node 是可以配置多个 slave node 的；</li>
<li>slave node 也可以连接其他的 slave node；</li>
<li>slave node 做复制的时候，不会 block master node 的正常工作；</li>
<li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li>
<li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li>
</ul>
<p>注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p>
<p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p>
<h2 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h2><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p>
<p>当且仅当 key 不存在，将 key 的值设为 value。若给定的 key 已经存在，则 SETNX 不做任何动作</p>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>返回值：设置成功，返回 1 。设置失败，返回 0 。</p>
<ul>
<li><p>使用SETNX完成同步锁的流程及事项如下：</p>
<p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</p>
<p>为了防止获取锁后程序出现异常，导致其他线程&#x2F;进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p>
</li>
<li><p>释放锁，使用DEL命令将锁数据删除</p>
</li>
</ul>
<h3 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h3><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p>
<p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
<p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p>
<h3 id="分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>分布式Redis是前期做还是后期规模上来了再做好？为什么？</h3><p>既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p>
<h3 id="什么是-RedLock"><a href="#什么是-RedLock" class="headerlink" title="什么是 RedLock"></a>什么是 RedLock</h3><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 <em>Redlock</em>，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li>
<li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li>
</ol>
<h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案</p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</li>
</ol>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案</p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p>解决方案</p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，互斥锁</li>
</ol>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作一下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h3 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h3><p>热点数据，缓存才有价值</p>
<p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</p>
<p>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p>
<p>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p>
<p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p>
<h3 id="缓存热点key"><a href="#缓存热点key" class="headerlink" title="缓存热点key"></a>缓存热点key</h3><p>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p><strong>解决方案</strong></p>
<p>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询</p>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>Redis支持的Java客户端都有哪些？官方推荐用哪个？</h3><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>
<h3 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h3><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, HyperLogLog)。</p>
<h3 id="Jedis与Redisson对比有什么优缺点？"><a href="#Jedis与Redisson对比有什么优缺点？" class="headerlink" title="Jedis与Redisson对比有什么优缺点？"></a>Jedis与Redisson对比有什么优缺点？</h3><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h3><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Redis%E4%B8%8EMemcached%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="Redis与Memcached的区别"></p>
<p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p>
<p>(2) redis的速度比memcached快很多</p>
<p>(3) redis可以持久化其数据</p>
<ul>
<li>Redis和Memcached都是将数据存放在内存中，都是内存数据库，不过memcache还用于缓存其他东西，例如：图片、视频等等</li>
<li>Redis不仅仅支持简单的k&#x2F;v类型的数据，同时还提供list、set、hash等数据结构的存储</li>
<li>虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value交换到磁盘</li>
<li>过期策略–memcache在set时就指定，例如set key1 0 0 8，即永不过期。Redis可以通过例如expire设定，例如expire name 10；</li>
<li>分布式–设定memcached集群，利用magent做一主多从；redis可以做一主多从。都可以一主一从</li>
<li>存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）</li>
<li>灾难恢复–memcached挂掉后，数据不可恢复；redis数据丢失后可以通过aof恢复</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份</li>
<li>memcached是高性能的分布式内存缓存服务器。<em>一般使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态web应用的速度、提高可扩展性。</em></li>
<li>redis是一个开源的内存<a href="http://lib.csdn.net/base/mysql">数据库</a>，它以键值对的形式存储数据。由于数据存储在内存中，因此Redis的速度很快，但是每次重启Redis服务时，其中的数据也会丢失，因此，Redis也提供了持久化存储机制，将数据以某种形式保存在文件中，每次重启时，可以自动从文件加载数据到内存当中。</li>
</ul>
<h3 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h3><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p>
<p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是<strong>先更新数据库，然后再删除缓存。</strong></p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%97%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7.png" alt="缓存与数据库双写时数据的一致性"></p>
<h3 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h3><ol>
<li>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库</li>
<li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li>
<li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li>
</ol>
<h3 id="一个字符串类型的值能存储最大容量是多少？"><a href="#一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="一个字符串类型的值能存储最大容量是多少？"></a>一个字符串类型的值能存储最大容量是多少？</h3><p>512M</p>
<h3 id="Redis如何做大量数据插入？"><a href="#Redis如何做大量数据插入？" class="headerlink" title="Redis如何做大量数据插入？"></a>Redis如何做大量数据插入？</h3><p>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p>
<h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。</p>
<p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p>
<p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h3 id="Redis回收进程如何工作的？"><a href="#Redis回收进程如何工作的？" class="headerlink" title="Redis回收进程如何工作的？"></a>Redis回收进程如何工作的？</h3><ol>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
</ol>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<h3 id="Redis回收使用的是什么算法？"><a href="#Redis回收使用的是什么算法？" class="headerlink" title="Redis回收使用的是什么算法？"></a>Redis回收使用的是什么算法？</h3><p>LRU算法，LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<h2 id="Redis如何统计独立用户访问量"><a href="#Redis如何统计独立用户访问量" class="headerlink" title="Redis如何统计独立用户访问量"></a>Redis如何统计独立用户访问量</h2><h3 id="使用Hash"><a href="#使用Hash" class="headerlink" title="使用Hash"></a><strong>使用Hash</strong></h3><p>哈希是Redis的一种基础数据结构，Redis底层维护的是一个开散列，会把不同的key映射到哈希表上，如果是遇到关键字冲突，那么就会拉出一个链表出来。</p>
<p>当一个用户访问的时候，如果用户登陆过，那么我们就使用用户的id，如果用户没有登陆过，那么我们也能够前端页面随机生成一个key用来标识用户，当用户访问的时候，我们可以使用<strong>HSET</strong>命令，key可以选择URI与对应的日期进行拼凑，field可以使用用户的id或者随机标识，value可以简单设置为1。</p>
<p>当我们要统计某一个网站某一天的访问量的时候，就可以直接使用<strong>HLEN</strong>来得到最终的结果了。</p>
<p><strong>优点：</strong>简单，容易实现，查询也是非常方便，数据准确性非常高。</p>
<p><strong>缺点：</strong>占用内存过大，。随着key的增多，性能也会下降。小网站还行，拼多多这种数亿PV的网站肯定受不了</p>
<h3 id="使用Bitset"><a href="#使用Bitset" class="headerlink" title="使用Bitset"></a><strong>使用Bitset</strong></h3><p>我们知道，对于一个32位的int，如果我们只用来记录id，那么只能够记录一个用户，但如果我们转成2进制，每位用来表示一个用户，那么我们就能够一口气表示32个用户，空间节省了32倍！对于有大量数据的场景，如果我们使用bitset，那么，可以节省非常多的内存。对于没有登陆的用户，我们也可以使用哈希算法，把对应的用户标识哈希成一个数字id。bitset非常的节省内存，假设有1亿个用户，也只需要100000000&#x2F;8&#x2F;1024&#x2F;1024约等于12兆内存。</p>
<p>Redis已经为我们提供了SETBIT的方法，使用起来非常的方便，我们可以看看下面的例子，我们在item页面可以不停地使用SETBIT命令，设置用户已经访问了该页面，也可以使用GETBIT的方法查询某个用户是否访问。最后我们通过BITCOUNT可以统计该网页每天的访问数量。</p>
<p><strong>优点</strong>占用内存更小，查询方便，可以指定查询某个用户，数据可能略有瑕疵，对于非登陆的用户，可能不同的key映射到同一个id，否则需要维护一个非登陆用户的映射，有额外的开销。</p>
<p><strong>缺点</strong>如果用户非常的稀疏，那么占用的内存可能比方法一更大。</p>
<h3 id="使用概率算法"><a href="#使用概率算法" class="headerlink" title="使用概率算法"></a><strong>使用概率算法</strong></h3><p>对于拼多多这种多个页面都可能非常多访问量的网站，如果所需要的数量不用那么准确，可以使用概率算法，事实上，我们对一个网站的UV的统计，1亿跟1亿零30万其实是差不多的。在Redis中，已经封装了HyperLogLog算法，他是一种基数评估算法。这种算法的特征，一般都是数据不存具体的值，而是存用来计算概率的一些相关数据。</p>
<p>当用户访问网站的时候，我们可以使用<strong>PFADD</strong>命令，设置对应的命令，最后我们只要通过<strong>PFCOUNT</strong>就能顺利计算出最终的结果，因为这个只是一个概率算法，所以可能存在0.81%的误差。</p>
<p><strong>优点</strong>占用内存极小，对于一个key，只需要12kb。对于拼多多这种超多用户的特别适用。</p>
<p><strong>缺点</strong>查询指定用户的时候，可能会出错，毕竟存的不是具体的数据。总数也存在一定的误差。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器 ECS CentOS 7配置默认防火墙 Firewall</title>
    <url>/2019/01/11/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-ECS-CentOS-7%E9%85%8D%E7%BD%AE%E9%BB%98%E8%AE%A4%E9%98%B2%E7%81%AB%E5%A2%99-Firewall/</url>
    <content><![CDATA[<p>阿里云服务器的 CentOS7 下默认的防火墙是 Firewall，替代了之前的 iptables，Firewall 有图形界面管理和命令行管理两种方式，本文简要介绍命令行 Firewall 的使用。</p>
<h3 id="配置-Firewall"><a href="#配置-Firewall" class="headerlink" title="配置 Firewall"></a>配置 Firewall</h3><p>进入系统之后，CentOS7 默认是已安装了 Firewall，但是没有启动的，所以需要先启动下 Firewall，同时设置开机自启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld       ##启动Firewall</span><br><span class="line">systemctl enable firewalld.service  ##设置开机自启动</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s &#x27;/usr/lib/systemd/system/firewalld.service&#x27; &#x27;/etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service&#x27;</span><br><span class="line">ln -s &#x27;/usr/lib/systemd/system/firewalld.service&#x27; &#x27;/etc/systemd/system/basic.target.wants/firewalld.service&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="常用命令介绍"><a href="#常用命令介绍" class="headerlink" title="常用命令介绍"></a>常用命令介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state                           ##查看防火墙状态，是否是running</span><br><span class="line">firewall-cmd --reload                          ##重新载入配置，比如添加规则之后，需要执行此命令</span><br><span class="line">firewall-cmd --get-zones                       ##列出支持的zone</span><br><span class="line">firewall-cmd --get-services                    ##列出支持的服务，在列表中的服务是放行的</span><br><span class="line">firewall-cmd --query-service ftp               ##查看ftp服务是否支持，返回yes或者no</span><br><span class="line">firewall-cmd --add-service=ftp                 ##临时开放ftp服务</span><br><span class="line">firewall-cmd --add-service=ftp --permanent     ##永久开放ftp服务</span><br><span class="line">firewall-cmd --remove-service=ftp --permanent  ##永久移除ftp服务</span><br><span class="line">firewall-cmd --add-port=80/tcp --permanent     ##永久添加80端口 </span><br><span class="line">iptables -L -n                                 ##查看规则，这个命令是和iptables的相同的</span><br><span class="line">man firewall-cmd                               ##查看帮助</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ECS</category>
      </categories>
      <tags>
        <tag>ECS</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown使用指南</title>
    <url>/2018/11/23/markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<h2 id="markdown使用指南"><a href="#markdown使用指南" class="headerlink" title="markdown使用指南"></a>markdown使用指南</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>标题能显示出文章的结构。行首插入1-6个 # ，每增加一个 # 表示更深入层次的内容，对应到标题的深度由 1-6 阶。</p>
<pre><code>H1 :# Header 1
H2 :## Header 2
H3 :### Header 3
H4 :#### Header 4
H5 :##### Header 5
H6 :###### Header 6
</code></pre>
<span id="more"></span>
<h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><p>（带“*”星号的文本样式，在原版Markdown标准中不存在，但在其大部分衍生标准中被添加）</p>
<pre><code>链接 :[Title](URL)
加粗 :**Bold**
斜体字 :*Italics*
*高亮 :==text==
段落 : 段落之间空一行
换行符 : 一行结束时输入两个空格
列表 :* 添加星号成为一个新的列表项。
引用 :&gt; 引用内容
内嵌代码 : `alert(&#39;Hello World&#39;);`
画水平线 (HR) :--------
方框：- [ ] -
</code></pre>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>使用Markdown将图像插入文章，你需要在Markdown编辑器输入 <strong><code>![]()</code></strong> 。 这时在预览面板中会自动创建一个图像上传框。你可以从电脑桌面拖放图片(.png, .gif, .jpg)到上传框, 或者点击图片上传框使用标准的图像上传方式。 如果你想通过链接插入网络上已经存在的图片，只要单击图片上传框的左下角的“链接”图标，这时就会呈现图像URL的输入框。想给图片添加一个标题, 你需要做的是将标题文本插图中的方括号， <strong><code>e.g;![This is a title]()</code></strong> .</p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注不存在于标准Markdown中。<br>使用这样的占位符号可以将脚注添加到文本中:[^1]. 另外，你可以使用“n”而不是数字的[^n]所以你可以不必担心使用哪个号码。在您的文章的结尾，你可以如下图所示定义匹配的注脚，URL将变成链接:<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里是脚注[^1]</span><br><span class="line">[^1]: 这里是脚注的内容</span><br><span class="line">这里是脚注[^n]</span><br><span class="line">[^n]: 这里是脚注的内容</span><br></pre></td></tr></table></figure></p>
<h3 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h3><p>添加内嵌代码可以使用一对回勾号 <strong>`alert(‘Hello World’)`</strong> .对于插入代码, Ghost支持标准的Markdown代码和GitHub Flavored Markdown (GFM) [4]  。标准Markdown基于缩进代码行或者4个空格位:<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\</span><br><span class="line">    insert code</span><br><span class="line">    insert code</span><br><span class="line">    insert code</span><br><span class="line">\</span><br><span class="line"></span><br><span class="line">**删除\**</span><br></pre></td></tr></table></figure></p>
<p>GFM 使用三个回勾号```<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">``\`</span><br><span class="line">insert code</span><br><span class="line">insert code</span><br><span class="line">insert code</span><br><span class="line">``\`</span><br><span class="line"></span><br><span class="line">**删除\**</span><br></pre></td></tr></table></figure></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>链接<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is a paragraph that contains a [link to example]()</span><br></pre></td></tr></table></figure></p>
<p>列表格式<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This paragraph contains a list of items.</span><br><span class="line">* Item 1</span><br><span class="line">* Item 2</span><br><span class="line">* Item three</span><br></pre></td></tr></table></figure></p>
<p>使用Markdown 引用文本：	<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This paragraph has a quote</span><br><span class="line"></span><br><span class="line">&gt; That is pulled out like this</span><br><span class="line">from the text my post.</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC核心知识点</title>
    <url>/2021/04/20/JUC%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>JMM是指Java<strong>内存模型</strong>，不是Java<strong>内存布局</strong>，不是所谓的栈、堆、方法区。</p>
<p>每个Java线程都有自己的<strong>工作内存</strong>。操作数据，首先从主内存中读，得到一份拷贝，操作完毕后再写回到主内存。</p>
<p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/JMM.png" alt="threadPoolProcedure">JMM可能带来<strong>可见性</strong>、<strong>原子性</strong>和<strong>有序性</strong>问题。所谓可见性，就是某个线程对主内存内容的更改，应该立刻通知到其它线程。原子性是指一个操作是不可分割的，不能执行到一半，就不执行了。所谓有序性，就是指令是有序的，不会被重排。</p>
<span id="more"></span>

<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p><code>volatile</code>关键字是Java提供的一种<strong>轻量级</strong>同步机制。它能够保证<strong>可见性</strong>和<strong>有序性</strong>，但是不能保证<strong>原子性</strong>。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/thread/VolatileDemo.java">可见性测试</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//volatile int number=0;</span></span><br><span class="line"></span><br><span class="line">    AtomicInteger atomicInteger=<span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTo60</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.number=<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时number前面已经加了volatile，但是不保证原子性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPlusPlus</span><span class="params">()</span>&#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtomic</span><span class="params">()</span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//volatile可以保证可见性，及时通知其它线程主物理内存的值已被修改</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">volatileVisibilityDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;可见性测试&quot;</span>);</span><br><span class="line">    <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();<span class="comment">//资源类</span></span><br><span class="line">    <span class="comment">//启动一个线程操作共享数据</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">3</span>);myData.setTo60();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t update number value: &quot;</span>+myData.number);&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;e.printStackTrace();&#125;</span><br><span class="line">    &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">    <span class="keyword">while</span> (myData.number==<span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">//main线程持有共享数据的拷贝，一直为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t mission is over. main get number value: &quot;</span>+myData.number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MyData</code>类是资源类，一开始<code>number</code>变量没有用<code>volatile</code>修饰，所以程序运行的结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">可见性测试</span><br><span class="line">AAA	 come in</span><br><span class="line">AAA	 update number value: <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>虽然一个线程把<code>number</code>修改成了60，但是<code>main</code>线程持有的仍然是最开始的0，所以一直循环，程序不会结束。</p>
<p>如果对<code>number</code>添加了<code>volatile</code>修饰，运行结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AAA	 come in</span><br><span class="line">AAA	 update number value: <span class="number">60</span></span><br><span class="line">main	 mission is over. main get number value: <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>可见某个线程对<code>number</code>的修改，会立刻反映到主内存上。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p><code>volatile</code>并<strong>不能保证操作的原子性</strong>。这是因为，比如一条number++的操作，会形成3条指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getfield        //读</span><br><span class="line">iconst_1	//++常量1</span><br><span class="line">iadd		//加操作</span><br><span class="line">putfield	//写操作</span><br></pre></td></tr></table></figure>

<p>假设有3个线程，分别执行number++，都先从主内存中拿到最开始的值，number&#x3D;0，然后三个线程分别进行操作。假设线程0执行完毕，number&#x3D;1，也立刻通知到了其它线程，但是此时线程1、2已经拿到了number&#x3D;0，所以结果就是写覆盖，线程1、2将number变成1。</p>
<p>解决的方式就是：</p>
<ol>
<li>对<code>addPlusPlus()</code>方法加锁。</li>
<li>使用<code>java.util.concurrent.AtomicInteger</code>类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">atomicDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;原子性测试&quot;</span>);</span><br><span class="line">    MyData myData=<span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                myData.addPlusPlus();</span><br><span class="line">                myData.addAtomic();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t int type finally number value: &quot;</span>+myData.number);</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t AtomicInteger type finally number value: &quot;</span>+myData.atomicInteger);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：可见，由于<code>volatile</code>不能保证原子性，出现了线程重复写的问题，最终结果比20000小。而<code>AtomicInteger</code>可以保证原子性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">原子性测试</span><br><span class="line">main	 <span class="type">int</span> type <span class="keyword">finally</span> number value: <span class="number">17542</span></span><br><span class="line">main	 AtomicInteger type <span class="keyword">finally</span> number value: <span class="number">20000</span></span><br></pre></td></tr></table></figure>

<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p><a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/thread/ResortSeqDemo.java">有序性案例</a></p>
<p>volatile可以保证<strong>有序性</strong>，也就是防止<strong>指令重排序</strong>。所谓指令重排序，就是出于优化考虑，CPU执行指令的顺序跟程序员自己编写的顺序不一致。就好比一份试卷，题号是老师规定的，是程序员规定的，但是考生（CPU）可以先做选择，也可以先做填空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11</span>; <span class="comment">//语句1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">12</span>; <span class="comment">//语句2</span></span><br><span class="line">x = x + <span class="number">5</span>;  <span class="comment">//语句3</span></span><br><span class="line">y = x * x;  <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p>以上例子，可能出现的执行顺序有1234、2134、1342，这三个都没有问题，最终结果都是x &#x3D; 16，y&#x3D;256。但是如果是4开头，就有问题了，y&#x3D;0。这个时候就<strong>不需要</strong>指令重排序。</p>
<p>volatile底层是用CPU的<strong>内存屏障</strong>（Memory Barrier）指令来实现的，有两个作用，一个是保证特定操作的顺序性，二是保证变量的可见性。在指令之间插入一条Memory Barrier指令，告诉编译器和CPU，在Memory Barrier指令之间的指令不能被重排序。</p>
<h2 id="哪些地方用到过volatile？"><a href="#哪些地方用到过volatile？" class="headerlink" title="哪些地方用到过volatile？"></a>哪些地方用到过volatile？</h2><h3 id="单例模式的安全问题"><a href="#单例模式的安全问题" class="headerlink" title="单例模式的安全问题"></a>单例模式的安全问题</h3><p>常见的DCL（Double Check Lock）模式虽然加了同步，但是在多线程下依然会有线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo singletonDemo=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 我是构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DCL模式 Double Check Lock 双端检索机制：在加锁前后都进行判断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonDemo==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo.class)&#123;</span><br><span class="line">                 <span class="keyword">if</span> (singletonDemo==<span class="literal">null</span>)&#123;</span><br><span class="line">                     singletonDemo=<span class="keyword">new</span> <span class="title class_">SingletonDemo</span>();</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonDemo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;,String.valueOf(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个漏洞比较tricky，很难捕捉，但是是存在的。<code>instance=new SingletonDemo();</code>可以大致分为三步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();     <span class="comment">//1.分配内存</span></span><br><span class="line">instance(memory);	 <span class="comment">//2.初始化对象</span></span><br><span class="line">instance = memory;	 <span class="comment">//3.设置引用地址</span></span><br></pre></td></tr></table></figure>

<p>其中2、3没有数据依赖关系，<strong>可能发生重排</strong>。如果发生，此时内存已经分配，那么<code>instance=memory</code>不为null。如果此时线程挂起，<code>instance(memory)</code>还未执行，对象还未初始化。由于<code>instance!=null</code>，所以两次判断都跳过，最后返回的<code>instance</code>没有任何内容，还没初始化。</p>
<p>解决的方法就是对<code>singletondemo</code>对象添加上<code>volatile</code>关键字，禁止指令重排。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS是指<strong>Compare And Swap</strong>，<strong>比较并交换</strong>，是一种很重要的同步思想。如果主内存的值跟期望值一样，那么就进行修改，否则一直重试，直到一致为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AtomicInteger atomicInteger=<span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>)+<span class="string">&quot;\t current data : &quot;</span>+ atomicInteger.get());</span><br><span class="line">        <span class="comment">//修改失败</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>)+<span class="string">&quot;\t current data : &quot;</span>+ atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次修改，期望值为5，主内存也为5，修改成功，为2019。第二次修改，期望值为5，主内存为2019，修改失败。</p>
<p>查看<code>AtomicInteger.getAndIncrement()</code>方法，发现其没有加<code>synchronized</code><strong>也实现了同步</strong>。这是为什么？</p>
<h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><p><code>AtomicInteger</code>内部维护了<code>volatile int value</code>和<code>private  static final Unsafe unsafe</code>两个比较重要的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>,valueOffset,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AtomicInteger.getAndIncrement()</code>调用了<code>Unsafe.getAndAddInt()</code>方法。<code>Unsafe</code>类的大部分方法都是<code>native</code>的，用来像C语言一样从底层操作内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAnddAddInt</span><span class="params">(Object var1,<span class="type">long</span> var2,<span class="type">int</span> var4)</span>&#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的var1和var2，就是根据<strong>对象</strong>和<strong>偏移量</strong>得到在<strong>主内存的快照值</strong>var5。然后<code>compareAndSwapInt</code>方法通过var1和var2得到当前<strong>主内存的实际值</strong>。如果这个<strong>实际值</strong>跟<strong>快照值</strong>相等，那么就更新主内存的值为var5+var4。如果不等，那么就一直循环，一直获取快照，一直对比，直到实际值和快照值相等为止。</p>
<p>比如有A、B两个线程，一开始都从主内存中拷贝了原值为3，A线程执行到<code>var5=this.getIntVolatile</code>，即var5&#x3D;3。此时A线程挂起，B修改原值为4，B线程执行完毕，由于加了volatile，所以这个修改是立即可见的。A线程被唤醒，执行<code>this.compareAndSwapInt()</code>方法，发现这个时候主内存的值不等于快照值3，所以继续循环，<strong>重新</strong>从主内存获取。</p>
<h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><p>CAS实际上是一种自旋锁，</p>
<ol>
<li>一直循环，开销比较大。</li>
<li>只能保证一个变量的原子操作，多个变量依然要加锁。</li>
<li>引出了<strong>ABA问题</strong>。</li>
</ol>
<h1 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h1><p>所谓ABA问题，就是比较并交换的循环，存在一个<strong>时间差</strong>，而这个时间差可能带来意想不到的问题。比如线程T1将值从A改为B，然后又从B改为A。线程T2看到的就是A，但是<strong>却不知道这个A发生了更改</strong>。尽管线程T2 CAS操作成功，但不代表就没有问题。<br>有的需求，比如CAS，<strong>只注重头和尾</strong>，只要首尾一致就接受。但是有的需求，还看重过程，中间不能发生任何修改，这就引出了<code>AtomicReference</code>原子引用。</p>
<h2 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h2><p><code>AtomicInteger</code>对整数进行原子操作，如果是一个POJO呢？可以用<code>AtomicReference</code>来包装这个POJO，使其操作原子化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">25</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Lucy&quot;</span>,<span class="number">21</span>);</span><br><span class="line">AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">atomicReference.set(user1);</span><br><span class="line">System.out.println(atomicReference.compareAndSet(user1,user2)); <span class="comment">// true</span></span><br><span class="line">System.out.println(atomicReference.compareAndSet(user1,user2)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="AtomicStampedReference和ABA问题的解决"><a href="#AtomicStampedReference和ABA问题的解决" class="headerlink" title="AtomicStampedReference和ABA问题的解决"></a>AtomicStampedReference和ABA问题的解决</h2><p>使用<code>AtomicStampedReference</code>类可以解决ABA问题。这个类维护了一个“<strong>版本号</strong>”Stamp，在进行CAS操作的时候，不仅要比较当前值，还要比较<strong>版本号</strong>。只有两者都相等，才执行更新操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicStampedReference.compareAndSet(expectedReference,newReference,oldStamp,newStamp);</span><br></pre></td></tr></table></figure>

<p>详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/thread/ABADemo.java">ABADemo</a>。</p>
<h1 id="集合类不安全问题"><a href="#集合类不安全问题" class="headerlink" title="集合类不安全问题"></a>集合类不安全问题</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><code>ArrayList</code>不是线程安全类，在多线程同时写的情况下，会抛出<code>java.util.ConcurrentModificationException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listNotSafe</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + list);</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：</p>
<ol>
<li>使用<code>Vector</code>（<code>ArrayList</code>所有方法加<code>synchronized</code>，太重）。</li>
<li>使用<code>Collections.synchronizedList()</code>转换成线程安全类。</li>
<li>使用<code>java.concurrent.CopyOnWriteArrayList</code>（推荐）。</li>
</ol>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>这是JUC的类，通过<strong>写时复制</strong>来实现<strong>读写分离</strong>。比如其<code>add()</code>方法，就是先<strong>复制</strong>一个新数组，长度为原数组长度+1，然后将新数组最后一个元素设为添加的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//得到旧数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">//复制新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//设置新元素</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//设置新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>跟List类似，<code>HashSet</code>和<code>TreeSet</code>都不是线程安全的，与之对应的有<code>CopyOnWriteSet</code>这个线程安全类。这个类底层维护了一个<code>CopyOnWriteArrayList</code>数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">    al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet和HashMap"><a href="#HashSet和HashMap" class="headerlink" title="HashSet和HashMap"></a>HashSet和HashMap</h3><p><code>HashSet</code>底层是用<code>HashMap</code>实现的。既然是用<code>HashMap</code>实现的，那<code>HashMap.put()</code>需要传<strong>两个参数</strong>，而<code>HashSet.add()</code>只<strong>传一个参数</strong>，这是为什么？实际上<code>HashSet.add()</code>就是调用的<code>HashMap.put()</code>，只不过<strong>Value</strong>被写死了，是一个<code>private static final Object</code>对象。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>HashMap</code>不是线程安全的，<code>Hashtable</code>是线程安全的，但是跟<code>Vector</code>类似，太重量级。所以也有类似CopyOnWriteMap，只不过叫<code>ConcurrentHashMap</code>。</p>
<p>关于集合不安全类请看<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/thread/ContainerNotSafeDemo.java">ContainerNotSafeDemo</a>。</p>
<h1 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h1><h2 id="公平锁-x2F-非公平锁"><a href="#公平锁-x2F-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h2><p><strong>概念</strong>：所谓<strong>公平锁</strong>，就是多个线程按照<strong>申请锁的顺序</strong>来获取锁，类似排队，先到先得。而<strong>非公平锁</strong>，则是多个线程抢夺锁，会导致<strong>优先级反转</strong>或<strong>饥饿现象</strong>。</p>
<p><strong>区别</strong>：公平锁在获取锁时先查看此锁维护的<strong>等待队列</strong>，<strong>为空</strong>或者当前线程是等待队列的<strong>队首</strong>，则直接占有锁，否则插入到等待队列，FIFO原则。非公平锁比较粗鲁，上来直接<strong>先尝试占有锁</strong>，失败则采用公平锁方式。非公平锁的优点是<strong>吞吐量</strong>比公平锁更大。</p>
<p><code>synchronized</code>和<code>juc.ReentrantLock</code>默认都是<strong>非公平锁</strong>。<code>ReentrantLock</code>在构造的时候传入<code>true</code>则是<strong>公平锁</strong>。</p>
<h2 id="可重入锁-x2F-递归锁"><a href="#可重入锁-x2F-递归锁" class="headerlink" title="可重入锁&#x2F;递归锁"></a>可重入锁&#x2F;递归锁</h2><p>可重入锁又叫递归锁，指的同一个线程在<strong>外层方法</strong>获得锁时，进入<strong>内层方法</strong>会自动获取锁。也就是说，线程可以进入任何一个它已经拥有锁的代码块。比如<code>get</code>方法里面有<code>set</code>方法，两个方法都有同一把锁，得到了<code>get</code>的锁，就自动得到了<code>set</code>的锁。</p>
<p>就像有了家门的锁，厕所、书房、厨房就为你敞开了一样。可重入锁可以<strong>避免死锁</strong>的问题。</p>
<p>ReentrantLockDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Phone phone=<span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        syncTest(phone);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Thread t3=<span class="keyword">new</span> <span class="title class_">Thread</span>(phone);</span><br><span class="line">        Thread t4=<span class="keyword">new</span> <span class="title class_">Thread</span>(phone);</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">syncTest</span><span class="params">(Phone phone)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//Synchronized TEST</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;sendSMS()&quot;</span>);</span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;sendEmail()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Reentrant TEST</span></span><br><span class="line"></span><br><span class="line">    Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;get()&quot;</span>);</span><br><span class="line">            set();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;set()&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="锁的配对"><a href="#锁的配对" class="headerlink" title="锁的配对"></a>锁的配对</h3><p>锁之间要配对，加了几把锁，最后就得解开几把锁，下面的代码编译和运行都没有任何问题，但锁的数量不匹配会导致死循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    someAction();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>所谓自旋锁，就是尝试获取锁的线程不会<strong>立即阻塞</strong>，而是采用<strong>循环的方式去尝试获取</strong>。自己在那儿一直循环获取，就像“<strong>自旋</strong>”一样。这样的好处是减少<strong>线程切换的上下文开销</strong>，缺点是会<strong>消耗CPU</strong>。CAS底层的<code>getAndAddInt</code>就是<strong>自旋锁</strong>思想。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跟CAS类似，一直循环比较。</span></span><br><span class="line"><span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>SpinLockDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋锁Demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLocDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;Thread&gt; threadAtomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;\t come in...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!threadAtomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        threadAtomicReference.compareAndSet(thread, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;\t unlock...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SpinLocDemo</span> <span class="variable">spinLocDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLocDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLocDemo.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLocDemo.unlock();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLocDemo.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLocDemo.unlock();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="读写锁-x2F-独占-x2F-共享锁"><a href="#读写锁-x2F-独占-x2F-共享锁" class="headerlink" title="读写锁&#x2F;独占&#x2F;共享锁"></a>读写锁&#x2F;独占&#x2F;共享锁</h2><p><strong>读锁</strong>是<strong>共享的</strong>，<strong>写锁</strong>是<strong>独占的</strong>。<code>juc.ReentrantLock</code>和<code>synchronized</code>都是<strong>独占锁</strong>，独占锁就是<strong>一个锁</strong>只能被<strong>一个线程</strong>所持有。有的时候，需要<strong>读写分离</strong>，那么就要引入读写锁，即<code>juc.ReentrantReadWriteLock</code>。</p>
<p>比如缓存，就需要读写锁来控制。缓存就是一个键值对，以下Demo模拟了缓存的读写操作，读的<code>get</code>方法使用了<code>ReentrantReadWriteLock.ReadLock()</code>，写的<code>put</code>方法使用了<code>ReentrantReadWriteLock.WriteLock()</code>。这样避免了写被打断，实现了多个线程同时读。</p>
<p>ReadWriteLockDemo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyCache</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tempInt</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; myCache.put(tempInt + <span class="string">&quot;&quot;</span>, tempInt + <span class="string">&quot;&quot;</span>), String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tempInt</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; myCache.get(tempInt + <span class="string">&quot;&quot;</span>), String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在写入：&quot;</span> + key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成：&quot;</span> + key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在读取：&quot;</span> + key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            value = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized和Lock的区别"><a href="#Synchronized和Lock的区别" class="headerlink" title="Synchronized和Lock的区别"></a>Synchronized和Lock的区别</h2><p><code>synchronized</code>关键字和<code>java.util.concurrent.locks.Lock</code>都能加锁，两者有什么区别呢？</p>
<ol>
<li><strong>原始构成</strong>：<code>sync</code>是JVM层面的，底层通过<code>monitorenter</code>和<code>monitorexit</code>来实现的。<code>Lock</code>是JDK API层面的。（<code>sync</code>一个enter会有两个exit，一个是正常退出，一个是异常退出）</li>
<li><strong>使用方法</strong>：<code>sync</code>不需要手动释放锁，而<code>Lock</code>需要手动释放。</li>
<li><strong>是否可中断</strong>：<code>sync</code>不可中断，除非抛出异常或者正常运行完成。<code>Lock</code>是可中断的，通过调用<code>interrupt()</code>方法。</li>
<li><strong>是否为公平锁</strong>：<code>sync</code>只能是非公平锁，而<code>Lock</code>既能是公平锁，又能是非公平锁。</li>
<li>**绑定多个条件<code>Condition</code>**：<code>sync</code>不能，只能随机唤醒。而<code>Lock</code>可以通过<code>Condition</code>来绑定多个条件，精确唤醒。</li>
</ol>
<h1 id="CountDownLatch-x2F-CyclicBarrier-x2F-Semaphore"><a href="#CountDownLatch-x2F-CyclicBarrier-x2F-Semaphore" class="headerlink" title="CountDownLatch&#x2F;CyclicBarrier&#x2F;Semaphore"></a>CountDownLatch&#x2F;CyclicBarrier&#x2F;Semaphore</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><code>CountDownLatch</code>内部维护了一个<strong>计数器</strong>，只有当<strong>计数器&#x3D;&#x3D;0</strong>时，某些线程才会停止阻塞，开始执行。</p>
<p><code>CountDownLatch</code>主要有两个方法，<code>countDown()</code>来让计数器-1，<code>await()</code>来让线程阻塞。当<code>count==0</code>时，阻塞线程自动唤醒。</p>
<p><strong>案例一班长关门</strong>：main线程是班长，6个线程是学生。只有6个线程运行完毕，都离开教室后，main线程班长才会关教室门。</p>
<p><strong>案例二秦灭六国</strong>：只有6国都被灭亡后（执行完毕），main线程才会显示“秦国一统天下”。</p>
<h3 id="枚举类的使用"><a href="#枚举类的使用" class="headerlink" title="枚举类的使用"></a>枚举类的使用</h3><p>在<strong>案例二</strong>中会使用到枚举类，因为灭六国，循环6次，想根据<code>i</code>的值来确定输出什么国，比如1代表楚国，2代表赵国。如果用判断则十分繁杂，而枚举类可以简化操作。</p>
<p>枚举类就像一个<strong>简化的数据库</strong>，枚举类名就像数据库名，枚举的项目就像数据表，枚举的属性就像表的字段。</p>
<p>CountDownLatchDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountdownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        closeDoor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeDoor</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 上完课，go&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;***** 班长上完课，关门，go&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CountDownLatch</code>是减，而<code>CyclicBarrier</code>是加，理解了<code>CountDownLatch</code>，<code>CyclicBarrier</code>就很容易。比如召集7颗龙珠才能召唤神龙。</p>
<p>CyclicBarrierDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>, () -&gt; System.out.println(<span class="string">&quot;*****召唤神龙&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 收集到第：&quot;</span> + finalI + <span class="string">&quot;龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>CountDownLatch</code>的问题是<strong>不能复用</strong>。比如<code>count=3</code>，那么加到3，就不能继续操作了。而<code>Semaphore</code>可以解决这个问题，比如6辆车3个停车位，对于<code>CountDownLatch</code><strong>只能停3辆车</strong>，而<code>Semaphore</code>可以停6辆车，车位空出来后，其它车可以占有，这就涉及到了<code>Semaphore.accquire()</code>和<code>Semaphore.release()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//模拟3个停车位</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;量汽车抢到了车位&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;量汽车停车3秒后离开车位&quot;</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p><strong>概念</strong>：当阻塞队列为空时，获取（take）操作是阻塞的；当阻塞队列为满时，添加（put）操作是阻塞的。</p>
<p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/BlockingQueue.png"></p>
<p><strong>好处</strong>：阻塞队列不用手动控制什么时候该被阻塞，什么时候该被唤醒，简化了操作。</p>
<p><strong>体系</strong>：<code>Collection</code>→<code>Queue</code>→<code>BlockingQueue</code>→七个阻塞队列实现类。</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ArrayBlockingQueue</strong></td>
<td>由<strong>数组</strong>构成的<strong>有界</strong>阻塞队列</td>
</tr>
<tr>
<td><strong>LinkedBlockingQueue</strong></td>
<td>由<strong>链表</strong>构成的<strong>有界</strong>阻塞队列</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>支持优先级排序的无界阻塞队列</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>支持优先级的延迟无界阻塞队列</td>
</tr>
<tr>
<td><strong>SynchronousQueue</strong></td>
<td>单个元素的阻塞队列</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>由链表构成的无界阻塞队列</td>
</tr>
<tr>
<td>LinkedBlockingDeque</td>
<td>由链表构成的双向阻塞队列</td>
</tr>
</tbody></table>
<p>粗体标记的三个用得比较多，许多消息中间件底层就是用它们实现的。</p>
<p>需要注意的是<code>LinkedBlockingQueue</code>虽然是有界的，但有个巨坑，其默认大小是<code>Integer.MAX_VALUE</code>，高达21亿，一般情况下内存早爆了（在线程池的<code>ThreadPoolExecutor</code>有体现）。</p>
<p><strong>API</strong>：抛出异常是指当队列满时，再次插入会抛出异常；返回布尔是指当队列满时，再次插入会返回false；阻塞是指当队列满时，再次插入会被阻塞，直到队列取出一个元素，才能插入。超时是指当一个时限过后，才会插入或者取出。</p>
<table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>返回布尔</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(E e)</td>
<td>offer(E e)</td>
<td>put(E e)</td>
<td>offer(E e,Time,TimeUnit)</td>
</tr>
<tr>
<td>取出</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(Time,TimeUnit)</td>
</tr>
<tr>
<td>队首</td>
<td>element()</td>
<td>peek()</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>抛出异常</td>
<td>当阻塞队列满时，再往队列里面add插入元素会抛IllegalStateException: Queue full<br />当阻塞队列空时，再往队列Remove元素时候回抛出NoSuchElementException</td>
</tr>
<tr>
<td>特殊值</td>
<td>插入方法，成功返回true 失败返回false<br />移除方法，成功返回元素，队列里面没有就返回null</td>
</tr>
<tr>
<td>一直阻塞</td>
<td>当阻塞队列满时，生产者继续往队列里面put元素，队列会一直阻塞直到put数据or响应中断退出。<br />当阻塞队列空时，消费者试图从队列take元素，队列会一直阻塞消费者线程直到队列可用。</td>
</tr>
<tr>
<td>超时退出</td>
<td>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过后限时后生产者线程就会退出</td>
</tr>
</tbody></table>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>队列只有一个元素，如果想插入多个，必须等队列元素取出后，才能插入，只能有一个“坑位”，用一个插一个，详见</p>
<p>SynchronousQueueDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 1&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 2&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 3&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + blockingQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h1><p><strong>与Runnable的区别</strong>：</p>
<ol>
<li>Callable带返回值。</li>
<li>会抛出异常。</li>
<li>覆写<code>call()</code>方法，而不是<code>run()</code>方法。</li>
</ol>
<p><strong>Callable接口的使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;come in callable&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1234</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;come in callable&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1234</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask3 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(() -&gt; System.out.println(<span class="string">&quot;come in runnable&quot;</span>), <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask4 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;come in runnable&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="阻塞队列的应用——生产者消费者"><a href="#阻塞队列的应用——生产者消费者" class="headerlink" title="阻塞队列的应用——生产者消费者"></a>阻塞队列的应用——生产者消费者</h1><h2 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h2><p>传统模式使用<code>Lock</code>来进行操作，需要手动加锁、解锁。</p>
<p>ProdConsTradiDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目: 一个初始值为零的变量，两个线程对其交替操作，一个加1，一个减1 ，来5轮</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductConsumerTraditionDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ShareData</span> <span class="variable">shareData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    shareData.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    shareData.decrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareData</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 judge</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 work</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\tincrement &quot;</span> + number);</span><br><span class="line">            <span class="comment">//3 notify to wake</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 judge</span></span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 work</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\tdecrement &quot;</span> + number);</span><br><span class="line">            <span class="comment">//3 notify to wake</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阻塞队列模式"><a href="#阻塞队列模式" class="headerlink" title="阻塞队列模式"></a>阻塞队列模式</h2><p>使用阻塞队列就不需要手动加锁了</p>
<p>ProducerConsumerBlockQueueDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerBlockQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyResource</span> <span class="variable">myResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyResource</span>(<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者线程启动！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.product();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者线程启动！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.consume();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;5秒后叫停&quot;</span>);</span><br><span class="line">            myResource.stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyResource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认开启，进行生产和消费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">FLAG</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; blockingQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">product</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> returnVal;</span><br><span class="line">        <span class="keyword">while</span> (FLAG) &#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            returnVal = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (returnVal) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t插入队列&quot;</span> + data + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t插入队列&quot;</span> + data + <span class="string">&quot;失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; STOP，表明FLAG=false，生产结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (FLAG) &#123;</span><br><span class="line">            result = blockingQueue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">null</span> || result.equalsIgnoreCase(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                FLAG = <span class="literal">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t超过2秒没有获取到产品，消费退出&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t消费队列&quot;</span> + result + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; STOP，表明FLAG=false，生产结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">this</span>.FLAG = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="阻塞队列的应用——线程池"><a href="#阻塞队列的应用——线程池" class="headerlink" title="阻塞队列的应用——线程池"></a>阻塞队列的应用——线程池</h1><h2 id="线程池基本概念"><a href="#线程池基本概念" class="headerlink" title="线程池基本概念"></a>线程池基本概念</h2><p><strong>概念</strong>：线程池主要是控制运行线程的数量，将待处理任务放到等待队列，然后创建线程执行这些任务。如果超过了最大线程数，则等待。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>线程复用：不用一直new新线程，重复利用已经创建的线程来降低线程的创建和销毁开销，节省系统资源。</li>
<li>提高响应速度：当任务达到时，不用创建新的线程，直接利用线程池的线程。</li>
<li>管理线程：可以控制最大并发数，控制线程的创建等。</li>
</ol>
<p><strong>体系</strong>：<code>Executor</code>→<code>ExecutorService</code>→<code>AbstractExecutorService</code>→<code>ThreadPoolExecutor</code>。<code>ThreadPoolExecutor</code>是线程池创建的核心类。类似<code>Arrays</code>、<code>Collections</code>工具类，<code>Executor</code>也有自己的工具类<code>Executors</code>。</p>
<h2 id="线程池三种常用创建方式"><a href="#线程池三种常用创建方式" class="headerlink" title="线程池三种常用创建方式"></a>线程池三种常用创建方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newFixedThreadPool(5);//一池5个处理线程       执行一个长期的任务，性能好很多</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newSingleThreadExecutor();//一池1个处理线程   一个任务一个线程执行的任务场景</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();<span class="comment">//一池N个处理线程         执行很多短期异步的小程序或者负载较轻的服务器</span></span><br><span class="line">        <span class="comment">//模拟10个用户来办理业务，每个用户就是一个来自外部的请求线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>newFixedThreadPool</strong>：使用<code>LinkedBlockingQueue</code>实现，定长线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>newSingleThreadExecutor</strong>：使用<code>LinkedBlockingQueue</code>实现，一池只有一个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span>(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>newCachedThreadPool</strong>：使用<code>SynchronousQueue</code>实现，变长线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池创建的七个参数"><a href="#线程池创建的七个参数" class="headerlink" title="线程池创建的七个参数"></a>线程池创建的七个参数</h2><table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>线程池常驻核心线程数</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>能够容纳的最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>空闲线程存活时间</td>
</tr>
<tr>
<td>unit</td>
<td>存活时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>存放提交但未执行任务的队列</td>
</tr>
<tr>
<td>threadFactory</td>
<td>创建线程的工厂类</td>
</tr>
<tr>
<td>handler</td>
<td>等待队列满后的拒绝策略</td>
</tr>
</tbody></table>
<p><strong>理解</strong>：线程池的创建参数，就像一个<strong>银行</strong>。</p>
<p><code>corePoolSize</code>就像银行的“<strong>当值窗口</strong>“，比如今天有<strong>2位柜员</strong>在受理<strong>客户请求</strong>（任务）。如果超过2个客户，那么新的客户就会在<strong>等候区</strong>（等待队列<code>workQueue</code>）等待。当<strong>等候区</strong>也满了，这个时候就要开启“<strong>加班窗口</strong>”，让其它3位柜员来加班，此时达到<strong>最大窗口</strong><code>maximumPoolSize</code>，为5个。如果开启了所有窗口，等候区依然满员，此时就应该启动”<strong>拒绝策略</strong>“<code>handler</code>，告诉不断涌入的客户，叫他们不要进入，已经爆满了。由于不再涌入新客户，办完事的客户增多，窗口开始空闲，这个时候就通过<code>keepAlivetTime</code>将多余的3个”加班窗口“取消，恢复到2个”当值窗口“。</p>
<h2 id="线程池底层原理"><a href="#线程池底层原理" class="headerlink" title="线程池底层原理"></a>线程池底层原理</h2><p><strong>原理图</strong>：上面银行的例子，实际上就是线程池的工作原理。</p>
<p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/threadPool.png" alt="threadPool"></p>
<ol>
<li><p>在创建了线程池后，等待提交过来的任务请求。</p>
</li>
<li><p>当调用<code>execute()</code>方法添加一-个请求任务时，线程池会做如下判断:</p>
<ol>
<li>如果正在运行的线程数量小于<code>corePoolSize</code>，那么马上创建线程运行这个任务</li>
<li>如果正在运行的线程数量大于或等于<code>corePoolSize</code>，那么将这个任务放入队列</li>
<li>如果这时候队列满了且正在运行的线程数量还小于<code>maximumPoolSize</code>，那么还是要创建非核心线程<strong>立刻运行</strong>这个任务</li>
<li>如果队列满了且正在运行的线程数量大于或等于<code>maximumPoolSize</code>，那么线程池会启动饱和拒绝策略来执行</li>
</ol>
</li>
<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>
</li>
<li><p>当一个线程无事可做超过一定的时间(<code>keepAliveTime</code>) 时，线程池会判断:</p>
<p>​	如果当前运行的线程数大于<code>corePoolSize</code>，那么这个线程就被停掉。</p>
</li>
</ol>
<p><strong>流程图</strong>：</p>
<p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/threadPoolProcedure.png" alt="threadPoolProcedure"></p>
<p>新任务到达→</p>
<p>如果正在运行的线程数小于<code>corePoolSize</code>，创建核心线程；大于等于<code>corePoolSize</code>，放入等待队列。</p>
<p>如果等待队列已满，但正在运行的线程数小于<code>maximumPoolSize</code>，创建非核心线程；大于等于<code>maximumPoolSize</code>，启动拒绝策略。</p>
<p>当一个线程无事可做一段时间<code>keepAliveTime</code>后，如果正在运行的线程数大于<code>corePoolSize</code>，则关闭非核心线程。</p>
<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>当等待队列满时，且达到最大线程数，再有新任务到来，就需要启动拒绝策略。JDK提供了四种拒绝策略，分别是。</p>
<ol>
<li><strong>AbortPolicy</strong>：默认的策略，直接抛出<code>RejectedExecutionException</code>异常，阻止系统正常运行。</li>
<li><strong>CallerRunsPolicy</strong>：既不会抛出异常，也不会终止任务，而是将任务返回给调用者。</li>
<li><strong>DiscardOldestPolicy</strong>：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交任务。</li>
<li><strong>DiscardPolicy</strong>：直接丢弃任务，不做任何处理。</li>
</ol>
<h2 id="实际生产使用哪一个线程池？"><a href="#实际生产使用哪一个线程池？" class="headerlink" title="实际生产使用哪一个线程池？"></a>实际生产使用哪一个线程池？</h2><p><strong>单一、可变、定长都不用</strong>！原因就是<code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>底层都是用<code>LinkedBlockingQueue</code>实现的，这个队列最大长度为<code>Integer.MAX_VALUE</code>，显然会导致OOM(Out Of Memery)。所以实际生产一般自己通过<code>ThreadPoolExecutor</code>的7个参数，自定义线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>,<span class="number">5</span>,</span><br><span class="line">                        <span class="number">1L</span>,TimeUnit.SECONDS,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                        Executors.defaultThreadFactory(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br></pre></td></tr></table></figure>

<h3 id="自定义线程池参数选择"><a href="#自定义线程池参数选择" class="headerlink" title="自定义线程池参数选择"></a>自定义线程池参数选择</h3><p>查看CPU核数：<code>System.out.println(Runtime.getRuntime().availableProcessors());</code></p>
<p>CPU密集型：CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。CPU密集型任务配置尽可能少的线程数量：一般公式: CPU核 数+1介线程的线程池。</p>
<p>IO密集型任务：任务需要大量的IO，即大量的阻塞，因此尽量多配点，可以是CPU线程数*2，或者CPU线程数&#x2F;(1-阻塞系数)。</p>
<h1 id="死锁编码和定位"><a href="#死锁编码和定位" class="headerlink" title="死锁编码和定位"></a>死锁编码和定位</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HoldLockThread</span>(lockA, lockB), <span class="string">&quot;ThreadAAA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HoldLockThread</span>(lockB, lockA), <span class="string">&quot;ThreadBBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HoldLockThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HoldLockThread</span><span class="params">(String lockA, String lockB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockA = lockA;</span><br><span class="line">        <span class="built_in">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t自己持有&quot;</span> + lockA + <span class="string">&quot;，尝试获取：&quot;</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t自己持有&quot;</span> + lockB + <span class="string">&quot;，尝试获取：&quot;</span> + lockA);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要是两个命令配合起来使用，定位死锁。</p>
<p><strong>jps</strong>指令：<code>jps -l</code>可以查看运行的Java进程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">9688</span> thread.DeadLockDemo</span><br><span class="line"><span class="number">12177</span> sun.tools.jps.Jps</span><br></pre></td></tr></table></figure>

<p><strong>jstack</strong>指令：<code>jstack pid</code>可以查看某个Java进程的堆栈信息，同时分析出死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;ThreadBBB&quot;</span>:</span><br><span class="line">        at com.monochrome.thread.HoldLockThread.run(DeadLockDemo.java:<span class="number">43</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x00000006edd5eae8</span>&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;<span class="number">0x00000006edd5eb20</span>&gt; (a java.lang.String)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">&quot;ThreadAAA&quot;</span>:</span><br><span class="line">        at com.monochrome.thread.HoldLockThread.run(DeadLockDemo.java:<span class="number">43</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x00000006edd5eb20</span>&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;<span class="number">0x00000006edd5eae8</span>&gt; (a java.lang.String)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring知识点</title>
    <url>/2021/07/01/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h1><p>Bean的生命周期指的就是：在Spring中，Bean是如何生成的？</p>
<p>被Spring管理的对象叫做Bean。Bean的生成步骤如下：</p>
<ol>
<li>Spring扫描class得到BeanDefinition</li>
<li>根据得到的BeanDefinition去生成bean</li>
<li>首先根据class推断构造方法</li>
<li>根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象）</li>
<li>填充原始对象中的属性（依赖注入）</li>
<li>如果原始对象中的某个方法被AOP了，那么则需要根据原始对象生成一个代理对象</li>
<li>把最终生成的代理对象放入单例池（源码中叫做singletonObjects）中，下次getBean时就直接从单例池拿即可</li>
</ol>
<span id="more"></span>

<p><img src="/images/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Bean的生命周期"></p>
<h1 id="Spring的循环依赖？"><a href="#Spring的循环依赖？" class="headerlink" title="Spring的循环依赖？"></a>Spring的循环依赖？</h1><p>很简单，就是A对象依赖了B对象，B对象依赖了A对象。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A依赖了B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B依赖了A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么循环依赖是个问题吗？</p>
<p>如果不考虑Spring，循环依赖并不是问题，因为对象之间相互依赖是很正常的事情。</p>
<p>比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"></span><br><span class="line">a.b = b;</span><br><span class="line">b.a = a;</span><br></pre></td></tr></table></figure>

<p>这样，A,B就依赖上了。</p>
<p>但是，在Spring中循环依赖就是一个问题了，为什么？</p>
<p>因为，在Spring中，一个对象并不是简单new出来了，而是会经过一系列的Bean的生命周期，就是因为Bean的生命周期所以才会出现循环依赖问题。当然，在Spring中，出现循环依赖的场景很多，有的场景Spring自动帮我们解决了，而有的场景则需要程序员来解决。</p>
<p>要明白Spring中的循环依赖，得先明白Spring中<a href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Bean的生命周期</a>。</p>
<p>可以发现，在Spring中，构造一个Bean，包括了new这个步骤（第4步构造方法反射）。</p>
<p>得到一个原始对象后，Spring需要给对象中的属性进行依赖注入，那么这个注入过程是怎样的？</p>
<p>比如上文说的A类，A类中存在一个B类的b属性，所以，当A类生成了一个原始对象之后，就会去给b属性去赋值，此时就会根据b属性的类型和属性名去BeanFactory中去获取B类所对应的单例bean。如果此时BeanFactory中存在B对应的Bean，那么直接拿来赋值给b属性；如果此时BeanFactory中不存在B对应的Bean，则需要生成一个B对应的Bean，然后赋值给b属性。</p>
<p>问题就出现在第二种情况，如果此时B类在BeanFactory中还没有生成对应的Bean，那么就需要去生成，就会经过B的Bean的生命周期。</p>
<p>那么在创建B类的Bean的过程中，如果B类中存在一个A类的a属性，那么在创建B的Bean的过程中就需要A类对应的Bean，但是，触发B类Bean的创建的条件是A类Bean在创建过程中的依赖注入，所以这里就出现了循环依赖：</p>
<p>ABean创建–&gt;依赖了B属性–&gt;触发BBean创建—&gt;B依赖了A属性—&gt;需要ABean（但ABean还在创建过程中）</p>
<p>从而导致ABean创建不出来，BBean也创建不出来。</p>
<p>这是循环依赖的场景，但是上文说了，在Spring中，通过某些机制帮开发者解决了部分循环依赖的问题，这个机制就是<strong>三级缓存</strong>。</p>
<h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>三级缓存是通用的叫法。</p>
<p>一级缓存为：<strong>singletonObjects</strong></p>
<p>二级缓存为：<strong>earlySingletonObjects</strong></p>
<p>三级缓存为：<strong>singletonFactories</strong></p>
<p><strong>先稍微解释一下这三个缓存的作用，后面详细分析：</strong></p>
<ul>
<li><p><strong>singletonObjects</strong>中缓存的是已经经历了完整生命周期的bean对象。</p>
</li>
<li><p><strong>earlySingletonObjects</strong>比singletonObjects多了一个early，表示缓存的是早期的bean对象。早期是什么意思？表示Bean的生命周期还没走完就把这个Bean放入了earlySingletonObjects。</p>
</li>
<li><p><strong>singletonFactories</strong>中缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的。</p>
</li>
</ul>
<h2 id="解决循环依赖思路分析"><a href="#解决循环依赖思路分析" class="headerlink" title="解决循环依赖思路分析"></a>解决循环依赖思路分析</h2><p>先来分析为什么缓存能解决循环依赖。</p>
<p>上文分析得到，之所以产生循环依赖的问题，主要是：</p>
<p>A创建时—&gt;需要B—-&gt;B去创建—&gt;需要A，从而产生了循环</p>
<p><img src="/images/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" alt="循环依赖"></p>
<p>那么如何打破这个循环，加个中间人（缓存）</p>
<p><img src="/images/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%89%93%E7%A0%B4%E5%BE%AA%E7%8E%AF.png" alt="打破循环"></p>
<p>A的Bean在创建过程中，在进行依赖注入之前，先把A的原始Bean放入缓存（提早暴露，只要放到缓存了，其他Bean需要时就可以从缓存中拿了），放入缓存后，再进行依赖注入，此时A的Bean依赖了B的Bean，如果B的Bean不存在，则需要创建B的Bean，而创建B的Bean的过程和A一样，也是先创建一个B的原始对象，然后把B的原始对象提早暴露出来放入缓存中，然后在对B的原始对象进行依赖注入A，此时能从缓存中拿到A的原始对象（虽然是A的原始对象，还不是最终的Bean），B的原始对象依赖注入完了之后，B的生命周期结束，那么A的生命周期也能结束。</p>
<p>因为整个过程中，都只有一个A原始对象，所以对于B而言，就算在属性注入时，注入的是A原始对象，也没有关系，因为A原始对象在后续的生命周期中在堆中没有发生变化。</p>
<p>从上面这个分析过程中可以得出，只需要一个缓存就能解决循环依赖了，那么为什么Spring中还需要<strong>singletonFactories</strong>呢？</p>
<p>这是难点，基于上面的场景想一个问题：如果A的原始对象注入给B的属性之后，A的原始对象进行了AOP产生了一个代理对象，此时就会出现，对于A而言，它的Bean对象其实应该是AOP之后的代理对象，而B的a属性对应的并不是AOP之后的代理对象，这就产生了冲突。</p>
<p><strong>B依赖的A和最终的A不是同一个对象</strong>。</p>
<p>那么如何解决这个问题？这个问题可以说没有办法解决。</p>
<p>因为在一个Bean的生命周期最后，Spring提供了BeanPostProcessor可以去对Bean进行加工，这个加工不仅仅只是能修改Bean的属性值，也可以替换掉当前Bean。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper极简入门及部署</title>
    <url>/2020/07/12/ZooKeeper%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8%E5%8F%8A%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apache ZooKeeper是Apache软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。ZooKeeper曾经是Hadoop的一个子项目，但现在是一个独立的顶级项目。</p>
<p>ZooKeeper的架构通过冗余服务实现高可用性。因此，如果第一次无应答，客户端就可以询问另一台ZooKeeper主机。ZooKeeper节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。更新是全序的。</p>
<span id="more"></span>

<h2 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h2><h3 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h3><ul>
<li>操作系统: Mac OS 10.15(其他系统一样)</li>
<li>JDK: 11</li>
</ul>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>打开 <a href="https://archive.apache.org/dist/zookeeper/">Zookeeper 下载页面</a>，选择想要安装的版本。我选择的是 <a href="https://archive.apache.org/dist/zookeeper/stable/">stable</a> 稳定版本，版本是3.5.8，选择编译好的包，<a href="https://archive.apache.org/dist/zookeeper/stable/apache-zookeeper-3.5.8-bin.tar.gz">apache-zookeeper-3.5.8-bin.tar.gz</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载</span></span><br><span class="line">wget https://archive.apache.org/dist/zookeeper/stable/apache-zookeeper-3.5.8-bin.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf apache-zookeeper-3.5.8-bin.tar.gz</span><br><span class="line">cd apache-zookeeper-3.5.8-bin</span><br></pre></td></tr></table></figure>

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>Zookeeper 提供了 <code>conf/zoo_sample.cfg</code> 模版配置文件，作为示例。这里，我们复制一下，复制出一个 <code>conf/zoo.cfg </code>(默认读取的配置文件)，然后在上面进行修改，修改后配置如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line"><span class="comment"># Client-Server 通信心跳时间</span></span><br><span class="line"><span class="comment"># Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。tickTime 以毫秒为单位。</span></span><br><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"># The number of ticks that the initial</span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line"><span class="comment"># Leader-Follower 初始通信时限</span></span><br><span class="line"><span class="comment"># 集群中的 follower 服务器(F)与 leader 服务器(L)之间初始连接时能容忍的最多心跳数（tickTime 的数量）。</span></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># The number of ticks that can pass between</span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line"><span class="comment"># Leader-Follower 同步通信时限</span></span><br><span class="line"><span class="comment"># 集群中的 follower 服务器与 leader 服务器之间请求和应答之间能容忍的最多心跳数（tickTime的数量）。</span></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just</span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="comment"># 数据文件目录</span></span><br><span class="line"><span class="comment"># Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">/Users/monochrome/app/Zookeeper/apache-zookeeper-3.5.8-bin/data</span></span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="comment"># 客户端连接端口</span></span><br><span class="line"><span class="comment"># 客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the</span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to &quot;0&quot; to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br></pre></td></tr></table></figure>

<h4 id="运行Zookeeper-Server"><a href="#运行Zookeeper-Server" class="headerlink" title="运行Zookeeper Server"></a>运行Zookeeper Server</h4><p>执行 <code>bin/zkServer.sh start</code> 命令，启动 Zookeeper Server 服务。此时，控制台会输出如下日志，表示启动成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下，Zookeeper 开启 JMX</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 conf/zoo.cfg 配置文件</span></span><br><span class="line">Using config: /Users/monochrome/app/Zookeeper/apache-zookeeper-3.5.8-bin/bin/../conf/zoo.cfg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 Zookeeper Server 成功（实际不一定成功）</span></span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>

<p>注意，Zookeeper 3.5 版本开始，默认会在 8080 端口，启动一个 Zookeeper <strong>AdminServer</strong>。如果 8080 端口已经被其它服务占用，会导致 Zookeeper Server 启动失败。此时，我们有三种解决方案：</p>
<ul>
<li>方式一，可以修改 <code>conf/zoo.cfg</code> 配置文件的 <code>admin.serverPort</code> 配置项，从而修改 Zookeeper AdminServer 的端口。</li>
<li>方式二，可以修改 <code>conf/zoo.cfg</code> 配置文件的 <code>admin.enableServer=false</code> 配置项，从而关闭 Zookeeper AdminServer 的启动。</li>
<li>方式三，关闭占用 8080 端口的服务。</li>
</ul>
<h4 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h4><p>测试连接到 Zookeeper Server 上，看看是否真的启动成功。操作命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接 Zookeeper Server</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/zkCli.sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出如下日志信息表示连接成功</span></span><br><span class="line">Welcome to ZooKeeper!</span><br><span class="line">JLine support is enabled</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 Zookeeper 命令行中，执行 <span class="built_in">ls</span> / 命令，输出根目录</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[zookeeper]</span><br></pre></td></tr></table></figure>

<h3 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h3><p>待续</p>
<h2 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h2><h3 id="pull-image"><a href="#pull-image" class="headerlink" title="pull image"></a>pull image</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="Start-a-Zookeeper-server-instance"><a href="#Start-a-Zookeeper-server-instance" class="headerlink" title="Start a Zookeeper server instance"></a>Start a Zookeeper server instance</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -d zookeeper</span><br></pre></td></tr></table></figure>

<p>This image includes <code>EXPOSE 2181 2888 3888 8080</code> (the zookeeper client port, follower port, election port, AdminServer port respectively), so standard container linking will make it automatically available to the linked containers. Since the Zookeeper “fails fast” it’s better to always restart it.</p>
<h3 id="Connect-to-Zookeeper-from-an-application-in-another-Docker-container"><a href="#Connect-to-Zookeeper-from-an-application-in-another-Docker-container" class="headerlink" title="Connect to Zookeeper from an application in another Docker container"></a>Connect to Zookeeper from an application in another Docker container</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-app --link some-zookeeper:zookeeper -d application-that-uses-zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="Connect-to-Zookeeper-from-the-Zookeeper-command-line-client"><a href="#Connect-to-Zookeeper-from-the-Zookeeper-command-line-client" class="headerlink" title="Connect to Zookeeper from the Zookeeper command line client"></a>Connect to Zookeeper from the Zookeeper command line client</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -it --rm --link some-zookeeper:zookeeper zookeeper zkCli.sh -server zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="…-via-docker-stack-deploy-or-docker-compose"><a href="#…-via-docker-stack-deploy-or-docker-compose" class="headerlink" title="… via docker stack deploy or docker-compose"></a>… via <a href="https://docs.docker.com/engine/reference/commandline/stack_deploy/"><code>docker stack deploy</code></a> or <a href="https://github.com/docker/compose"><code>docker-compose</code></a></h3><p>Example <code>stack.yml</code> for <code>zookeeper</code>:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zoo1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=0.0.0.0:2888:3888;2181</span> <span class="string">server.2=zoo2:2888:3888;2181</span> <span class="string">server.3=zoo3:2888:3888;2181</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zoo2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2182</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888;2181</span> <span class="string">server.2=0.0.0.0:2888:3888;2181</span> <span class="string">server.3=zoo3:2888:3888;2181</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zoo3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2183</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888;2181</span> <span class="string">server.2=zoo2:2888:3888;2181</span> <span class="string">server.3=0.0.0.0:2888:3888;2181</span></span><br></pre></td></tr></table></figure>

<p><a href="http://play-with-docker.com/?stack=https://raw.githubusercontent.com/docker-library/docs/ef162dce5998011e1753c3337dcbe61200c522d2/zookeeper/stack.yml"><img src="https://github.com/play-with-docker/stacks/raw/cff22438cb4195ace27f9b15784bbb497047afa7/assets/images/button.png" alt="Try in PWD"></a></p>
<p>This will start Zookeeper 3.5 in <a href="https://zookeeper.apache.org/doc/current/zookeeperStarted.html#sc_RunningReplicatedZooKeeper">replicated mode</a>. Please note, that Zookeeper 3.4 has slightly different <code>ZOO_SERVERS</code> format. Run <code>docker stack deploy -c stack.yml zookeeper</code> (or <code>docker-compose -f stack.yml up</code>) and wait for it to initialize completely. Ports <code>2181-2183</code> will be exposed.</p>
<blockquote>
<p>Please be aware that setting up multiple servers on a single machine will not create any redundancy. If something were to happen which caused the machine to die, all of the zookeeper servers would be offline. Full redundancy requires that each server have its own machine. It must be a completely separate physical server. Multiple virtual machines on the same physical host are still vulnerable to the complete failure of that host.</p>
</blockquote>
<p>Consider using <a href="https://www.docker.com/products/docker-swarm">Docker Swarm</a> when running Zookeeper in replicated mode.</p>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>Zookeeper configuration is located in <code>/conf</code>. One way to change it is mounting your config file as a volume:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -d -v $(pwd)/zoo.cfg:/conf/zoo.cfg zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="Environment-variables"><a href="#Environment-variables" class="headerlink" title="Environment variables"></a>Environment variables</h3><p>ZooKeeper recommended defaults are used if <code>zoo.cfg</code> file is not provided. They can be overridden using the following environment variables.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -e &quot;ZOO_INIT_LIMIT=10&quot; --name some-zookeeper --restart always -d zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="ZOO-TICK-TIME"><a href="#ZOO-TICK-TIME" class="headerlink" title="ZOO_TICK_TIME"></a><code>ZOO_TICK_TIME</code></h3><p>Defaults to <code>2000</code>. ZooKeeper’s <code>tickTime</code></p>
<blockquote>
<p>The length of a single tick, which is the basic time unit used by ZooKeeper, as measured in milliseconds. It is used to regulate heartbeats, and timeouts. For example, the minimum session timeout will be two ticks</p>
</blockquote>
<h3 id="ZOO-INIT-LIMIT"><a href="#ZOO-INIT-LIMIT" class="headerlink" title="ZOO_INIT_LIMIT"></a><code>ZOO_INIT_LIMIT</code></h3><p>Defaults to <code>5</code>. ZooKeeper’s <code>initLimit</code></p>
<blockquote>
<p>Amount of time, in ticks (see tickTime), to allow followers to connect and sync to a leader. Increased this value as needed, if the amount of data managed by ZooKeeper is large.</p>
</blockquote>
<h3 id="ZOO-SYNC-LIMIT"><a href="#ZOO-SYNC-LIMIT" class="headerlink" title="ZOO_SYNC_LIMIT"></a><code>ZOO_SYNC_LIMIT</code></h3><p>Defaults to <code>2</code>. ZooKeeper’s <code>syncLimit</code></p>
<blockquote>
<p>Amount of time, in ticks (see tickTime), to allow followers to sync with ZooKeeper. If followers fall too far behind a leader, they will be dropped.</p>
</blockquote>
<h3 id="ZOO-MAX-CLIENT-CNXNS"><a href="#ZOO-MAX-CLIENT-CNXNS" class="headerlink" title="ZOO_MAX_CLIENT_CNXNS"></a><code>ZOO_MAX_CLIENT_CNXNS</code></h3><p>Defaults to <code>60</code>. ZooKeeper’s <code>maxClientCnxns</code></p>
<blockquote>
<p>Limits the number of concurrent connections (at the socket level) that a single client, identified by IP address, may make to a single member of the ZooKeeper ensemble.</p>
</blockquote>
<h3 id="ZOO-STANDALONE-ENABLED"><a href="#ZOO-STANDALONE-ENABLED" class="headerlink" title="ZOO_STANDALONE_ENABLED"></a><code>ZOO_STANDALONE_ENABLED</code></h3><p>Defaults to <code>true</code>. Zookeeper’s <a href="https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html#sc_reconfig_standaloneEnabled"><code>standaloneEnabled</code></a></p>
<blockquote>
<p>Prior to 3.5.0, one could run ZooKeeper in Standalone mode or in a Distributed mode. These are separate implementation stacks, and switching between them during run time is not possible. By default (for backward compatibility) standaloneEnabled is set to true. The consequence of using this default is that if started with a single server the ensemble will not be allowed to grow, and if started with more than one server it will not be allowed to shrink to contain fewer than two participants.</p>
</blockquote>
<h3 id="ZOO-ADMINSERVER-ENABLED"><a href="#ZOO-ADMINSERVER-ENABLED" class="headerlink" title="ZOO_ADMINSERVER_ENABLED"></a><code>ZOO_ADMINSERVER_ENABLED</code></h3><p>Defaults to <code>true</code>. Zookeeper’s <a href="http://zookeeper.apache.org/doc/r3.5.7/zookeeperAdmin.html#sc_adminserver_config"><code>admin.enableServer</code></a></p>
<blockquote>
<p>New in 3.5.0: The AdminServer is an embedded Jetty server that provides an HTTP interface to the four letter word commands. By default, the server is started on port 8080, and commands are issued by going to the URL “&#x2F;commands&#x2F;[command name]”, e.g., <a href="http://localhost:8080/commands/stat">http://localhost:8080/commands/stat</a>.</p>
</blockquote>
<h3 id="ZOO-AUTOPURGE-PURGEINTERVAL"><a href="#ZOO-AUTOPURGE-PURGEINTERVAL" class="headerlink" title="ZOO_AUTOPURGE_PURGEINTERVAL"></a><code>ZOO_AUTOPURGE_PURGEINTERVAL</code></h3><p>Defaults to <code>0</code>. Zookeeper’s <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_advancedConfiguration"><code>autoPurge.purgeInterval</code></a></p>
<blockquote>
<p>The time interval in hours for which the purge task has to be triggered. Set to a positive integer (1 and above) to enable the auto purging. Defaults to 0.</p>
</blockquote>
<h3 id="ZOO-AUTOPURGE-SNAPRETAINCOUNT"><a href="#ZOO-AUTOPURGE-SNAPRETAINCOUNT" class="headerlink" title="ZOO_AUTOPURGE_SNAPRETAINCOUNT"></a><code>ZOO_AUTOPURGE_SNAPRETAINCOUNT</code></h3><p>Defaults to <code>3</code>. Zookeeper’s <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_advancedConfiguration"><code>autoPurge.snapRetainCount</code></a></p>
<blockquote>
<p>When enabled, ZooKeeper auto purge feature retains the autopurge.snapRetainCount most recent snapshots and the corresponding transaction logs in the dataDir and dataLogDir respectively and deletes the rest. Defaults to 3. Minimum value is 3.</p>
</blockquote>
<h3 id="ZOO-4LW-COMMANDS-WHITELIST"><a href="#ZOO-4LW-COMMANDS-WHITELIST" class="headerlink" title="ZOO_4LW_COMMANDS_WHITELIST"></a><code>ZOO_4LW_COMMANDS_WHITELIST</code></h3><p>Defaults to <code>srvr</code>. Zookeeper’s <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_clusterOptions"><code>4lw.commands.whitelist</code></a></p>
<blockquote>
<p>A list of comma separated Four Letter Words commands that user wants to use. A valid Four Letter Words command must be put in this list else ZooKeeper server will not enable the command. By default the whitelist only contains “srvr” command which zkServer.sh uses. The rest of four letter word commands are disabled by default.</p>
</blockquote>
<h2 id="Advanced-configuration"><a href="#Advanced-configuration" class="headerlink" title="Advanced configuration"></a>Advanced configuration</h2><h3 id="ZOO-CFG-EXTRA"><a href="#ZOO-CFG-EXTRA" class="headerlink" title="ZOO_CFG_EXTRA"></a><code>ZOO_CFG_EXTRA</code></h3><p>Not every Zookeeper configuration setting is exposed via the environment variables listed above. These variables are only meant to cover minimum configuration keywords and some often changing options. If <a href="https://hub.docker.com/_/zookeeper#configuration">mounting your custom config file</a> as a volume doesn’t work for you, consider using <code>ZOO_CFG_EXTRA</code> environment variable. You can add arbitrary configuration parameters to Zookeeper configuration file using this variable. The following example shows how to enable Prometheus metrics exporter on port <code>7070</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -e ZOO_CFG_EXTRA=&quot;metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider metricsProvider.httpPort=7070&quot; zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="JVMFLAGS"><a href="#JVMFLAGS" class="headerlink" title="JVMFLAGS"></a><code>JVMFLAGS</code></h3><p>Many of the Zookeeper advanced configuration options can be set there using Java system properties in the form of <code>-Dproperty=value</code>. For example, you can use Netty instead of NIO (default option) as a server communication framework:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -e JVMFLAGS=&quot;-Dzookeeper.serverCnxnFactory=org.apache.zookeeper.server.NettyServerCnxnFactory&quot; zookeeper</span><br></pre></td></tr></table></figure>

<p>See <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_advancedConfiguration">Advanced Configuration</a> for the full list of supported Java system properties.</p>
<p>Another example use case for the <code>JVMFLAGS</code> is setting a maximum JWM heap size of 1 GB:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run --name some-zookeeper --restart always -e JVMFLAGS=&quot;-Xmx1024m&quot; zookeeper</span><br></pre></td></tr></table></figure>

<h2 id="Replicated-mode"><a href="#Replicated-mode" class="headerlink" title="Replicated mode"></a>Replicated mode</h2><p>Environment variables below are mandatory if you want to run Zookeeper in replicated mode.</p>
<h3 id="ZOO-MY-ID"><a href="#ZOO-MY-ID" class="headerlink" title="ZOO_MY_ID"></a><code>ZOO_MY_ID</code></h3><p>The id must be unique within the ensemble and should have a value between 1 and 255. Do note that this variable will not have any effect if you start the container with a <code>/data</code> directory that already contains the <code>myid</code> file.</p>
<h3 id="ZOO-SERVERS"><a href="#ZOO-SERVERS" class="headerlink" title="ZOO_SERVERS"></a><code>ZOO_SERVERS</code></h3><p>This variable allows you to specify a list of machines of the Zookeeper ensemble. Each entry has the form of <code>server.id=host:port:port</code>. Entries are separated with space. Do note that this variable will not have any effect if you start the container with a <code>/conf</code> directory that already contains the <code>zoo.cfg</code> file.</p>
<p>In 3.5, the syntax of this has changed. Servers should be specified as such: <code>server.id=&lt;address1&gt;:&lt;port1&gt;:&lt;port2&gt;[:role];[&lt;client port address&gt;:]&lt;client port&gt;</code> <a href="https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html">Zookeeper Dynamic Reconfiguration</a></p>
<h2 id="Where-to-store-data"><a href="#Where-to-store-data" class="headerlink" title="Where to store data"></a>Where to store data</h2><p>This image is configured with volumes at <code>/data</code> and <code>/datalog</code> to hold the Zookeeper in-memory database snapshots and the transaction log of updates to the database, respectively.</p>
<blockquote>
<p>Be careful where you put the transaction log. A dedicated transaction log device is key to consistent good performance. Putting the log on a busy device will adversely affect performance.</p>
</blockquote>
<h2 id="How-to-configure-logging"><a href="#How-to-configure-logging" class="headerlink" title="How to configure logging"></a>How to configure logging</h2><p>By default, ZooKeeper redirects stdout&#x2F;stderr outputs to the console. You can redirect to a file located in <code>/logs</code> by passing environment variable <code>ZOO_LOG4J_PROP</code> as follows:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -e ZOO_LOG4J_PROP=&quot;INFO,ROLLINGFILE&quot; zookeeper</span><br></pre></td></tr></table></figure>

<p>This will write logs to <code>/logs/zookeeper.log</code>. Check <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_logging">ZooKeeper Logging</a> for more details.</p>
<p>This image is configured with a volume at <code>/logs</code> for your convenience.</p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Jenkins集群</title>
    <url>/2019/11/28/%E6%90%AD%E5%BB%BAJenkins%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h3 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h3><p>下载<a href="http://updates.jenkins-ci.org/download/war/">Jenkins</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://updates.jenkins-ci.org/latest/jenkins.war</span><br></pre></td></tr></table></figure>

<p>启动Jenkins war包，默认8080端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar jenkins.war</span><br></pre></td></tr></table></figure>

<p>后台启动Jenkins</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup java -jar jenkins.war --httpPort=8080 &amp;</span><br></pre></td></tr></table></figure>

<p>查看日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -f nohup.out</span><br></pre></td></tr></table></figure>

<p>开放端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看想开的端口是否已开：</span><br><span class="line">firewall-cmd --query-port=9090/tcp </span><br><span class="line">添加指定需要开放的端口：</span><br><span class="line">firewall-cmd --add-port=9090/tcp --permanent</span><br><span class="line">重载入添加的端口：</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">查询指定端口是否开启成功：</span><br><span class="line">firewall-cmd --query-port=9090/tcp</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>

<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>进入系统管理–&gt;节点管理–&gt;新建节点：</p>
<p><img src="/images/%E6%90%AD%E5%BB%BAJenkins%E9%9B%86%E7%BE%A4-1.png" alt="搭建Jenkins集群-1"></p>
<p>写入节点名称，选择固定节点，配置节点：</p>
<p><img src="/images/%E6%90%AD%E5%BB%BAJenkins%E9%9B%86%E7%BE%A4-2.png" alt="搭建Jenkins集群-2"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>在Jenkins上创建多分支流水线</title>
    <url>/2019/12/05/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<h3 id="准备Jenkinsfile配置文件"><a href="#准备Jenkinsfile配置文件" class="headerlink" title="准备Jenkinsfile配置文件"></a>准备Jenkinsfile配置文件</h3><h4 id="准备公共配置文件"><a href="#准备公共配置文件" class="headerlink" title="准备公共配置文件"></a>准备公共配置文件</h4><p>新建远程仓库，文件目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 资源文件</span><br><span class="line">|-- resources</span><br><span class="line"># 执行脚本文件</span><br><span class="line">|-- vars</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>新建配置文件<code>build.groovy</code>，放在<code>vars</code>文件夹下:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">#!groovy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> call(Map map) &#123;</span><br><span class="line"></span><br><span class="line">    pipeline &#123;</span><br><span class="line">        agent any</span><br><span class="line"></span><br><span class="line">        environment &#123;</span><br><span class="line">			APP_NAME = <span class="string">&quot;$&#123;map.APP_NAME&#125;&quot;</span></span><br><span class="line">			APP_PORT = <span class="string">&quot;$&#123;map.APP_PORT&#125;&quot;</span></span><br><span class="line">            <span class="comment">//非必要，可以设置用于发版</span></span><br><span class="line">            REMOTE_HOST = <span class="string">&quot;$&#123;map.REMOTE_HOST&#125;&quot;</span></span><br><span class="line">            <span class="comment">//程序远程仓库地址</span></span><br><span class="line">            REPO_URL = <span class="string">&quot;$&#123;map.REPO_URL&#125;&quot;</span></span><br><span class="line">            BRANCH_NAME = <span class="string">&quot;$&#123;map.BRANCH_NAME&#125;&quot;</span></span><br><span class="line">            <span class="comment">//非必要</span></span><br><span class="line">            STACK_NAME = <span class="string">&quot;$&#123;map.STACK_NAME&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stages &#123;</span><br><span class="line">            stage(<span class="string">&#x27;获取代码&#x27;</span>) &#123;</span><br><span class="line">                steps &#123;</span><br><span class="line">                    git([<span class="attr">url:</span> <span class="string">&quot;$&#123;REPO_URL&#125;&quot;</span>, <span class="attr">branch:</span> <span class="string">&quot;$&#123;BRANCH_NAME&#125;&quot;</span>])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stage(<span class="string">&#x27;编译代码&#x27;</span>) &#123;</span><br><span class="line">                steps &#123;</span><br><span class="line">                    withMaven(<span class="attr">maven:</span> <span class="string">&#x27;maven 3.6&#x27;</span>) &#123;</span><br><span class="line">                        sh <span class="string">&quot;mvn -U -am clean package -DskipTests&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stage(<span class="string">&#x27;构建镜像&#x27;</span>) &#123;</span><br><span class="line">                steps &#123;</span><br><span class="line">					sh <span class="string">&quot;cp ./target/*.jar ./&quot;</span></span><br><span class="line">                    sh <span class="string">&quot;docker build -t $&#123;APP_NAME&#125;/$&#123;BRANCH_NAME&#125;:1.0-SNAPSHOT .&quot;</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">			stage(<span class="string">&#x27;运行镜像&#x27;</span>) &#123;</span><br><span class="line">                steps &#123;</span><br><span class="line">					sh <span class="string">&quot;if docker ps -a | grep $&#123;APP_NAME&#125;-$&#123;BRANCH_NAME&#125;;\n then docker rm -f $&#123;APP_NAME&#125;-$&#123;BRANCH_NAME&#125;\n echo Remove Docker Container: $&#123;APP_NAME&#125;-$&#123;BRANCH_NAME&#125;\n fi&quot;</span></span><br><span class="line">					sh <span class="string">&quot;docker run -d -p $&#123;APP_PORT&#125;:$&#123;APP_PORT&#125; --name $&#123;APP_NAME&#125;-$&#123;BRANCH_NAME&#125; $&#123;APP_NAME&#125;/$&#123;BRANCH_NAME&#125;:1.0-SNAPSHOT&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置Jenkins公共Jenkinsfile库的地址"><a href="#配置Jenkins公共Jenkinsfile库的地址" class="headerlink" title="配置Jenkins公共Jenkinsfile库的地址"></a>配置Jenkins公共Jenkinsfile库的地址</h4><p>进入Jenkins的系统管理的系统配置，找到<code>Global Pipeline Libraries</code>，配置远程仓库地址：<br><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-0.png" alt="在Jenkins上创建多分支流水线-0"></p>
<h4 id="准备程序Jenkinsfile配置文件"><a href="#准备程序Jenkinsfile配置文件" class="headerlink" title="准备程序Jenkinsfile配置文件"></a>准备程序Jenkinsfile配置文件</h4><p>程序根目录新建Jenkinsfile文件，填写配置：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">#!groovy</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在多分支构建下，严格规定Jenkinsfile只存在可以发版的分支上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用在jenkins已经全局定义好的library</span></span><br><span class="line">library <span class="string">&#x27;aptst-pipeline-library&#x27;</span></span><br><span class="line"><span class="keyword">def</span> map = [:]</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序名称</span></span><br><span class="line">map.put(<span class="string">&#x27;APP_NAME&#x27;</span>,<span class="string">&#x27;aptst-config-server&#x27;</span>)</span><br><span class="line"><span class="comment">//程序端口</span></span><br><span class="line">map.put(<span class="string">&#x27;APP_PORT&#x27;</span>,<span class="string">&#x27;3344&#x27;</span>)</span><br><span class="line"><span class="comment">// 远程管理节点地址（用于执行发版）</span></span><br><span class="line">map.put(<span class="string">&#x27;REMOTE_HOST&#x27;</span>,<span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>)</span><br><span class="line"><span class="comment">// 项目github代码地址</span></span><br><span class="line">map.put(<span class="string">&#x27;REPO_URL&#x27;</span>,<span class="string">&#x27;XXX&#x27;</span>)</span><br><span class="line"><span class="comment">// 分支名称</span></span><br><span class="line">map.put(<span class="string">&#x27;BRANCH_NAME&#x27;</span>,<span class="string">&#x27;master&#x27;</span>)</span><br><span class="line"><span class="comment">// 服务栈名称，公共配置没配置可以不需要</span></span><br><span class="line">map.put(<span class="string">&#x27;STACK_NAME&#x27;</span>,<span class="string">&#x27;XXX&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用library中vars目录下的build.groovy脚本</span></span><br><span class="line">build(map)</span><br></pre></td></tr></table></figure>

<h3 id="Blue-Ocean"><a href="#Blue-Ocean" class="headerlink" title="Blue Ocean"></a>Blue Ocean</h3><p>首先进入Jenkins的Blue Ocean页面，在Jenkins页面左边找到按钮或输入网址<code>http://&lt;jenkins address&gt;/blue</code></p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-1.png" alt="在Jenkins上创建多分支流水线-1"></p>
<h3 id="创建Pipeline"><a href="#创建Pipeline" class="headerlink" title="创建Pipeline"></a>创建Pipeline</h3><p>点击<code>创建流水线</code>：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-2.png" alt="在Jenkins上创建多分支流水线-2"></p>
<p>选择代码仓库，根据你远程仓库选择对应的：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-3.png" alt="在Jenkins上创建多分支流水线-3"></p>
<p>添加GitHub服务器：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-4.png" alt="在Jenkins上创建多分支流水线-4"></p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-5.png" alt="在Jenkins上创建多分支流水线-5"></p>
<p>选择仓库然后点击创建流水线：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-6.png" alt="在Jenkins上创建多分支流水线-6"></p>
<p>完整步骤图：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-7.png" alt="在Jenkins上创建多分支流水线-7"></p>
<h3 id="配置webhook"><a href="#配置webhook" class="headerlink" title="配置webhook"></a>配置webhook</h3><p>首先让我们看看 <a href="https://developer.github.com/webhooks/">Github官方</a> 关于Github webhooks的解释： </p>
<blockquote>
<p>Webhooks allow you to build or set up integrations which subscribe to certain events on GitHub.com.</p>
</blockquote>
<p>中文意思就是： webhook允许您构建或设置订阅GitHub.com上某些事件的集成。 通过webhook，我们就可以实现自动化部署。</p>
<p>进入项目GitHub仓库地址，进入**<code>settings</code><strong>，点击</strong><code> hook</code><strong>，再点击</strong><code>Add webhook</code>**：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-8.png" alt="在Jenkins上创建多分支流水线-8"></p>
<p>填写Jenkins接收事件地址**<code>Payload URL</code>**：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://&lt;Jenkins address&gt;/github-webhook/</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-9.png" alt="在Jenkins上创建多分支流水线-9"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>Pipeline</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Pipeline</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列学习</title>
    <url>/2021/07/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><h2 id="消息中间件的含义"><a href="#消息中间件的含义" class="headerlink" title="消息中间件的含义"></a>消息中间件的含义</h2><ol>
<li>利用可靠的消息传递机制进行系统和系统直接的通讯</li>
<li>通过提供消息传递和消息的派对机制，它可以在分布式系统环境下扩展进程间的通讯</li>
</ol>
<h2 id="消息中间件应用的场景"><a href="#消息中间件应用的场景" class="headerlink" title="消息中间件应用的场景"></a>消息中间件应用的场景</h2><ol>
<li>跨系统数据传递</li>
<li>高并发的流量削峰</li>
<li>数据的并发和异步处理</li>
<li>大数据分析与传递</li>
<li>分布式事务比如你有一个数据要进行迁移或者请求并发过多的时候，</li>
</ol>
<h2 id="常见的消息中间件"><a href="#常见的消息中间件" class="headerlink" title="常见的消息中间件"></a>常见的消息中间件</h2><p>ActiveMQ、RabbitMQ、Kafka、RocketMQ等</p>
<h2 id="消息中间件的本质及设计"><a href="#消息中间件的本质及设计" class="headerlink" title="消息中间件的本质及设计"></a>消息中间件的本质及设计</h2><p>它是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务</p>
<p>MQ消息队列：负责数据的传接受，存储和传递，所以性能要高于普通服务和技术</p>
<h2 id="消息中间件的核心组成部分"><a href="#消息中间件的核心组成部分" class="headerlink" title="消息中间件的核心组成部分"></a>消息中间件的核心组成部分</h2><p>消息的协议<br>消息的持久化机制<br>消息的分发策略<br>消息的高可用，高可靠<br>消息的容错机制</p>
<span id="more"></span>

<h1 id="消息队列协议"><a href="#消息队列协议" class="headerlink" title="消息队列协议"></a>消息队列协议</h1><h2 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h2><p>AMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现由 RabbitMQ等</p>
<p>特性：</p>
<ol>
<li>分布式事务支持</li>
<li>消息的持久化支持</li>
<li>高性能和高可靠的消息处理优势</li>
</ol>
<p>支持者：RabbitMQ，ActiveMQ</p>
<h2 id="MQTT协议"><a href="#MQTT协议" class="headerlink" title="MQTT协议"></a>MQTT协议</h2><p>MQTT协议（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分</p>
<p>特点：</p>
<ol>
<li>轻量</li>
<li>结构简单</li>
<li>传输快，不支持事务</li>
<li>没有持久化设计</li>
</ol>
<p>应用场景：</p>
<ol>
<li>适用于计算能力有限</li>
<li>低带宽</li>
<li>网络不稳定的场景</li>
</ol>
<p>支持者：RabbitMQ，ActiveMQ</p>
<h2 id="OpenMessage协议"><a href="#OpenMessage协议" class="headerlink" title="OpenMessage协议"></a>OpenMessage协议</h2><p>是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准</p>
<p>特点：</p>
<ol>
<li>结构简单</li>
<li>解析速度快</li>
<li>支持事务和持久化设计</li>
</ol>
<p>支持者：RocketMQ </p>
<h2 id="Kafka协议"><a href="#Kafka协议" class="headerlink" title="Kafka协议"></a>Kafka协议</h2><p>Kafka协议是基于 TCP&#x2F;IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成</p>
<p>特点：</p>
<ol>
<li>结构简单</li>
<li>解析速度快</li>
<li>无事务支持</li>
<li>有持久化设计</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>协议：实在 tcp&#x2F;ip协议基础之上构建的一种约定俗称的规范和机制、它的主要目的可以让客户端（应用程序 java，go）进行沟通和通讯。并且这种写一下规范必须具有持久性，高可用，高可靠的性能</p>
<h2 id="消息的分发策略"><a href="#消息的分发策略" class="headerlink" title="消息的分发策略"></a>消息的分发策略</h2><table>
<thead>
<tr>
<th></th>
<th align="center">ActiveMQ</th>
<th align="center">RabbitMQ</th>
<th align="center">Kafka</th>
<th align="center">RocketMQ</th>
</tr>
</thead>
<tbody><tr>
<td>发布订阅</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td>轮询分发</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">&#x2F;</td>
</tr>
<tr>
<td>公平分发</td>
<td align="center">&#x2F;</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">&#x2F;</td>
</tr>
<tr>
<td>重发</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">&#x2F;</td>
<td align="center">支持</td>
</tr>
<tr>
<td>消息拉取</td>
<td align="center">&#x2F;</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="Docker安装RabbitMQ"><a href="#Docker安装RabbitMQ" class="headerlink" title="Docker安装RabbitMQ"></a>Docker安装RabbitMQ</h2><h3 id="获取rabbit镜像"><a href="#获取rabbit镜像" class="headerlink" title="获取rabbit镜像"></a>获取rabbit镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure>

<h3 id="创建并运行容器"><a href="#创建并运行容器" class="headerlink" title="创建并运行容器"></a>创建并运行容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -id --name docker-rabbitmq-management -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br></pre></td></tr></table></figure>

<h3 id="添加用户并授权权限"><a href="#添加用户并授权权限" class="headerlink" title="添加用户并授权权限"></a>添加用户并授权权限</h3><h4 id="新增用户"><a href="#新增用户" class="headerlink" title="新增用户"></a>新增用户</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl add_user admin admin</span><br></pre></td></tr></table></figure>

<h4 id="设置用户分配操作权限"><a href="#设置用户分配操作权限" class="headerlink" title="设置用户分配操作权限"></a>设置用户分配操作权限</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure>

<p>用户级别：</p>
<ol>
<li><p>administrator：可以登录控制台、查看所有信息、可以对 rabbitmq进行管理</p>
<p>policymaker和monitoring可以做的任何事外加:<br>创建和删除virtual hosts<br>查看、创建和删除users<br>查看创建和删除permissions<br>关闭其他用户的connections</p>
</li>
<li><p>monitoring：监控者 登录控制台，查看所有信息</p>
<p>management可以做的任何事外加：</p>
<p>列出所有virtual hosts，包括他们不能登录的virtual hosts<br>查看其他用户的connections和channels<br>查看节点级别的数据如clustering和memory使用情况<br>查看真正的关于所有virtual hosts的全局的统计信息</p>
</li>
<li><p>policymaker：策略制定者 登录控制台，指定策略</p>
<p>management可以做的任何事外加：</p>
<p>查看、创建和删除自己的virtual hosts所属的policies和parameters</p>
</li>
<li><p>managment 普通管理员 登录控制台</p>
<p>用户可以通过AMQP做的任何事外加：<br>列出自己可以通过AMQP登入的virtual hosts<br>查看自己的virtual hosts中的queues, exchanges 和 bindings<br>查看和关闭自己的channels 和 connections<br>查看有关自己的virtual hosts的“全局”的统计信息，包含其他用户在这些virtual hosts中的活动。</p>
</li>
</ol>
<h4 id="为用户添加资源权限"><a href="#为用户添加资源权限" class="headerlink" title="为用户添加资源权限"></a>为用户添加资源权限</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p / admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure>

<h2 id="RabbitMQ入门案例-Simple-简单模式"><a href="#RabbitMQ入门案例-Simple-简单模式" class="headerlink" title="RabbitMQ入门案例 - Simple 简单模式"></a>RabbitMQ入门案例 - Simple 简单模式</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;monochrome&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//2.创建通道</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//3.通过创建交换机，声明队列，绑定关系，路由key，发送消息和接受消息</span></span><br><span class="line">            <span class="comment">/*参数1:是否持久化，非持久化消息会存盘吗？会存盘，但是会随着重启服务器而丢失</span></span><br><span class="line"><span class="comment">              参数2:是否独占队列</span></span><br><span class="line"><span class="comment">              参数3:是否自动删除，随着最后一个消费者消息完毕消息以后是否把队列自动删除</span></span><br><span class="line"><span class="comment">              参数4:携带附属属性</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;queue1&quot;</span>;</span><br><span class="line">            channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.发送消息给队列queue</span></span><br><span class="line">            <span class="comment">/*参数1:交换机</span></span><br><span class="line"><span class="comment">              参数2:队列、路由key</span></span><br><span class="line"><span class="comment">              参数3:消息的状态控制</span></span><br><span class="line"><span class="comment">              参数4:消息主题</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//面试题：可以存在没有交换机的队列吗？不可能，虽然没有指定交换机但是一定会存在一个默认的交换机</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5.关闭</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;monochrome&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">            <span class="comment">//2.创建通道</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;queue1&quot;</span>;</span><br><span class="line"></span><br><span class="line">            channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DeliverCallback</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> <span class="title class_">CancelCallback</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收消息失败！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;开始接收消息&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5.关闭</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>AMQP全称：Advanced Message Queuing Protocol（高级消息队列协议）。是应用层协议的一个开发标准，为面向消息的中间件设计</p>
<h3 id="AMQP生产者流转过程"><a href="#AMQP生产者流转过程" class="headerlink" title="AMQP生产者流转过程"></a>AMQP生产者流转过程</h3><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/AMQP%E7%94%9F%E4%BA%A7%E8%80%85%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B.png" alt="AMQP生产者流转过程"></p>
<h3 id="AMQP消费者流转过程"><a href="#AMQP消费者流转过程" class="headerlink" title="AMQP消费者流转过程"></a>AMQP消费者流转过程</h3><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/AMQP%E6%B6%88%E8%B4%B9%E8%80%85%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B.png" alt="AMQP消费者流转过程"></p>
<h2 id="RabbitMQ的核心组成部分"><a href="#RabbitMQ的核心组成部分" class="headerlink" title="RabbitMQ的核心组成部分"></a>RabbitMQ的核心组成部分</h2><h3 id="RabbitMQ的核心组成部分-1"><a href="#RabbitMQ的核心组成部分-1" class="headerlink" title="RabbitMQ的核心组成部分"></a>RabbitMQ的核心组成部分</h3><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/RabbitMQ%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png" alt="RabbitMQ的核心组成部分"></p>
<p>Server：又被称为Broker,接受客户端的连接，实现AMQP服务。就是我们自己安装的rabbitmq-server<br>Connection：连接，应用程序与Broker的网络连接（使用的是TCP&#x2F;IP连接）<br>Channel：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，每个通道Channel代表一个会话任务。<br>Message：消息，服务于应用程序之间传递的数据，由Properties和body组成，Properties可以对消息进行修饰，比如消息的优先级，延迟等高级特征，Body则是消息体的内容。<br>Virtual Host：虚拟地址，用于逻辑层隔离，最上层的消息路由，一个虚拟机理由可以有若干的Exchange和Queueu，同一个虚拟机里面不能有相同名字的Exchange。<br>Exchange：交换机，接收消息，根据路由键发送消息到绑定的队列（不具备储存消息的能力）<br>Bindings：Exchange和Queue之间的虚拟连接，Binding中可以保护多个routing key.<br>Routing key：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。<br>Queue：队列，也是MessageQueue队列，保存消息转发给消费者</p>
<h3 id="RabbitMQ的操作流程"><a href="#RabbitMQ的操作流程" class="headerlink" title="RabbitMQ的操作流程"></a>RabbitMQ的操作流程</h3><p>第一：获取Conection<br>第二：获取Channel<br>第三：定义Exchange，Queue<br>第四：使用一个RoutingKey将Queue Binding到一个Exchange上<br>第五：通过指定一个Exchange和一个RoutingKey来将消息发送到对应的Queue上，<br>第六：Consumer在接收时也是获取connection，接着获取channel，然后指定一个Queue，到Queue上取消息，它对Exchange，RoutingKey及如何Binding都不关心，到对应的Queue上去取消息就行了。</p>
<p>注意：一个PublisherClient发送消息，哪些ConsumerClient可以收到消息，在于Exchange，RoutingKey，Queue的关系上</p>
<h3 id="RabbitMQ支持的消息模型"><a href="#RabbitMQ支持的消息模型" class="headerlink" title="RabbitMQ支持的消息模型"></a>RabbitMQ支持的消息模型</h3><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/RabbitMQ%E6%94%AF%E6%8C%81%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B-1.png" alt="RabbitMQ支持的消息模型-1"></p>
<p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/RabbitMQ%E6%94%AF%E6%8C%81%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B-2.png" alt="RabbitMQ支持的消息模型-2"></p>
<ol>
<li>简单模式 Simple</li>
<li>工作模式 Work</li>
<li>发布订阅模式</li>
<li>路由模式</li>
<li>主题 Topic模式</li>
<li>参数模式</li>
</ol>
<h2 id="RabbitMQ-fanout-模式"><a href="#RabbitMQ-fanout-模式" class="headerlink" title="RabbitMQ - fanout 模式"></a>RabbitMQ - fanout 模式</h2><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/fanout%E6%A8%A1%E5%BC%8F.png" alt="fanout模式"></p>
<p><strong>发布订阅模式的具体实现</strong></p>
<ol>
<li>类型：fanout</li>
<li>特点：Fanout - 发布与订阅模式，是一种广播机制，它是没有路由 key的模式</li>
</ol>
<h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    connectionFactory.setHost(<span class="string">&quot;10.15.0.9&quot;</span>);</span><br><span class="line">    connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">    connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">    <span class="comment">//2.创建通道</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">    <span class="comment">//3.通过创建交换机，声明队列，绑定关系，路由key，发送消息和接受消息</span></span><br><span class="line">    <span class="comment">/*参数1: 是否持久化，非持久化消息会存盘吗？会存盘，但是会随着重启服务器而丢失</span></span><br><span class="line"><span class="comment">      参数2:是否独占队列 </span></span><br><span class="line"><span class="comment">      参数3:是否自动删除，随着最后一个消费者消息完毕消息以后是否把队列自动删除</span></span><br><span class="line"><span class="comment">  	  参数4:携带附属属性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;queue1&quot;</span>;</span><br><span class="line">    channel.queueDeclare(queueName,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//4.发送消息给队列queue</span></span><br><span class="line">    <span class="comment">/*参数1: 交换机</span></span><br><span class="line"><span class="comment">      参数2:队列、路由key</span></span><br><span class="line"><span class="comment">      参数3:消息的状态控制</span></span><br><span class="line"><span class="comment">  	  参数4:消息主题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//面试题：可以存在没有交换机的队列吗？不可能，虽然没有指定交换机但是一定会存在一个默认的交换机</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="comment">//5.准备交换机</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;fanout-exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//6.定义路由key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">routeKey</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//7.指定交换机的类型</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;fanout&quot;</span>;</span><br><span class="line">    channel.basicPublish(exchangeName,routeKey, <span class="literal">null</span>,message.getBytes());</span><br><span class="line">    <span class="comment">//8.关闭</span></span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RabbitMQ-direct-模式"><a href="#RabbitMQ-direct-模式" class="headerlink" title="RabbitMQ - direct 模式"></a>RabbitMQ - direct 模式</h2><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/direct%E6%A8%A1%E5%BC%8F.png" alt="direct模式"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6.定义路由key</span></span><br><span class="line"><span class="type">String</span> <span class="variable">routeKey</span> <span class="operator">=</span> <span class="string">&quot;email&quot;</span>;</span><br><span class="line"><span class="comment">//7.指定交换机的类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;direct&quot;</span>;</span><br><span class="line">channel.basicPublish(exchangeName,routeKey, <span class="literal">null</span>,message.getBytes());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="RabbitMQ-topic-模式"><a href="#RabbitMQ-topic-模式" class="headerlink" title="RabbitMQ - topic 模式"></a>RabbitMQ - topic 模式</h2><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/topic%E6%A8%A1%E5%BC%8F.png" alt="topic模式"></p>
<p>#：匹配0、1或多个<br>*：匹配一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6.定义路由key</span></span><br><span class="line"><span class="type">String</span> <span class="variable">routeKey</span> <span class="operator">=</span> <span class="string">&quot;com.order.test.xxx&quot;</span>;</span><br><span class="line"><span class="comment">//7.指定交换机的类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;direct&quot;</span>;</span><br><span class="line">channel.basicPublish(exchangeName, routeKey, <span class="literal">null</span>,message.getBytes());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="代码创建及绑定"><a href="#代码创建及绑定" class="headerlink" title="代码创建及绑定"></a>代码创建及绑定</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.准备交换机</span></span><br><span class="line"><span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;direct_message_exchange&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">exchangeType</span> <span class="operator">=</span> <span class="string">&quot;direct&quot;</span>;</span><br><span class="line"><span class="comment">//如果你用界面把queue和exchange的关系先绑定话，代码就不需要在编写这些声明代码可以让代码变得更简洁</span></span><br><span class="line"><span class="comment">//如果用代码的方式去声明，我们要学习一下</span></span><br><span class="line"><span class="comment">//6.声明交换机 所谓的持久化就是指，交换机会不会随着服务器重启造成丢失</span></span><br><span class="line">channel.exchangeDeclare(exchangeName,exchangeType,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.声明队列</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;queue5&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;queue6&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;queue7&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.绑定队列和交换机的关系</span></span><br><span class="line">channel.queueBind(<span class="string">&quot;queue5&quot;</span>,exchangeName,<span class="string">&quot;order&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;queue6&quot;</span>,exchangeName,<span class="string">&quot;order&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;queue7&quot;</span>,exchangeName,<span class="string">&quot;course&quot;</span>);</span><br><span class="line"></span><br><span class="line">channel.basicPublish(exchangeName,course, <span class="literal">null</span>,message.getBytes());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="RabbitMQ-header模式"><a href="#RabbitMQ-header模式" class="headerlink" title="RabbitMQ - header模式"></a>RabbitMQ - header模式</h2><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/headers%E6%A8%A1%E5%BC%8F.png" alt="headers模式"></p>
<h2 id="RabbitMQ-work模式"><a href="#RabbitMQ-work模式" class="headerlink" title="RabbitMQ - work模式"></a>RabbitMQ - work模式</h2><p>当有多个消费者时，我们的消息会被哪个消费者消费呢，我们又该如何均衡消费者消费信息的多少呢？</p>
<p>主要有两种模式：</p>
<ol>
<li>轮询模式的分发：一个消费者一条，按均分配</li>
<li>公平分发：根据消费者的消费能力进行公平分发，处理快的处理的多，处理慢的处理的少；按劳分配</li>
</ol>
<h3 id="work模式轮询模式（Round-Robin）"><a href="#work模式轮询模式（Round-Robin）" class="headerlink" title="work模式轮询模式（Round-Robin）"></a>work模式轮询模式（Round-Robin）</h3><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/work%E6%A8%A1%E5%BC%8F-%E8%BD%AE%E8%AF%A2%E6%A8%A1%E5%BC%8F.png" alt="work模式-轮询模式"></p>
<h4 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.rabbitmq.work.polling;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;monochrome&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//2.创建通道</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//3.通过创建交换机，声明队列，绑定关系，路由key，发送消息和接受消息</span></span><br><span class="line">            <span class="comment">/*参数1:是否持久化，非持久化消息会存盘吗？会存盘，但是会随着重启服务器而丢失</span></span><br><span class="line"><span class="comment">              参数2:是否独占队列</span></span><br><span class="line"><span class="comment">              参数3:是否自动删除，随着最后一个消费者消息完毕消息以后是否把队列自动删除</span></span><br><span class="line"><span class="comment">              参数4:携带附属属性</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;queue-polling&quot;</span>;</span><br><span class="line">            channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.发送消息给队列queue</span></span><br><span class="line">            <span class="comment">/*参数1:交换机</span></span><br><span class="line"><span class="comment">              参数2:队列、路由key</span></span><br><span class="line"><span class="comment">              参数3:消息的状态控制</span></span><br><span class="line"><span class="comment">              参数4:消息主题</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + i;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5.关闭</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.rabbitmq.work.polling;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建连接工厂</span></span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">            connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            connectionFactory.setPassword(<span class="string">&quot;monochrome&quot;</span>);</span><br><span class="line">            connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection = connectionFactory.newConnection(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">                <span class="comment">//2.创建通道</span></span><br><span class="line">                channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">workName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                <span class="type">String</span> <span class="variable">routingName</span> <span class="operator">=</span> <span class="string">&quot;queue-polling&quot;</span>;</span><br><span class="line"></span><br><span class="line">                channel.basicConsume(routingName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DeliverCallback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        System.out.println(workName + <span class="string">&quot;收到消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">                        <span class="keyword">switch</span> (workName) &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&quot;work1&quot;</span>:</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&quot;work2&quot;</span>:</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> <span class="title class_">CancelCallback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        System.out.println(workName + <span class="string">&quot;接收消息失败！&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                System.out.println(<span class="string">&quot;开始接收消息：&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//5.关闭</span></span><br><span class="line">                <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        channel.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="literal">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        connection.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;work1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;work2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="work模式公平分发模式"><a href="#work模式公平分发模式" class="headerlink" title="work模式公平分发模式"></a>work模式公平分发模式</h3><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/work%E6%A8%A1%E5%BC%8F-%E5%85%AC%E5%B9%B3%E6%A8%A1%E5%BC%8F.png" alt="work模式-公平模式"></p>
<p>生产者同轮询模式</p>
<h4 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.rabbitmq.work.fair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建连接工厂</span></span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">            connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            connectionFactory.setPassword(<span class="string">&quot;monochrome&quot;</span>);</span><br><span class="line">            connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection = connectionFactory.newConnection(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">                <span class="comment">//2.创建通道</span></span><br><span class="line">                channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">workName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                <span class="type">String</span> <span class="variable">routingName</span> <span class="operator">=</span> <span class="string">&quot;queue-polling&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//公平分发需要改成手动应答</span></span><br><span class="line">                <span class="type">Channel</span> <span class="variable">finalChannel</span> <span class="operator">=</span> channel;</span><br><span class="line">                <span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">                <span class="comment">//这告诉 RabbitMQ 一次不要给一个工人多个消息。或者，换句话说，在处理并确认前一条消息之前，不要向工作人员发送新消息。相反，它会将它分派给下一个不忙的工人。</span></span><br><span class="line">                finalChannel.basicQos(prefetchCount);</span><br><span class="line">                channel.basicConsume(routingName, <span class="literal">false</span>, <span class="keyword">new</span> <span class="title class_">DeliverCallback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        System.out.println(workName + <span class="string">&quot;收到消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">                        <span class="keyword">switch</span> (workName) &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&quot;work1&quot;</span>:</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&quot;work2&quot;</span>:</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        finalChannel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> <span class="title class_">CancelCallback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        System.out.println(workName + <span class="string">&quot;接收消息失败！&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                System.out.println(<span class="string">&quot;开始接收消息：&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//5.关闭</span></span><br><span class="line">                <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        channel.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="literal">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        connection.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;work1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;work2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Springboot集成RabbitMQ"><a href="#Springboot集成RabbitMQ" class="headerlink" title="Springboot集成RabbitMQ"></a>Springboot集成RabbitMQ</h2><h3 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a><strong>application.yml</strong></h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">monochrome</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>

<h3 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;生成订单：&quot;</span> + uuid);</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;fanout-order-exchange&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, routingKey, uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者-3"><a href="#消费者-3" class="headerlink" title="消费者"></a>消费者</h3><p>配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutOrderExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;fanout-order-exchange&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">smsQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;sms.fanout.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">emailQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;email.fanout.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">wechatQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;wechat.fanout.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">smsBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(smsQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">emailBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(emailQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">wechatBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(wechatQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Consumer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;email.fanout.queue&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutEmailConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;email接收到消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;sms.fanout.queue&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutSmsConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sms接收到消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;wechat.fanout.queue&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutWechatConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;wechat接收到消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：<a href="https://github.com/zhaoyangmushiyi/springboot-rabbitmq">https://github.com/zhaoyangmushiyi/springboot-rabbitmq</a></p>
]]></content>
      <categories>
        <category>消息队列</category>
        <category>RabbitMQ</category>
        <category>Kafka</category>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
        <tag>Kafka</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Hexo framework</title>
    <url>/2019/11/29/%E5%AE%89%E8%A3%85Hexo%20framework/</url>
    <content><![CDATA[<h1 id="安装Hexo-framework"><a href="#安装Hexo-framework" class="headerlink" title="安装Hexo framework"></a>安装Hexo framework</h1><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><ul>
<li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 8.6，建议使用 Node.js 10.0 及以上版本)</li>
<li><a href="http://git-scm.com/">Git</a></li>
</ul>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing index.html from permalinks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Metadata elements</span></span><br><span class="line"><span class="comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span><br><span class="line"><span class="attr">meta_generator:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="comment">## Use post&#x27;s date for updated date unless set in front-matter</span></span><br><span class="line"><span class="attr">use_date_for_updated:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include / Exclude file(s)</span></span><br><span class="line"><span class="comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>title</code></td>
<td align="left">网站标题</td>
</tr>
<tr>
<td align="left"><code>subtitle</code></td>
<td align="left">网站副标题</td>
</tr>
<tr>
<td align="left"><code>description</code></td>
<td align="left">网站描述</td>
</tr>
<tr>
<td align="left"><code>keywords</code></td>
<td align="left">网站的关键词。使用半角逗号 <code>,</code> 分隔多个关键词。</td>
</tr>
<tr>
<td align="left"><code>author</code></td>
<td align="left">您的名字</td>
</tr>
<tr>
<td align="left"><code>language</code></td>
<td align="left">网站使用的语言</td>
</tr>
<tr>
<td align="left"><code>timezone</code></td>
<td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td>
</tr>
</tbody></table>
<p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo-site&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hexo&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hexo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.8.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-archive&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.1.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.1.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.2.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-ejs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.3.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-stylus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.3.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-marked&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.3.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.3.3&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>
<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold&#x2F;post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p>
<h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ol>
<li><p>Install <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>Add the following configurations to <strong>_config.yml</strong>, (remove existing lines if any)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&lt;username&gt;/&lt;project&gt;</span></span><br><span class="line">  <span class="comment"># example, https://github.com/hexojs/hexojs.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gh-pages</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Run <code>hexo clean &amp;&amp; hexo deploy</code>.</p>
</li>
<li><p>Check the webpage at <em>username</em>.github.io.</p>
</li>
</ol>
<h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><h3 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h3><p>安装NexT主题</p>
<h3 id="开启文章字数统计"><a href="#开启文章字数统计" class="headerlink" title="开启文章字数统计"></a>开启文章字数统计</h3><p>安装 hexo-symbols-count-time：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time</span><br></pre></td></tr></table></figure>

<p>配置next _config.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>

<h3 id="配置背景特效"><a href="#配置背景特效" class="headerlink" title="配置背景特效"></a>配置背景特效</h3><p>安装canvas-nest.js：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save canvas-nest.js</span><br></pre></td></tr></table></figure>

<p>配置next _config.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="attr">canvas_nest:</span> <span class="string">//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js</span></span><br></pre></td></tr></table></figure>

<h3 id="配置背景图片："><a href="#配置背景图片：" class="headerlink" title="配置背景图片："></a>配置背景图片：</h3><p>添加文件到<code>next/source/css/_custom/custom.styl</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: url(/images/uploads/background.jpg) no-repeat;</span><br><span class="line">  <span class="comment">/* 背景图垂直、水平均居中 */</span></span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="comment">/* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 */</span></span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">  <span class="comment">/* 让背景图基于容器大小伸缩 */</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="comment">/* 设置背景颜色，背景图加载过程中会显示背景色 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">	<span class="attribute">background</span>:url(/images/uploads/sidebar.jpg);</span><br><span class="line">	<span class="attribute">background-size</span>: cover;</span><br><span class="line">	<span class="attribute">background-position</span>:center;</span><br><span class="line">	<span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">	<span class="selector-tag">p</span>,<span class="selector-tag">span</span>,<span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">            <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">60px</span> <span class="number">30px</span> <span class="number">60px</span>;</span><br><span class="line">            <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>) none repeat scroll <span class="meta">!important</span>;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="selector-id">#lv-container</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">60px</span> <span class="number">30px</span> <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>) none repeat scroll <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>激活用户自定义配置，打开<code>next/source/css/main.styl</code>，添加配置：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Custom Layer</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;_custom/custom&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
        <category>NexT</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-代理模式</title>
    <url>/2022/07/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User [&quot;</span>+username+<span class="string">&quot;] logins!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceStaticProxy</span> <span class="keyword">extends</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;login start：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">        <span class="built_in">super</span>.login(username, password);</span><br><span class="line">        System.out.println(<span class="string">&quot;login end：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p>
<p>Java实现动态代理采用的是反射。</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>动态代理有两种，一种是被代理的类是实体类，而不是接口，这种情况在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p>
<h3 id="java代理"><a href="#java代理" class="headerlink" title="java代理"></a>java代理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicInvocationHandler</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.proxiedObject = proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;login start：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(proxiedObject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;login end：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceDynamicProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceDynamicProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">        Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class="line">        <span class="type">DynamicInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicInvocationHandler</span>(userService);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceStaticProxy</span>();</span><br><span class="line">        userService.login(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">UserServiceDynamicProxy</span> <span class="variable">userServiceDynamicProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceDynamicProxy</span>();</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService1</span> <span class="operator">=</span> (UserService) userServiceDynamicProxy.createProxy(<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>());</span><br><span class="line">        userService1.login(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h3><p>还有一种被代理的类是接口，这种情况需要用到CGLIB代理</p>
<p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CglibProxyFactory</span><span class="params">(T target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// cglib工具类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置父类</span></span><br><span class="line">        enhancer.setSuperclass(<span class="built_in">this</span>.target.getClass());</span><br><span class="line">        <span class="comment">// 设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;login start：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;login end：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyInterfaceFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxyInstance</span><span class="params">(Class&lt;T&gt; clz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Enhancer.create(clz, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;login start：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;login end：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库知识</title>
    <url>/2021/07/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h1><p>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般来说，数据库只需满足第三范式(3NF）就行了。</p>
<span id="more"></span>

<h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 1NF"></a><strong>第一范式 1NF</strong></h2><p><strong>定义：</strong> 属于第一范式关系的所有属性都不可再分，即数据项不可分。</p>
<p><strong>理解：</strong> 第一范式强调数据表的原子性，是其他范式的基础。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F.png" alt="第一范式"></p>
<h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 2NF"></a><strong>第二范式 2NF</strong></h2><p>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</p>
<p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F.png" alt="第二范式"></p>
<h2 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 3NF"></a><strong>第三范式 3NF</strong></h2><p>在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</p>
<p>第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F.png" alt="第三范式"></p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行 。事务是一个不可分割的工作逻辑单元 事务必须具备以下四个属性，简称 ACID 属性：</p>
<ol>
<li><p>原子性（<strong>Atomicity</strong>） </p>
<p>事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执行。</p>
</li>
<li><p>一致性（<strong>Consistency</strong>） </p>
<p>当事务完成时，数据必须处于一致状态。</p>
</li>
<li><p>隔离性（<strong>Isolation</strong>） </p>
<p>对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。</p>
</li>
<li><p>持久性（<strong>Durability</strong>） </p>
<p>事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。</p>
</li>
</ol>
<h1 id="数据库并发策略"><a href="#数据库并发策略" class="headerlink" title="数据库并发策略"></a>数据库并发策略</h1><p>并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据;悲观锁就刚好相反，觉得自 己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度;时间 戳就是不加锁，通过时间戳来控制并发出现的问题。</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加 锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数 据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允 许其他用户访问那部分数据。</p>
<h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字 段也读出来，当写回去的时候，把该字段加 1，提交之前 ，跟数据库的该字段比较一次，如果比数 据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁 机制，但是这种方法可以大大提高数据库处理的并发量，</p>
<p>以上悲观锁所说的加“锁”，其实分为几种锁，分别是:排它锁(写锁)和共享锁(读锁)。 </p>
<h1 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h1><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁是一种排他锁，防止其他事务修改此行;在使用以下语句时，Oracle 会自动应用行级锁:</p>
<ol>
<li>INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];</li>
<li>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新</li>
<li>使用 COMMIT 或 ROLLBACK 语句释放锁。</li>
</ol>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使 用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁(共享锁)与表独占写锁 (排他锁)。</p>
<h2 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h2><p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁</p>
<h2 id="基于-Redis-分布式锁"><a href="#基于-Redis-分布式锁" class="headerlink" title="基于 Redis 分布式锁"></a>基于 <strong>Redis</strong> 分布式锁</h2><ol>
<li>获取锁的时候，使用 setnx(SETNX key val:当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1;若 key 存在，则什么都不做，返回 0)加锁，锁的 value 值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添 加一个超时时间，超过该时间则自动释放锁。</li>
<li>获取锁的时候调用 setnx，如果返回 0，则该锁正在被别人使用，返回 1 则成功获取 锁。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ol>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="MySQL-有哪些数据类型？"><a href="#MySQL-有哪些数据类型？" class="headerlink" title="MySQL 有哪些数据类型？"></a>MySQL 有哪些数据类型？</h2><p>MySQL 支持多种类型，大致可以分为三类：数值、日期&#x2F;时间和字符串(字符)类型。具体可以看看 <a href="http://www.runoob.com/mysql/mysql-data-types.html">《MySQL 数据类型》</a> 文档。</p>
<ul>
<li>正确的使用数据类型，对数据库的优化是非常重要的。</li>
</ul>
<h3 id="MySQL-中-varchar-与-char-的区别？varchar-50-中的-50-代表的涵义？"><a href="#MySQL-中-varchar-与-char-的区别？varchar-50-中的-50-代表的涵义？" class="headerlink" title="MySQL 中 varchar 与 char 的区别？varchar(50) 中的 50 代表的涵义？"></a><strong>MySQL 中 varchar 与 char 的区别？varchar(50) 中的 50 代表的涵义？</strong></h3><ul>
<li><p>1、varchar 与 char 的区别，char 是一种固定长度的类型，varchar 则是一种可变长度的类型。</p>
</li>
<li><p>2、varchar(50) 中 50 的涵义最多存放 50 个字符。varchar(50) 和 (200) 存储 hello 所占空间一样，</p>
<p>但后者在排序时会消耗更多内存，因为 <code>ORDER BY col</code> 采用 fixed_length 计算 col 长度(memory引擎也一样)。</p>
<blockquote>
<p>所以，实际场景下，选择合适的 varchar 长度还是有必要的。</p>
</blockquote>
</li>
</ul>
<h3 id="int-11-中的-11-代表什么涵义？"><a href="#int-11-中的-11-代表什么涵义？" class="headerlink" title="int(11) 中的 11 代表什么涵义？"></a><strong>int(11) 中的 11 代表什么涵义？</strong></h3><p>int(11) 中的 11 ，不影响字段存储的范围，只影响展示效果。具体可以看看 <a href="https://blog.csdn.net/qmhball/article/details/51544484">《MySQL 中 int 长度的意义》</a> 文章。</p>
<h3 id="金额-金钱-相关的数据，选择什么数据类型？"><a href="#金额-金钱-相关的数据，选择什么数据类型？" class="headerlink" title="金额(金钱)相关的数据，选择什么数据类型？"></a><strong>金额(金钱)相关的数据，选择什么数据类型？</strong></h3><ul>
<li>方式一，使用 int 或者 bigint 类型。如果需要存储到分的维度，需要 *100 进行放大。</li>
<li>方式二，使用 decimal 类型，避免精度丢失。如果使用 Java 语言时，需要使用 BigDecimal 进行对应。</li>
</ul>
<h3 id="一张表，里面有-ID-自增主键，当-insert-了-17-条记录之后，删除了第-15-16-17-条记录，再把-MySQL-重启，再-insert-一条记录，这条记录的-ID-是-18-还是-15？"><a href="#一张表，里面有-ID-自增主键，当-insert-了-17-条记录之后，删除了第-15-16-17-条记录，再把-MySQL-重启，再-insert-一条记录，这条记录的-ID-是-18-还是-15？" class="headerlink" title="一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 MySQL 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15？"></a><strong>一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 MySQL 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15？</strong></h3><ul>
<li>一般情况下，我们创建的表的类型是 InnoDB ，如果新增一条记录（不重启 MySQL 的情况下），这条记录的 ID 是18 ；但是如果重启 MySQL 的话，这条记录的 ID 是 15 。因为 InnoDB 表只把自增主键的最大 ID 记录到内存中，所以重启数据库或者对表 OPTIMIZE 操作，都会使最大 ID 丢失。</li>
<li>但是，如果我们使用表的类型是 MyISAM ，那么这条记录的 ID 就是 18 。因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里面，重启 MYSQL 后，自增主键的最大 ID 也不会丢失。</li>
</ul>
<p>最后，还可以跟面试官装个 x ，生产数据，不建议进行物理删除记录。</p>
<h3 id="表中有大字段-X-例如：text-类型-，且字段-X-不会经常更新，以读为为主，请问您是选择拆成子表，还是继续放一起-写出您这样选择的理由"><a href="#表中有大字段-X-例如：text-类型-，且字段-X-不会经常更新，以读为为主，请问您是选择拆成子表，还是继续放一起-写出您这样选择的理由" class="headerlink" title="表中有大字段 X(例如：text 类型)，且字段 X 不会经常更新，以读为为主，请问您是选择拆成子表，还是继续放一起?写出您这样选择的理由"></a><strong>表中有大字段 X(例如：text 类型)，且字段 X 不会经常更新，以读为为主，请问您是选择拆成子表，还是继续放一起?写出您这样选择的理由</strong></h3><ul>
<li><p>拆带来的问题：连接消耗 + 存储拆分空间。</p>
<blockquote>
<p>如果能容忍拆分带来的空间问题，拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序 IO ，减少连接消耗，最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗。</p>
</blockquote>
</li>
<li><p>不拆可能带来的问题：查询性能。</p>
<blockquote>
<p>如果能容忍不拆分带来的查询性能损失的话，上面的方案在某个极致条件下肯定会出现问题，那么不拆就是最好的选择。</p>
</blockquote>
</li>
</ul>
<p>实际场景下，例如说商品表数据量比较大的情况下，会将商品描述单独存储到一个表中。即，使用拆的方案。</p>
<h2 id="MySQL-有哪些存储引擎？"><a href="#MySQL-有哪些存储引擎？" class="headerlink" title="MySQL 有哪些存储引擎？"></a>MySQL 有哪些存储引擎？</h2><p>MySQL 提供了多种的存储引擎：</p>
<ul>
<li>InnoDB</li>
<li>MyISAM</li>
<li>MRG_MYISAM</li>
<li>MEMORY</li>
<li>CSV</li>
<li>ARCHIVE</li>
<li>BLACKHOLE</li>
<li>PERFORMANCE_SCHEMA</li>
<li>FEDERATED</li>
<li>…</li>
</ul>
<p>具体每种存储引擎的介绍，可以看看 <a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md">《数据库存储引擎》</a> 。</p>
<h3 id="如何选择合适的存储引擎？"><a href="#如何选择合适的存储引擎？" class="headerlink" title="如何选择合适的存储引擎？"></a><strong>如何选择合适的存储引擎？</strong></h3><p>提供几个选择标准，然后按照标准，选择对应的存储引擎即可，也可以根据 <a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E5%B8%B8%E7%94%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94">常用引擎对比</a> 来选择你使用的存储引擎。使用哪种引擎需要根据需求灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎，将会提高整个数据库的性能。</p>
<ol>
<li><p>是否需要支持事务。</p>
</li>
<li><p>对索引和缓存的支持。</p>
</li>
<li><p>是否需要使用热备。</p>
</li>
<li><p>崩溃恢复，能否接受崩溃。</p>
</li>
<li><p>存储的限制。</p>
</li>
<li><p>是否需要外键支持。</p>
<blockquote>
<p>目前开发已经不考虑外键，主要原因是性能。具体可以看看 <a href="http://www.justabug.net/think-in-mysql-foreign-key/">《从 MySQL 物理外键开始的思考》</a> 文章。</p>
</blockquote>
</li>
</ol>
<p>目前，MySQL 默认的存储引擎是 InnoDB ，并且也是最主流的选择。主要原因如下：</p>
<ul>
<li>【最重要】支持事务。</li>
<li>支持行级锁和表级锁，能支持更多的并发量。</li>
<li>查询不加锁，完全不影响查询。</li>
<li>支持崩溃后恢复。</li>
</ul>
<p>在 MySQL5.1 以及之前的版本，默认的存储引擎是 MyISAM ，但是目前已经不再更新，且它有几个比较关键的缺点：</p>
<ul>
<li>不支持事务。</li>
<li>使用表级锁，如果数据量大，一个插入操作锁定表后，其他请求都将阻塞。</li>
</ul>
<h3 id="请说明-InnoDB-和-MyISAM-的区别"><a href="#请说明-InnoDB-和-MyISAM-的区别" class="headerlink" title="请说明 InnoDB 和 MyISAM 的区别"></a><strong>请说明 InnoDB 和 MyISAM 的区别</strong></h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">InnoDB</th>
<th align="left">MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td align="left">事务</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">存储限制</td>
<td align="left">64TB</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">锁粒度</td>
<td align="left">行锁</td>
<td align="left">表锁</td>
</tr>
<tr>
<td align="left">崩溃后的恢复</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">外键</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">全文检索</td>
<td align="left">5.7 版本后支持</td>
<td align="left">支持</td>
</tr>
</tbody></table>
<h3 id="请说说-InnoDB-的-4-大特性"><a href="#请说说-InnoDB-的-4-大特性" class="headerlink" title="请说说 InnoDB 的 4 大特性"></a><strong>请说说 InnoDB 的 4 大特性</strong></h3><ul>
<li>插入缓冲(insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<h3 id="为什么-SELECT-COUNT-FROM-table-在-InnoDB-比-MyISAM-慢？"><a href="#为什么-SELECT-COUNT-FROM-table-在-InnoDB-比-MyISAM-慢？" class="headerlink" title="为什么 SELECT COUNT(*) FROM table 在 InnoDB 比 MyISAM 慢？"></a><strong>为什么 SELECT COUNT(*) FROM table 在 InnoDB 比 MyISAM 慢？</strong></h3><p>对于 <code>SELECT COUNT(*) FROM table</code> 语句，在没有 <code>WHERE</code> 条件的情况下，InnoDB 比 MyISAM 可能会慢很多，尤其在大表的情况下。因为，InnoDB 是去实时统计结果，会全表扫描；而 MyISAM 内部维持了一个计数器，预存了结果，所以直接返回即可。</p>
<p>详细的原因，胖友可以看看 <a href="https://blog.csdn.net/qq_15037231/article/details/81179383">《高性能 MySQL 之 Count 统计查询》</a> 博客。</p>
<h3 id="各种不同-MySQL-版本的-Innodb-的改进？-了解"><a href="#各种不同-MySQL-版本的-Innodb-的改进？-了解" class="headerlink" title="各种不同 MySQL 版本的 Innodb 的改进？(了解)"></a><strong>各种不同 MySQL 版本的 Innodb 的改进？(了解)</strong></h3><p>MySQL5.6 下 Innodb 引擎的主要改进：</p>
<ol>
<li>online DDL</li>
<li>memcached NoSQL 接口</li>
<li>transportable tablespace（ alter table discard&#x2F;import tablespace）</li>
<li>MySQL 正常关闭时，可以 dump 出 buffer pool 的（ space， page_no），重启时 reload，加快预热速度</li>
<li>索引和表的统计信息持久化到 mysql.innodb_table_stats 和 mysql.innodb_index_stats，可提供稳定的执行计划</li>
<li>Compressed row format 支持压缩表</li>
</ol>
<p>MySQL5.7 下 Innodb 引擎的主要改进：</p>
<ul>
<li><p>1、修改 varchar 字段长度有时可以使用</p>
<blockquote>
<p>这里的“有时”，指的是也有些限制。可见 <a href="https://yq.aliyun.com/articles/581726">《MySQL 5.7 online ddl 的一些改进》</a> 。</p>
</blockquote>
</li>
<li><p>2、Buffer pool 支持在线改变大小</p>
</li>
<li><p>3、Buffer pool 支持导出部分比例</p>
</li>
<li><p>4、支持新建 innodb tablespace，并可以在其中创建多张表</p>
</li>
<li><p>5、磁盘临时表采用 innodb 存储，并且存储在 innodb temp tablespace 里面，以前是 MyISAM 存储</p>
</li>
<li><p>6、透明表空间压缩功能</p>
</li>
</ul>
<h2 id="【重点】什么是索引？"><a href="#【重点】什么是索引？" class="headerlink" title="【重点】什么是索引？"></a>【重点】什么是索引？</h2><p>索引，类似于书籍的目录，想找到一本书的某个特定的主题，需要先找到书的目录，定位对应的页码。</p>
<p>MySQL 中存储引擎使用类似的方式进行查询，先去索引中查找对应的值，然后根据匹配的索引找到对应的数据行。</p>
<h3 id="索引有什么好处？"><a href="#索引有什么好处？" class="headerlink" title="索引有什么好处？"></a><strong>索引有什么好处？</strong></h3><ol>
<li>提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。</li>
<li>降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则正好降低了排序的成本。</li>
</ol>
<h3 id="索引有什么坏处？"><a href="#索引有什么坏处？" class="headerlink" title="索引有什么坏处？"></a><strong>索引有什么坏处？</strong></h3><ol>
<li>占用存储空间：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。</li>
<li>降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更，从而减低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。</li>
</ol>
<h3 id="索引的使用场景？"><a href="#索引的使用场景？" class="headerlink" title="索引的使用场景？"></a><strong>索引的使用场景？</strong></h3><ul>
<li><p>1、对非常小的表，大部分情况下全表扫描效率更高。</p>
</li>
<li><p>2、对中大型表，索引非常有效。</p>
</li>
<li><p>3、特大型的表，建立和使用索引的代价随着增长，可以使用分区技术来解决。</p>
<blockquote>
<p>实际场景下，MySQL 分区表很少使用，原因可以看看 <a href="https://blog.csdn.net/admin1973/article/details/55504018">《互联网公司为啥不使用 MySQL 分区表？》</a> 文章。</p>
<p>对于特大型的表，更常用的是“分库分表”，目前解决方案有 Sharding Sphere、MyCAT 等等。</p>
</blockquote>
</li>
</ul>
<h3 id="索引的类型？"><a href="#索引的类型？" class="headerlink" title="索引的类型？"></a><strong>索引的类型？</strong></h3><p>索引，都是实现在存储引擎层的。主要有六种类型：</p>
<ul>
<li><p>1、普通索引：最基本的索引，没有任何约束。</p>
</li>
<li><p>2、唯一索引：与普通索引类似，但具有唯一性约束。</p>
</li>
<li><p>3、主键索引：特殊的唯一索引，不允许有空值。</p>
</li>
<li><p>4、复合索引：将多个列组合在一起创建索引，可以覆盖多个列。</p>
</li>
<li><p>5、外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。</p>
</li>
<li><p>6、全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎。</p>
<blockquote>
<p>常用的全文索引引擎的解决方案有 Elasticsearch、Solr 等等。最为常用的是 Elasticsearch 。</p>
</blockquote>
</li>
</ul>
<p>具体的使用，可以看看 <a href="http://blog.720ui.com/2017/mysql_core_03_how_use_index/">《服务端指南 数据存储篇 | MySQL（03） 如何设计索引》</a> 。</p>
<h3 id="MySQL-索引的“创建”原则？"><a href="#MySQL-索引的“创建”原则？" class="headerlink" title="MySQL 索引的“创建”原则？"></a><strong>MySQL 索引的“创建”原则？</strong></h3><ul>
<li><p>1、最适合索引的列是出现在 <code>WHERE</code> 子句中的列，或连接子句中的列，而不是出现在 <code>SELECT</code> 关键字后的列。</p>
</li>
<li><p>2、索引列的基数越大，索引效果越好。</p>
<blockquote>
<p>具体为什么，可以看看如下两篇文章：</p>
<ul>
<li><a href="https://blog.csdn.net/mingyundezuoan/article/details/79038989">《MySQL 索引基数》</a> 理解相对简单</li>
<li><a href="https://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1309cardinal/index.html">《低基数索引为什么会对性能产生负面影响》</a> 写的更原理，所以较为难懂。</li>
</ul>
</blockquote>
</li>
<li><p>3、根据情况创建复合索引，复合索引可以提高查询效率。</p>
<blockquote>
<p>因为复合索引的基数会更大。</p>
</blockquote>
</li>
<li><p>4、避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率。</p>
</li>
<li><p>5、主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用提高查询效率。</p>
</li>
<li><p>6、对字符串进行索引，应该定制一个前缀长度，可以节省大量的索引空间。</p>
</li>
</ul>
<h3 id="MySQL-索引的“使用”注意事项？"><a href="#MySQL-索引的“使用”注意事项？" class="headerlink" title="MySQL 索引的“使用”注意事项？"></a><strong>MySQL 索引的“使用”注意事项？</strong></h3><ul>
<li><p>1、应尽量避免在 <code>WHERE</code> 子句中使用 <code>!=</code> 或 <code>&lt;&gt;</code> 操作符，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。</p>
<blockquote>
<p>注意，<code>column IS NULL</code> 也是不可以使用索引的。</p>
</blockquote>
</li>
<li><p>2、应尽量避免在 <code>WHERE</code> 子句中使用 <code>OR</code> 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：<code>SELECT id FROM t WHERE num = 10 OR num = 20</code> 。</p>
</li>
<li><p>3、应尽量避免在 <code>WHERE</code> 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</p>
</li>
<li><p>4、应尽量避免在 <code>WHERE</code> 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</p>
</li>
<li><p>5、不要在 <code>WHERE</code> 子句中的 <code>=</code> 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
<li><p>6、复合索引遵循前缀原则。</p>
</li>
<li><p>7、如果 MySQL 评估使用索引比全表扫描更慢，会放弃使用索引。如果此时想要索引，可以在语句中添加强制索引。</p>
</li>
<li><p>8、列类型是字符串类型，查询时一定要给值加引号，否则索引失效。</p>
</li>
<li><p>9、<code>LIKE</code>查询，<code>%</code>不能在前，因为无法使用索引。如果需要模糊匹配，可以使用全文索引。</p>
</li>
</ul>
<p>关于这块，可以看看 <a href="http://blog.720ui.com/2017/mysql_core_04_index_item/">《服务端指南 数据存储篇 | MySQL（04） 索引使用的注意事项》</a> 文章，写的更加细致。</p>
<h3 id="以下三条-SQL-如何建索引，只建一条怎么建？"><a href="#以下三条-SQL-如何建索引，只建一条怎么建？" class="headerlink" title="以下三条 SQL 如何建索引，只建一条怎么建？"></a><strong>以下三条 SQL 如何建索引，只建一条怎么建？</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE a = 1 AND b = 1</span><br><span class="line">WHERE b = 1</span><br><span class="line">WHERE b = 1 ORDER BY time DESC</span><br></pre></td></tr></table></figure>

<ul>
<li>以顺序 b , a, time 建立复合索引，<code>CREATE INDEX table1_b_a_time ON index_test01(b, a, time)</code>。</li>
<li>对于第一条 SQL ，因为最新 MySQL 版本会优化 <code>WHERE</code> 子句后面的列顺序，以匹配复合索引顺序。</li>
</ul>
<h3 id="想知道一个查询用到了哪个索引，如何查看"><a href="#想知道一个查询用到了哪个索引，如何查看" class="headerlink" title="想知道一个查询用到了哪个索引，如何查看?"></a><strong>想知道一个查询用到了哪个索引，如何查看?</strong></h3><p><code>EXPLAIN</code> 显示了 MYSQL 如何使用索引来处理 SELECT 语句以及连接表,可以帮助选择更好的索引和写出更优化的查询语句。</p>
<p>使用方法，在 <code>SELECT</code> 语句前加上 <code>EXPLAIN</code> 就可以了。感兴趣的胖友，可以详细看看 <a href="http://www.jfox.info/2017/mysql-explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A.html">《MySQL explain 执行计划详细解释》</a> 。</p>
<h2 id="【重点】MySQL-索引的原理？"><a href="#【重点】MySQL-索引的原理？" class="headerlink" title="【重点】MySQL 索引的原理？"></a>【重点】MySQL 索引的原理？</h2><p>解释 MySQL 索引的原理，篇幅会比较长，并且网络上已经有靠谱的资料可以看，所以艿艿这里整理了几篇，胖友可以对照着看。</p>
<ul>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">《MySQL索引背后的数据结构及算法原理》</a></li>
<li><a href="https://blog.csdn.net/u013235478/article/details/50625677">《MySQL 索引原理》</a></li>
<li><a href="https://blog.csdn.net/tongdanping/article/details/79878302">《深入理解 MySQL 索引原理和实现 —— 为什么索引可以加速查询？》</a></li>
</ul>
<h3 id="MySQL-有哪些索引方法？"><a href="#MySQL-有哪些索引方法？" class="headerlink" title="MySQL 有哪些索引方法？"></a><strong>MySQL 有哪些索引方法？</strong></h3><blockquote>
<p>艿艿：这个问题是索引方法 Index Method ，上面的索引类型 Index Type 。</p>
</blockquote>
<p>在 MySQL 中，我们可以看到两种索引方式：</p>
<ul>
<li>B-Tree 索引。</li>
<li>Hash 索引。</li>
</ul>
<p>实际场景下，我们基本仅仅使用 B-Tree 索引。详细的对比可以看看 <a href="https://blog.csdn.net/oChangWen/article/details/54024063">《MySQL BTree 索引和 hash 索引的区别》</a> 。</p>
<p>对于 Hash 索引，我们了解即可，面试重点是掌握 B-Tree 索引的原理。</p>
<p><strong>什么是 B-Tree 索引？</strong></p>
<p>B-Tree 是为磁盘等外存储设备设计的一种平衡查找树。因此在讲 B-Tree 之前先了解下磁盘的相关知识。</p>
<ul>
<li><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
</li>
<li><p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16 KB，可通过参数 innodb_page_size 将页的大小设置为 4K、8K、16K ，在 MySQL 中可通过如下命令查看页的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_page_size&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB 。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I&#x2F;O 次数，提高查询效率。</p>
</li>
</ul>
<p>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组 [key, data] ，key 为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p>
<p>一棵 m 阶的 B-Tree 有如下特性：</p>
<ol>
<li>每个节点最多有 m 个孩子。<ul>
<li>除了根节点和叶子节点外，其它每个节点至少有 Ceil(m&#x2F;2) 个孩子。</li>
<li>若根节点不是叶子节点，则至少有 2 个孩子。</li>
</ul>
</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息。</li>
<li>每个非叶子节点包含 n 个关键字信息（P0,P1,…Pn, k1,…kn）<ul>
<li>关键字的个数 n 满足：ceil(m&#x2F;2)-1 &lt;&#x3D; n &lt;&#x3D; m-1</li>
<li>ki(i&#x3D;1,…n) 为关键字，且关键字升序排序。</li>
<li>Pi(i&#x3D;0,…n) 为指向子树根节点的指针。P(i-1) 指向的子树的所有节点关键字均小于 ki ，但都大于 k(i-1) 。</li>
</ul>
</li>
</ol>
<p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/B-Tree%E7%BB%93%E6%9E%84.png" alt="B-Tree结构"></p>
<ul>
<li>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的 key 和三个指向子树根节点的 point ，point 存储的是子节点所在磁盘块的地址。两个 key 划分成的三个范围域，对应三个 point 指向的子树的数据的范围域。</li>
<li>以根节点为例，key 为 17 和 35 ，P1 指针指向的子树的数据范围为小于 17 ，P2 指针指向的子树的数据范围为 [17~35] ，P3 指针指向的子树的数据范围为大于 35 。</li>
</ul>
<p>模拟查找 key 为 29 的过程：</p>
<ul>
<li>1、根据根节点找到磁盘块 1 ，读入内存。【磁盘I&#x2F;O操作第1次】</li>
<li>2、比较 key 29 在区间（17,35），找到磁盘块 1 的指针 P2 。</li>
<li>3、根据 P2 指针找到磁盘块 3 ，读入内存。【磁盘I&#x2F;O操作第2次】</li>
<li>4、比较 key 29 在区间（26,30），找到磁盘块3的指针P2。</li>
<li>5、根据 P2 指针找到磁盘块 8 ，读入内存。【磁盘I&#x2F;O操作第3次】</li>
<li>6、在磁盘块 8 中的 key 列表中找到 key 29 。</li>
</ul>
<p>分析上面过程，发现需要 3 次磁盘 I&#x2F;O 操作，和 3 次内存查找操作。由于内存中的 key 是一个有序表结构，可以利用二分法查找提高效率。而 3 次磁盘 I&#x2F;O 操作是影响整个 B-Tree 查找效率的决定因素。B-Tree 相对于 AVLTree 缩减了节点个数，使每次磁盘 I&#x2F;O 取到内存的数据都发挥了作用，从而提高了查询效率。</p>
<h3 id="什么是-B-Tree-索引？"><a href="#什么是-B-Tree-索引？" class="headerlink" title="什么是 B+Tree 索引？"></a><strong>什么是 B+Tree 索引？</strong></h3><p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用 B+Tree 实现其索引结构。</p>
<blockquote>
<p>下面这一段，面试非常关键。</p>
</blockquote>
<p>从上一节中的 B-Tree 结构图中可以看到，每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I&#x2F;O 次数，进而影响查询效率。在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。</p>
<p>B+Tree 相对于 B-Tree 有几点不同：</p>
<ul>
<li>非叶子节点只存储键值信息。</li>
<li>所有叶子节点之间都有一个链指针。</li>
<li>数据记录都存放在叶子节点中。</li>
</ul>
<p>将上一节中的 B-Tree 优化，由于 B+Tree 的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 B+Tree 后其结构如下图所示：</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/B+Tree%E7%BB%93%E6%9E%84.png" alt="B+Tree结构"></p>
<ul>
<li>通常在 B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对 B+Tree 进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</li>
</ul>
<p>可能上面例子中只有 22 条数据记录，看不出 B+Tree 的优点，下面做一个推算：</p>
<ul>
<li>InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用4个字节） 或 BIGINT（占用8个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 16KB&#x2F;(8B+8B)&#x3D;1K 个键值（因为是估值，为方便计算，这里的 K 取值为〖10〗^3）。也就是说一个深度为 3 的 B+Tree 索引可以维护10^3 <em>10^3</em> 10^3 &#x3D; 10亿 条记录。</li>
<li>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2<del>4 层。MySQL 的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1</del>3 次磁盘 I&#x2F;O 操作。</li>
</ul>
<h3 id="B-Tree-有哪些索引类型？"><a href="#B-Tree-有哪些索引类型？" class="headerlink" title="B-Tree 有哪些索引类型？"></a><strong>B-Tree 有哪些索引类型？</strong></h3><p>在 B+Tree 中，根据叶子节点的内容，索引类型分为<strong>主键索引</strong>和<strong>非主键索引</strong>。</p>
<blockquote>
<p>注意，这里的索引类型，和上面的索引类型，还是对的上的噢。</p>
</blockquote>
<ul>
<li><p>主键索引的叶子节点存的数据是整行数据( 即具体数据 )。在 InnoDB 里，主键索引也被称为<strong>聚集索引</strong>（clustered index）。</p>
</li>
<li><p>非主键索引的叶子节点存的数据是整行数据的主键，键值是索引。在 InnoDB 里，非主键索引也被称为</p>
<p>辅助索引</p>
<p>（secondary index）。</p>
<blockquote>
<p>二级索引的叶节点存储的是主键值，而不是行指针，这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</p>
</blockquote>
</li>
</ul>
<p>辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，需要进过两步：</p>
<ul>
<li>首先，InnoDB 存储引擎会遍历辅助索引找到主键。</li>
<li>然后，再通过主键在聚集索引中找到完整的行记录数据。</li>
</ul>
<p>另外，InnoDB 通过主键聚簇数据，如果没有定义主键，会选择一个唯一的非空索引代替，如果没有这样的索引，会隐式定义个主键作为聚簇索引。</p>
<p>再另外，可能有胖友有和艿艿的一样疑惑，在<strong>辅助索引</strong>如果相同的索引怎么存储？最终存储到 B+Tree 非子节点中时，它们对应的主键 ID 是不同的，所以妥妥的。</p>
<h3 id="聚簇索引的注意点有哪些？"><a href="#聚簇索引的注意点有哪些？" class="headerlink" title="聚簇索引的注意点有哪些？"></a><strong>聚簇索引的注意点有哪些？</strong></h3><p>聚簇索引表最大限度地提高了 I&#x2F;O 密集型应用的性能，但它也有以下几个限制：</p>
<ul>
<li><p>1、插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。</p>
<blockquote>
<p>关于这一点，可能面试官会换一个问法。例如，为什么主键需要是自增 ID ，又或者为什么主键需要带有时间性关联。</p>
</blockquote>
</li>
<li><p>2、更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB 表，我们一般定义主键为不可更新。</p>
<blockquote>
<p>MySQL 默认情况下，主键是允许更新的。对于 MongoDB ，其 主键是不允许更新的。</p>
</blockquote>
</li>
<li><p>3、二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
<blockquote>
<p>当然，有一种情况可以无需二次查找，基于非主键索引查询，但是查询字段只有主键 ID ，那么在二级索引中就可以查找到。</p>
</blockquote>
</li>
<li><p>4、主键 ID 建议使用整型。因为，每个主键索引的 B+Tree 节点的键值可以存储更多主键 ID ，每个非主键索引的 B+Tree 节点的数据可以存储更多主键 ID 。</p>
</li>
</ul>
<h3 id="什么是索引的最左匹配特性？"><a href="#什么是索引的最左匹配特性？" class="headerlink" title="什么是索引的最左匹配特性？"></a><strong>什么是索引的最左匹配特性？</strong></h3><p>当 B+Tree 的数据项是复合的数据结构，比如索引 <code>(name, age, sex)</code> 的时候，B+Tree 是按照从左到右的顺序来建立搜索树的。</p>
<ul>
<li>比如当 <code>(张三, 20, F)</code> 这样的数据来检索的时候，B+Tree 会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex ，最后得到检索的数据。</li>
<li>但当 <code>(20, F)</code> 这样的没有 name 的数据来的时候，B+Tree 就不知道下一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。</li>
<li>比如当 <code>(张三, F)</code> 这样的数据来检索时，B+Tree 可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了。</li>
</ul>
<p>这个是非常重要的性质，即索引的最左匹配特性。</p>
<h2 id="【重点】请说说-MySQL-的四种事务隔离级别？"><a href="#【重点】请说说-MySQL-的四种事务隔离级别？" class="headerlink" title="【重点】请说说 MySQL 的四种事务隔离级别？"></a>【重点】请说说 MySQL 的四种事务隔离级别？</h2><p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。</p>
<p>这样可以防止出现脏数据，防止数据库数据出现问题。</p>
<h3 id="事务的特性指的是？"><a href="#事务的特性指的是？" class="headerlink" title="事务的特性指的是？"></a><strong>事务的特性指的是？</strong></h3><ol>
<li><strong>原子性</strong> Atomicity ：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li><strong>一致性</strong> Consistency ：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">约束</a>、<a href="https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93)">触发器</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A&action=edit&redlink=1">级联回滚</a>等。</li>
<li><strong>隔离性</strong> Isolation ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性</strong> Durability ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ol>
<h3 id="事务的并发问题？"><a href="#事务的并发问题？" class="headerlink" title="事务的并发问题？"></a><strong>事务的并发问题？</strong></h3><p>实际场景下，事务并不是串行的，所以会带来如下三个问题：</p>
<ul>
<li>1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。</li>
<li>2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。</li>
<li>3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>
</ul>
<p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p>
<h3 id="MySQL-事务隔离级别会产生的并发问题？"><a href="#MySQL-事务隔离级别会产生的并发问题？" class="headerlink" title="MySQL 事务隔离级别会产生的并发问题？"></a><strong>MySQL 事务隔离级别会产生的并发问题？</strong></h3><p>事务定义了四种事务隔离级别，不同数据库在实现时，产生的并发问题是不同的。</p>
<blockquote>
<p>不同的隔离级别有不同的现象，并有不同的锁定&#x2F;并发机制，隔离级别越高，数据库的并发性就越差。</p>
</blockquote>
<ul>
<li><p>READ UNCOMMITTED（未提交读）：事务中的修改，即使没有提交，对其他事务也都是可见的。</p>
<blockquote>
<p>会导致脏读。</p>
</blockquote>
</li>
<li><p>READ COMMITTED（提交读）：事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。</p>
<blockquote>
<p>会导致不可重复读。</p>
<p>这个隔离级别，也可以叫做“不可重复读”。</p>
</blockquote>
</li>
<li><p>REPEATABLE READ（可重复读）：一个事务按相同的查询条件读取以前检索过的数据，其他事务插入了满足其查询条件的新数据。产生幻行。</p>
<blockquote>
<p>会导致幻读。</p>
</blockquote>
</li>
<li><p>SERIALIZABLE（可串行化）：强制事务串行执行。</p>
</li>
</ul>
<p>MySQL InnoDB 采用 <strong>MVCC</strong> 来支持高并发，实现结果如下表所示：</p>
<blockquote>
<p>关于 Oracle 和 PostgreSQL ，需要胖友自己去搜索资料。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">事务隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读未提交（read-uncommitted）</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">读已提交（read-committed）</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">可重复读（repeatable-read）</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">是（x）</td>
</tr>
<tr>
<td align="left">串行化（serializable）</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
</tbody></table>
<ul>
<li><p>MySQL 默认的事务隔离级别为可重复读（repeatable-read） 。</p>
</li>
<li><p>上图的 <code>&lt;X&gt;</code> 处，<strong>MySQL 通过 MVCC + 事务第一次调用 <code>SELECT</code> 语句才生成快照，实现其在可重复读（repeatable-read）的隔离级别下，不存在幻读问题。</strong>也就是说，上图 <code>&lt;X&gt;</code> 处，需要改成“否”！！！！想要进一步了解的，可以看看 <a href="https://blog.csdn.net/cxm19881208/article/details/79415726">《MySQL InnoDB 事务 —— 一致性读(快照读)》</a>、<a href="https://blog.csdn.net/z69183787/article/details/81709743">《MYSQL 当前读和快照读》</a>、<a href="https://www.cnblogs.com/wwcom123/p/10727194.html">《【MySQL】当前读、快照读、MVCC》</a> 文章。</p>
<blockquote>
<p>艿艿：实际上，艿艿在看完上述几篇文章，仿佛理解了，仿佛又有一点懵逼。后来在看完丁奇老师的 <a href="http://www.iocoder.cn/images/jikeshijian/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2.jpg">《MySQL 实战 45 讲》</a> 的「08 | 事务到底是隔离的还是不隔离的？」后，稳了，通透了。</p>
</blockquote>
</li>
<li><p>😈 记住这个表的方式，我们会发现它是自左上向右下是一个对角线。当然，最好是去理解。</p>
</li>
<li><p>具体的实验，胖友可以看看 <a href="https://www.cnblogs.com/huanongying/p/7021555.html">《MySQL 的四种事务隔离级别》</a> 。</p>
</li>
<li><p>有些资料说可重复读解决了幻读，实际是存在的，可以通过 <code>SELECT xxx FROM t WHERE id = ? FOR UPDATE</code> 的方式，获得到悲观锁，禁止其它事务操作对应的数据，从而解决幻读问题。感兴趣的胖友，可以看看如下文章：</p>
<ul>
<li><p>必读 <a href="https://segmentfault.com/a/1190000016566788">《MySQL 幻读的详解、实例及解决办法》</a> 案例性更强，易懂。</p>
<blockquote>
<p>其实 RR 也是可以避免幻读的，通过对 select 操作手动加 行X锁（SELECT … FOR UPDATE 这也正是 SERIALIZABLE 隔离级别下会隐式为你做的事情），同时还需要知道，即便当前记录不存在，比如 id &#x3D; 1 是不存在的，当前事务也会获得一把记录锁（因为InnoDB的行锁锁定的是索引，故记录实体存在与否没关系，存在就加 行X锁，不存在就加 next-key lock间隙X锁），其他事务则无法插入此索引的记录，故杜绝了幻读。</p>
</blockquote>
</li>
<li><p>选读 <a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html">《MySQL 的 InnoDB 的幻读问题》</a> 原理性更强，读懂会很爽。</p>
</li>
<li><p>随意 <a href="https://github.com/Yhzhtk/note/issues/42">《Innodb 中 RR 隔离级别能否防止幻读？》</a> 一个简单的讨论。</p>
</li>
</ul>
</li>
</ul>
<h2 id="【重点】请说说-MySQL-的锁机制？"><a href="#【重点】请说说-MySQL-的锁机制？" class="headerlink" title="【重点】请说说 MySQL 的锁机制？"></a>【重点】请说说 MySQL 的锁机制？</h2><p>表锁是日常开发中的常见问题，因此也是面试当中最常见的考察点，当多个查询同一时刻进行数据修改时，就会产生并发控制的问题。MySQL 的共享锁和排他锁，就是读锁和写锁。</p>
<ul>
<li>共享锁：不堵塞，多个用户可以同时读一个资源，互不干扰。</li>
<li>排他锁：一个写锁会阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他用户读取正在写入的资源。</li>
</ul>
<h3 id="锁的粒度？"><a href="#锁的粒度？" class="headerlink" title="锁的粒度？"></a><strong>锁的粒度？</strong></h3><ul>
<li>表锁：系统开销最小，会锁定整张表，MyIsam 使用表锁。</li>
<li>行锁：最大程度的支持并发处理，但是也带来了最大的锁开销，InnoDB 使用行锁。</li>
</ul>
<h3 id="什么是悲观锁？什么是乐观锁？"><a href="#什么是悲观锁？什么是乐观锁？" class="headerlink" title="什么是悲观锁？什么是乐观锁？"></a><strong>什么是悲观锁？什么是乐观锁？</strong></h3><p>1）悲观锁</p>
<p>它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p>
<blockquote>
<p>艿艿：悲观锁，就是我们上面看到的共享锁和排他锁。</p>
</blockquote>
<p>2）乐观锁</p>
<p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p>
<p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<blockquote>
<p>艿艿：乐观锁，实际就是通过版本号，从而实现 CAS 原子性更新。</p>
</blockquote>
<h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a><strong>什么是死锁？</strong></h3><p>多数情况下，可以认为如果一个资源被锁定，它总会在以后某个时间被释放。而死锁发生在当多个进程访问同一数据库时，其中每个进程拥有的锁都是其他进程所需的，由此造成每个进程都无法继续下去。简单的说，进程 A 等待进程 B 释放他的资源，B 又等待 A 释放他的资源，这样就互相等待就形成死锁。</p>
<p>虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件：</p>
<ul>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合 {P0，P1，P2，•••，Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。</li>
</ul>
<p>下列方法有助于最大限度地降低死锁：</p>
<ul>
<li><p>设置获得锁的超时时间。</p>
<blockquote>
<p>通过超时，至少保证最差最差最差情况下，可以有退出的口子。</p>
</blockquote>
</li>
<li><p>按同一顺序访问对象。</p>
<blockquote>
<p>这个是最重要的方式。</p>
</blockquote>
</li>
<li><p>避免事务中的用户交互。</p>
</li>
<li><p>保持事务简短并在一个批处理中。</p>
</li>
<li><p>使用低隔离级别。</p>
</li>
<li><p>使用绑定连接。</p>
</li>
</ul>
<h3 id="MySQL-中-InnoDB-引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？？"><a href="#MySQL-中-InnoDB-引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？？" class="headerlink" title="MySQL 中 InnoDB 引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？？"></a><strong>MySQL 中 InnoDB 引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？？</strong></h3><p>InnoDB 是基于索引来完成行锁。例如：<code>SELECT * FROM tab_with_index WHERE id = 1 FOR UPDATE</code> 。</p>
<ul>
<li><code>FOR UPDATE</code> 可以根据条件来完成<strong>行锁</strong>锁定，并且 id 是有索引键的列,如果 id 不是索引键那么 InnoDB 将完成<strong>表锁</strong>，并发将无从谈起。</li>
</ul>
<h2 id="【重要】MySQL-查询执行顺序？"><a href="#【重要】MySQL-查询执行顺序？" class="headerlink" title="【重要】MySQL 查询执行顺序？"></a>【重要】MySQL 查询执行顺序？</h2><p>MySQL 查询执行的顺序是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)     SELECT</span><br><span class="line">(2)     DISTINCT &lt;select_list&gt;</span><br><span class="line">(3)     FROM &lt;left_table&gt;</span><br><span class="line">(4)     &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">(5)     ON &lt;join_condition&gt;</span><br><span class="line">(6)     WHERE &lt;where_condition&gt;</span><br><span class="line">(7)     GROUP BY &lt;group_by_list&gt;</span><br><span class="line">(8)     HAVING &lt;having_condition&gt;</span><br><span class="line">(9)     ORDER BY &lt;order_by_condition&gt;</span><br><span class="line">(10)    LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<p>具体的，可以看看 <a href="http://zouzls.github.io/2017/03/23/SQL%E6%9F%A5%E8%AF%A2%E4%B9%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E8%A7%A3%E6%9E%90/">《SQL 查询之执行顺序解析》</a> 文章。</p>
<h2 id="【重要】聊聊-MySQL-SQL-优化？"><a href="#【重要】聊聊-MySQL-SQL-优化？" class="headerlink" title="【重要】聊聊 MySQL SQL 优化？"></a>【重要】聊聊 MySQL SQL 优化？</h2><p>可以看看如下几篇文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/ab958a4823d1">《PHP 面试之 MySQL 查询优化》</a></li>
<li><a href="https://blog.csdn.net/DERRANTCM/article/details/51534411">《【面试】【MySQL常见问题总结】【03】》</a> 第 078、095、105 题</li>
</ul>
<p>另外，除了从 SQL 层面进行优化，也可以从服务器硬件层面，进一步优化 MySQL 。具体可以看看 <a href="https://blog.csdn.net/bemavery/article/details/46241533">《MySQL 数据库性能优化之硬件优化》</a> 。</p>
<h2 id="【加分】什么是-MVCC-？"><a href="#【加分】什么是-MVCC-？" class="headerlink" title="【加分】什么是 MVCC ？"></a>【加分】什么是 MVCC ？</h2><p>多版本并发控制（MVCC），是一种用来<strong>解决读-写冲突</strong>的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。</p>
<p>推荐可以看看如下资料：</p>
<ul>
<li><p>沈询 <a href="https://www.imooc.com/learn/272">《在线分布式数据库原理与实践》</a></p>
<blockquote>
<p>一共 1 小时 53 分钟，有趣，牛逼，强烈推荐！！！</p>
</blockquote>
</li>
<li><p>钟延辉</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/sOxLZlXRYR-zZKStE7qAwg">《分布式数据库 MVCC 技术探秘 (1)》</a></li>
<li><a href="https://mp.weixin.qq.com/s/8lX3Gyq4J5vLHETtG01EdA">《分布式数据库 MVCC 技术探秘(2): 混合逻辑时钟》</a></li>
</ul>
</li>
</ul>
<h2 id="编写-SQL-查询语句的考题合集"><a href="#编写-SQL-查询语句的考题合集" class="headerlink" title="编写 SQL 查询语句的考题合集"></a>编写 SQL 查询语句的考题合集</h2><p>因为考题比较多，艿艿就不一一列举，瞄了一些还不错的文章，如下：</p>
<ul>
<li><a href="https://www.yanxurui.cc/posts/mysql/2016-11-10-10-sql-interview-questions/">《10 道 MySQL 查询语句面试题》</a></li>
<li><a href="https://www.cnblogs.com/geaozhang/p/6839297.html">《MySQL 开发面试题》</a></li>
<li><a href="https://juejin.im/entry/5b57ebdcf265da0f61320e6f">《企业面试题｜最常问的 MySQL 面试题集合（二）》</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-开篇</title>
    <url>/2022/05/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<p><img src="/../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81.png" alt="编写高质量代码"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-建造者模式</title>
    <url>/2022/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p>
<ul>
<li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li>
<li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li>
<li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。</li>
</ul>
<p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p>
<span id="more"></span>

<h1 id="ConstructorArg使用创建者模式重构"><a href="#ConstructorArg使用创建者模式重构" class="headerlink" title="ConstructorArg使用创建者模式重构"></a><code>ConstructorArg</code>使用创建者模式重构</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> Scope.SINGLETON;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">lazyInit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClassName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;ConstructorArg&gt; <span class="title function_">getConstructorArgs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> constructorArgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConstructorArgs</span><span class="params">(List&lt;ConstructorArg&gt; constructorArgs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.constructorArgs = constructorArgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Scope <span class="title function_">getScope</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScope</span><span class="params">(Scope scope)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.scope = scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLazyInit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lazyInit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLazyInit</span><span class="params">(<span class="type">boolean</span> lazyInit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lazyInit = lazyInit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getScope().equals(Scope.SINGLETON);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Scope</span> &#123;</span><br><span class="line">        SINGLETON,</span><br><span class="line">        PROTOTYPE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConstructorArg</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isRef</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">private</span> Class type;</span><br><span class="line">        <span class="keyword">private</span> Object arg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRef</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isRef;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Class <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getArg</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> arg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">ConstructorArg</span><span class="params">(<span class="type">boolean</span> isRef, Class type, Object arg)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.isRef = isRef;</span><br><span class="line">            <span class="built_in">this</span>.type = type;</span><br><span class="line">            <span class="built_in">this</span>.arg = arg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">private</span> Class type;</span><br><span class="line">            <span class="keyword">private</span> Object arg;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> ConstructorArg <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ref &amp;&amp; type != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;bean为ref类型时type不需要设置&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!ref &amp;&amp; (type == <span class="literal">null</span> || arg == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;bean不为ref类型时type和arg必须填写&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstructorArg</span>(ref, type, arg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> Builder <span class="title function_">setRef</span><span class="params">(<span class="type">boolean</span> ref)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.ref = ref;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> Builder <span class="title function_">setType</span><span class="params">(Class type)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.type = type;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> Builder <span class="title function_">setArg</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.arg = arg;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// parse方法也需要更改</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;BeanDefinition&gt; <span class="title function_">parse</span><span class="params">(InputStream inputStream)</span> &#123;</span><br><span class="line">        List&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> reader.read(inputStream);<span class="comment">// 获取根节点</span></span><br><span class="line">            <span class="type">Element</span> <span class="variable">beans</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">            <span class="comment">// 获取迭代器</span></span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">beanIt</span> <span class="operator">=</span> beans.elementIterator();</span><br><span class="line">            <span class="comment">// 遍历迭代器，获取根节点信息</span></span><br><span class="line">            <span class="keyword">while</span>(beanIt.hasNext())&#123;</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>();</span><br><span class="line">                <span class="type">Element</span> <span class="variable">bean</span> <span class="operator">=</span> (Element) beanIt.next();</span><br><span class="line"></span><br><span class="line">                List&lt;Attribute&gt; attributes = bean.attributes();</span><br><span class="line">                <span class="comment">// 获取bean属性名和属性值</span></span><br><span class="line">                <span class="keyword">for</span> (Attribute attribute : attributes) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;id&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                        beanDefinition.setId(attribute.getValue());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;class&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                        beanDefinition.setClassName(attribute.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Iterator</span> <span class="variable">argsIt</span> <span class="operator">=</span> bean.elementIterator();</span><br><span class="line">                List&lt;BeanDefinition.ConstructorArg&gt; constructorArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span>(argsIt.hasNext())&#123;</span><br><span class="line">                    BeanDefinition.ConstructorArg.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>.ConstructorArg.Builder();</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">arg</span> <span class="operator">=</span> (Element) argsIt.next();</span><br><span class="line">                    List&lt;Attribute&gt; argAttributes = arg.attributes();</span><br><span class="line">                    <span class="comment">// 获取bean属性名和属性值</span></span><br><span class="line">                    <span class="keyword">for</span> (Attribute attribute : argAttributes) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;type&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                builder.setType(Class.forName(attribute.getValue()));</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                            builder.setArg(arg.getText());</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;ref&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                            builder.setRef(<span class="literal">true</span>);</span><br><span class="line">                            builder.setArg(attribute.getValue());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    constructorArgs.add(builder.build());</span><br><span class="line">                    beanDefinition.setConstructorArgs(constructorArgs);</span><br><span class="line">                &#125;</span><br><span class="line">                beanDefinitions.add(beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码学习笔记</title>
    <url>/2021/03/25/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Spring源码学习笔记"><a href="#Spring源码学习笔记" class="headerlink" title="Spring源码学习笔记"></a>Spring源码学习笔记</h1><h2 id="Spring-IoC介绍"><a href="#Spring-IoC介绍" class="headerlink" title="Spring IoC介绍"></a>Spring IoC介绍</h2><p>IoC 全称为 <code>Inversion of Control</code>，翻译为 “控制反转”，它还有一个别名为 DI（<code>Dependency Injection</code>）,即依赖注入。</p>
<blockquote>
<p><strong>所谓 IoC ，就是由 Spring IoC 容器来负责对象的生命周期和对象之间的关系</strong></p>
</blockquote>
<ol>
<li><strong>谁控制谁</strong>：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IoC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象</li>
<li><strong>控制什么</strong>：控制对象。</li>
<li><strong>为何是反转</strong>：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li>
<li><strong>哪些方面反转了</strong>：所依赖对象的获取被反转了。</li>
</ol>
<span id="more"></span>

<h2 id="调试环境搭建"><a href="#调试环境搭建" class="headerlink" title="调试环境搭建"></a>调试环境搭建</h2><h3 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h3><ul>
<li>Gradle</li>
<li>Git</li>
<li>JDK1.8+</li>
<li>IntelliJ IDEA</li>
</ul>
<h3 id="源码拉取"><a href="#源码拉取" class="headerlink" title="源码拉取"></a>源码拉取</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/spring-projects/spring-framework.git</span><br></pre></td></tr></table></figure>

<h3 id="预编译-spring-oxm-项目"><a href="#预编译-spring-oxm-项目" class="headerlink" title="预编译 spring-oxm 项目"></a>预编译 <code>spring-oxm</code> 项目</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure>

<h2 id="Spring-统一资源加载策略"><a href="#Spring-统一资源加载策略" class="headerlink" title="Spring 统一资源加载策略"></a>Spring 统一资源加载策略</h2><h3 id="统一资源：Resource"><a href="#统一资源：Resource" class="headerlink" title="统一资源：Resource"></a>统一资源：Resource</h3><p><code>org.springframework.core.io.Resource</code> 为 Spring 框架所有资源的抽象和访问接口，它继承 <code>org.springframework.core.io.InputStreamSource</code>接口。作为所有资源的统一抽象，Resource 定义了一些通用的方法，由子类 <code>AbstractResource</code> 提供统一的默认实现。</p>
<p>如果我们想要实现自定义的 Resource ，记住不要实现 Resource 接口，而应该继承 AbstractResource 抽象类，然后根据当前的具体资源特性覆盖相应的方法即可。</p>
<h3 id="统一资源定位：ResourceLoader"><a href="#统一资源定位：ResourceLoader" class="headerlink" title="统一资源定位：ResourceLoader"></a>统一资源定位：ResourceLoader</h3><p><code>org.springframework.core.io.ResourceLoader</code> 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为统一资源定位器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">CLASSPATH_URL_PREFIX</span> <span class="operator">=</span> ResourceUtils.CLASSPATH_URL_PREFIX; <span class="comment">// CLASSPATH URL 前缀。默认为：&quot;classpath:&quot;</span></span><br><span class="line"></span><br><span class="line">	Resource <span class="title function_">getResource</span><span class="params">(String location)</span>;</span><br><span class="line"></span><br><span class="line">	ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>#getResource(String location)</code>方法，根据所提供资源的路径 location 返回 Resource 实例，但是它不确保该 Resource 一定存在，需要调用<code>Resource#exist()</code>方法来判断。<ul>
<li>该方法支持以下模式的资源加载：<ul>
<li>URL位置资源，如 <code>&quot;file:C:/test.dat&quot;</code> 。</li>
<li>ClassPath位置资源，如 <code>&quot;classpath:test.dat&quot;</code> 。</li>
<li>相对路径资源，如 <code>&quot;WEB-INF/test.dat&quot;</code> ，此时返回的Resource 实例，根据实现不同而不同。</li>
</ul>
</li>
<li>该方法的主要实现是在其子类 DefaultResourceLoader 中实现，具体过程我们在分析 DefaultResourceLoader 时做详细说明。</li>
</ul>
</li>
<li><code>#getClassLoader()</code> 方法，返回 ClassLoader 实例，对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用该方法来获取。在分析 Resource 时，提到了一个类 ClassPathResource ，这个类是可以根据指定的 ClassLoader 来加载资源的。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此 Spring 整个资源记载过程已经分析完毕。下面简要总结下：</p>
<ul>
<li>Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其定位。使得资源与资源的定位有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。</li>
<li>AbstractResource 为 Resource 的默认抽象实现，它对 Resource 接口做了一个统一的实现，子类继承该类后只需要覆盖相应的方法即可，同时对于自定义的 Resource 我们也是继承该类。</li>
<li>DefaultResourceLoader 同样也是 ResourceLoader 的默认实现，在自定 ResourceLoader 的时候我们除了可以继承该类外还可以实现 ProtocolResolver 接口来实现自定资源加载协议。</li>
<li>DefaultResourceLoader 每次只能返回单一的资源，所以 Spring 针对这个提供了另外一个接口 ResourcePatternResolver ，该接口提供了根据指定的 locationPattern 返回多个资源的策略。其子类 PathMatchingResourcePatternResolver 是一个集大成者的 ResourceLoader ，因为它即实现了 <code>Resource getResource(String location)</code> 方法，也实现了 <code>Resource[] getResources(String locationPattern)</code> 方法。</li>
</ul>
<h2 id="加载-BeanDefinition"><a href="#加载-BeanDefinition" class="headerlink" title="加载 BeanDefinition"></a>加载 BeanDefinition</h2><p>先看一段熟悉的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPathResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;bean.xml&quot;</span>); <span class="comment">// &lt;1&gt;</span></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>(); <span class="comment">// &lt;2&gt;</span></span><br><span class="line"><span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(factory); <span class="comment">// &lt;3&gt;</span></span><br><span class="line">reader.loadBeanDefinitions(resource); <span class="comment">// &lt;4&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码是 Spring 中编程式使用 IoC 容器，通过这四段简单的代码，我们可以初步判断 IoC 容器的使用过程。</p>
<ol>
<li>获取资源</li>
<li>获取 BeanFactory</li>
<li>根据新建的 BeanFactory 创建一个 BeanDefinitionReader 对象，该 Reader 对象为资源的<strong>解析器</strong></li>
<li>装载资源</li>
</ol>
<p>整个过程就分为三个步骤：资源定位、装载、注册：</p>
<ul>
<li><strong>资源定位</strong>。我们一般用外部资源来描述 Bean 对象，所以在初始化 IoC 容器的第一步就是需要定位这个外部资源。</li>
<li><strong>装载</strong>。装载就是 BeanDefinition 的载入。BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IoC 容器的内部数据结构：BeanDefinition 。<ul>
<li>在 IoC 容器内部维护着一个 BeanDefinition Map 的数据结构</li>
<li>在配置文件中每一个 <code>&lt;bean&gt;</code> 都对应着一个 BeanDefinition 对象。</li>
<li>本文，我们分享的就是<strong>装载</strong>这个步骤。</li>
</ul>
</li>
<li><strong>注册</strong>。向 IoC 容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistry 接口来实现的。在 IoC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IoC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。<ul>
<li>在这里需要注意的一点是这个过程并没有完成依赖注入（Bean 创建），Bean 创建是发生在应用第一次调用 <code>#getBean(...)</code> 方法，向容器索要 Bean 时。</li>
<li>当然我们可以通过设置预处理，即对某个 Bean 设置 <code>lazyinit = false</code> 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。</li>
</ul>
</li>
</ul>
<blockquote>
<p>简单的说，上面步骤的结果是，XML Resource &#x3D;&gt; XML Document &#x3D;&gt; Bean Definition 。</p>
</blockquote>
<h3 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions"></a>loadBeanDefinitions</h3><p>资源定位在前面已经分析了，下面我们直接分析<strong>加载</strong>，上面看到的 <code>reader.loadBeanDefinitions(resource)</code> 代码，才是加载资源的真正实现，所以我们直接从该方法入手。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// XmlBeanDefinitionReader.java</span><br><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从指定的 xml 文件加载 Bean Definition ，这里会先对 Resource 资源封装成 <code>org.springframework.core.io.support.EncodedResource</code> 对象。这里为什么需要将 Resource 封装成 EncodedResource 呢？主要是为了对 Resource 进行编码，保证内容读取的正确性。</li>
<li>然后，再调用 <code>#loadBeanDefinitions(EncodedResource encodedResource)</code> 方法，执行真正的逻辑实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程，正在加载的 EncodedResource 集合。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;EncodedResource&gt;&gt; resourcesCurrentlyBeingLoaded = <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;XML bean definition resources currently being loaded&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &lt;1&gt; 获取已经加载过的资源</span></span><br><span class="line">	Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">	<span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">		currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">		<span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123; <span class="comment">// 将当前资源加入记录中。如果已存在，抛出异常</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// &lt;2&gt; 从 EncodedResource 获取封装的 Resource ，并从 Resource 中获取其中的 InputStream</span></span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">			<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123; <span class="comment">// 设置编码</span></span><br><span class="line">				inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 核心逻辑部分，执行加载 BeanDefinition</span></span><br><span class="line">			<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			inputStream.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 从缓存中剔除该资源 &lt;3&gt;</span></span><br><span class="line">		currentResources.remove(encodedResource);</span><br><span class="line">		<span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">			<span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;1&gt;</code>处，通过<code>resourcesCurrentlyBeingLoaded.get()</code>代码，来获取已经加载过的资源，然后将<code>encodedResource</code>加入其中，如果<code>resourcesCurrentlyBeingLoaded</code>中已经存在该资源，则抛出 BeanDefinitionStoreException 异常。<ul>
<li>为什么需要这么做呢？答案在 <code>&quot;Detected cyclic loading&quot;</code> ，避免一个 EncodedResource 在加载时，还没加载完成，又加载自身，从而导致<strong>死循环</strong>。</li>
<li>也因此，在 <code>&lt;3&gt;</code> 处，当一个 EncodedResource 加载完成后，需要从缓存中剔除。</li>
</ul>
</li>
<li><code>&lt;2&gt;</code> 处理，从 <code>encodedResource</code> 获取封装的 Resource 资源，并从 Resource 中获取相应的 InputStream ，然后将 InputStream 封装为 InputSource ，最后调用 <code>#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code> 方法，执行加载 Bean Definition 的真正逻辑。</li>
</ul>
<h3 id="doLoadBeanDefinitions"><a href="#doLoadBeanDefinitions" class="headerlink" title="doLoadBeanDefinitions"></a>doLoadBeanDefinitions</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doLoadDocument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerBeanDefinitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// &lt;1&gt; 获取 XML Document 实例</span></span><br><span class="line">		<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">		<span class="comment">// &lt;2&gt; 根据 Document 实例，注册 Bean 信息</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">                <span class="string">&quot;Line &quot;</span> + ex.getLineNumber() + <span class="string">&quot; in XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Parser configuration exception parsing XML from &quot;</span> + resource, ex);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;IOException parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Unexpected exception parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>&lt;1&gt;</code> 处，调用 <code>#doLoadDocument(InputSource inputSource, Resource resource)</code> 方法，根据 xml 文件，获取 Document 实例。</li>
<li>在 <code>&lt;2&gt;</code> 处，调用 <code>#registerBeanDefinitions(Document doc, Resource resource)</code> 方法，根据获取的 Document 实例，注册 Bean 信息。</li>
</ul>
<h3 id="doLoadDocument"><a href="#doLoadDocument" class="headerlink" title="doLoadDocument"></a>doLoadDocument</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 XML Document 实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Actually load the specified document using the configured DocumentLoader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the DOM Document</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception when thrown from the DocumentLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setDocumentLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DocumentLoader#loadDocument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Document <span class="title function_">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="built_in">this</span>.errorHandler,</span><br><span class="line">			getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>调用 <code>#getValidationModeForResource(Resource resource)</code> 方法，获取指定资源（xml）的<strong>验证模式</strong>。详细解析，见 <a href="#%E8%8E%B7%E5%8F%96%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9E%8B-ValidationMode">《获取验证模型》</a> 。</p>
</li>
<li><p>调用 <code>DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，获取 XML Document 实例。详细解析，见 [《获取 Document 对象》](#获取 Document 对象) 。</p>
</li>
</ol>
<h3 id="registerBeanDefinitions"><a href="#registerBeanDefinitions" class="headerlink" title="registerBeanDefinitions"></a>registerBeanDefinitions</h3><p>该方法的详细解析，见 [《注册 BeanDefinition》](#注册 BeanDefinition) 。</p>
<h2 id="获取验证模型-ValidationMode"><a href="#获取验证模型-ValidationMode" class="headerlink" title="获取验证模型(ValidationMode)"></a>获取验证模型(ValidationMode)</h2><p>在核心逻辑方法 <code>#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code> 方法中，中主要是做三件事情：</p>
<ol>
<li>调用 <code>#getValidationModeForResource(Resource resource)</code> 方法，获取指定资源（xml）的<strong>验证模式</strong>。</li>
<li>调用 <code>DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver,ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，获取 XML Document 实例。</li>
<li>调用 <code>#registerBeanDefinitions(Document doc, Resource resource)</code> 方法，根据获取的 Document 实例，注册 Bean 信息。</li>
</ol>
<p>这章主要<strong>第 1 步</strong>，分析获取 xml 文件的验证模式。为什么需要获取验证模式呢？原因如下：</p>
<blockquote>
<p>XML 文件的验证模式保证了 XML 文件的正确性。</p>
</blockquote>
<h3 id="DTD-与-XSD-的区别"><a href="#DTD-与-XSD-的区别" class="headerlink" title="DTD 与 XSD 的区别"></a>DTD 与 XSD 的区别</h3><h4 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h4><p>DTD(Document Type Definition)，即文档类型定义，为 XML 文件的验证机制，属于 XML 文件中组成的一部分。DTD 是一种保证 XML 文档格式正确的有效验证方式，它定义了相关 XML 文档的元素、属性、排列方式、元素的内容类型以及元素的层次结构。其实 DTD 就相当于 XML 中的 “词汇”和“语法”，我们可以通过比较 XML 文件和 DTD 文件 来看文档是否符合规范，元素和标签使用是否正确。</p>
<p>要在 Spring 中使用 DTD，需要在 Spring XML 文件头部声明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">beans</span> <span class="keyword">PUBLIC</span>  <span class="string">&quot;-//SPRING//DTD BEAN//EN&quot;</span>  <span class="string">&quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DTD 在一定的阶段推动了 XML 的发展，但是它本身存在着一些<strong>缺陷</strong>：</p>
<ol>
<li>它没有使用 XML 格式，而是自己定义了一套格式，相对解析器的重用性较差；而且 DTD 的构建和访问没有标准的编程接口，因而解析器很难简单的解析 DTD 文档。</li>
<li>DTD 对元素的类型限制较少；同时其他的约束力也叫弱。</li>
<li>DTD 扩展能力较差。</li>
<li>基于正则表达式的 DTD 文档的描述能力有限。</li>
</ol>
<h4 id="XSD"><a href="#XSD" class="headerlink" title="XSD"></a>XSD</h4><p>针对 DTD 的缺陷，W3C 在 2001 年推出 XSD。XSD（XML Schemas Definition）即 XML Schema 语言。XML Schema 本身就是一个 XML文档，使用的是 XML 语法，因此可以很方便的解析 XSD 文档。相对于 DTD，XSD 具有如下<strong>优势</strong>：</p>
<ol>
<li>XML Schema 基于 XML ，没有专门的语法。</li>
<li>XML Schema 可以象其他 XML 文件一样解析和处理。</li>
<li>XML Schema 比 DTD 提供了更丰富的数据类型。</li>
<li>XML Schema 提供可扩充的数据模型。</li>
<li>XML Schema 支持综合命名空间。</li>
<li>XML Schema 支持属性组。</li>
</ol>
<h3 id="getValidationModeForResource"><a href="#getValidationModeForResource" class="headerlink" title="getValidationModeForResource"></a>getValidationModeForResource</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VALIDATION_NONE</span> <span class="operator">=</span> XmlValidationModeDetector.VALIDATION_NONE;</span><br><span class="line"><span class="comment">// 自动获取验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VALIDATION_AUTO</span> <span class="operator">=</span> XmlValidationModeDetector.VALIDATION_AUTO;</span><br><span class="line"><span class="comment">// DTD 验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VALIDATION_DTD</span> <span class="operator">=</span> XmlValidationModeDetector.VALIDATION_DTD;</span><br><span class="line"><span class="comment">// XSD 验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VALIDATION_XSD</span> <span class="operator">=</span> XmlValidationModeDetector.VALIDATION_XSD;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证模式。默认为自动模式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">validationMode</span> <span class="operator">=</span> VALIDATION_AUTO;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getValidationModeForResource</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">	<span class="comment">// &lt;1&gt; 获取指定的验证模式</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">validationModeToUse</span> <span class="operator">=</span> getValidationMode();</span><br><span class="line">	<span class="comment">// 首先，如果手动指定，则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (validationModeToUse != VALIDATION_AUTO) &#123;</span><br><span class="line">		<span class="keyword">return</span> validationModeToUse;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 其次，自动获取验证模式</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">detectedMode</span> <span class="operator">=</span> detectValidationMode(resource);</span><br><span class="line">	<span class="keyword">if</span> (detectedMode != VALIDATION_AUTO) &#123;</span><br><span class="line">		<span class="keyword">return</span> detectedMode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后，使用 VALIDATION_XSD 做为默认</span></span><br><span class="line">	<span class="comment">// Hmm, we didn&#x27;t get a clear indication... Let&#x27;s assume XSD,</span></span><br><span class="line">	<span class="comment">// since apparently no DTD declaration has been found up until</span></span><br><span class="line">	<span class="comment">// detection stopped (before finding the document&#x27;s root tag).</span></span><br><span class="line">	<span class="keyword">return</span> VALIDATION_XSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取-Document-对象"><a href="#获取-Document-对象" class="headerlink" title="获取 Document 对象"></a>获取 Document 对象</h2><p>在 <code>XmlBeanDefinitionReader#doLoadDocument(InputSource inputSource, Resource resource)</code> 方法，中做了两件事情：</p>
<ul>
<li>调用<code>#getValidationModeForResource(Resource resource)</code>方法，获取指定资源（xml）的验证模式。</li>
<li>调用 <code>DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，获取 XML Document 实例。</li>
</ul>
<h3 id="DocumentLoader"><a href="#DocumentLoader" class="headerlink" title="DocumentLoader"></a>DocumentLoader</h3><p>获取 Document 的策略，由接口 <code>org.springframework.beans.factory.xml.DocumentLoader</code> 定义。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DocumentLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">	Document <span class="title function_">loadDocument</span><span class="params">(</span></span><br><span class="line"><span class="params">			InputSource inputSource, EntityResolver entityResolver,</span></span><br><span class="line"><span class="params">			ErrorHandler errorHandler, <span class="type">int</span> validationMode, <span class="type">boolean</span> namespaceAware)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>inputSource</code> 方法参数，加载 Document 的 Resource 资源。</li>
<li><code>entityResolver</code> 方法参数，解析文件的解析器。</li>
<li><code>errorHandler</code> 方法参数，处理加载 Document 对象的过程的错误。</li>
<li><code>validationMode</code> 方法参数，验证模式。</li>
<li><code>namespaceAware</code> 方法参数，命名空间支持。如果要提供对 XML 名称空间的支持，则需要值为 <code>true</code> 。</li>
</ul>
<h4 id="DefaultDocumentLoader"><a href="#DefaultDocumentLoader" class="headerlink" title="DefaultDocumentLoader"></a>DefaultDocumentLoader</h4><p>该方法由 DocumentLoader 的默认实现类 <code>org.springframework.beans.factory.xml.DefaultDocumentLoader</code> 实现。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the &#123;<span class="doctag">@link</span> Document&#125; at the supplied &#123;<span class="doctag">@link</span> InputSource&#125; using the standard JAXP-configured</span></span><br><span class="line"><span class="comment"> * XML parser.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Document <span class="title function_">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span><br><span class="line"><span class="params">		ErrorHandler errorHandler, <span class="type">int</span> validationMode, <span class="type">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// &lt;1&gt; 创建 DocumentBuilderFactory</span></span><br><span class="line">	<span class="type">DocumentBuilderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Using JAXP provider [&quot;</span> + factory.getClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// &lt;2&gt; 创建 DocumentBuilder</span></span><br><span class="line">	<span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">	<span class="comment">// &lt;3&gt; 解析 XML InputSource 返回 Document 对象</span></span><br><span class="line">	<span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先，调用 #<code>createDocumentBuilderFactory(...)</code> 方法，创建 <code>javax.xml.parsers.DocumentBuilderFactory</code> 对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JAXP attribute used to configure the schema language for validation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHEMA_LANGUAGE_ATTRIBUTE</span> <span class="operator">=</span> <span class="string">&quot;http://java.sun.com/xml/jaxp/properties/schemaLanguage&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JAXP attribute value indicating the XSD schema language.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">XSD_SCHEMA_LANGUAGE</span> <span class="operator">=</span> <span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>;</span><br><span class="line"><span class="keyword">protected</span> DocumentBuilderFactory <span class="title function_">createDocumentBuilderFactory</span><span class="params">(<span class="type">int</span> validationMode, <span class="type">boolean</span> namespaceAware)</span></span><br><span class="line">        <span class="keyword">throws</span> ParserConfigurationException &#123;</span><br><span class="line">    <span class="comment">// 创建 DocumentBuilderFactory</span></span><br><span class="line">    <span class="type">DocumentBuilderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">    factory.setNamespaceAware(namespaceAware); <span class="comment">// 设置命名空间支持</span></span><br><span class="line">    <span class="keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;</span><br><span class="line">        factory.setValidating(<span class="literal">true</span>); <span class="comment">// 开启校验</span></span><br><span class="line">        <span class="comment">// XSD 模式下，设置 factory 的属性</span></span><br><span class="line">        <span class="keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;</span><br><span class="line">            <span class="comment">// Enforce namespace aware for XSD...</span></span><br><span class="line">            factory.setNamespaceAware(<span class="literal">true</span>); <span class="comment">// XSD 模式下，强制设置命名空间支持</span></span><br><span class="line">            <span class="comment">// 设置 SCHEMA_LANGUAGE_ATTRIBUTE</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">                <span class="type">ParserConfigurationException</span> <span class="variable">pcex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParserConfigurationException</span>(</span><br><span class="line">                        <span class="string">&quot;Unable to validate using XSD: Your JAXP provider [&quot;</span> + factory +</span><br><span class="line">                        <span class="string">&quot;] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;</span>);</span><br><span class="line">                pcex.initCause(ex);</span><br><span class="line">                <span class="keyword">throw</span> pcex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，调用 <code>#createDocumentBuilder(DocumentBuilderFactory factory, EntityResolver entityResolver,ErrorHandler errorHandler)</code> 方法，创建 <code>javax.xml.parsers.DocumentBuilder</code> 对象。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected DocumentBuilder createDocumentBuilder(DocumentBuilderFactory factory,</span><br><span class="line">		@Nullable EntityResolver entityResolver, @Nullable ErrorHandler errorHandler)</span><br><span class="line">		throws ParserConfigurationException &#123;</span><br><span class="line">	// 创建 DocumentBuilder 对象</span><br><span class="line">	DocumentBuilder docBuilder = factory.newDocumentBuilder();</span><br><span class="line">	// &lt;x&gt; 设置 EntityResolver 属性</span><br><span class="line">	if (entityResolver != null) &#123;</span><br><span class="line">		docBuilder.setEntityResolver(entityResolver);</span><br><span class="line">	&#125;</span><br><span class="line">	// 设置 ErrorHandler 属性</span><br><span class="line">	if (errorHandler != null) &#123;</span><br><span class="line">		docBuilder.setErrorHandler(errorHandler);</span><br><span class="line">	&#125;</span><br><span class="line">	return docBuilder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>&lt;x&gt;</code> 处，设置 DocumentBuilder 的 <strong>EntityResolver</strong> 属性。</li>
</ul>
</li>
<li><p>最后，调用 <code>DocumentBuilder#parse(InputSource)</code> 方法，解析 InputSource ，返回 Document 对象。</p>
</li>
</ul>
<h2 id="注册-BeanDefinitions"><a href="#注册-BeanDefinitions" class="headerlink" title="注册 BeanDefinitions"></a>注册 BeanDefinitions</h2><p>获取 XML Document 对象后，会根据该对象和 Resource 资源对象调用 <code>XmlBeanDefinitionReader#registerBeanDefinitions(Document doc, Resource resource)</code> 方法，开始注册 BeanDefinitions 之旅。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractBeanDefinitionReader.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="comment">// &lt;1&gt; 创建 BeanDefinitionDocumentReader 对象</span></span><br><span class="line">	<span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="comment">// &lt;2&gt; 获取已注册的 BeanDefinition 数量</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">	<span class="comment">// &lt;3&gt; 创建 XmlReaderContext 对象</span></span><br><span class="line">	<span class="comment">// &lt;4&gt; 注册 BeanDefinition</span></span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="comment">// 计算新注册的 BeanDefinition 数量</span></span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;1&gt;</code> 处，调用 <code>#createBeanDefinitionDocumentReader()</code> 方法，实例化 BeanDefinitionDocumentReader 对象。</p>
</li>
<li><p><code>&lt;2&gt;</code> 处，调用 <code>BeanDefinitionRegistry#getBeanDefinitionCount()</code> 方法，获取<strong>已注册</strong>的 BeanDefinition 数量。</p>
</li>
<li><p><code>&lt;3&gt;</code> 处，调用 <code>#createReaderContext(Resource resource)</code> 方法，创建 XmlReaderContext 对象。</p>
</li>
<li><p><code>&lt;4&gt;</code> 处，调用 <code>BeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</code> 方法，读取 XML 元素，注册 BeanDefinition 们。</p>
</li>
<li><p><code>&lt;5&gt;</code> 处，计<strong>算新注册</strong>的 BeanDefinition 数量。</p>
</li>
</ul>
<h3 id="createBeanDefinitionDocumentReader"><a href="#createBeanDefinitionDocumentReader" class="headerlink" title="createBeanDefinitionDocumentReader"></a>createBeanDefinitionDocumentReader</h3><p><code>#createBeanDefinitionDocumentReader()</code>，实例化 BeanDefinitionDocumentReader 对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * documentReader 的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #createBeanDefinitionDocumentReader() </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionDocumentReader</span>&gt; documentReaderClass = DefaultBeanDefinitionDocumentReader.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title function_">createBeanDefinitionDocumentReader</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> BeanUtils.instantiateClass(<span class="built_in">this</span>.documentReaderClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>documentReaderClass</code> 的默认值为 <code>DefaultBeanDefinitionDocumentReader.class</code> 。关于它，我们在后续的文章，详细解析。</li>
</ul>
<h3 id="registerBeanDefinitions-1"><a href="#registerBeanDefinitions-1" class="headerlink" title="registerBeanDefinitions"></a>registerBeanDefinitions</h3><p><code>BeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</code> 方法，注册 BeanDefinition ，在接口 BeanDefinitionDocumentReader 中定义。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionDocumentReader</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Read bean definitions from the given DOM document and</span></span><br><span class="line"><span class="comment">	 * register them with the registry in the given reader context.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> doc the DOM document</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> readerContext the current context of the reader</span></span><br><span class="line"><span class="comment">	 * (includes the target registry and the resource being parsed)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of parsing errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从给定的 Document 对象中解析定义的 BeanDefinition 并将他们注册到注册表中</strong>。方法接收两个参数：</p>
<ul>
<li><code>doc</code> 方法参数：待解析的 Document 对象。</li>
<li><code>readerContext</code> 方法，解析器的当前上下文，包括目标注册表和被解析的资源。</li>
</ul>
<h4 id="DefaultBeanDefinitionDocumentReader"><a href="#DefaultBeanDefinitionDocumentReader" class="headerlink" title="DefaultBeanDefinitionDocumentReader"></a>DefaultBeanDefinitionDocumentReader</h4><p>BeanDefinitionDocumentReader 有且只有一个默认实现类 DefaultBeanDefinitionDocumentReader 。它对 <code>#registerBeanDefinitions(...)</code> 方法的实现代码如下：</p>
<p>DefaultBeanDefinitionDocumentReader 对该方法提供了实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> XmlReaderContext readerContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> BeanDefinitionParserDelegate delegate;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation parses bean definitions according to the &quot;spring-beans&quot; XSD</span></span><br><span class="line"><span class="comment"> * (or DTD, historically).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Opens a DOM Document; then initializes the default settings</span></span><br><span class="line"><span class="comment"> * specified at the &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; level; then parses the contained bean definitions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">    <span class="comment">// 获得 XML Document Root Element</span></span><br><span class="line">    <span class="comment">// 执行注册 BeanDefinition</span></span><br><span class="line">    doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register each bean definition within the given root &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span>  <span class="comment">// for Environment.acceptsProfiles(String...)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">    <span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">    <span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">    <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">    <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">    <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">    <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">    <span class="comment">// 记录老的 BeanDefinitionParserDelegate 对象</span></span><br><span class="line">    <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">    <span class="comment">// &lt;1&gt; 创建 BeanDefinitionParserDelegate 对象，并进行设置到 delegate</span></span><br><span class="line">    <span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    <span class="comment">// &lt;2&gt; 检查 &lt;beans /&gt; 根标签的命名空间是否为空，或者是 http://www.springframework.org/schema/beans</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        <span class="comment">// &lt;2.1&gt; 处理 profile 属性。可参见《Spring3自定义环境配置 &lt;beans profile=&quot;&quot;&gt;》http://nassir.iteye.com/blog/1535799</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            <span class="comment">// &lt;2.2&gt; 使用分隔符切分，可能有多个 profile 。</span></span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="comment">// &lt;2.3&gt; 如果所有 profile 都无效，则不进行注册</span></span><br><span class="line">            <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">            <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">            <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                            <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;3&gt; 解析前处理</span></span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    <span class="comment">// &lt;4&gt; 解析</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">    <span class="comment">// &lt;5&gt; 解析后处理</span></span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 delegate 回老的 BeanDefinitionParserDelegate 对象</span></span><br><span class="line">    <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;1&gt;</code> 处，创建 BeanDefinitionParserDelegate 对象，并进行设置到 <code>delegate</code> 。BeanDefinitionParserDelegate 是一个重要的类，它负责<strong>解析 BeanDefinition</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title function_">createDelegate</span><span class="params">(</span></span><br><span class="line"><span class="params">        XmlReaderContext readerContext, Element root, <span class="meta">@Nullable</span> BeanDefinitionParserDelegate parentDelegate)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 BeanDefinitionParserDelegate 对象</span></span><br><span class="line">    <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">delegate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionParserDelegate</span>(readerContext);</span><br><span class="line">    <span class="comment">// 初始化默认</span></span><br><span class="line">    delegate.initDefaults(root, parentDelegate);</span><br><span class="line">    <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;2&gt;</code> 处，检查 <code>&lt;beans /&gt;</code> <strong>根</strong>标签的命名空间是否为空，或者是 <a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a> 。</p>
<ul>
<li><code>&lt;2.1&gt;</code> 处，判断是否 <code>&lt;beans /&gt;</code> 上配置了 <code>profile</code> 属性。</li>
<li><code>&lt;2.2&gt;</code> 处，使用分隔符切分，可能有<strong>多个</strong> profile 。</li>
<li><code>&lt;2.3&gt;</code> 处，判断，如果所有 profile 都无效，则 <code>return</code> 不进行注册。</li>
</ul>
</li>
<li><p><code>&lt;4&gt;</code> 处，调用 <code>#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)</code> 方法，进行解析逻辑。详细解析，见 <a href="http://svip.iocoder.cn/Spring/IoC-register-BeanDefinitions/#">「3.1 parseBeanDefinitions」</a> 。</p>
</li>
<li><p><code>&lt;3&gt;</code> &#x2F; <code>&lt;5&gt;</code> 处，解析<strong>前后</strong>的处理，目前这两个方法都是空实现，交由子类来实现。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">preProcessXml</span><span class="params">(Element root)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessXml</span><span class="params">(Element root)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="parseBeanDefinitions"><a href="#parseBeanDefinitions" class="headerlink" title="parseBeanDefinitions"></a>parseBeanDefinitions</h5><p><code>#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)</code> 方法，进行解析逻辑。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the elements at the root level in the document:</span></span><br><span class="line"><span class="comment"> * &quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root the DOM root element of the document</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="comment">// &lt;1&gt; 如果根节点使用默认命名空间，执行默认解析</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        <span class="comment">// 遍历子节点</span></span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">                <span class="comment">// &lt;1&gt; 如果该节点使用默认命名空间，执行默认解析</span></span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                <span class="comment">// 如果该节点非默认命名空间，执行自定义解析</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// &lt;2&gt; 如果根节点非默认命名空间，执行自定义解析</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Spring 有两种Bean 声明方式：</p>
<ul>
<li>配置文件式声明：<code>&lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.StudentService&quot; /&gt;</code> 。对应 <code>&lt;1&gt;</code> 处。</li>
<li>自定义注解方式：<code>&lt;tx:annotation-driven&gt;</code> 。对应 <code>&lt;2&gt;</code> 处。</li>
</ul>
</li>
<li><p><code>&lt;1&gt;</code> 处，如果<strong>根</strong>节点或<strong>子</strong>节点<strong>使用</strong>默认命名空间，调用 <code>#parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate)</code> 方法，执行默认解析。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; <span class="comment">// import</span></span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; <span class="comment">// alias</span></span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; <span class="comment">// bean</span></span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; <span class="comment">// beans</span></span><br><span class="line">		<span class="comment">// recurse</span></span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>详细的解析，见后续文章。</li>
</ul>
</li>
<li><p><code>&lt;2&gt;</code> 处，如果<strong>根</strong>节点或<strong>子</strong>节点<strong>不使用</strong>默认命名空间，调用<code>BeanDefinitionParserDelegate#parseCustomElement(Element ele)</code> 方法，执行<strong>自定义</strong>解析。详细的解析，见后续文章。</p>
</li>
</ul>
<h3 id="createReaderContext"><a href="#createReaderContext" class="headerlink" title="createReaderContext"></a>createReaderContext</h3><p><code>#createReaderContext(Resource resource)</code> 方法，创建 XmlReaderContext 对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ProblemReporter</span> <span class="variable">problemReporter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FailFastProblemReporter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReaderEventListener</span> <span class="variable">eventListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmptyReaderEventListener</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">SourceExtractor</span> <span class="variable">sourceExtractor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullSourceExtractor</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> NamespaceHandlerResolver namespaceHandlerResolver;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the &#123;<span class="doctag">@link</span> XmlReaderContext&#125; to pass over to the document reader.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> XmlReaderContext <span class="title function_">createReaderContext</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlReaderContext</span>(resource, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.eventListener,</span><br><span class="line">			<span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 XmlReaderContext 的详细解析，见后续文章。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式-依赖注入容器</title>
    <url>/2022/07/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。</p>
<p>DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p>
<p>除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。</p>
<span id="more"></span>

<h1 id="DI-容器的核心功能"><a href="#DI-容器的核心功能" class="headerlink" title="DI 容器的核心功能"></a>DI 容器的核心功能</h1><ul>
<li>配置解析</li>
<li>对象创建</li>
<li>对象生命周期管理</li>
</ul>
<h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><p>我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</p>
<p>容器读取这个配置文件，解析出要创建的两个对象：<code>rateLimiter</code> 和 <code>redisCounter</code>，并且得到两者的依赖关系：<code>rateLimiter</code> 依赖 <code>redisCounter</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisCounter redisCounter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RateLimiter</span><span class="params">(RedisCounter redisCounter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisCounter = redisCounter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> RedisCounter <span class="title function_">getRedisCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisCounter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(redisCounter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String ipAddress;</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCounter</span><span class="params">(String ipAddress, String port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ipAddress = ipAddress;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件<code>beans.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;rateLimiter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mono.monochrome.bean.RateLimiter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;redisCounter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisCounter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mono.monochrome.bean.RedisCounter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span>1234<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 <code>BeansFactory</code>。</p>
<p>如果要创建的类对象非常多，<code>BeansFactory</code> 利用<code>Java</code>的“反射”机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。</p>
<h2 id="对象的生命周期管理"><a href="#对象的生命周期管理" class="headerlink" title="对象的生命周期管理"></a>对象的生命周期管理</h2><p>简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope&#x3D;prototype 表示返回新创建的对象，scope&#x3D;singleton 表示返回单例对象。</p>
<p>除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init&#x3D;true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init&#x3D;false，对象在应用启动的时候就事先创建好。</p>
<h1 id="实现一个简单的-DI-容器"><a href="#实现一个简单的-DI-容器" class="headerlink" title="实现一个简单的 DI 容器"></a>实现一个简单的 DI 容器</h1><h2 id="最小原型设计"><a href="#最小原型设计" class="headerlink" title="最小原型设计"></a>最小原型设计</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">RedisCounter</span> <span class="variable">redisCounter</span> <span class="operator">=</span> (RedisCounter) applicationContext.getBean(<span class="string">&quot;redisCounter&quot;</span>);</span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> (RateLimiter) applicationContext.getBean(<span class="string">&quot;rateLimiter&quot;</span>);</span><br><span class="line">        System.out.println(redisCounter);</span><br><span class="line">        rateLimiter.test();</span><br><span class="line">        System.out.println(redisCounter == rateLimiter.getRedisCounter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提供执行入口"><a href="#提供执行入口" class="headerlink" title="提供执行入口"></a>提供执行入口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String beanId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeansFactory beansFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanConfigParser beanConfigParser;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beansFactory = <span class="keyword">new</span> <span class="title class_">BeansFactory</span>();</span><br><span class="line">        <span class="built_in">this</span>.beanConfigParser = <span class="keyword">new</span> <span class="title class_">XmlBeanConfigParser</span>();</span><br><span class="line">        <span class="built_in">this</span>.loadBeanDefinitions(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(String configLocation)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="built_in">this</span>.getClass().getResourceAsStream(<span class="string">&quot;/&quot;</span> + configLocation);</span><br><span class="line">            <span class="keyword">if</span> (inputStream == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can not find config file: &quot;</span> + configLocation);</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(inputStream);</span><br><span class="line">            beansFactory.addBeanDefinitions(beanDefinitions);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String beanId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beansFactory.getBean(beanId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClassPathXmlApplicationContext</code> 负责组装 <code>BeansFactory</code> 和 <code>BeanConfigParser</code> 两个类，串联执行流程：从 <code>classpath</code> 中加载 <code>xml</code> 格式的配置文件，通过 <code>BeanConfigParser</code> 解析为统一的 <code>BeanDefinition</code> 格式，然后，<code>BeansFactory</code> 根据 <code>BeanDefinition</code> 来创建对象。</p>
<h2 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h2><p>配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。</p>
<p>pom文件中引入解析xml文件的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>BeanDefinition：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> Scope.SINGLETON;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">lazyInit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//setter and getter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Scope</span> &#123;</span><br><span class="line">        SINGLETON,</span><br><span class="line">        PROTOTYPE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConstructorArg</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isRef</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">private</span> Class type;</span><br><span class="line">        <span class="keyword">private</span> Object arg;</span><br><span class="line">        <span class="comment">//settier and getter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanConfigParser：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanConfigParser</span> &#123;</span><br><span class="line">    List&lt;BeanDefinition&gt; <span class="title function_">parse</span><span class="params">(InputStream inputStream)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlBeanConfigParser</span> <span class="keyword">implements</span> <span class="title class_">BeanConfigParser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">SAXReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XmlBeanConfigParser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;BeanDefinition&gt; <span class="title function_">parse</span><span class="params">(InputStream inputStream)</span> &#123;</span><br><span class="line">        List&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> reader.read(inputStream);<span class="comment">// 获取根节点</span></span><br><span class="line">            <span class="type">Element</span> <span class="variable">beans</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">            <span class="comment">// 获取迭代器</span></span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">beanIt</span> <span class="operator">=</span> beans.elementIterator();</span><br><span class="line">            <span class="comment">// 遍历迭代器，获取根节点信息</span></span><br><span class="line">            <span class="keyword">while</span>(beanIt.hasNext())&#123;</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>();</span><br><span class="line">                <span class="type">Element</span> <span class="variable">bean</span> <span class="operator">=</span> (Element) beanIt.next();</span><br><span class="line"></span><br><span class="line">                List&lt;Attribute&gt; attributes = bean.attributes();</span><br><span class="line">                <span class="comment">// 获取bean属性名和属性值</span></span><br><span class="line">                <span class="keyword">for</span> (Attribute attribute : attributes) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;id&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                        beanDefinition.setId(attribute.getValue());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;class&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                        beanDefinition.setClassName(attribute.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Iterator</span> <span class="variable">argsIt</span> <span class="operator">=</span> bean.elementIterator();</span><br><span class="line">                List&lt;BeanDefinition.ConstructorArg&gt; constructorArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span>(argsIt.hasNext())&#123;</span><br><span class="line">                    BeanDefinition.<span class="type">ConstructorArg</span> <span class="variable">constructorArg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>.ConstructorArg();</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">arg</span> <span class="operator">=</span> (Element) argsIt.next();</span><br><span class="line">                    List&lt;Attribute&gt; argAttributes = arg.attributes();</span><br><span class="line">                    <span class="comment">// 获取bean属性名和属性值</span></span><br><span class="line">                    <span class="keyword">for</span> (Attribute attribute : argAttributes) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;type&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                constructorArg.setType(Class.forName(attribute.getValue()));</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                            constructorArg.setArg(arg.getText());</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;ref&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                            constructorArg.setRef(<span class="literal">true</span>);</span><br><span class="line">                            constructorArg.setArg(attribute.getValue());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    constructorArgs.add(constructorArg);</span><br><span class="line">                    beanDefinition.setConstructorArgs(constructorArgs);</span><br><span class="line">                &#125;</span><br><span class="line">                beanDefinitions.add(beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂类设计"><a href="#工厂类设计" class="headerlink" title="工厂类设计"></a>工厂类设计</h2><p>如果对象的 <code>scope</code> 属性是 <code>singleton</code>，那对象创建之后会缓存在 <code>singletonObjects</code> 这样一个 <code>map</code> 中，下次再请求此对象的时候，直接从 <code>map</code> 中取出返回，不需要重新创建。如果对象的 <code>scope</code> 属性是 <code>prototype</code>，那每次请求对象，<code>BeansFactory</code> 都会创建一个新的对象返回。实际上，<code>BeansFactory</code> 创建对象用到的主要技术点就是 <code>Java</code> 中的反射语法：一种动态加载类和创建对象的机制。我们知道，<code>JVM</code> 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 <code>JVM</code> 帮我们自动完成了，我们需要利用 <code>Java</code> 提供的反射语法自己去编写代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeanDefinitions</span><span class="params">(List&lt;BeanDefinition&gt; beanDefinitions)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitions) &#123;</span><br><span class="line">            <span class="built_in">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!beanDefinition.isLazyInit() &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> createBean(beanDefinition);</span><br><span class="line">                singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String beanId)</span> &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> beanDefinitions.get(beanId);</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Bean is not defined:&quot;</span> + beanId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> createBean(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.containsKey(beanDefinition.getId())) &#123;</span><br><span class="line">            <span class="keyword">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">beanClass</span> <span class="operator">=</span> Class.forName(beanDefinition.getClassName());</span><br><span class="line">            List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();</span><br><span class="line">            <span class="keyword">if</span> (args.isEmpty()) &#123;</span><br><span class="line">                bean = beanClass.newInstance();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Class[] argClasses = <span class="keyword">new</span> <span class="title class_">Class</span>[args.size()];</span><br><span class="line">                Object[] argObjects = <span class="keyword">new</span> <span class="title class_">Object</span>[args.size()];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.size(); i++) &#123;</span><br><span class="line">                    BeanDefinition.<span class="type">ConstructorArg</span> <span class="variable">arg</span> <span class="operator">=</span> args.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (!arg.isRef()) &#123;</span><br><span class="line">                        argClasses[i] = arg.getType();</span><br><span class="line">                        argObjects[i] = arg.getArg();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">BeanDefinition</span> <span class="variable">refBeanDefinition</span> <span class="operator">=</span> beanDefinitions.get(arg.getArg());</span><br><span class="line">                        <span class="keyword">if</span> (refBeanDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(<span class="string">&quot;Bean is not defined: &quot;</span> + arg.getArg());</span><br><span class="line">                        &#125;</span><br><span class="line">                        argClasses[i] = Class.forName(refBeanDefinition.getClassName());</span><br><span class="line">                        <span class="comment">// 依赖的bean还未创建，先去创建依赖的bean</span></span><br><span class="line">                        argObjects[i] = createBean(refBeanDefinition);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                bean = beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException |</span><br><span class="line">                 NoSuchBeanDefinitionException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition.isSingleton()) &#123;</span><br><span class="line">            singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeansFactory</code> 类中的 <code>createBean()</code> 函数是一个递归函数。当构造函数的参数是 <code>ref</code> 类型时，会递归地创建 <code>ref</code> 属性指向的对象。如果我们在配置文件中错误地配置了对象之间的依赖关系，导致存在循环依赖，后续再解决循环依赖吧。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
