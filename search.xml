<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring REST API实体和DTO之间的转换</title>
    <url>/2018/11/26/API%E5%AE%9E%E4%BD%93%E5%92%8CDTO%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="Spring-REST-API实体和DTO之间的转换"><a href="#Spring-REST-API实体和DTO之间的转换" class="headerlink" title="Spring REST API实体和DTO之间的转换"></a>Spring REST API实体和DTO之间的转换</h1><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h2><p>在本教程中，我们将处理在Spring应用程序的内部实体和被发送到客户端的外部DTO（数据传输对象）之间的转换。</p>
<h2 id="2-ModelMapper"><a href="#2-ModelMapper" class="headerlink" title="2. ModelMapper"></a>2. ModelMapper</h2><p>首先，让我们看看用来执行实体-DTO转换的主要类库——ModelMapper。</p>
<p>我们需要在pom.xml中添加这个依赖：</p>
<figure class="highlight plaintext"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.modelmapper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;modelmapper&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>如果需要检查这个库是否有更新的版本， 请<a href="https://search.maven.org/classic/#search|gav|1|g%3A%22org.modelmapper%22%20AND%20a%3A%22modelmapper%22">点击这里</a>。</p>
<p>然后，我们将在Spring配置中定义ModelMapperbean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ModelMapper <span class="title function_">modelMapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelMapper</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-DTO"><a href="#3-DTO" class="headerlink" title="3. DTO"></a>3. DTO</h2><p>话分两头，接下来让我们来看看本例使用的DTO——PostDto。</p>
<figure class="highlight java"><figcaption><span>PostDto.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostDto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDto user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getSubmissionDateConverted</span><span class="params">(String timezone)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        dateFormat.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">        <span class="keyword">return</span> dateFormat.parse(<span class="built_in">this</span>.date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSubmissionDate</span><span class="params">(Date date, String timezone)</span> &#123;</span><br><span class="line">        dateFormat.setTimeZone(TimeZone.getTimeZone(timezone));</span><br><span class="line">        <span class="built_in">this</span>.date = dateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，上面与日期相关的两个方法，它们是用来处理客户端和服务器之间日期数据转换的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getSubmissionDateConverted()方法将日期字符串转换为服务器所在时区中的日期，以便将其用于持久化Post实体</span><br><span class="line">setSubmissionDate()方法是将DTO的日期设置为当前用户所在时区的Post日期</span><br></pre></td></tr></table></figure>

<h2 id="4-服务层"><a href="#4-服务层" class="headerlink" title="4. 服务层"></a>4. 服务层</h2><p>现在让我们看一下服务层的操作——它显然是与实体（而不是DTO）一起工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Post&gt; <span class="title function_">getPostsList</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> page, <span class="type">int</span> size, String sortDir, String sort)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">PageRequest</span> <span class="variable">pageReq</span></span><br><span class="line">     <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageRequest</span>(page, size, Sort.Direction.fromString(sortDir), sort);</span><br><span class="line"></span><br><span class="line">    Page&lt;Post&gt; posts = postRepository</span><br><span class="line">      .findByUser(userService.getCurrentUser(), pageReq);</span><br><span class="line">    <span class="keyword">return</span> posts.getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-控制器层"><a href="#5-控制器层" class="headerlink" title="5. 控制器层"></a>5. 控制器层</h2><p>下面让我们来看看服务层上面的控制器层，这才是转换操作实际触发的地方。<br>现在，让我们来看一个标准的控制器，一个暴露Post资源的REST API。  </p>
<p>我们将在这里展示一些简单的CRUD操作：创建、更新、获取一条和全部记录。考虑到操作非常简单，并且我们特别感兴趣的是实体-DTO转换方面：  </p>
<figure class="highlight java"><figcaption><span>PostRestController.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostRestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IPostService postService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ModelMapper modelMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;PostDto&gt; <span class="title function_">getPosts</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        List&lt;Post&gt; posts = postService.getPostsList(page, size, sortDir, sort);</span><br><span class="line">        <span class="keyword">return</span> posts.stream()</span><br><span class="line">          .map(post -&gt; convertToDto(post))</span><br><span class="line">          .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CREATED)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> PostDto <span class="title function_">createPost</span><span class="params">(<span class="meta">@RequestBody</span> PostDto postDto)</span> &#123;</span><br><span class="line">        <span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> convertToEntity(postDto);</span><br><span class="line">        <span class="type">Post</span> <span class="variable">postCreated</span> <span class="operator">=</span> postService.createPost(post));</span><br><span class="line">        <span class="keyword">return</span> convertToDto(postCreated);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> PostDto <span class="title function_">getPost</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> convertToDto(postService.getPostById(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.PUT)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePost</span><span class="params">(<span class="meta">@RequestBody</span> PostDto postDto)</span> &#123;</span><br><span class="line">        <span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> convertToEntity(postDto);</span><br><span class="line">        postService.updatePost(post);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我们从Post实体到PostDto的转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> PostDto <span class="title function_">convertToDto</span><span class="params">(Post post)</span> &#123;</span><br><span class="line">    <span class="type">PostDto</span> <span class="variable">postDto</span> <span class="operator">=</span> modelMapper.map(post, PostDto.class);</span><br><span class="line">    postDto.setSubmissionDate(post.getSubmissionDate(), </span><br><span class="line">        userService.getCurrentUser().getPreference().getTimezone());</span><br><span class="line">    <span class="keyword">return</span> postDto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是从DTO到实体的转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Post <span class="title function_">convertToEntity</span><span class="params">(PostDto postDto)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> modelMapper.map(postDto, Post.class);</span><br><span class="line">    post.setSubmissionDate(postDto.getSubmissionDateConverted(</span><br><span class="line">      userService.getCurrentUser().getPreference().getTimezone()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (postDto.getId() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Post</span> <span class="variable">oldPost</span> <span class="operator">=</span> postService.getPostById(postDto.getId());</span><br><span class="line">        post.setRedditID(oldPost.getRedditID());</span><br><span class="line">        post.setSent(oldPost.isSent());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> post;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，正如您所看到的，在modelmapper库的帮助下，转换逻辑是快速且简单的——我们使用了modelMapper的map API，并且在不编写任何转换逻辑的情况下完成了数据转换。</p>
<h2 id="6-单元测试"><a href="#6-单元测试" class="headerlink" title="6. 单元测试"></a>6. 单元测试</h2><p>最后，让我们做一个非常简单的测试，以确保实体和DTO之间的转换可以很好地工作：</p>
<figure class="highlight java"><figcaption><span>PostDtoUnitTest.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostDtoUnitTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ModelMapper</span> <span class="variable">modelMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenConvertPostEntityToPostDto_thenCorrect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Post</span>();</span><br><span class="line">        post.setId(Long.valueOf(<span class="number">1</span>));</span><br><span class="line">        post.setTitle(randomAlphabetic(<span class="number">6</span>));</span><br><span class="line">        post.setUrl(<span class="string">&quot;www.test.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PostDto</span> <span class="variable">postDto</span> <span class="operator">=</span> modelMapper.map(post, PostDto.class);</span><br><span class="line">        assertEquals(post.getId(), postDto.getId());</span><br><span class="line">        assertEquals(post.getTitle(), postDto.getTitle());</span><br><span class="line">        assertEquals(post.getUrl(), postDto.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenConvertPostDtoToPostEntity_thenCorrect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PostDto</span> <span class="variable">postDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PostDto</span>();</span><br><span class="line">        postDto.setId(Long.valueOf(<span class="number">1</span>));</span><br><span class="line">        postDto.setTitle(randomAlphabetic(<span class="number">6</span>));</span><br><span class="line">        postDto.setUrl(<span class="string">&quot;www.test.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> modelMapper.map(postDto, Post.class);</span><br><span class="line">        assertEquals(postDto.getId(), post.getId());</span><br><span class="line">        assertEquals(postDto.getTitle(), post.getTitle());</span><br><span class="line">        assertEquals(postDto.getUrl(), post.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装morunchang/fastdfs</title>
    <url>/2021/03/24/Docker%E5%AE%89%E8%A3%85morunchang-fastdfs/</url>
    <content><![CDATA[<h1 id="Docker安装morunchang-x2F-fastdfs"><a href="#Docker安装morunchang-x2F-fastdfs" class="headerlink" title="Docker安装morunchang&#x2F;fastdfs"></a>Docker安装morunchang&#x2F;fastdfs</h1><h2 id="FastDFS简介"><a href="#FastDFS简介" class="headerlink" title="FastDFS简介"></a>FastDFS简介</h2><p>FastDFS是一款开源的分布式文件系统，功能主要包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了文件大容量存储和高性能访问的问题。FastDFS特别适合以文件为载体的在线服务，如图片、视频、文档等等。</p>
<p>FastDFS作为一款轻量级分布式文件系统，版本V6.01代码量6.3万行。FastDFS用C语言实现，支持Linux、FreeBSD、MacOS等类UNIX系统。FastDFS类似google FS，属于应用级文件系统，不是通用的文件系统，只能通过专有API访问，目前提供了C和Java SDK，以及PHP扩展SDK。</p>
<p>FastDFS为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性。FastDFS可以看做是基于文件的key value存储系统，key为文件ID，value为文件内容，因此称作分布式文件存储服务更为合适。</p>
<span id="more"></span>

<h2 id="FastDFS由跟踪服务器-Tracker-Server-、存储服务器-Storage-Server-和客户端-Client-构成。"><a href="#FastDFS由跟踪服务器-Tracker-Server-、存储服务器-Storage-Server-和客户端-Client-构成。" class="headerlink" title="FastDFS由跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)构成。"></a>FastDFS由跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)构成。</h2><h3 id="Tracker-server-追踪服务器"><a href="#Tracker-server-追踪服务器" class="headerlink" title="Tracker server 追踪服务器"></a>Tracker server 追踪服务器</h3><p>追踪服务器负责接收客户端的请求，选择合适的组合storage server ，tracker server 与 storage server之间也会用心跳机制来检测对方是否活着。<br>Tracker需要管理的信息也都放在内存中，并且里面所有的Tracker都是对等的（每个节点地位相等），很容易扩展客户端访问集群的时候会随机分配一个Tracker来和客户端交互。</p>
<h3 id="Storage-server-储存服务器"><a href="#Storage-server-储存服务器" class="headerlink" title="Storage server 储存服务器"></a>Storage server 储存服务器</h3><p>实际存储数据，分成若干个组（group），实际traker就是管理的storage中的组，而组内机器中则存储数据，group可以隔离不同应用的数据，不同的应用的数据放在不同group里面，</p>
<ul>
<li>优点：<br>海量的存储：主从型分布式存储，存储空间方便拓展,<br>fastDFS对文件内容做hash处理，避免出现重复文件<br>然后fastDFS结合Nginx集成, 提供网站效率</li>
</ul>
<h3 id="客户端Client"><a href="#客户端Client" class="headerlink" title="客户端Client"></a>客户端Client</h3><ul>
<li>主要是上传下载数据的服务器，也就是我们自己的项目所部署在的服务器。</li>
</ul>
<h2 id="FastDFS特点"><a href="#FastDFS特点" class="headerlink" title="FastDFS特点"></a>FastDFS特点</h2><ol>
<li>分组存储，简单灵活；</li>
<li>对等结构，不存在单点；</li>
<li>文件ID由FastDFS生成，作为文件访问凭证。FastDFS不需要传统的name server或meta server；</li>
<li>大、中、小文件均可以很好支持，可以存储海量小文件；</li>
<li>一台storage支持多块磁盘，支持单盘数据恢复；</li>
<li>提供了nginx扩展模块，可以和nginx无缝衔接；</li>
<li>支持多线程方式上传和下载文件，支持断点续传；</li>
<li>存储服务器上可以保存文件附加属性。</li>
</ol>
<h2 id="安装FastDFS"><a href="#安装FastDFS" class="headerlink" title="安装FastDFS"></a>安装FastDFS</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull morunchang/fastdfs;</span><br></pre></td></tr></table></figure>

<h3 id="设置Tracker"><a href="#设置Tracker" class="headerlink" title="设置Tracker"></a>设置Tracker</h3><h4 id="运行-tracker"><a href="#运行-tracker" class="headerlink" title="运行 tracker"></a>运行 tracker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name tracker --net=host morunchang/fastdfs sh tracker.sh</span><br></pre></td></tr></table></figure>

<p>上面的启动命令是在Linux下，如果是Mac或Windows操作系统network&#x3D;host（容器与主机享受相同的network namespace）会失效，此时需要指定对应的端口映射，-p 22122:22122 </p>
<h4 id="进入-tracker"><a href="#进入-tracker" class="headerlink" title="进入 tracker"></a>进入 tracker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it tracker /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h4><p><strong><code>/etc/nginx/conf/nginx.conf</code></strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">server <span class="punctuation">&#123;</span></span><br><span class="line">        listen       <span class="number">21000</span>;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>/etc/fdfs/client.conf</code></strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">tracker_server</span>=<span class="string">127.0.0.1:22122</span></span><br><span class="line"><span class="attr">......</span></span><br><span class="line"><span class="attr">http.tracker_server_port</span>=<span class="string">21000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>/etc/fdfs/tracker.conf</code></strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">port</span>=<span class="string">22122</span></span><br><span class="line"><span class="attr">......</span></span><br><span class="line"><span class="attr">http.server_port</span>=<span class="string">21000</span></span><br></pre></td></tr></table></figure>

<h3 id="设置Storage"><a href="#设置Storage" class="headerlink" title="设置Storage"></a>设置Storage</h3><h4 id="运行-storage"><a href="#运行-storage" class="headerlink" title="**运行 storage **"></a>**运行 storage **</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name storage --net=host -e TRACKER_IP=127.0.0.1:22122 -e GROUP_NAME=group1 morunchang/fastdfs sh storage.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">共享卷</span></span><br><span class="line">docker run -d --name storage --net=host -e TRACKER_IP=127.0.0.1:22122 -v /home/monochrome/app/fastdfs/storage:/data/fast_data -e GROUP_NAME=group1 morunchang/fastdfs sh storage.sh</span><br><span class="line"></span><br><span class="line">docker run -d --name storage -p 22000:22000 -p 23000:23000 -e TRACKER_IP=127.0.0.1:22122 -e GROUP_NAME=group1 morunchang/fastdfs sh storage.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">共享卷</span></span><br><span class="line">docker run -d --name storage -p 22000:22000 -p 23000:23000 -e TRACKER_IP=127.0.0.1:22122 -v /home/monochrome/app/fastdfs/storage:/data/fast_data -e GROUP_NAME=mono morunchang/fastdfs sh storage.sh</span><br></pre></td></tr></table></figure>

<h4 id="进入-storage"><a href="#进入-storage" class="headerlink" title="进入 storage"></a><strong>进入 storage</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it storage /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="修改端口-1"><a href="#修改端口-1" class="headerlink" title="修改端口"></a>修改端口</h4><p><strong><code>/etc/nginx/conf/nginx.conf</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       22000;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>/etc/fdfs/client.conf</code></strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">tracker_server</span>=<span class="string">127.0.0.1:22122</span></span><br><span class="line"><span class="attr">http.tracker_server_port</span>=<span class="string">21000</span></span><br></pre></td></tr></table></figure>

<p><strong><code>/etc/fdfs/storage.conf</code></strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">port</span>=<span class="string">23000</span></span><br><span class="line"><span class="attr">tracker_server</span>=<span class="string">127.0.0.1:22122</span></span><br><span class="line"><span class="attr">http.server_port</span>=<span class="string">22000</span></span><br></pre></td></tr></table></figure>

<h3 id="替换配置文件"><a href="#替换配置文件" class="headerlink" title="替换配置文件"></a>替换配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp nginx.conf tracker:/etc/nginx/conf/nginx.conf</span><br><span class="line">docker cp client.conf tracker:/etc/fdfs/client.conf</span><br><span class="line">docker cp tracker.conf tracker:/etc/fdfs/tracker.conf</span><br><span class="line"></span><br><span class="line">docker cp nginx.conf storage:/etc/nginx/conf/nginx.conf</span><br><span class="line">docker cp client.conf storage:/etc/fdfs/client.conf</span><br><span class="line">docker cp storage.conf storage:/etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure>

<h2 id="通过Spring-Boot使用FastDFS"><a href="#通过Spring-Boot使用FastDFS" class="headerlink" title="通过Spring Boot使用FastDFS"></a>通过Spring Boot使用FastDFS</h2><h3 id="导入Maven依赖"><a href="#导入Maven依赖" class="headerlink" title="导入Maven依赖"></a>导入Maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.tobato<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastdfs-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.27.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>详见作者GitHub：<a href="https://github.com/tobato/FastDFS_Client">https://github.com/tobato/FastDFS_Client</a></p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>FastDFS</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装与常用命令</title>
    <url>/2019/01/11/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><h4 id="卸载老版本的Docker"><a href="#卸载老版本的Docker" class="headerlink" title="卸载老版本的Docker"></a>卸载老版本的Docker</h4><p>　　在CentOS中，老版本Docker名称是<code>docker</code>或<code>docker-engine</code>，而Docker CE的软件包名称是<code>docker-ce</code>。因此，如已安装过老版本的Docker，需使用如下命令卸载。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<p>　　需要注意的是，执行该命令只会卸载Docker本身，而不会删除Docker存储的文件，例如镜像、容器、卷以及网络文件等。这些文件保存在<code>/var/lib/docker</code>目录中，需要手动删除。</p>
<span id="more"></span>
<h4 id="安装仓库"><a href="#安装仓库" class="headerlink" title="安装仓库"></a>安装仓库</h4><p>　　执行以下命令，安装Docker所需的包。其中，<code>yum-utils</code>提供了<code>yum-config-manager</code>工具；<code>device-mapper-persistent-data</code>及<code>lvm2</code>则是<code>devicemapper</code>存储驱动所需的包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
<p>　　执行如下命令，安装<code>stable</code>仓库。必须安装<code>stable</code>仓库，即使你想安装<code>edge</code>或<code>test</code>仓库中的Docker构建版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>　　[可选] 执行如下命令，启用<code>edge</code>及<code>test</code>仓库。<code>edge/test</code>仓库其实也包含在了<code>docker.repo</code>文件中，但默认是禁用的，可使用以下命令来启用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --enable docker-ce-edge    # 启用edge仓库</span><br><span class="line">sudo yum-config-manager --enable docker-ce-test    # 启用test仓库</span><br></pre></td></tr></table></figure>
<p>　　如需再次禁用，可加上<code>--disable</code>标签。例如，执行如下命令即可禁用<code>edge</code>仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --disable docker-ce-edge</span><br></pre></td></tr></table></figure>
<p>　　TIPS：从<code>Docker 17.06</code>起，<code>stable</code>版本也会发布到<code>edge</code>以及<code>test</code>仓库中。</p>
<h4 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h4><p>　　执行以下命令，更新yum的包索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>
<p>　　执行如下命令即可安装最新版本的Docker CE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure>
<p>　　在生产环境中，可能需要指定想要安装的版本，此时可使用如下命令列出当前可用的Docker版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list docker-ce.x86_64  --showduplicates | sort -r</span><br></pre></td></tr></table></figure>
<p>　　这样，列出版本后，可使用如下命令，安装想要安装的Docker CE版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce-&lt;VERSION&gt;</span><br></pre></td></tr></table></figure>
<p>　　启动Docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<p>　　验证安装是否正确。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<p>　　这样，Docker将会下载测试镜像，并使用该镜像启动一个容器。如能够看到类似如下的输出，则说明安装成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">b04784fba78d: Pull complete</span><br><span class="line">Digest: sha256:f3b3b28a45160805bb16542c9531888519430e9e6d6ffc09d72261b0d26ff74f</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://cloud.docker.com/</span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/engine/userguide/</span><br></pre></td></tr></table></figure>
<h4 id="升级Docker-CE"><a href="#升级Docker-CE" class="headerlink" title="升级Docker CE"></a>升级Docker CE</h4><p>　　如需升级Docker CE，只需执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>
<p>　　然后按照安装Docker的步骤，即可升级Docker。</p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p>　　CentOS 7安装Docker官方文档：<a href="https://docs.docker.com/install/linux/docker-ce/centos/">Docker for CentOS</a>，文档中还讲解了在CentOS 7中安装Docker CE的其他方式，本文不作赘述。</p>
<h3 id="shell一键安装"><a href="#shell一键安装" class="headerlink" title="shell一键安装"></a>shell一键安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>
<h2 id="Windows-docker-for-windows"><a href="#Windows-docker-for-windows" class="headerlink" title="Windows(docker for windows)"></a>Windows(docker for windows)</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>　　Windows 10 Professional 或 Windows 10 Enterprise X64 或Windows Home 10(Version 2004 or later，Windows Home can only run the WSL 2 backend)</p>
<p>　　对于Win 7 or 低版本Windows 10 Home，可使用Docker Toolbox（不建议使用）</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>　　前往<a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows">Docker for Windows 10</a>，下载安装包，双击即可安装。</p>
<h4 id="配置Table自动补全"><a href="#配置Table自动补全" class="headerlink" title="配置Table自动补全"></a>配置Table自动补全</h4><ol>
<li><p>启动一个的PowerShell（即以管理员身份运行）。搜索PowerShell，右键单击，然后选择以管理员身份运行。在PowerShell提示符下键入： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查策略设置是否正确，运行：<code>get-executionpolicy</code> ，应该返回RemoteSigned。</p>
</li>
<li><p>安装posh-dockerPowerShell模块以自动完成Docker命令，键入：<code>Install-Module posh-docker</code>或者，要仅为当前用户安装模块，键入： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Install-Module -Scope CurrentUser posh-docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完成后，只能为当前PowerShell启用自动完成功能，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Import-Module posh-docker</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h2><h3 id="阿里云加速器"><a href="#阿里云加速器" class="headerlink" title="阿里云加速器"></a>阿里云加速器</h3><p>　　注册阿里云账号后，进入<a href="https://cr.console.aliyun.com/#/accelerator">阿里云控制台</a>。<br>　　针对Docker客户端版本大于 1.10.0 的用户，可以通过修改daemon配置文件<code>/etc/docker/daemon.json</code>来使用加速器：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://arbzyqhz.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>　　以上内容转载自周立的Docker教程，<a href="http://www.itmuch.com/docker/02-docker-install/">Docker系列教程02-Docker安装(CentOS7&#x2F;Ubuntu&#x2F;macOS&#x2F;Windows)</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item1 考虑静态工厂方法代替构造方法</title>
    <url>/2018/12/06/Effective-Java-Item1-%E8%80%83%E8%99%91%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>一个类允许客户端获取他的一个实例的传统方法是提供一个公有的构造函数。除此之外，还有一个技术，每个程序员都应该掌握。就是一个类提供一个公有的静态工厂方法，这个方法就是一个简单的返回当前类一个实例的静态方法。这里有个来自于<strong>Boolean</strong>（对原生类型<strong>boolean</strong>的装箱）类内部实现的简单的例。下面的方法可以将一个原生<strong>boolean</strong>类型的值转变成一个对<strong>Boolean</strong>对象的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>请注意，上面这个静态工厂方法与设计模式[Gamma95]中的工厂方法模式并不一样。本条款所介绍的静态工厂方法在设计模式一书中并没有直接的等价物。  </p>
<p>除了公有构造方法外，类还可以向其客户端提供静态工厂方法。相比于公有构造方法来说，提供静态工厂方法有利也有弊。</p>
<p><strong>静态工厂方法其中一个好处是，它可以有自己的名字，而构造函数不行</strong>。如果构造函数的参数，他们本身并不能描述返回的对象，那么拥有恰当名字的静态工厂将会更加易于使用，所生成的客户端代码的可读性也更好。举个例子，通过构造函数<strong>BigInteger(int, int, Random)</strong> 返回一个值可能是质数的<strong>BigInteger</strong> 对象，还有更好的方法，就是通<strong>BigInteger.probablePrime</strong> 这个静态工厂方法来实现。（这个方法在java4时加入）</p>
<p>一个类只能有一个指定签名的构造函数。程序员们已经知道如何绕过这个限制了，那就是提供两个构造方法，<br>这两个构造方法之间唯一的差别就是参数列表中参数类型的顺序是不同的。<br>这是一个非常差劲的想法。像这样的API，使用者将永远不能够记住哪个构造函数是哪个的，最终会错误地调用错误的构造函数。<br>人们在读使用了这些构造函数的代码时，如果没有类说明文档，就没有办法知道这些代码是做什么的。</p>
<p>由于拥有名字，因此静态工厂方法不会遇到上面所讨论的限制。当一个类需要多个拥有相同签名的构造方法时，只需使用静态工厂方法来代替构造方法，<br>并精心选择好名字来明确他们之间的差别即可。</p>
<p><strong>静态工厂方法的第二个好处是，它不像构造函数那样，他不需要每次调用都创建一个新的对象</strong>。这样就可以让不变类使用预先构造好的实例，或是在构造时将其缓存起来，从而避免了创建不必要的重复对象的情况。<strong>Boolea.valueOf(boolean)</strong> 这个方法就论证了这个技术：它绝不会创建一个对象。这个技术非常像享元设计模式。如果相同的一个对象经常被请求而且创建这个对象的成本是昂贵的，那么静态工厂方法能极大地提高性能。</p>
<p>静态工厂方法可以在重复调用的情况下返回同一个对象的能力使得类可以在任何时候都能严格控制哪些实例可以存在<br>采取这种做法的类叫做实例控制。这里有几个理由去使用实例化控制的类。<br>实例化控制允许一个类可以保证他是单例的（条目3）或者不可实例化的（条目4）。此外，它允许不可变值类(条目17)保证没有两个相等的实例存在：<br>当且仅当a &#x3D;&#x3D; b时，a.equals(b)才为true。这是享元模式的基础[Gamma95]。<br>枚举类型(条目34)提供了此保证。</p>
<p><strong>静态工厂方法的第三个优点是，与构造函数不同，它们可以返回所声明的返回类型的任何子类型的对象</strong>。这样，在选择返回对象的类型时，给了你很大的灵活性。</p>
<p>这种灵活性的一个应用场景就是API能够在无需将类声明为公有的情况下就可以返回对象。以这种方式隐藏实现类使得API变得非常紧凑。这项技术也被应用到了基于接口的框架（条目20）中，其中接口就为静态工厂方法提供了自然而然的返回类型。</p>
<p>在Java 8之前，接口不能有静态方法。根据约定，针对名为Type的接口的静态工厂方法会被放到名为Types的不可实例化的伴生类（条目4）当中。Java集合框架有接口的45个辅助实现，提供了不可修改的集合、同步集合等等。几乎所有接口的实现都是通过一个不能实例化的类（<strong>java.util.Collections</strong>）的静态工厂方法提供的。返回对象的类型都是非公开的。</p>
<p>集合框架API要比它本来的样子小很多，它公开了了45个独立的公有类，每个类都针对于一个便捷的实现。这并不仅仅只是API的数量少了了，更为重要的是概念上的数量少了。程序员使用API所需掌握的概念的数量和难度都降低了。程序员知道所返回的对象是由其接口API所精确描述的，因此不需要读取额外的关于实现类的文档说明。使用这种静态工厂方法要求客户端引用接口而非实现类所返回的对象，这通常是很好的实践(条目64)。</p>
<p>在Java 8中，接口不能包含静态方法的限制被消除了，这样一般来说，我们就没必要再为接口提供不可实例化的伴生类了。很多本应该位于这种类中的公有静态成员现在应该放到接口自身当中了。不过，值得注意的是，我们还是需要将这些静态方法的实现代码放到单独的包级别的私有类中。这是因为Java 8要求接口的所有静态成员都是公共的。Java 9允许私有静态方法，但是静态字段和静态成员类仍然需要公开。</p>
<p><strong>静态工厂的第四个好处在于，作为输入参数的函数，返回对象所属的类会随着调用的不同而不同</strong>。所声明的返回类型的任何子类型都是允许的。返回对象所属的类也会随着调用的不同而不同</p>
<p>EnumSet类（条款36）没有公有的构造方法，只有静态工厂方法。在OpenJDK的实现当中，它返回其中两个子类中任意一个类的一个实例，这取决于底层枚举类型的大小：如果拥有的元素数量小于等于64个（这也是大多数枚举类型的情况），它的静态工厂方法会返回一个RegularEnumSet实例，其底层是个long类型。如果枚举类型拥有的元素数量大于等于65个，那么工厂返回一个JumboEnumSet实例，其底层是个long类型的数组。</p>
<p>这两个实现类的存在对客户端是透明的。如果RegularEnumSet不再为小型枚举类型提供性能优势，那么它可以在未来的版本中消除，不会有任何不良影响。类似地，将来的版本可以添加第三或第四个EnumSet 实现，只要这些实现被证明对性能有好处。客户端既不知道也不关心他们从工厂返回的对象的类型，它们只在乎它是EnumSet的某个子类就行。</p>
<p><strong>静态工厂的第五个好处在于，在使用包含了了方法的类时，返回对象所属的类不必事先存在。</strong>。这种灵活的静态工厂方法构成了服务提供者框架的基础，如Java 数据库连接API （JDBC）。服务提供者框架是这样一种系统，提供者实现了某个服务，系统将其实现公开给客户端，从而实现了客户端与实现之间的解耦。</p>
<p>服务提供者框架里有3个最基本的组件：</p>
<ul>
<li>服务接口，代表某一个实现。</li>
<li>提供者注册API，提供者通过它来注册实现 。</li>
<li>服务访问API，客户端通过它获取服务实例。</li>
</ul>
<p>客户端可以通过服务访问API来指定标准，从而选择相应的实现 。如果没有指定这样的一个标准，那么API返回一个默认实现的实例，或者允许客户端循环所有可得到的实例。服务访问API是灵活的静态工厂，它构成了服务提供者框架的基础。</p>
<p>服务提供者框架第四个可选的组件是服务提供者接口，它描述了一个生产服务接口实例的工厂对象。在缺少服务提供者接口的情况下，实现必须通过反射的方式去实例化 (项目65)。在JDBC的场景下，Connection扮演这服务接口的角色，DriverManager.registerDriver就是服务提供者注册API，DriverManager.getConnection就是服务访问API，Driver就是服务提供者接口。</p>
<p>服务提供者框架模式有许多变形。比如说，服务访问API可以向客户端返回比提供者所规定的更为宽泛的服务接口 。这就是桥接模式[Gamma95]。依赖注入框架(项目5)可以看作是强大的服务提供者。从Java 6开始，Java平台有一个通用的服务者提供框架，java.util.ServiceLoader，所以通常你不必，也不应该自己去写这个框架了(条目59)。JDBC并未使用ServiceLoader，因为前者出现的时间要更早一些。。</p>
<p><strong>只提供静态工厂方法的主要限制是没有公共或受保护构造函数的类不能被子类化</strong>。例如，在集合框架中不可能子类化任何方便实现类。可以说，这可能是因祸得福，因为它鼓励程序员使用组合而不是继承(条目18)，并且需要不可变类型(条目17)</p>
<p><strong>静态工厂方法的第二个缺点是，程序员很难找到它们</strong>。他们并不像构造方法那样在API文档中有清楚的说明，这样对于只提供静态工厂方法，而没提供构造方法的类来说，我们就很难知晓到底该用那种方式来实例化它。Javadoc工具可能有一天会引起对静态工厂方法的注意。与此同时，你可以多多注意到类或接口文档中的静态工厂并坚持使用常见的命名约定来减少此类问题的发生。下面是一些静态工厂方法的常用名称。这个列表并不是十分详尽:</p>
<ul>
<li>From —— 一种类型转换方法，它接受单个参数并返回该类型的相应实例，例如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> Date.from(instant);</span><br></pre></td></tr></table></figure></li>
<li>Of —— 一个聚合方法，它接受多个参数并返回该类型的实例，该实例包含了它们，例如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</span><br></pre></td></tr></table></figure></li>
<li>valueOf —— from与of的一种更加冗长的替代方案 ，例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">prime</span> <span class="operator">=</span> BigInteger.valueOf(Integer.MAX_VALUE);</span><br></pre></td></tr></table></figure></li>
<li>instance或者getInstance —— 返回一个实例，该实例由其参数(如果有)描述，但不能说具有相同的值，例如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StackWalker</span> <span class="variable">luke</span> <span class="operator">=</span> StackWalker.getInstance(options);</span><br></pre></td></tr></table></figure></li>
<li>create或者newInstance —— 跟instance和getInstance方法有点类似,期望方法能保证每次调用都返回新的实例，例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">newArray</span> <span class="operator">=</span> Array.newInstance(classObject, arrayLen);</span><br></pre></td></tr></table></figure></li>
<li>getType —— 有点像getInstance，但是，是在工厂方法在一个不同的类中时使用。Type就是工厂方法返回的对象类型，比如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileStore</span> <span class="variable">fs</span> <span class="operator">=</span> Files.getFileStore(path);</span><br></pre></td></tr></table></figure></li>
<li>newType —— 有点像newInstance，但是，是在工厂方法在一个不同的类中时使用。Type就是工厂方法返回的对象类型，比如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> Files.newBufferedReader(path);</span><br></pre></td></tr></table></figure></li>
<li>type ——  getType与newType的一个简洁的替代方案，比如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Complaint&gt; litany = Collections.list(legacyLitany);</span><br></pre></td></tr></table></figure>
总结来说，静态工厂方法和构造方法都有他们的用法，我们需要理解他们各自的优点。通常，静态工厂是优先选择的，这样可以避免习惯性地在没有考虑静态工厂的情况下就提供公有构造方法的情况发生 。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item0 引言</title>
    <url>/2018/12/06/Effective-Java-Item0-%E5%BC%95%E8%A8%80/</url>
    <content><![CDATA[<p>这本书的目的是帮助你高效地使用java这门编程语言和它的基本类库：java.lang ,  java.util, and java.io<br>和这些包子包下的：java.util.concurrent 和java.util.function 。其它的类库也会时不时地被讨论到。</p>
<p>这本书有90个小项，每一项都表达了一个准则。这些准则是由那些最优秀、最有经验的程序员总结出来的最佳实践。<br>这些小项松散地被分到11个章节下面，每个章节都涵盖了软件设计的一个广泛的方面。这本书不需要一页一页地读，每一项都是独立的，正正好好。<br>这些项目被大量交叉引用，因此您可以轻松地在书中计划自己的课程。</p>
<span id="more"></span>

<p>自从这本书第二版出版后，Java平台又增添了很多新特性。这本书大部分都或多或少地用到了这些特性。这张表向您展示了主要覆盖了的关键特性:</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>所在条目</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Lambdas</td>
<td>第42~44条</td>
<td>Java8</td>
</tr>
<tr>
<td>Streams</td>
<td>第45~48条</td>
<td>Java8</td>
</tr>
<tr>
<td>Optionals</td>
<td>第55条</td>
<td>Java8</td>
</tr>
<tr>
<td>Default methods in interfaces</td>
<td>第21条</td>
<td>Java8</td>
</tr>
<tr>
<td>try -with-resources</td>
<td>第9条</td>
<td>Java7</td>
</tr>
<tr>
<td>@SafeVarargs</td>
<td>第32条</td>
<td>Java7</td>
</tr>
<tr>
<td>Modules</td>
<td>第15条</td>
<td>Java9</td>
</tr>
</tbody></table>
<p>大多数项目都用程序示例进行说明的。<br>这本书的一个重要特点是它通过一些代码示例，来阐明许多设计模式和习惯用法。<br>在适当的情况下，它们被交叉引用到这个领域的标准参考工作[Gamma95]。</p>
<p>很多项目都包含了一个或多个程序示例，来说明有些行为是可以避免的。<br>这种例子，被称为反例，然后被清楚地加上了注释，如“Never do this!”。<br>在每种情况下，该项目解释了为什么这个例子不好，并提出了另一种方法。</p>
<p>这本书不适合初学者:它假定您已经熟悉Java。<br>因为effective java是为那些有这门语言工作经验的人阅读的，所以它应该给那些高级开发人员提供更高级的使用。</p>
<p>这本书中的大部分规则都源于一些基本原则。简单明了就是是很重要的原则之一。组件的使用者不会对它的行为感到惊讶。<br>组件应该尽可能地小，但又不能太小。（就像这本书中提到的，这里的术语“组件”是指可重用的软件元素，即从一个独立的方法到一个由多个模块组成的复杂的框架，<br>都可以被称为“组件”）。<br>代码应该能重复使用而不是到处复制。组建之间的依赖应该保持低耦合。代码在完成之后错误应该尽快被检测出来，最好是在编译时期。</p>
<p>虽然这本书中的规则并不是100%的适用，但在绝大多数情况下它们确实都是最佳的编程实践。<br>你不应该盲目地遵循这些规则，如果有充分的理由，你也可以不遵循这些规则。<br>学习编程的艺术，就跟其它大多数学科一样，先要学习规则，然后要知道什么时候去打破规则。</p>
<p>大部分情况下，这本书并没有涉及性能方面。它指导我们如何写出清晰的，正确的，可重用的，健壮的，可维护的代码。如果你能做到这点，那么提升你想要的性能就是一件相对简单的事情了(Item 67)。<br>有些项目确实讨论了所关心的性能问题，有些项目还给出了有关性能的数据。这些数据在被介绍时，都提前说明是在“我的机器上”。这种描述是被认为最恰当的。</p>
<p>当讨论Java编程语言的特性和它的类库时，有时候需要引用特定版本。为了方便起见，这本书用别名来指定官方版本名。<br>下面的表展示了官方版本名和别名之间的映射关系。</p>
<table>
<thead>
<tr>
<th>官方版本名</th>
<th>别名</th>
</tr>
</thead>
<tbody><tr>
<td>JDK 1.0.x</td>
<td>Java 1.0</td>
</tr>
<tr>
<td>JDK 1.1.x</td>
<td>Java 1.1</td>
</tr>
<tr>
<td>Java 2 Platform, Standard Edition, v1.2</td>
<td>Java 2</td>
</tr>
<tr>
<td>Java 2 Platform, Standard Edition, v1.3</td>
<td>Java 3</td>
</tr>
<tr>
<td>Java 2 Platform, Standard Edition, v1.4</td>
<td>Java 4</td>
</tr>
<tr>
<td>Java 2 Platform, Standard Edition, v5.0</td>
<td>Java 5</td>
</tr>
<tr>
<td>Java Platform, Standard Edition 6</td>
<td>Java 6</td>
</tr>
<tr>
<td>Java Platform, Standard Edition 7</td>
<td>Java 7</td>
</tr>
<tr>
<td>Java Platform, Standard Edition 8</td>
<td>Java 8</td>
</tr>
<tr>
<td>Java Platform, Standard Edition 9</td>
<td>Java 9</td>
</tr>
</tbody></table>
<p>书中的例子都已经相当完整了，但是比完整性跟重要的是可读性。程序员们大量地使用java.util和java.io包下的类。为了成功编译书中的示例，您可能需要添加一个或多个导入声明，或其他这样的样板文件。<br>这本书的网址上<a href="http://joshbloch.com/effectivejava">Effective Java</a>，包含了每个示例的一个完整版本，你可以下载下来编译并运行它。</p>
<p>大多数情况下，这本书里用到的技术术语都在Java SE 8这个版本的Java语言规范中定义的。其中有一些术语特别值得提出来。比如说，Java支持四种类型:接口(包括注解)、类(包括枚举)、数组和原生类型。前三种被称为引用类型。类的实例化和数组叫做对象，<br>而原生类型的值不是对象。类的成员包括它的字段、方法、成员类和成员接口。方法的签名包括它的名字和形参的类型；签名不包括方法的返回类型。</p>
<p>本书使用了一些与Java语言规范不同的术语。与Java语言规范不同，本书使用继承作为子类化的同义词。与使用术语继承来实现接口不同，这本书简单地说明了一个类实现了一个接口，或者一个接口继承了另一个接口。本书使用了传统的包私有的（package-private）访问级别，<br>而不是技术上正确的包访问（package access），来描述没有指定的访问级别。</p>
<p>这本书用到了一些《Java语言规范》没有定义的技术术语。API暴露出的术语(简称API)指程序员访问类、接口或包里面的的类、接口、构造函数、成员和序列化形式。术语API是application programming interface的简称，它更倾向于使用其他更好的术语接口，<br>以避免与该名称的语言结构混淆。编写使用API的程序的程序员被称为API的用户。通过API来实现的类叫做API的客户端。</p>
<p>类、接口、构造函数、成员和序列化形式统称为API元素。<br>一个暴露出来的API是由可以在定义该API的包外访问到的API元素组成。这些API元素可以给任意客户端使用，并且API的作者提供支持。不凑巧的是，它们也是Javadoc实用程序在其默认的操作模式中生成文档的元素。宽泛地说，一个包的对外API由公共和受保护的成员和包中的每个公共类或接口的构造函数组成。<br>在Java9中，模块系统被添加到平台里。如果一个库使用了模块系统，它对外的API是该模块系统声明对外包下的对外API的联和。<br>最后，提供一下<a href="https://github.com/jbloch/effective-java-3e-source-code">Effective Java源码</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item4 通过私有的构造方法来阻止类的实例化</title>
    <url>/2018/12/06/Effective-Java-Item4-%E9%80%9A%E8%BF%87%E7%A7%81%E6%9C%89%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9D%A5%E9%98%BB%E6%AD%A2%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96/</url>
    <content><![CDATA[<p>有时，你想要编写一个只包含一组静态方法和静态字段的类。这种类有一个不太好的名声，因为有些人会滥用他们，不从对象的角度来思考，而是坚信他们的想法是正确无误的 。他们可以把原生类型的值或数组相关的方法分一组，就像<code>java.lang.Math</code>或<code>java.util.Arrays</code>的方式。还可以将静态方法划分到一起，包括工厂（Item 1），用于实现了某个接口的对象，就想<code>java.util.Collections</code>一样。（从Java 8开始，如果想要自己修改，那么你还可以将这类方法放到接口中）最后，还可以将针对终态类的方法划分到一起，因为你无法再将他们放到子类中了 。</p>
<span id="more"></span>

<p>把这样的公共类设计成不可实例化，是因为它的实例化是没有意义地。然而，在没有显式构造函数的情况下，编译器提供一个公共的、无参数的默认构造函数。对使用者来说，这个构造函数跟其它的没什么区别。我们常常会在已发布的APIs中看到无意中被实例化的类 。</p>
<p><strong>通过将一个类设置为抽象类来强制禁止类的实例化是行不通的</strong>。这个抽象类可以有子类，然后子类可以实例化。而且这会误导使用者去想要去设计一个类，然后继承这个抽象类（Item 19）。然后这里有一个简单的做法来保证非实例化。只有在类不包含显示构造函数时候，默认的构造函数才会生成。所以，一个类可以通过提供私有的构造函数来做到非实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Noninstantiable utility class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UtilityClass</span> &#123;</span><br><span class="line">    <span class="comment">// Suppress default constructor for noninstantiability</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">UtilityClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为显示指定构造函数是私有的，所有无法在类外面访问到。<code>AssertionError</code>不是必须的，但它提供了一个保障，防止构造函数在类的内部被意外调用。它保证了类在任何情况都不会被实例化。这种做法有点反常识，因为提供构造方法的目的仅仅是为了自己不能被调用 。所以，更好的做法则是加上一些注释说明，正如上述代码所做的那样。</p>
<p>这样做的副作用是，阻止了类被子类化。所有构造函数都必须显式或隐式地调用父类构造函数，但是子类将没有可访问的父类构造函数来调用。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item2 当遇到许多构造方法参数时，考虑构建器</title>
    <url>/2018/12/06/Effective-Java-Item2-%E5%BD%93%E9%81%87%E5%88%B0%E8%AE%B8%E5%A4%9A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%97%B6%EF%BC%8C%E8%80%83%E8%99%91%E6%9E%84%E5%BB%BA%E5%99%A8/</url>
    <content><![CDATA[<p>静态工厂和构造函数有一个共同的限制:它们不能很好地扩展到大量可选参数。考虑一个代表包装食品上出现的营养成分标签的类的例子。这些标签有一些必要的字段，如分量大小、每瓶容量以及每份的卡路里里数，以及超过20个可选的字段——总脂肪，饱和脂肪，反式脂肪，胆固醇，钠，等等。大多数产品只有少数几个可选字段的值为非零值。</p>
<span id="more"></span>

<p>对于这样一个类来说，你应该编写哪种构造方法或是静态工厂呢？传统上，程序员们会使用重叠构造方法模式，在这种模式中，您只提供了一个只有必需参数的构造函数，然后编写一个接收单个可选参数的构造方法，再编写一个接收两个可选参数的构造方法，以此类推，最后提供一个接收所有可选参数的构造方法。如下代码示例例就说明了了这一点。出于简洁的目的，这里只给出了4个可选字段：</p>
<figure class="highlight java"><figcaption><span>NutritionFacts.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Telescoping constructor pattern - does not scale well!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize; <span class="comment">// (mL) required</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings; <span class="comment">// (per container) required</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories; <span class="comment">// (per serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat; <span class="comment">// (g/serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium; <span class="comment">// (mg/serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate; <span class="comment">// (g/serving) optional</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> calories)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, calories, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> calories, <span class="type">int</span> fat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, calories, fat, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> calories, <span class="type">int</span> fat, <span class="type">int</span> sodium)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(servingSize, servings, calories, fat, sodium, <span class="number">0</span>);</span><br><span class="line">    &#125;                                                            </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> calories, <span class="type">int</span> fat, <span class="type">int</span> sodium, <span class="type">int</span> carbohydrate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.servingSize = servingSize;</span><br><span class="line">        <span class="built_in">this</span>.servings = servings;</span><br><span class="line">        <span class="built_in">this</span>.calories = calories;</span><br><span class="line">        <span class="built_in">this</span>.fat = fat;</span><br><span class="line">        <span class="built_in">this</span>.sodium = sodium;</span><br><span class="line">        <span class="built_in">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当您想要创建一个实例时，您可以使用包含您想要设置的所有参数的最短参数列表的构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NutritionFacts</span> <span class="variable">cocaCola</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>(<span class="number">240</span>, <span class="number">8</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">35</span>, <span class="number">27</span>);</span><br></pre></td></tr></table></figure>

<p>通常，这个构造函数调用需要许多您不想设置的参数，但是您必须为它们传递一个值。在本例中，我们传递了一个值为0的<code>fat</code>。“只有”6个参数可能看起来不那么糟糕，但是随着参数数量的增加，很快你就数不过来了。</p>
<p><strong>简而言之，构造函数模式是有效的，但是当有许多参数时，客户端的代码很难写，而且可读性更差</strong>。读者不知道这些值是什么意思，必须仔细地计算参数的个数来找出答案。长长的同类型参数序列会导致非常隐秘的Bug。。如果客户端不小心将两个这样的参数位置颠倒，编译器是不会报错的，但是程序在运行时将会出错(Item 51)。</p>
<p>当你遇到一个构造函数中有许多可选参数时，第二个替代方法是<strong>JavaBeans</strong>模式，在这个模式中，你调用一个无参数的构造函数来创建对象，然后调用<strong>setter</strong>方法来设置每个必需的参数和每个可选的参数:</p>
<figure class="highlight java"><figcaption><span>NutritionFacts.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaBeans Pattern - allows inconsistency, mandates mutability</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="comment">// Parameters initialized to default values (if any)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">servingSize</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// Required; no default value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">servings</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// Required; no default value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">calories</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fat</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sodium</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">carbohydrate</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// Setters</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServingSize</span><span class="params">(<span class="type">int</span> val)</span> &#123; servingSize = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServings</span><span class="params">(<span class="type">int</span> val)</span> &#123; servings = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCalories</span><span class="params">(<span class="type">int</span> val)</span> &#123; calories = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFat</span><span class="params">(<span class="type">int</span> val)</span> &#123; fat = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSodium</span><span class="params">(<span class="type">int</span> val)</span> &#123; sodium = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCarbohydrate</span><span class="params">(<span class="type">int</span> val)</span> &#123; carbohydrate = val; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模式没有重叠构造函数模式的缺点。通过这种方式可以轻松创建实例例（就是稍微有点冗长），并且代码读起来也比较容易：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NutritionFacts</span> <span class="variable">cocaCola</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>();</span><br><span class="line">cocaCola.setServingSize(<span class="number">240</span>);</span><br><span class="line">cocaCola.setServings(<span class="number">8</span>);</span><br><span class="line">cocaCola.setCalories(<span class="number">100</span>);</span><br><span class="line">cocaCola.setSodium(<span class="number">35</span>);</span><br><span class="line">cocaCola.setCarbohydrate(<span class="number">27</span>);</span><br></pre></td></tr></table></figure>

<p>不幸的是，JavaBeans模式本身有严重的缺点。由于构造方法在多个调用中被拆分，所以JavaBean可能在其构建过程中处于不一致的状态。仅仅通过检查构造函数参数的有效性，该类没法实现一致性。在不一致的状态下尝试使用对象可能会导致与包含bug的代码相去甚远的错误，因此很难进行调试。与此相关的一个缺点是，JavaBeans模式排除了使类不可变的可能性(见Item 17)，并要求程序员为确保线程安全而增加工作。</p>
<p>当构造完毕时，我们可以通过手工『冻结』对象并且直到冻结后才允许使用对象来消除这些缺陷，不过这种做法很少使用。此外，这么做会导致运行期错误，因为编译器无法确保程序员在使用对象前会调用对象的冻结方法。</p>
<p>幸运的是，还有第三种选择，它将伸缩构造函数模式的安全性与JavaBeans模式的可读性相结合。它就是构建器模式的形式。客户端调用一个构造方法（或是静态工厂），并附上它需要的参数来获得一个构建器对象，来代替直接创造所需的目标对象。然后客户端调用构建起对象上的类似setter的方法去设置每一个感兴趣的可选的参数。最后，客户端调用无参的build方法去生成目标对象，通常它是不可变的。一般来说，这个构建器类是它构建的类的静态成员类。在实践中它通常看起来就是下面的样子：</p>
<figure class="highlight java"><figcaption><span>NutritionFacts.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Builder Pattern</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="comment">// Required parameters</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">        <span class="comment">// Optional parameters - initialized to default values</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">calories</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fat</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sodium</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">carbohydrate</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="built_in">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">calories</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">        &#123; calories = val; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">fat</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">        &#123; fat = val; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">sodium</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">        &#123; sodium = val; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">carbohydrate</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">        &#123; carbohydrate = val; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> NutritionFacts <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NutritionFacts</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        servingSize = builder.servingSize;</span><br><span class="line">        servings = builder.servings;</span><br><span class="line">        calories = builder.calories;</span><br><span class="line">        fat = builder.fat;</span><br><span class="line">        sodium = builder.sodium;</span><br><span class="line">        carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NutritionFacts</code>类是不可变的，所有参数默认值都在一个位置。构建器的<code>setter</code>方法返回构建器本身，这样调用就可以链接起来，形成一种流式API 。客户端代码是这样的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NutritionFacts</span> <span class="variable">cocaCola</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>.Builder(<span class="number">240</span>, <span class="number">8</span>)</span><br><span class="line">                            .calories(<span class="number">100</span>)</span><br><span class="line">                            .sodium(<span class="number">35</span>)</span><br><span class="line">                            .carbohydrate(<span class="number">27</span>)</span><br><span class="line">                            .build();</span><br></pre></td></tr></table></figure>

<p>该客户端代码易于编写，更重要的是易于阅读。构建器模式模拟了在Python和Scala中找到的命名可选参数。</p>
<p>为简便起见，省略了有效性检查。要检查构建器的构造函数和方法中的参数有效性，为了尽快检查出无效参数。检查<code>build</code>方法调用的构造函数中涉及多个参数的不变量。要确保这些不变量没被篡改，请在复制构造器参数(Item 50)之后对对象字段进行检查。如果检查失败，会抛出一个<code>IllegalArgumentException</code>（Item 72），它的详细消息会指示出哪些参数无效(Item 75)。</p>
<p>构建器模式非常适合类的层次结构。使用并行的构建器层次结构，每个构建器嵌套在相应的类中。抽象类有抽象的构建器;具体类有具体的构建器。例如，将一个抽象类当做代表了不同种类披萨的层次结构的根类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Builder pattern for class hierarchies</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Topping</span> &#123; HAM, MUSHROOM, ONION, PEPPER, SAUSAGE &#125;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;Topping&gt; toppings;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Builder</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">addTopping</span><span class="params">(Topping topping)</span> &#123;</span><br><span class="line">            toppings.add(Objects.requireNonNull(topping));</span><br><span class="line">            <span class="keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">abstract</span> Pizza <span class="title function_">build</span><span class="params">()</span>;</span><br><span class="line">        <span class="comment">// Subclasses must override this method to return &quot;this&quot;</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">self</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pizza(Builder&lt;?&gt; builder) &#123;</span><br><span class="line">        toppings = builder.toppings.clone(); <span class="comment">// See Item 50</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>Pizza.Builder</code>是个泛型类型，它有一个递归的类型参数（Item 30）。通过该参数以及抽象的<code>self</code>方法可以让方法在子类中恰当地链接起来，而无需进行类型转换。这种对于Java缺乏自我类型问题的解决方案叫做模拟的自我类型。</p>
<p>这里有两个具体的披萨子类，一个是标准的纽约风格披萨，另一个是奶酪馅饼式披萨。前者有一个必填的<code>size</code>参数 ，而后者可以让你指定酱汁是在里面还是在外面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NyPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span> &#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span>.Builder&lt;Builder&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(Size size)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.size = Objects.requireNonNull(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="keyword">public</span> NyPizza <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NyPizza</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="keyword">protected</span> Builder <span class="title function_">self</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NyPizza</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(builder);</span><br><span class="line">        size = builder.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calzone</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> sauceInside;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span>.Builder&lt;Builder&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">sauceInside</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Default</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">sauceInside</span><span class="params">()</span> &#123;</span><br><span class="line">            sauceInside = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Calzone <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Calzone</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Builder <span class="title function_">self</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Calzone</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(builder);</span><br><span class="line">        sauceInside = builder.sauceInside;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意每个子类的<code>builder</code>的<code>build()</code>方法都被声明成返回一个具类： <code>NyPizza.Builder</code>的<code>build</code>方法返回<code>NyPizza</code>类，而<code>Calzone.Builder</code>的<code>build</code>方法返回<code>Calzone</code>类，这种子类方法返回父类中声明的返回类型的子类型的技术，称为协变返回类型 。它允许客户端使用这些构建器，而不需要强制转换。</p>
<p>这些“层次化的构建器”的客户端代码本质上等价于简单的<code>NutritionFacts</code>的构建器的代码。如下的示例客户端代码假设已经静态导入了枚举常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NyPizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NyPizza</span>.Builder(SMALL)</span><br><span class="line">                    .addTopping(SAUSAGE)</span><br><span class="line">                    .addTopping(ONION)</span><br><span class="line">                    .build();</span><br><span class="line"><span class="type">Calzone</span> <span class="variable">calzone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calzone</span>.Builder()</span><br><span class="line">                    .addTopping(HAM)</span><br><span class="line">                    .sauceInside()</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure>

<p>与构造函数相比，构建器的一个小小的优势是，构建器可以有多个可变的参数，因为每个参数都在自己的方法中指定。或者，构建器可以把多次调用所需要的参数聚合到一个方法里的一个单一字段上，正如前面<code>addTopping</code>方法所展示的那样。</p>
<p>构建器模式非常灵活。一个构建器可以重复使用建立多个对象。构建器的参数可以在调用构建方法时进行调整，以改变创建的对象。构建器可以在对象创建时自动填充一些字段，比如说每次创建一个对象时递增的序列号等。</p>
<p>构建器模式也有缺点。为了能创建一个对象，你必须先创建它的构建器。虽然创建这个构建器的成本在实践中不太可能被注意到，但是在对性能要求很高的场景下这可能是个问题。此外，构建器模式比可伸缩构造器模式更加冗长，因此，只有当有足够多的参数时，使用它才有价值，比如4个以上的参数时。但如果一开始使用的是构造方法或是静态工厂，当参数量变得很多时，想要切换到构建器，那么显而易见，会遗留很多废弃的构造方法或是静态工厂。因此，更好的做法则是一开始就使用构建器器。</p>
<p>总之，在设计类时，如果类的构造方法或是静态工厂有很多参数，那么构建器模式是一个很好的选择，特别是如果许多参数是可选的或类型相同的情况下更是如此。 与重叠构造函数相比，使用构建器模式的客户端代码更容易读写，而且构建器比JavaBeans要安全得多。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item3 通过私有的构造方法或者一个枚举类型来使用单例属性</title>
    <url>/2018/12/06/Effective-Java-Item3-%E9%80%9A%E8%BF%87%E7%A7%81%E6%9C%89%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E4%B8%80%E4%B8%AA%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E4%BD%BF%E7%94%A8%E5%8D%95%E4%BE%8B%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p><strong>单例</strong>对象是一个仅仅只会实例化一次的类。单例对象通常表示一个无状态对象，例如一个函数(Item 24)或一个本质上惟一的系统组件。<strong>使类成为单例会使测试它的客户端变得困难</strong>，因为不可能用模拟实现代替单例，除非它实现一个接口作为它的类型。</p>
<span id="more"></span>
<p>实现单例有两种常见的方法。两者都基于保持构造函数为私有，并对外提供公共静态成员以提供对唯一实例的访问。在第一种方式中，成员是个<code>final</code>字段:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singleton with public final field</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**只调用私有构造函数一次，以初始化公共静态<code>final</code>字段<code>Elvi.instance</code>**。不提供公有的或者受保护的构造函数保证了全局“唯一性”：当Elvis类初始化的时候，仅仅只会有一个<code>Elvis</code>实例存在——不多也不少 。无论客户端怎么做都无法改变这一点，只不过我还是要警告一下 ：授权的客户端可以通过反射来调用私有构造方法（Item 65），借助于<code>AccessibleObject.setAccessible</code>方法即可做到 。如果需要防范这种攻击，请修改构造函数，使其在被要求创建第二个实例时抛出异常。</p>
<p><strong>第二种实现单例模式的方法是，提供一个公有的静态工厂方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singleton with static factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有调用<code>Elvis</code>类的<code>getInstance</code>方法，返回相同的对象引用，并且不会有其它的<code>Elvis</code>对象被创建。（但同样有上面提到的警告）</p>
<p>公共字段方法的主要优点是，通过API我们就可以很清晰地看到类是个单例 ：<code>public static</code>字段是<code>final</code>的，所以它将始终包含相同的对象引用。 第二个优点是它更简单。静态工厂方法的一个优点是它可以让你灵活地改变你的想法，即当你想要改变类的单例特性时，你无需修改其API 。工厂方法返回唯一的实例，但可以修改它，使得每个线程调用它时都返回一个单独的实例。所以，如果你的项目需要，你可以定义一个通用的单例工厂。使用静态工厂方法最后一个好处就是，方法引用可以当做一个提供者，例如，<code>Elvis::instance</code>就是一个<code>Supplier&lt;Elvis&gt;</code>的实例。除非上述这些好处存在一定程度的相关性 ，不然提供公有字段的方法更适合。</p>
<p>要想让上述两种方式实现的单例类能够序列化（Chapter 12），仅仅在声明中添加实现Serializable接口是不够的。为了保证单例，将所有实例字段声明为<code>transient</code>，并提供一个<code>readResolve</code>方法(Item 89)。否则，每次反序列化一个序列化的实例时，都会创建一个新的实例，在我们的示例中，就会出现另一个<code>Elvise</code>。为了阻止这样的事发生，给<code>Elvis</code>类添加一个<code>readResolve</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readResolve method to preserve singleton property</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return the one true Elvis and let the garbage collector</span></span><br><span class="line">    <span class="comment">// take care of the Elvis impersonator.</span></span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三种实现单例的方式是，声明一个单元素的枚举类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法跟提供公有的字段方法很类似，但它更简洁，提供天然的可序列化机制和能够强有力地保证不会出现多次实例化的情况 ，甚至面对复杂的序列化和反射的攻击下。这种方法可能看起来不太自然，但是<strong>拥有单元素的枚举类型可能是实现单例模式的最佳实践</strong>。注意，如果单例必须要继承一个父类而非枚举的情况下是无法使用该方式的（不过可以声明一个实现了接口的枚举）。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item5 优先使用依赖注入而非硬编码资源的关联关系</title>
    <url>/2018/12/07/Effective-Java-Item5-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%80%8C%E9%9D%9E%E7%A1%AC%E7%BC%96%E7%A0%81%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>很多类都会依赖于一个或多个底层资源。比如说，拼写检查器会依赖于字典。我们常常会看<br>到这种类被实现为了静态辅助类（Item 4）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inappropriate use of static utility - inflexible &amp; untestable!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpellChecker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lexicon</span> <span class="variable">dictionary</span> <span class="operator">=</span> ...;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SpellChecker</span><span class="params">()</span> &#123;&#125; <span class="comment">// Noninstantiable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String word)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">suggestions</span><span class="params">(String typo)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>同样地，将他们以单例的形式来实现也很常见(Item 3)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inappropriate use of singleton - inflexible &amp; untestable!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpellChecker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lexicon</span> <span class="variable">dictionary</span> <span class="operator">=</span> ...;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SpellChecker</span><span class="params">(...)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpellChecker</span>(...);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String word)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">suggestions</span><span class="params">(String typo)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方法都不令人满意，因为它们假定只有一个字典值得使用。实际上，每种语言都有自己的字典，特殊的字典用于特殊的词汇表。此外，我们还需要一个特殊的字典用于测试。想当然地认为一本字典就足够了，这是一厢情愿的想法。</p>
<p>你可以尝试让<strong>拼写检查器</strong>支持多个字典，方法是使<code>dictionary</code>字段成为非<code>final</code>类型，并在现有的拼写检查器中添加一个方法来更改<code>dictionary</code>的引用，不过这么做有些笨拙、易出错，并且在并发设置下无法正常工作。<strong>如果一个类的行为是通过底层资源来参数化的，那么静态辅助类与单例就不适合这种情况</strong>。</p>
<p>我们所需要的是支持类的多个实例的能力(在我们的例子中，<code>SpellChecker</code>)，每个实例都使用客户机所希望的资源(在我们的例子中，是字典)。满足此需求的一个简单模式是在<strong>创建新实例时将资源传递给它的构造函数</strong>。这是依赖注入的一种形式：字典是拼写检查器器的依赖，在创建拼写检查器时会将字典注入到其中 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dependency injection provides flexibility and testability</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpellChecker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lexicon dictionary;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SpellChecker</span><span class="params">(Lexicon dictionary)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.dictionary = Objects.requireNonNull(dictionary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String word)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">suggestions</span><span class="params">(String typo)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依赖注入模式如此简单，以至于许多程序员使用了多年，却不知道它的名字。 虽然我们的拼写检查的示例只有一个资源(字典)，但是依赖项注入可以处理任意数量的资源和任意依赖图。它保持了不可变性(Item 17)，因此多个客户机可以共享依赖对象(假设客户机需要相同的底层资源)。依赖项注入同样适用于构造函数、静态工厂(Item 1)和构建器(Item 2)。</p>
<p>这个模式的有一个有用的变换是将资源工厂传递给构造函数。工厂是一个对象，可以反复调用它来创建同一类型的实例。这些工厂体现了一种设计模式，即<strong>工厂方法模式</strong>。Java 8中引入的<code>Supplier&lt;T&gt;</code>接口非常适合表示工厂。将<code>Supplier&lt;T&gt;</code>作为输入的方法会通过绑定的<strong>通配符类型</strong>（item 31）来限制工厂的类型参数。比如说，如下方法会通过客户端提供的用于生成每个瓷砖的工厂来创建一个马赛克：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mosaic <span class="title function_">create</span><span class="params">(Supplier&lt;? extends Tile&gt; tileFactory)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>尽管依赖注入极大地提高了灵活性和可测试性，但它可能会使大型项目变得混乱，而大型项目通常包含数千个依赖项。如果我们使用依赖注入框架(如Dagger [Dagger]、Guice [Guice]或Spring [Spring])，几乎可以消除这种混乱。这些框架的使用介绍超出了本书的范围，不过请注意，针对手工进行依赖管理所设计的APIs也是适合于这些框架的 。</p>
<p>总结一下，如果一个类依赖于一个或多个底层资源，而这些资源的行为会影响到类的行为，那么请不要使用单例或是静态辅助类来实现，也不要让类直接创建这些资源。替代的方法是，将该资源或生产这个资源的工厂传递给构造方法(或者是静态工厂或者是构建器)。这种实践叫做依赖注入，它会极大增强类的灵活性、重用性与可测试性。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item7 消除废弃的对象引用</title>
    <url>/2018/12/07/Effective-Java-Item7-%E6%B6%88%E9%99%A4%E5%BA%9F%E5%BC%83%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>如果您从使用手动管理内存的语言(如C或c++)切换到使用垃圾收集语言(如Java)，那么你作为程序员的工作就会变得容易得多，因为你的对象在使用完后会自动被回收。 当你第一次体验这种编程的时候，它看起来就像是魔术一般。它很容易给人留下这样的印象：你不必考虑内存管理，但这并不完全正确。 </p>
<span id="more"></span>

<p>思考下面这个简单的堆栈实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Can you spot the &quot;memory leak&quot;?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;</span><br><span class="line">   		elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Ensure space for at least one more element, roughly</span></span><br><span class="line"><span class="comment">    * doubling the capacity each time the array needs to grow.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">        	elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序并没有明显的错误（不过请查看Item 29来了解更加通用的版本）。你可以不断测试该程序，程序也会顺利通过每个测试，不过有一个潜伏的问题。大致来说，该程序存在一处『内存泄露』，其性能会逐步降低，这是因为不断增加的垃圾收集器活动与内存占用问题。在极端情况下，这种内存泄露会导致磁盘分页，甚至会因<code>OutOfMemoryError</code>造成程序失败，不过这种失败的情况是非常少见的。</p>
<p>所以，内存泄漏在哪呢？如果栈不断增长，然后再收缩，那么出站的数据并不会被垃圾回收。即便使用了栈的程序不再引用他们亦如此。这是因为堆栈维护着对他们的<em><strong>过时的引用</strong></em>。废弃的引用指的是永远不会被解引用的引用。在该示例中，位于元素数组『活动部分』之外的任何引用都是废弃的。活动部分包含了索引小于<code>size</code>的元素。</p>
<p>垃圾收集语言中的内存泄露（更恰当的叫法是无意的对象保持）是非常不易察觉的。如果对象引用被无意保持了，那么不仅该对象会从垃圾收集中排除出去，该对象所引用的其他对象也会被排除出去，以此类推。即便只有少量的对象引用被无意保持了，造成的后果就是会有很多、很多对象会从垃圾收集中排除出去，这会对性能造成很严重的影响。</p>
<p>这类问题的解决方案很简单：一旦引用变成废弃状态，立刻将其置为<code>null</code>。对于我们的<code>Stack</code>类来说，如果元素从栈中弹出，那么对其的引用就变成废弃状态了。<code>pop</code>方法的正确版本如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> elements[--size];</span><br><span class="line">    elements[size] = <span class="literal">null</span>; <span class="comment">// Eliminate obsolete reference</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将过时的引用指向<code>null</code>的另一个好处是，如果他们后面被错误地取消引用了，程序会立刻报<code>NullPointerException</code>的错误，而不是静静地做错误的事情。尽可能快地发现程序的错误总是有益的。</p>
<p>当程序员初次遇到这个问题时，他们会采取矫枉过正的措施：当程序使用完对象后，会将每个对象引用都设为<code>null</code>。这么做既没必要，也不值得；它会毫无必要地将程序搞乱。取消对象引用应该是例外而不是规范。消除废弃引用的最佳方式是让包含了引用的变量离开作用域。如果在最小的作用域内定义每个变量，那么这就是自然而然的事情了（Item 57）。</p>
<p>那么应该在何时将引用置为<code>null</code>呢？<code>Stack</code>类的哪个地方使得它容易出现内存泄露问题呢？简而言之，它来管理自己的内存。存储池包含了<code>elements</code>数组的元素（对象引用单元，而非对象自身）。位于数组活跃部分中的元素（如之前所定义的那样）会被分配，而数组其他部分的元素则是空闲的。垃圾收集器并不知晓这一点；对于垃圾收集器器来说，<code>elements</code>数组中的所有对象引用都是有效的。程序员可以与垃圾收集器就这个事实进行高效的沟通，方式是当数组元素进入到非活跃部分中时就立刻将其手工置为<code>null</code>。</p>
<p>一般来说，<strong>当类管理自己的内存时，程序员应该警惕内存泄露问题</strong>。当元素释放时，包含在该元素中的任何对象引用都应该被置为<code>null</code>。</p>
<p><strong>另一个常见的内存泄漏源是缓存</strong>。一旦将对象引用放入缓存中，就很容易忘记它的存在，然后当缓存失效后它就会一直在那儿。这里有几个解决该问题的办法。如果实现了一个缓存，只要缓存外有引用指向缓存的键，缓存就处于有效状态时，那么缓存就可以使用<code>WeakHashMap</code>来表示;当变为废弃状态时，缓存中的条目就会自动移除。请记住，只有在缓存条目的生命周期是由对其键（而非值）的外部引用所决定时，<code>WeakHashMap</code>才是适合的。</p>
<p>更为常见的情况则是，缓存条目的生命周期不是那么明确的，随着时间的流逝，缓存条目的价值也变得越来越低。在这些情况下，我们应该适时清理那些不再使用的缓存条目。这可以通过后台线程（也许是<code>ScheduledThreadPoolExecutor</code>）来实现，或是在将新的条目添加到缓存中时顺便完成。<code>LinkedHashMap</code>类通过其<code>removeEldestEntry</code>方法可以简化后者的操作。对于更加复杂的缓存来说，你可能需要直接使用<code>java.lang.ref</code>。</p>
<p><strong>内存泄漏的第三个常见来源是监听器和其他回调</strong>。如果实现了一个API，客户端在该API上注册了回调，但却没有显式取消注册，那么他们就会不断累积，除非采取一些行动。确保回调会立刻被垃圾收集的一种方式是只存储对其的弱引用，比如说，在<code>WeakHashMap</code>中只将其以键的形式存储。</p>
<p>由于内存泄露通常并不会导致立刻失败，因此它们可能会在系统中保留多年。他们通常是通过精心的代码检查或是借助于调试工具（<strong>heap profiler</strong>）的帮助才能发现。因此，你需要学习如何在内存泄露出现前就能预测到问题，并防止他们发生。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item10 覆盖equals时请遵守通用约定</title>
    <url>/2018/12/10/Effective-Java-Item10-%E8%A6%86%E7%9B%96equals%E6%97%B6%E8%AF%B7%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h2><p>　　尽管<code>Object</code>是一个具体类，但是设计它主要是为了扩展。它所有的非<code>final</code>方法(<code>equals</code>、<code>hashCode</code>、<code>toString</code>、<code>clone</code>和<code>finalize</code>)都有明确的通用约定（**<code>general contract</code>**）,因为它们被设计成是要被覆盖（<code>override</code>）的。任何一个类，它在覆盖这些方法的时候，都有责任遵守这些通用约定；如果不能做到这一点，其他依赖于这些约定的类（例如<code>HashMap</code>和<code>HashSet</code>）就无法结合该类一起正常运作。</p>
<p>　　本章将讲述何时以及如何盖这些非<code>final</code>的<code>Object</code>方法。本章不再讨论<code>finalize</code>方法，因为Item 8已经讨论过这个方法了。而<code>Comparable.compareTo</code>虽然不是<code>Object</code>方法，但是本章也对它进行讨论，因为它具有类似的特征。</p>
<span id="more"></span>

<h3 id="Item-10：覆盖equals时请遵守通用约定"><a href="#Item-10：覆盖equals时请遵守通用约定" class="headerlink" title="Item 10：覆盖equals时请遵守通用约定"></a>Item 10：覆盖<code>equals</code>时请遵守通用约定</h3><p> 　　覆盖<code>equals</code>方法看起来似乎很简单，但是有许多覆盖方式会导致错误，并且后果非常严重。最容易避免这类问提的办法就是不覆盖<code>equals</code>方法，在这种情况下，类的每个实例都只与它自身相等。如果满足了以下任何一个条件，这就正是所期望的结果：</p>
<ul>
<li><p><strong>类的每个实例本质上都是唯一的</strong>。对于代表活动实体而不是值(<code>value</code>)的类来说确实如此，例如<code>Thread</code>。<code>Object</code>的<code>equals</code>实现对于这些类来说正是正确的行为。  </p>
</li>
<li><p><strong>不关心类是否提供了“逻辑相等(<code>logical equality</code>)”的测试功能</strong>。例如，<code>java.util.Random</code>覆盖了<code>equals</code>，以检查两个<code>Random</code>实例是否产生相同的随机数序列，但是设计者并不认为客户需要或者期望这样的功能。在这样的情况下，从<code>Object</code>继承得到的<code>equals</code>实现已经足够了。  </p>
</li>
<li><p><strong>超类己经覆盖了equals．从超类继承过来的行为对于子类也是合适的</strong>。例如，大多数的<code>Set</code>实现都从<code>AbstractSet</code>继承<code>equals</code>实现，<code>Map</code>实现从<code>AbstractMap</code>继承<code>equals</code>实现。</p>
</li>
<li><p><strong>类是私有的或是包级私有的，可以确定它的<code>equals</code>方法永远不会被调用</strong>。在这种情况下，无疑是应该覆盖<code>equals</code>方法的，以防它被意外调用：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(); <span class="comment">// Method is never called</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　那么，什么时候应该覆盖<code>Object.equals</code>呢？如果类具有自己特有的“逻辑相等”概念（不同于对象等同的概念),而且超类还没有覆盖<code>equals</code>以实现期望的行为。这时我们就需要覆盖<code>equals</code>方法。这通常属于“值类（<code>value class</code>）”的情形。值类仅仅是一个表示值的类，例如<code>Integer</code>或者<code>Date</code>。程序员在利用<code>equals</code>方法来比较对象的引用时，希望知道它们在逻辑上是否相等，而不是想了解它们是否指向同一个对象。为了满足程序员的要求，不仅必需覆盖<code>equals</code>方法，而且这样做也使得这个类的实例可以被用做映射表(<code>map</code>)的键(<code>key</code>)，或者集合（<code>set</code>）的元素，使映射或者集合表现出预期的行为。</p>
</li>
</ul>
<p>　　有一种“值类”不需要覆盖<code>equals</code>方法，即用实例受控（Item 1）确保“每个值至多只存在一个对象”的类。枚举类型（Item 34）就属于这种类。对于这样的类而言，逻辑相同与对象等同是一回事，因此<code>Object</code>的<code>equals</code>方法等同于逻辑意义上的<code>equals</code>方法。</p>
<p>　　在覆盖<code>equals</code>方法的时候，你必须要遵守它的通用约定。下面是约定的内容，来自<code>Object</code>的规范[JavaSE6]: </p>
<p>　　<code>equals</code>方法实现了等价关系(<code>equivalence relation</code>):</p>
<ul>
<li><p>自反性(<code>reflexive</code>)。对于任何非<code>null</code>的引用值，<code>x.equals(x)</code>必须返回<code>true</code>。</p>
</li>
<li><p>对称性(<code>symmetric</code>)。对于任何非<code>null</code>的引用值x和Y，当且仅当<code>y.equals(x)</code>返回<code>true</code>时，<br><code>x.equals(y)</code>必须返回<code>true</code>。</p>
</li>
<li><p>传递性(<code>transitive</code>)。对于任何非<code>null</code>的引用值x、y和z,如果<code>x.equals(y)</code>返回<code>true</code>，并<br>且<code>y.equals(z)</code>也返回true，那么<code>x.equals(z)</code>也必须返回<code>true</code>。</p>
</li>
<li><p>一致性：(<code>consistent</code>)。对于任何非<code>null</code>的引用值x和y，只要<code>equals</code>的比较操作在对象中<br>所用的信息没有被修改多次调用<code>x.equals(y)</code>就会一致地返回<code>true</code>，或者一致地返回<code>false</code>。</p>
</li>
<li><p>对于任何非<code>null</code>的引用值x，<code>x.equals(null)</code>必须返回<code>false</code>。</p>
<p>  　　除非你对数学特别感兴，否则这些规定看起来可能有点让人感到恐惧，但是绝对不要忽视这些规定！如果你违反了它们，就会发现你的程序将会表现不正常，甚至崩溃，而且很难找到失败的根源。用John Donne的话说，没有哪个类是孤立的。一个类的实例通常会被频繁地传递给另一个类的实例。有许多类，包括所有的集合类（<code>collection class</code>)在内，都依赖于传递给它们的对象是否遵守了<code>equals</code>约定。</p>
</li>
</ul>
<p>　　现在你已经知道了违反<code>equals</code>约定有多么可怕，现在我们就来更细致地讨论这些约定。值得欣慰的是，这些约定虽然看起来很吓人，实际上并不十分复杂。一旦理解了这些约定，要遵守它们并不困难。现在我们按照顺序逐一查看以下5个要求：</p>
<p>　　**自反性（<code>reflexivity</code>)**——第一个要求仅仅说明对象必须等于其自身。很难想像会无意识地违反这一条。假如违背了这一条，然后把该类的实例添加到集合(<code>collection</code>)中，该集合的<code>contain</code>方法将果断地告诉你，该集合不包含你刚刚添加的实例。</p>
<p>　　<strong>对称性(<code>symmetry</code>)<strong>——第二个要求是说，任何两个对象对于“它们是否相等”的问题都必须保持一致。与第一个要求不同，若无意中违反这一条，这种情形倒是不难想像。例如，考虑下面的类，它实现了一个区分大小写的字符串。字符串由<code>toString</code>保存，但在比较操作中被忽略。<br>    <figure class="highlight java"><figcaption><span>CaseInsensitiveString.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - violates symmetry!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CaseInsensitiveString</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CaseInsensitiveString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = Objects.requireNonNull(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Broken - violates symmetry!</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> CaseInsensitiveString)</span><br><span class="line">            <span class="keyword">return</span> s.equalsIgnoreCase(</span><br><span class="line">                    ((CaseInsensitiveString) o).s);</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> String)  <span class="comment">// One-way interoperability!</span></span><br><span class="line">            <span class="keyword">return</span> s.equalsIgnoreCase((String) o);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Demonstration of the problem (Page 40)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CaseInsensitiveString</span> <span class="variable">cis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaseInsensitiveString</span>(<span class="string">&quot;Polish&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;polish&quot;</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;CaseInsensitiveString&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(cis);</span><br><span class="line"></span><br><span class="line">        System.out.println(list.contains(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // Fixed equals method (Page 40)</span></span><br><span class="line"><span class="comment">//    @Override public boolean equals(Object o) &#123;</span></span><br><span class="line"><span class="comment">//        return o instanceof CaseInsensitiveString &amp;&amp;</span></span><br><span class="line"><span class="comment">//                ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　在这个类中，<code>equals</code>方法的意图非常好，它企图与普通的字符串(<code>String</code>)对象进行互操作。假设我们有一个不区分大小写的字符串和一个普通的字符串：<br>    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CaseInsensitiveString</span> <span class="variable">cis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaseInsensitiveString</span>(<span class="string">&quot;PoliSh&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;polish&quot;</span>;</span><br></pre></td></tr></table></figure><br>　　正如所料，<code>cis.equals(s)</code>返回<code>true</code>。问题在于，虽然<code>CaseInsensitiveString</code>类中的<code>equals</code>方法知道普通的字符串(<code>String</code>)对象，但是，<code>String</code>类中的<code>equals</code>方法却并不知道不区分大小写的字符串。因此，<code>s.equals(cis)</code>返回<code>false</code>，显然违反了对称性，假设你把不区分大小写的字符串对象放到一个集合中：<br>    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;CaseInsensitiveString&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CaseInsensitiveString&gt;();</span><br><span class="line">list.add(ics);</span><br></pre></td></tr></table></figure><br>　　此时<code>list.contains(s)</code>会返回什么结果呢？没人知道。在OpenJDK的当前实现中，它碰巧返回<code>false</code>，但这只是这个特定实现得出的结果而已。在其他的实现中，它有可能返回<code>true</code>，或者抛出一个运行时(<code>runtime</code>)异常。</strong>一旦违反了<code>equals</code>约定，当其他对象面对你的对象时，你完全不知道这些对象的行为会怎么样。</strong></p>
<p>　　为了解决这个问题，只需把企图与<code>String</code>互操作的这段代码从<code>equals</code>方法中去掉就可以了。这样做之后，就可以重构该方法，使它变成一条单独的返回句：<br>    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> o <span class="keyword">instanceof</span> CaseInsensitiveString &amp;&amp;</span><br><span class="line">        ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　**传递性(<code>transitivity</code>)**——<code>equals</code>约定的第三个要求是，如果一个对象等于第二个对象，并且第二个对象又等于第三个对象，则第一个对象一定等于第三个对象。同样地，无意识地违反这条规则的情形也不难想像。考虑子类的情形，它将一个新的值组件(<code>value component</code>)添加到了超类中。换句话说，子类增加的信息会影响到<code>equals</code>的比较结果。我们首先以一个简单的不可变的二维整数型<code>Point</code>类作为开始：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Simple immutable two-dimensional integer point class (Page 37)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> (Point)o;</span><br><span class="line">        <span class="keyword">return</span> p.x == x &amp;&amp; p.y == y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    // Broken - violates Liskov substitution principle (page 43)</span></span><br><span class="line"><span class="comment">//    @Override public boolean equals(Object o) &#123;</span></span><br><span class="line"><span class="comment">//        if (o == null || o.getClass() != getClass())</span></span><br><span class="line"><span class="comment">//            return false;</span></span><br><span class="line"><span class="comment">//        Point p = (Point) o;</span></span><br><span class="line"><span class="comment">//        return p.x == x &amp;&amp; p.y == y;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// See Item 11</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　假设你想要扩展这个类，为一个点添加颜色信息：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adds a value component without violating the equals contract (page 44)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColorPoint</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Point point;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ColorPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, Color color)</span> &#123;</span><br><span class="line">        point = <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">        <span class="built_in">this</span>.color = Objects.requireNonNull(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the point-view of this color point.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">asPoint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ColorPoint</span> <span class="variable">cp</span> <span class="operator">=</span> (ColorPoint) o;</span><br><span class="line">        <span class="keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * point.hashCode() + color.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　<code>equals</code>方法会怎么样呢？如果完全不提供<code>equals</code>方法，而是直接从<code>Point</code>继承过来，在<code>equals</code>做比较的时候颜色信息就被忽略掉了，虽然这样做不会违反<code>equals</code>约定，但是很明显这是无法接受的。假设你编写了一个<code>equals</code>方法，只有当它的参数是另一个有色点，并且具有同样的位置和颜色时，它才会返回<code>true</code>：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - violates symmetry!</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　这个方法的问题在于，你在比较普通点和有色点，以及相反的情形时，可能会得到不同的结果。前一种比较忽略了颜色信息，而后一种比较则总是返回<code>false</code>，因为参数的类型不正确。为了直观地说明问题所在，我们创建一个普通点和一个有色点！<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">ColorPoint</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br></pre></td></tr></table></figure><br>　　然后，<code>p.equals(cp)</code>返回<code>true</code>，<code>cp.equals(p)</code>则返回<code>false</code>。你可以做这样的尝试来修正这个问题，让<code>ColorPoint.equals</code>在进行“混合比较”时忽略颜色信息:<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - violates transitivity!</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// If o is a normal Point, do a color-blind comparison</span></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">        <span class="keyword">return</span> o.equals(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// o is a ColorPoint; do a full comparison</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　这种方法确实提供了对称性，但是却牺牲了传递性：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ColorPoint</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br><span class="line"><span class="type">Point</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">ColorPoint</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, Color.BLUE);</span><br></pre></td></tr></table></figure><br>　　此时，<code>p1.equalS(p2)</code>和<code>p2.equals(p3)</code>都返回<code>true</code>，但是<code>p1.equals(p3)</code>则返回<code>false</code>，很显然违反了传递性。前两种比较不考虑颜色信息（“色盲”），而第三种比较中则考虑了倾色信息。</p>
<p>　　怎么解决呢？事实上，这是面向对象语言中关于等价关系的一个基本问题。<strong>我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留<code>equals</code>约定</strong>，除非愿意放弃面向对象的抽象所带来的优势。</p>
<p>　　你可能听说，在<code>equals</code>方法中用<code>getClass</code>测试代替<code>instanceof</code>测试，可以扩展可实例化的类和增加新的值组件，同时保留<code>equals</code>约定：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - violates Liskov substitution principle (page 43)</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || o.getClass() != getClass())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">    <span class="keyword">return</span> p.x == x &amp;&amp; p.y == y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　这段程序只有当对象具有相同的实现时，才能使对象等同。虽然这样也不算太槽糕，但是结果却是无法接受的。假设我们要编写一个方法，以检验某个整值点是否处在单位圆中。下面是可以采用的其中一种方法，<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize unitCircle to contain all Points on the unit circle</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Point&gt; unitCircle = Set.of(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Point</span>( <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> <span class="title class_">Point</span>( <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Point</span>(-<span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> <span class="title class_">Point</span>( <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">onUnitCircle</span><span class="params">(Point p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unitCircle.contains(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　虽然这可能不是实现这种功能的最快方式，不过它的效果很好。但是假设你通过某种不添加值组件的方式扩展了<code>Point</code>，例如让它的构造器记录创建了多少个实例：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterPoint</span> <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CounterPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(x, y);</span><br><span class="line">        counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numberCreated</span><span class="params">()</span> &#123; <span class="keyword">return</span> counter.get(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　<strong>里氏替换原则（Liskov substitution principle）</strong> 认为，一个类型的任何重要属性也将适用于它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行得很好[Liskov87]。但是假设我们将<code>CounterPoint</code>实例传给了<code>onUnitCircle</code>方法。如果<code>Point</code>类使用了基于<code>getClass</code>的<code>equals</code>方法，无论<code>CounterPoint</code>实例的x和y值是什么，<code>onUnitCircle</code>方法都会返回<code>false</code>。之所以如此，是因为像<code>onUnitCircle</code>方法所用的<code>HashSet</code>这样的集合，利用<code>equals</code>方法检验包含条件，没有任何<code>CounterPoint</code>实例与任何<code>Point</code>对应。但是，如果在<code>Point</code>上使用适当的基于<code>instanceof</code>的<code>equals</code>方法，当遇到<code>Counterpoint</code>时，相同的<code>onUnitCircle</code>方法就会工作得很好。</p>
<p>　　虽然没有一种令人满意的办法可以既扩展不可实例化的类，又增加值组件，但还是有一种不错的权宜之计（<code>workaround</code>)。根据Item 18的建议：复合优先于继承。我们不再让<code>ColorPoint</code>扩展<code>Point</code>，而是在<code>ColorPoint</code>中加人一个私有的<code>Point</code>域，以及一个公有的视图(<code>view</code>)方法（Item 6），此方法返回一个与该有色点处在相同位置的普通<code>Point</code>对象：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adds a value component without violating the equals contract</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColorPoint</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Point point;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ColorPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, Color color)</span> &#123;</span><br><span class="line">        point = <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">        <span class="built_in">this</span>.color = Objects.requireNonNull(color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the point-view of this color point.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">asPoint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ColorPoint</span> <span class="variable">cp</span> <span class="operator">=</span> (ColorPoint) o;</span><br><span class="line">        <span class="keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　在Java平台类库中，有一些类扩展了可实例化的类，并添加了新的值组件。例如，<code>java.sql.Timestamp</code>对<code>java.util.Date</code>进行了扩展，并增加了<code>nanoseconds</code>域，<code>Timestamp</code>的<code>equals</code>实现确实违反了对称性，如果<code>Timestamp</code>和<code>Date</code>对象被用于同一个集合中，或者以其他方式被混合在一起，则会引起不正确的行为。<code>Timestamp</code>类有一个免责声明，告诫程序员不要混合使用<code>Date</code>和<code>Timestamp</code>对象。只要你不把它们混合在一起，就不会有麻烦，除此之外没有其他的措施可以防止你这么做，而且结果导致的错误将很难调试。<code>Timestamp</code>的这种行为是个错误，不值得仿效。</p>
<p>　　注意，你可以在一个抽象(<code>abstract</code>)类的子类中增加新的值组件，而不会违反<code>equals</code>约定。对于Item 23的建议“用类层次(<code>class hierarchies</code>)代替标签类(<code>tagged class</code>)”而得到的那种类层次结构来说，这一点非常重要。例如，你可能有一个抽象的<code>Shape</code>类，它没有任何值组件，<code>Circle</code>子类添加了一个<code>radiust</code>域，<code>Rectangle</code>子类添加了<code>length</code>和<code>width</code>域。只要不可能直接创建超类的实例，前面所述的种种问题就都不会发生。</p>
<ul>
<li><p>一致性(<code>consistency</code>)——<code>equals</code>约定的第四个要求是，如果两个对象相等，它们就必须始终保持相等，除非它们中有一个对象（或者两个都）被修改了。换句话说，可变对象在不同的时候可以与不同的对象相等，而不可变对象则不会这样。当你在写一个类的时候，应该仔细考虑它是否应该是不可变的（Item 17）。如果认为它应该是不可变的，就必须保证<code>equals</code>方法满足这样的限制条件：相等的对象永远相等，不相等的对象永远不相等。</p>
<p>  　　无论类是否是不可变的，都不要使<code>equals</code>方法依赖于不可靠的资源。如果违反了这条禁令，要想满足一致性的要求就十分困难了。例如，<code>java.net.URL</code>的<code>equals</code>方法依赖于对URL中主机IP地址的比较。将一个主机名转变成IP地址可能需要访问网络，随着时间的推移，不确保会产生相同的结果．这样会导致URL的<code>equals</code>方法违反<code>equals</code>约定，在实践中有可能引发一些问题。（遗憾的是，因为兼容性的要求，这一行为无法被改变。）除了极少数的例外情况，<code>equals</code>方法都应该对驻留在内存中的对象执行确定性的计算。</p>
</li>
<li><p>非空性(<code>Non-nullity</code>)——最后一个要求没有名称，我姑且称它为“非空性(<code>Non-nullity</code>)”，意思是指所有的对象都必须不等于<code>null</code>。尽管很难想像什么情况下<code>o.equals(null)</code>调用会意外地返回<code>true</code>，但是意外抛出<code>NullPointerException</code>异常的情形却不难想像。通用约定不允许抛出<code>NullPointerException</code>异常。许多类的<code>equals</code>方法都通过一个显式的null测试来防止这种情况:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    `<span class="keyword">if</span> (o == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  　　这项测试是不必要的。为了测试其参数的等同性，<code>equals</code>方法必须先把参数转换成适当的类型，以便可以调用它的访问方法(<code>accessor</code>),或者访问它的域。在进行转换之前，<code>equals</code>方法必须使用<code>instanceof</code>操作符，检查其参数是否为正确的类型：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> MyType))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">MyType</span> <span class="variable">mt</span> <span class="operator">=</span> (MyType) o;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  　　如果漏掉了这一步的类型检查，并且传递给<code>equals</code>方法的参数又是错误的类型，那么<code>equals</code>方法将会抛出<code>ClassCastException</code>异常，这就违反了<code>equals</code>的约定但是，如果<code>instanceof</code>的第一个操作数为<code>null</code>，那么，不管第二个操作数是哪种类型，<code>instanceof</code>操作符都指定应该返回<code>false</code>[JLS, 15.20.2]。因此，如果把<code>null</code>传给<code>equals</code>方法，类型检查就会返回<code>false</code>，所以不需要单独的<code>null</code>检查。</p>
</li>
</ul>
<p>　　结合所有这些要求，得出了以下实现高质量<code>equals</code>方法的诀窍：</p>
<p>　　1．<strong>使用&#x3D;&#x3D;操作符检查“参數是否为这个对象的引用”</strong>。如果是，则返回<code>true</code>。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。</p>
<p>　　2．<strong>使用<code>instanceof</code>操作符检查“参數是否为正确的类型”</strong>。如果不是、则返回<code>false</code>。一般说来，所谓“正确的类型”是指<code>equals</code>方法所在的那个类。有些情况下，是指该类所实现的某个接口。如果类实现的接口改进了<code>equals</code>约定，允许在实现了该接口的类之间进行比较，那么就使用接口。集合接口(<code>collection interface</code>)如<code>Set</code>、<code>List</code>、<code>Map</code>和<code>MapEntry</code>具有这样的特性。</p>
<p>　　3．<strong>把参数转换成正确的类型</strong>。因为转换之前进行过<code>instanceof</code>测试，所以确保会成功。</p>
<p>　　4．<strong>对于该类中的每个“关键(<code>significant</code>)”域，检查参数中的域是否与该对象中对应的域相匹配</strong>。如果这些测试全部成功，则返回否則返回<code>false</code>。如果第2步中的类型是个接口，就必须通过接口方法访问参数中的域，如果该类型是个类，也许就能够直接访问参数中的域，这要取决干它们的可访问性。</p>
<p>　　对于既不是<code>float</code>也不是<code>double</code>类型的基本类型域，可以使用&#x3D;&#x3D;操作符进行比较；对于对象引用域，可以递归地调用<code>equals</code>这方法；对于<code>float</code>域，可以使用<code>Float.compare</code>方法；对于<code>double</code>域，则使用<code>Double.compare</code>。对<code>float</code>和<code>double</code>域进行特殊的处理是有必要的，因为存在着<code>Float.NaN</code>、<code>-0.0f</code>及类似的<code>double</code>常量；详细信息请参考[JLS 15.21.1]或<code>Float.equals</code>的文档。对于数组域，则要把以上这些指导原则应用到每个元素上。如果数组域中的每个元素都很重要，就可以使用其中一个<code>Arrays.equals</code>方法。</p>
<p>　　有些对象引用域包含<code>null</code>可能是合法的，所以，为了避兔可能导致<code>NullPointerException</code>异常，则使用静态方法<code>Objects.equals(Object, Object)</code>来检查这样的域。</p>
<p>　　对干有些类，比如前面提到的<code>CaseInsensitiveString</code>类，域的比较要比简单的等同性测试复杂得多，如果是这种情况，可能会希望保存该域的一个“范式(<code>canonical form</code>)”，这样<code>equals</code>方法就可以根据这些范式进行低开销的精确比较，而不是高开销的非精确比较。这种方法对于不可变类（Item 17）是最为合适的；如果对象可能发生化，必须使其范式保持最新。</p>
<p>　　域的比较顺序可能会影响到<code>equals</code>方法的性能。为了获得最隹的性能，应该最先比较最有可能不一致的域，或者是开销最低的域，最理想的情况是两个条件同时满足的域，你不应该去比较那些不属于对象逻辑状态的域，例如用于同步操作的<code>Lock</code>域。也不需要比较冗余域(<code>redundant field</code>)，因为这些冗余域可以由“关键域”计算获得，但是这样做有可能提高<code>equals</code>方法的性能。如果冗余域代表了整个对象的综合描述，比较这个域可以节省当比较失败时去比较实际数据所需要的开销。例如，假设有一个<code>Polygon</code>类，并缓存了该区域。如果两个多边形有着不同的区域，就没有必要去比较它们的边和至高点。</p>
<p>　　5.<strong>当你编写完成了<code>equals</code>方法之后，应该问自己三个问题：它是否是对称的、传递的、一致的</strong>？并且不要只是自问，还要编写单元测试来检验这些特性！如果答案是否定的，就要找出原因，再相应地修改<code>equals</code>方法的代码。当然，<code>equals</code>方法也必须满足其他两个特性（自反性和非空性），但是这两种特性通常会自动满足。</p>
<p>　　下面是一个根据上面的诀窍构建的<code>equals</code>方法的具体例子，在一个简单的PhoneNumber类里面：<br>        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class with a typical equals method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">short</span> areaCode, prefix, lineNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhoneNumber</span><span class="params">(<span class="type">int</span> areaCode, <span class="type">int</span> prefix, <span class="type">int</span> lineNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.areaCode = rangeCheck(areaCode, <span class="number">999</span>, <span class="string">&quot;area code&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.prefix = rangeCheck(prefix, <span class="number">999</span>, <span class="string">&quot;prefix&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.lineNum = rangeCheck(lineNum, <span class="number">9999</span>, <span class="string">&quot;line num&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> max, String arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; <span class="number">0</span> || val &gt; max)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(arg + <span class="string">&quot;: &quot;</span> + val);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">short</span>) val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PhoneNumber))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">PhoneNumber</span> <span class="variable">pn</span> <span class="operator">=</span> (PhoneNumber) o;</span><br><span class="line">        <span class="keyword">return</span> pn.lineNum == lineNum &amp;&amp; pn.prefix == prefix</span><br><span class="line">                &amp;&amp; pn.areaCode == areaCode;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　下面是最后的一些告诚:</p>
<ul>
<li><p>**覆盖<code>equals</code>时总要覆<code>hashCode</code>**（Item 9）。</p>
</li>
<li><p><strong>不要企图让<code>equals</code>方法过于智能</strong>。如果只是简单地测试域中的值是否相等，则不难做到遵守<code>equals</code>约定。如果想过度地去寻求各种等价关系，则很容易陷人麻烦之中。把任何一种别名形式考虑到等价的范围内，往往不会是个好主意。例如，<code>File</code>类不应该试图把指向同一个文件的符号链接(<code>symbolic link</code>)当作相等的对象来看待。所幸<code>File</code>类没有这样做。</p>
</li>
<li><p><strong>不要将<code>equals</code>声明中的<code>Object</code>对象替换为其他的类型</strong>。程序员编写出下面这样的<code>equals</code>方法并不鲜见，这会使程序员花上数个小时都搞不清为什么它不能正常工作：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broken - parameter type must be Object!</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(MyClass o)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  　　问题在于，这个方法并没有覆盖<code>Object.equals</code>，因为它的参数应该是<code>Object</code>类型，相反，它重载(<code>overload</code>)了<code>Object.equals</code>（Item 52）。在原有<code>equals</code>方法的基础上，再提供一个“强类型(<code>strongly typed</code>)”的<code>equals</code>方法，即使这两个方法返回同样的结果（没有强制的理由必须这样做），这也是不可以接受的。因为它能导致<code>@Override</code>注解在子类生成误报并提供错误的安全感。</p>
<p>  　　<code>@Override</code>注解的用法一致，就如本条目中所示，可以防止犯这种错误（Item 40）。这个<code>equals</code>方法不能编译，错误消息会告诉你到底哪里出了问题：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Still broken, but won’t compile</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(MyClass o)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  　　编写和测试<code>equals</code>（和<code>hashCode</code>）方法很繁琐，结果代码很平常。手动编写和测试这些方法的一个很好的替代方法是使用Google的开源<code>AutoValue</code>框架，该框架会自动为您生成这些方法，由类中的单个注释触发。在大多数情况下，<code>AutoValue</code>生成的方法与您自己编写的方法基本相同。</p>
<p>  　　IDE也有生成<code>equals</code>和<code>hashCode</code>方法的工具，但生成的源代码比使用<code>AutoValue</code>的代码更冗长，更不易读，不会自动跟踪类中的更改，因此需要测试。也就是说，让IDE生成<code>equals</code>（和<code>hashCode</code>）方法通常比手动实现它们更可取，因为IDE不会造成粗心的错误，大多数人也会这样做。</p>
<p>  　　总之，不要覆盖<code>equals</code>方法，除非你必须：在许多情况下，从<code>Object</code>继承的实现完全符合您的要求。如果你确实覆盖了<code>equals</code>，请确保比较所有类的重要字段，并以保留<code>equals</code>约定的所有五个条款的方式对它们进行比较。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item9 优先使用“try-with-resources”来代替“try-finally”</title>
    <url>/2018/12/07/Effective-Java-Item9-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E2%80%9Ctry-with-resources%E2%80%9D%E6%9D%A5%E4%BB%A3%E6%9B%BF%E2%80%9Ctry-finally%E2%80%9D/</url>
    <content><![CDATA[<p>Java库包含许多必须通过手动调用<code>close</code>方法关闭的资源。其中包括：<code>InputStream</code>，<code>OutputStream</code>和<code>java.sql.Connection</code>。关闭资源常常会被客户端所忽视，这会导致可怕的性能问题。虽然很多资源使用了终结器来作为安全网，不过终结器却并不那么尽如人意（Item 8）。</p>
<span id="more"></span>

<p>纵观历史，<code>try-finally</code>语句是保证资源被正确关闭的最好方法，即便在遇到异常或是返回语句时亦如此：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try-finally - No longer the best way to close resources!</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> br.readLine();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		br.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来还不错，不过当添加了第二个资源时情况就变得有些糟糕了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try-finally is ugly when used with more than one resource!</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">	 <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dst);</span><br><span class="line">	 <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];</span><br><span class="line">	     <span class="type">int</span> n;</span><br><span class="line">	     <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">		 out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">	 &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	     out.close();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	 in.close();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可能难以置信，但即使是优秀的程序员也有犯这个错误的时候。对于初学者来说，我在<strong>Java Puzzlers</strong>[Bloch05]的第88页指出了问题，但多年来没人注意到。事实上，2007年，在Java库中对<code>close</code>方法的使用有2&#x2F;3是错误的。</p>
<p>即使使用<code>try-finally</code>语句关闭资源的正确代码(如前两个代码示例所示)也有一个细微的缺陷。<code>try</code>块和<code>finally</code>块中的代码都能够抛出异常。例如，在<code>firstLineOfFile</code>方法中，由于底层物理设备发生故障，对<code>readLine</code>的调用可能会抛出异常，而<code>close</code>的调用也可能出于同样的原因而失败。在这种情况下，第二个异常完全把第一个异常给覆盖了。异常堆栈跟踪中没有第一个异常的记录，这可能会使实际系统中的调试变得非常复杂——通常这是你希望看到的第一个异常，以便诊断问题。虽然可以通过编写代码来抑制第二个异常而支持第一个异常，但实际上没有人会这样做，因为它太过啰嗦。</p>
<p>当Java 7引入了<code>try-with-resources</code>语句[JLS，14.20.3]时，所有这些问题都被一举解决了。要想使用这个结构，资源必须实现<code>AutoCloseable</code>接口，该接口包含了唯一一个返回<code>void</code>类型的<code>close</code>方法。现在Java库和第三方库中的许多类和接口去实现或继承了<code>AutoCloseable</code>接口。如果你要编写一个代表必须关闭的资源的类，那么你的类也应该实现<code>AutoCloseable</code>接口。</p>
<p>如下代码使用<code>try-with-resources</code>改写了上面第一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try-with-resources - the the best way to close resources!</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path))) &#123;</span><br><span class="line">    	<span class="keyword">return</span> br.readLine();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下代码使用<code>try-with-resources</code>改写了上面第二个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try-with-resources on multiple resources - short and sweet</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">    		<span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dst)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">        	out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与以前的版本相比，<code>try-with-resources</code>版本不仅更短，可读性更好，而且提供了更好的诊断。仔细想想<code>firstLineOfFile</code>方法。如果<code>firstLineOfFile</code>和<code>close</code>方法（不可见）都抛出了异常，则后一个异常将被抑制，来支持前一个异常。 实际上，可能会抑制多个异常，而保留你实际希望看到的异常。这些被压制的异常并不是被丢弃掉；它们会被打印到堆栈信息里，并用一个标记来说明它们是被抑制的。在程序中你可以用<code>getSuppressed</code>方法来访问它们，该方法是在Java 7中被添加到<code>Throwable</code>中的。</p>
<p>你可以将<code>catch</code>从句放到<code>try-with-resources</code>语句上，就像在正常的<code>try-finally</code>语句中那样。这样就可以在处理异常的同时又不会在另一个嵌套层次上搞乱代码了。举个例子，举个例子下面是不抛出异常的<code>firstLineOfFile</code>方法版本，不过如果无法打开文件或是无法读取文件，那么它会接收一个默认值来返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/ <span class="keyword">try</span>-with-resources with a <span class="keyword">catch</span> clause</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">firstLineOfFile</span><span class="params">(String path, String defaultVal)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path))) &#123;</span><br><span class="line">    	<span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    	<span class="keyword">return</span> defaultVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论很明显：当使用了必须关闭的资源时，总是优先使用<code>try-with-resources</code>，来代替<code>try-finally</code>。结果代码更短、也更清晰，它所生成的异常也更加有用。<code>try-with-resources</code>语句使得编写使用了必须要关闭的资源的代码更加轻松，而这是<code>try-finally</code>所做不到的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item8 避免使用终结器与清理器</title>
    <url>/2018/12/07/Effective-Java-Item8-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%BB%88%E7%BB%93%E5%99%A8%E4%B8%8E%E6%B8%85%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p><strong>终结器是不可预测的、常常会很危险，而且通常没必要。使用终结器会导致奇怪的行为、孱弱的性能以及可移植性问题</strong>。终结器有一些有效的用途，我们将在后面的条款中介绍，但是作为一个规则，你应该避免他们。在Java 9中，终结器已经被弃用，但是Java库仍然在使用它们。Java 9中，替代终结器的是清除器（<strong>cleaner</strong>）。<strong>清除器比终结器危险小，但仍然不可预测、效率慢，而且通常没有必要</strong>。 </p>
<span id="more"></span>

<p>C++程序员们不要将Java中的终结器或是清理器当作是C++中的析构函数。在C++中，析构函数是回收与对象所关联的资源的常规方式，它是与构造函数必要的一个对应之物。 在Java中，当与对象所关联的存储变得不可达时，垃圾收集器就会将其回收，不需要程序员做任何额外的事情。 c++析构函数也可以用于回收其他非内存资源。在Java中，<code>try-with-resources</code>或<code>try-finally</code>代码块就是用于此目的(Item 9)。</p>
<p>终结器与清理器的一个缺点在于，没有人可以保证他们会立刻执行[JLS, 12.6]。在对象变得不可及与终结器或是清理器开始运行之间可能会间隔任意长的时间。这意味着你永远不要在终结器或是清理器中做任何时间关键的事情。例如，依赖于终结器或清除器来关闭文件就是一个严重的错误，因为打开的文件描述符是有限的资源。如果由于系统运行终结器或是清理器产生了延迟而导致很多文件处于打开的状态，那么程序就有可能失败，因为它无法再打开文件了。</p>
<p>到底哪个终结器和清理器会执行主要是由垃圾回收算法来决定的，而算法在不同的实现间存在着较大的差别 。依赖于终结器或是清理器的立刻执行的程序行为也存在着较大的差别。因此，同样一个程序在你测试的JVM中完美运行，然后却在你最重要的客户上的机器上不幸地失败了，这种情况是完全有可能发生的。</p>
<p>终结器不会立刻执行并不仅仅是个理论上的问题 。为类提供终结器可能会随意地延迟自己的实例的回收。一位同事调试了一个长期运行的GUI应用程序，该应用程序因<code>OutOfMemoryError</code>而奇怪地崩溃过。分析显示，在应用程序崩溃的时候，它的终结器队列中有数千个图形对象等待被终结并回收。遗憾的是，终结器运行所在的线程要比另一个应用线程的优先级低，这样对象被终止的速度远远跟不上其进入到终止状态的速度。Java语言规范没有明确说明哪个线程将执行终结器，因此除了避免使用终结器之外，没有其他更方便的方法来防止这类问题。这个问题上，清洁器在这方面要比终结器好一些，因为类的创建者可以控制自己的清洁器线程，不过，清洁器依然运行在后台，在垃圾收集器的控制之下，因此对于立刻清洁这个问题也没有提供任何保证。</p>
<p>规范不仅没有提供终结器或是清理器会立刻运行的保证，也没有对其一定会运行提供任何保证。完全有可能出现这样的情况，当程序终止时，它并没有对早就处于不可达的对象运行其终结器和清理器。因此，你<strong>永远都不应该依赖于终结器或是清理器来更新持久化状态</strong>。比如说，依赖于终结器或是清理器来释放如数据库等共享资源上的持久化锁可能会导致整个分布式系统陷入瘫痪状态。</p>
<p>不要被<code>System.gc</code>和<code>System.runFinalization</code>方法所诱惑。它们可能会增加终结器或清除器被执行的几率，但他们并不能保证一定如此。曾经有两个方法做过这个保证：<code>System.runFinalizersOnExit</code>及其搭档<code>Runtime.runFinalizersOnExit</code>。这两个方法存在严重的问题，早就已经不建议使用了[ThreadStop]。</p>
<p>终结器的另一个问题是在执行终结时，未捕获的异常会被忽略掉，这时对象的终结会被终止[JLS, 12.6]。未捕获的异常会导致其他对象的状态被破坏掉。如果另一个线程试图使用这样一个已损坏的对象，则可能导致任意的不确定性行为。正常情况下，未捕获的异常会终止线程并打印堆栈信息，但如果在终结器中就不会这样——它甚至不会打印出任何警告信息。清理器不存在这个问题，因为使用了清理器的库会自己控制其线程。。</p>
<p><strong>使用终结方法和清除方法会有严重的性能损失</strong>。在我的机器上，创建一个简单的<code>AutoCloseable</code>对象，使用<code>try-with-resources</code>关闭它，然后让垃圾收集器对其进行回收，大约需要花费12ns。使用终结器可以将时间增加到550纳秒。换句话说，使用终结器创建和销毁对象的速度要慢50倍。这主要是因为终结器阻碍了高效的垃圾回收。如果使用清理器来清除类的所有实例（在我的机器上每个实例大约需要花费500ns），它在速度上与终结器大致相同；不过，如果只是将清理器作为一个安全网（后续将会介绍），那么其速度将会快很多。如下所述。在这些情况下，我的机器上创建、清理与销毁一个对象所花费的时间大约需要66ns，这意味着你为安全网的使用需要付出5倍因子（不是50倍）的代价。</p>
<p><strong>终结方法有一个严重的安全问题：他们会使你的类遭遇到终结器攻击</strong>。终结器攻击背后的想法非常简单：如果异常是从构造方法或是序列化方法<code>readObject</code>与<code>readResolve</code>中抛出的（chapter 12），那么恶意的子类终结器就会运行在部分构建完毕的对象上，而这个对象本应该『中途夭折的』。这个终结器会将对对象的引用记录在一个静态字段中，防止其被垃圾回收掉。一旦将这个不完整的对象记录下来后，我们就可以轻松调用这个对象上的任意方法，而这个对象原本是不应该存在的。<strong>从构造方法中抛出异常足以禁止对象的创建；但在使用终结器的情况下，却并非如此</strong>。 这种攻击还会产生非常严重的后果。终态类不受终结器攻击的影响，因为没人可以创建终态类的恶意子类。若想保护非终态类免受终结器攻击，<strong>请编写一个什么都不做的<code>final</code>的<code>finalize</code>方法</strong>。</p>
<p>那么，对于封装了需要终止的资源（如文件或是线程）的对象来说，如果不为类编写终结器或是清理器，那该怎么办呢？只需让类实现<code>AutoCloseable</code>即可，并让其客户端在不需要其实例时调用其<code>close</code>方法，通常我们会使用<code>try-with-resources</code>来确保终止，即便在异常的情况下亦如此（Item 9）。值得提及的一个细节是，实例必须要追踪其是否已经关闭了：<code>close</code>方法必须要在一个字段中记录下对象已经不再有效了，其他方法则必须要检查该字段，如果当对象已经关闭后还调用这些方法，那就需要抛出<code>IllegalStateException</code>异常。</p>
<p>那么，清理器与终结器到底有什么好处呢？他们有两个合理的用途。一是作为安全网，防止资源所有者忘记调用其<code>close</code>方法。虽然没人能够保证清理器或是终结器会立刻运行（或是否运行），不过如果客户端忘记释放资源，那么迟做总比不做强。如果考虑编写这样的安全网终结器，那么请仔细考虑，这种保护是否真的值得。一些Java库类（如<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>ThreadPoolExecutor</code>及<code>java.sql.Connection</code>）都将终结器作为安全网。</p>
<p>清理器的第二个合理使用场景与拥有本地对端（<code>native peers</code>）的对象有关。所谓本地对端指的是本地对象（非Java对象），常规对象通过本地方法将调用委托给它由于本地对端并非常规对象，因此垃圾收集器并不知晓它，当其Java对端被回收时，也并不会对其进行回收。清理器或是终结器是完成这个任务的恰当工具，假设性能是可接受的，并且本地对端并没有持有关键资源。如果性能是不可接受的，或是本地对端持有必须要立刻回收的资源，那么类就应该拥有一个<code>close</code>方法，如前所示。</p>
<p>清理器的使用有一些棘手。如下是个简单的<code>Room</code>类，演示了其使用方式。假设房间在被回收前必须要清理。<code>Room</code>类实现了<code>AutoCloseable</code>；其自动清理安全网使用了清理器这个事实只不过是个实现细节而已。与终结器不同，清理器不会污染类的公有API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An autocloseable class using a cleaner as a safety net</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Cleaner</span> <span class="variable">cleaner</span> <span class="operator">=</span> Cleaner.create();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Resource that requires cleaning. Must not refer to Room!</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">State</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="type">int</span> numJunkPiles; <span class="comment">// Number of junk piles in this room</span></span><br><span class="line">        </span><br><span class="line">        State(<span class="type">int</span> numJunkPiles) &#123;</span><br><span class="line">            <span class="built_in">this</span>.numJunkPiles = numJunkPiles;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Invoked by close method or cleaner</span></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Cleaning room&quot;</span>);</span><br><span class="line">            numJunkPiles = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The state of this room, shared with our cleanable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> State state;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Our cleanable. Cleans the room when it’s eligible for gc</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cleaner.Cleanable cleanable;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Room</span><span class="params">(<span class="type">int</span> numJunkPiles)</span> &#123;</span><br><span class="line">        state = <span class="keyword">new</span> <span class="title class_">State</span>(numJunkPiles);</span><br><span class="line">        cleanable = cleaner.register(<span class="built_in">this</span>, state);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类<code>State</code>持有清洁器清洁房间所需的资源。在这个例子中，资源就是字段<code>numJunkPiles</code>，表示房间中的混乱程度。更为现实的情况，它可以是个<code>final long</code>字段，包含着一个指针，指向了本地对端。<code>State</code>实现了<code>Runnable</code>，其<code>run</code>方法至多会被<code>Cleanable</code>调用一次，<code>Cleanable</code>则是我们在<code>Room</code>构造方法中将<code>State</code>实例注册到清理器上所得到的。对<code>run</code>方法的调用会被两个动作所触发：通常，它会被<code>Room</code>的<code>close</code>方法调用，<code>close</code>方法又会调用<code>Cleanable</code>的<code>clean</code>方法。如果在<code>Room</code>实例可以被垃圾回收时，客户端没有调用<code>close</code>方法，那么清理器就会（希望如此）调用<code>State</code>的<code>run</code>方法。</p>
<p><code>state</code>实例不持有对它的<code>Room</code>实例的引用，这一点很重要。如果它持有引用，那么它会创造一个死循环，阻止<code>Room</code>实例被垃圾收集器回收（以及自动清理）。因此，<code>State</code>必须是一个静态内部类，因为非静态内部类包含对其外部类实例的引用(item 24)。同样不建议使用<code>lambda</code>，因为它们可以很容易地捕获对外部类对象的引用。 </p>
<p>如前所述，<code>Room</code>的清理器只用作安全网。如果客户端在<code>try-with-resource</code>块中完成了所有的<code>Room</code>实例化动作，那么自动化清理就永远不需要了。如下行为良好的客户端演示了该行为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adult</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Room</span> <span class="variable">myRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="number">7</span>)) &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;Goodbye&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所想，运行<code>Adult</code>程序会打印出<code>Goodbye</code>，然后是<code>Cleaning room</code>。不过，下面这个有问题的程序呢，它永远不会清理房间？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teenager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="keyword">new</span> <span class="title class_">Room</span>(<span class="number">99</span>);</span><br><span class="line">    	System.out.println(<span class="string">&quot;Peace out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能觉得它会打印出<code>Peace out</code>，然后是<code>Cleaning room</code>，不过在我的机器上，它永远不会打印出<code>Cleaning room</code>；它只不过退出了而已。这就是我们之前提到的不可预测性。<strong>Cleaner</strong>规范说到：『在<code>System.exit</code>时清理器的行为是特定于实现的』。没有人可以保证清理动作是否会被调用。虽然规范没这么说，但对于正常的程序退出来说就是如此。在我的机器上，往<code>Teenager</code>类的<code>main</code>方法里添加一行<code> System.gc()</code>，能让程序在退出前打印“<code>Cleaning room</code>”，但是不保证在你的机器上就能看到相同的结果。</p>
<p>总结一下，不要使用清理器，或者说不要在Java 9之前的版本使用终结器，除非将其作为安全网或是用来终止不重要的本地资源。即便如此，也请小心其不确定性和性能影响。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java Item6 避免创建不必要的对象</title>
    <url>/2018/12/07/Effective-Java-Item6-%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>在需要一个对象时，恰当的做法是尽可能重用这个对象而非创建一个功能完全一样的新对象。重用既比较快又比较流行。如果一个对象是不可变的(Item 17)，那么它总是可以被重用的。</p>
<span id="more"></span>

<p>作为一个绝对不要这么做的极端示例，考虑如下语句：	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;bikini&quot;</span>); <span class="comment">// DON&#x27;T DO THIS!</span></span><br></pre></td></tr></table></figure>

<p>这个语句在每次执行时都会创建一个新的字符串实例，而这些对象创建其实都是不必要的。<code>String</code>构造方法的参数(“<code>bikini</code>“)本身就是个<code>String</code>实例，与构造函数创建的所有对象功能相同。如果这种用法出现在一个循环语句中或一个被频繁调用的方法中，那么可能会创建百万个没必要的<code>String</code>实例。</p>
<p>改进后的版本简单如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;bikini&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这个版本使用单个的字符串实例，而不是每次执行时创建一个新的。此外，它还确保了运行在同一个虚拟机中并且包含了相同字符串字面值的其他代码能够重用该对象 。如果不变类既提供了静态工厂方法（Item 1），也提供了构造方法，那么你就可以通过前者来避免创建不必要的对象。例如，工厂方法<code>Boolean.valueOf(String)</code>比构造函数<code>Boolean(String)</code>更可取，后者在Java 9中已经被弃用。每一次调用构造方法，一定会创建一个新的对象，然而工厂方法完全没必要这么做，而且实践当中也不会这么做。除了重用不可变对象之外，如果你知道不会修改这个可变对象，那么你也可以重用这个可变对象。</p>
<p>有些对象创建要比其他对象昂贵得多。如果你以后会反复需要这样一个“昂贵的对象”，那么最好将其缓存以供重用。不幸的是，在创建这样的对象时，并不总是显而易见的。假设你想写一个方法来确定字符串是否是有效的罗马数字。这里有个最简单的方法就是，使用正则表达式来做这件事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Performance can be greatly improved!</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRomanNumeral</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span></span><br><span class="line">            + <span class="string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现的问题在于它依赖于<code>String.matches</code>方法。<strong>虽然<code>String.matches</code>是检查一个字符串是否匹配这个正则表达式最简单的方法，但是在性能要求苛刻的场景下，他并不适合重复使用</strong>。这样做的问题是，它会在内部为正则表达式创建一个<code>Pattern</code>实例，并且仅仅使用它一次，之后它就可以进行垃圾收集了。创建一个<code>Pattern</code>实例非常昂贵，因为它需要将正则表达式编译成一个有限状态机。</p>
<p>为了改进性能，请在类的初始化过程中手动将正则表达式编译为<code>Pattern</code>实例（它是不可变的），然后将其缓存起来，并在每次调用<code>isRomanNumeral</code>方法时重用这个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reusing expensive object for improved performance</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RomanNumerals</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">ROMAN</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span></span><br><span class="line">    		+ <span class="string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRomanNumeral</span><span class="params">(String s)</span> &#123;</span><br><span class="line">   	 	<span class="keyword">return</span> ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进版本的<code>isRomanNumeral</code>在频繁调用的情况下极大提升了性能 。在我的机器上，当输入长度为8的字符串时，第一版的方法执行了1.1微秒，而改进版的方法执行了0.17微秒，比原来快了6.5倍。不仅性能得到了改善，而且可以认为代码也变得更清晰了。使用一个静态<code>final</code>字段来表示原本不可见的Pattern的实例，这样允许我们给这个字段取个名字，这样做比正则表达式本身可读性高多了。</p>
<p>如果包含改进版的<code>isRomanNumeral</code>方法的类被初始化了，但是没有主动调用这个方法，那么字段<code>ROMAN</code>依然会被没必要地初始化。当第一次调用<code>isRomanNumeral</code>方法时，我们可以通过惰性初始化字段的方法来消除上面的没必要地初始化。但是不推荐这样做。因为对于延迟初始化来说，它常常会导致实现变得复杂，并且不能带来很大的性能提升。当一个对象是不可变的时，很明显它可以安全地被重用，但是在其他情况下，它就不那么明显了，甚至是违反直觉的。考虑适配器的情况，也称为视图。所谓适配器，指的是委托给支撑对象的对象，并提供了另外的接口。由于适配器除了支撑对象的状态外，它自身是没有状态的，因此对于给定的对象来说，没必要为其创建多个适配器实例 。</p>
<p>例如，<code>Map</code>接口的<code>keySet</code>方法返回<code>Map</code>对象的<code>Set</code>视图，其中包含映射中的所有键。直觉上，似乎每个对<code>keySet</code>的调用都必须创建一个新的<code>Set</code>实例，不过实际情况却是，每次调用给定<code>Map</code>对象的<code>keySet</code>都只会返回同一个<code>Set</code>实例 。虽然返回的Set实例通常是可变的，但所有返回的对象在功能上是相同的: 当其中一个返回的对象发生更改时，其他的对象也会发生变化，因为它们都是由同一个<code>Map</code>实例支持的。虽然创建<code>keySet</code>视图对象的多个实例基本上是无害的，但它是不必要的，没有任何好处。</p>
<p>另一种创建不必要对象的方法是自动装箱 ，它允许程序员把原生类型和原生类型的包装类混合用，并且会根据需要自动地拆箱和装箱。<strong>自动装箱使原生类型和包装类之间界限变得模糊，但是并没有消除原生类型和原生类型的包装类之间的区别</strong>。这里存在一些微小的语义上的差别以及稍微有点大的性能上的差别（Item 61)。考虑如下方法，它会计算所有正整型int值的和。为了做到这一点，程序需要使用<code>long</code>运算，因为<code>int</code>不足以容纳所有正整型<code>int</code>值的和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hideously slow! Can you spot the object creation?</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">    	sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序会得到正确的答案，不过要比预计慢很多，原因在于一个字符拼写上的错误 。变量sum被声明为Long型而不是long型，这就意味着这个程序要构造2^31个不必要的<code>Long</code>实例（大概每一次<code>long</code>型<code>i</code>与<code>Long</code>类型的<code>sum</code>相加都会创建一个实例）。在我的机器上，将<code>sum</code>声明由<code>Long</code>改为<code>long</code>则会将运行时间由6.3s减少到0.59s。这个例子很清楚：<strong>相对包装类型，优先使用原生类型，并且注意无意识地自动装箱</strong>。</p>
<p>不应该误解该条款，以为对象创建是非常昂贵的，应该避免。相反地，小对象的创建和回收是廉价的，因为他们的构造函数没有做什么明显的工作，特别是在现代JVM实现中 。创建额外的对象来增强程序的清晰度、简单性或程序的能力通常是一件好事。相反，除非池中的对象非常重量级，否则通过维护自己的对象池来避免对象创建是一个坏主意。真正需要对象池的对象的一个典型示例就是数据库连接。建立连接的成本非常高，因此重用这些对象是有意义的。然而，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代JVM实现具有高度优化的垃圾收集器，它们在轻量级对象上轻松胜过此类对象池。 </p>
<p>与本条款对应的是关于<strong>防御式拷贝</strong>的Item 50。当前的条款说，“当应该重用一个已经存在的对象时，就不应该创建新的对象”。然而，第50条说，“当您应该创建一个新的对象时，不要重用现有的对象。”注意，在需要进行防御性复制时重用对象的惩罚远远大于不必要地创建重复对象的惩罚。如果不能在需要的地方创建防御复制，可能会导致潜在的bug和安全漏洞;而不必要地创建对象只会影响样式和性能。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git开发规范</title>
    <url>/2019/12/20/Git%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h3 id="分支介绍及命名规则"><a href="#分支介绍及命名规则" class="headerlink" title="分支介绍及命名规则"></a>分支介绍及命名规则</h3><h4 id="master-分支"><a href="#master-分支" class="headerlink" title="master 分支"></a><strong>master 分支</strong></h4><ul>
<li>master 为主分支，也是用于部署生产环境的分支，一定要确保master分支稳定性</li>
<li>master 分支一般从develop或bugfix分支合并，任何时间都不能直接修改master分支的代码</li>
</ul>
<h4 id="develop-分支"><a href="#develop-分支" class="headerlink" title="develop 分支"></a><strong>develop 分支</strong></h4><ul>
<li>develop 为开发分支，始终保持最新完成以及bug修复后的代码，</li>
<li>一般开发的新功能时，feature分支都是基于develop分支下创建的</li>
</ul>
<h4 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a><strong>feature 分支</strong></h4><ul>
<li>feature 为开发新功能时创建的分支，并且一般是由develop为基础来创建feature分支</li>
<li>分支命名: feature&#x2F; 开头的为特性分支， 命名示例: feature&#x2F;user_module、 feature&#x2F;vacation_plan_module</li>
</ul>
<span id="more"></span>

<h4 id="release-分支"><a href="#release-分支" class="headerlink" title="release 分支"></a><strong>release 分支</strong></h4><ul>
<li>release 为预上线分支，发布提测阶段，会以release分支代码为基准提测，因为项目组实际情况，人数不够的情况下可以不需要此分支。</li>
</ul>
<h4 id="bugfix-分支"><a href="#bugfix-分支" class="headerlink" title="bugfix 分支"></a><strong>bugfix 分支</strong></h4><ul>
<li>bugfix 为修复分支，它的命名规则与 feature 分支类似，例如bugfix&#x2F;xxx</li>
<li>线上出现紧急问题时，需要及时修复，以master或develop分支为基线，创建bugfix分支，修复完成后，需要合并到master分支和develop分支</li>
</ul>
<h3 id="操作步骤及命令"><a href="#操作步骤及命令" class="headerlink" title="操作步骤及命令"></a>操作步骤及命令</h3><h4 id="管理员「项目负责人」创建master及develop分支"><a href="#管理员「项目负责人」创建master及develop分支" class="headerlink" title="管理员「项目负责人」创建master及develop分支"></a>管理员「项目负责人」创建master及develop分支</h4><p>一般master分支在创建项目是会默认创建，现在只需要创建develop分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b develop #git checkout命令加上-b参数表示创建并切换，相当于git branch develop与git checkout develop</span><br></pre></td></tr></table></figure>

<p>用<code>git branch</code>命令查看当前分支，命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* develop</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>

<h4 id="项目成员「开发者」clone-项目，在本地建立自己的功能分支"><a href="#项目成员「开发者」clone-项目，在本地建立自己的功能分支" class="headerlink" title="项目成员「开发者」clone 项目，在本地建立自己的功能分支"></a>项目成员「开发者」clone 项目，在本地建立自己的功能分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone &lt;项目 git 地址&gt;</span><br><span class="line">git checkout -b develop origin/develop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建本地功能分支</span></span><br><span class="line">git checkout -b feature/[feature-name] develop</span><br></pre></td></tr></table></figure>

<p>在自己的本地feature分支上进行开发 ： <code>git add</code> ，<code>git commit</code> 等，注意此时不要 push 到远程分支（origin）。</p>
<p>功能完成后可以直接合并本地的 <code>feature</code> 分支到本地的 <code>develop</code> 分支后 push 到远程仓库，合并的时候很大几率发生冲突，此时需要 <code>merge</code> ，<code>merge</code> 的时候确保不影响项目其他成员，如果多个人都操作了同一个类，最好当面确认后在进行修改。等合并完成确认无误后，删除本地开发分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout develop </span><br><span class="line">git pull origin develop #确保本地 developer 分支为最新的</span><br><span class="line">git merge feature/[feature-name] #合并本地的 `feature` 分支到本地的 `develop` 分支</span><br><span class="line">git push #确保你当前在develop分支下面push</span><br><span class="line">git branch -d feature/[feature-name] #删除本地分支</span><br></pre></td></tr></table></figure>

<h4 id="发布分支"><a href="#发布分支" class="headerlink" title="发布分支"></a>发布分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b release-0.1 develop #从develop分支迁出预发布分支</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">一旦准备好了发版，合并修改到 master 分支和 developer 分支上，删除发布分支</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">合并修改到 master 分支</span></span><br><span class="line">git checkout master </span><br><span class="line">git merge release-0.1 </span><br><span class="line">git push </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">合并修改到 develop 分支</span></span><br><span class="line">git checkout develop </span><br><span class="line">git merge release-0.1 </span><br><span class="line">git push </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除发布分支</span></span><br><span class="line">git branch -d release-0.1</span><br></pre></td></tr></table></figure>

<h4 id="为-master-分支打发版-tag"><a href="#为-master-分支打发版-tag" class="headerlink" title="为 master 分支打发版 tag"></a>为 master 分支打发版 tag</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git tag -a 0.1 -m &quot;Initial public release&quot; master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<h4 id="修复-bug"><a href="#修复-bug" class="headerlink" title="修复 bug"></a>修复 bug</h4><p>如果正在开发功能的同时，发现了线上 bug，或者未上线的 bug，我们可以开一个 bugfix 分支来修复 bug，然后将修复后的代码发布到线上以及正在开发的分支上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b bugfix/[bug-name] master（或 develop）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">when fixed bug，合并修改好的代码到master以及develop分支</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge bugfix/[bug-name]</span><br><span class="line">git checkout develop</span><br><span class="line">git merge bugfix/[bug-name]</span><br><span class="line"></span><br><span class="line">git push</span><br><span class="line">git branch -d bugfix/[bug-name]</span><br></pre></td></tr></table></figure>

<h4 id="特别提示"><a href="#特别提示" class="headerlink" title="特别提示"></a>特别提示</h4><p>项目中存在很多配置文件，不同分支配置文件可能不同，因此在merge时需要忽略配置文件合并</p>
<ol>
<li><p>首先，需要创建自定义的 <code>merge driver</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global merge.ours.driver true</span><br></pre></td></tr></table></figure>
</li>
<li><p>在要被<code>merge</code>的分支上创建<code>.gitattributes</code>文件,并且在文件中置顶不<code>merge</code>的文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;Jenkinsfile merge=ours&#x27; &gt;&gt; .gitattributes</span><br><span class="line">git add .gitattributes</span><br><span class="line">git commit -m &#x27;chore: Preserve Jenkinsfile during merges&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>回到要合并到的分支<code>master</code>,执行<code>merge</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge xxxx</span><br></pre></td></tr></table></figure></li>
</ol>
<p>PS：只能<code>master</code>合并<code>其他分支</code>时忽略<code>其他分支</code>上的文件, <code>其他分支</code>合并<code>master</code>无法忽略<code>master</code>上的文件</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC并发编程</title>
    <url>/2022/05/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="一把锁"><a href="#一把锁" class="headerlink" title="一把锁"></a>一把锁</h2><p>synchronized</p>
<h2 id="两个并（并发、并行）"><a href="#两个并（并发、并行）" class="headerlink" title="两个并（并发、并行）"></a>两个并（并发、并行）</h2><p>并发：</p>
<ul>
<li>是在同一实体上的多个事件</li>
<li>是在一合处理器上“同时”处理多个任务</li>
<li>同一时刻，其实是只有一个事件在发生</li>
</ul>
<p>并行：</p>
<ul>
<li>是在不同实体上的多个事件</li>
<li>是在多台处理器上同时处理多个任务</li>
<li>同一时刻，大家真的都在做事情</li>
</ul>
<h2 id="三个程（进程、线程、管程）"><a href="#三个程（进程、线程、管程）" class="headerlink" title="三个程（进程、线程、管程）"></a>三个程（进程、线程、管程）</h2><p>进程：简单的说，在系统中运行的一个应用程序就是一个进程，每一个进程都有它自己的内存空间和系统资源。</p>
<p>线程：也被称为轻量级进程，在同一个进程内会有1个或多个线程，是大多数操作系统进行时序调度的基本单元。</p>
<p>管程：Monitor(监视器），也就是我们平时所说的锁，Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。JVM中同步是基于进入和退出监视器对象(Monitor，管程对象)来实现的，每个对象实例都会有一个Monitor对象。Monitor对象会和Java对象一同创建并销毁。</p>
<h2 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h2><p>执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成 （无论是正當完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。</p>
<p>如果一个同步方法执行期间拋出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虛拟机的指令集中有monitorenter和monitorext 两条指令来支持synchronized关键字的语义，正确实现synchronized关键宇需要Javac编译器与Java虛拟机两者共同协作支持。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式</title>
    <url>/2021/06/09/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p>
<span id="more"></span>

<h1 id="软件设计7大原则"><a href="#软件设计7大原则" class="headerlink" title="软件设计7大原则"></a>软件设计7大原则</h1><table>
<thead>
<tr>
<th>设计原则</th>
<th>一句话归纳</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>开闭原则</td>
<td>对扩展开放，对修改关闭</td>
<td>降低维护带来的新风险</td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td>高层不应该依赖低层，要面向接口编程</td>
<td>更利于代码结构的升级扩展</td>
</tr>
<tr>
<td>单一职责原则</td>
<td>一个类只干一件事，实现类要单一</td>
<td>便于理解，提高代码的可读性</td>
</tr>
<tr>
<td>接口隔离原则</td>
<td>一个接口只干一件事，接口要精简单一</td>
<td>功能解耦，高聚合、低耦合</td>
</tr>
<tr>
<td>迪米特法则</td>
<td>不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td>
<td>只和朋友交流，不和陌生人说话，减少代码臃肿</td>
</tr>
<tr>
<td>里氏替换原则</td>
<td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td>
<td>防止继承泛滥</td>
</tr>
<tr>
<td>合成复用原则</td>
<td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td>
<td>降低代码耦合</td>
</tr>
</tbody></table>
<blockquote>
<p>记忆口诀：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。</p>
</blockquote>
<h1 id="创建型模式的特点和分类"><a href="#创建型模式的特点和分类" class="headerlink" title="创建型模式的特点和分类"></a>创建型模式的特点和分类</h1><p>创建型模式分为以下几种。</p>
<ul>
<li><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例（Singleton）模式</a>：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
</ul>
<p>以上 5 种创建型模式，除了<a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">工厂方法模式</a>属于类创建型模式，其他的全部属于对象创建型模式，我们将在之后的教程中详细地介绍它们的特点、结构与应用。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="什么是Singleton"><a href="#什么是Singleton" class="headerlink" title="什么是Singleton?"></a>什么是Singleton?</h3><p>Singleton:在Java中 即指单例设计模式，探视软件开发最常用的设计模式之一</p>
<p>单：唯一</p>
<p>例：实例</p>
<p>单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式</p>
<p>例如：代表JVM运行环境的Runtime类</p>
<h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><p>一是某个类只能有一个实例</p>
<ul>
<li>构造器私有化</li>
</ul>
<p>二是他必须自行创建实例</p>
<ul>
<li>含有一个该类的静态变量来保存这个唯一的实例</li>
</ul>
<p>三是它必须自行向整个系统提供这个实例</p>
<p>对外提供获取该类实例对象的方式</p>
<ul>
<li>直接暴露</li>
<li>用静态变量的get方法获取</li>
</ul>
<h3 id="几种常见形式"><a href="#几种常见形式" class="headerlink" title="几种常见形式"></a>几种常见形式</h3><p>饿汉式：直接创建对象，不存在线程安全问题</p>
<ul>
<li><p>直接实例化饿汉式(简洁直观)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、构造器私有化</span></span><br><span class="line"><span class="comment"> * 2、自行创建，并且用静态变量保存</span></span><br><span class="line"><span class="comment"> * 3、向外提供实例</span></span><br><span class="line"><span class="comment"> * 4、强调这是一个单例，我们可以用final修改</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>枚举式 (最简洁)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举类型：表示该类型是有限的几个</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>静态代码块饿汉式(适合复杂实例化)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton3 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton3</span>(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">(String info)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>懒汉式：延迟创建对象</p>
<ul>
<li><p>线程不安全(使用于单线程)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> * 线程不安全(使用于单线程)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>线程安全(使用于多线程)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> * 线程安全(使用于多线程)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton5 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton5.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>静态内部类模式 (适用于多线程)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、内部类被加载和初始化时，才创建INSTANCE实例对象</span></span><br><span class="line"><span class="comment"> * 2、静态内部类不会自动创建,随着外部类的加载初始化而初始化，他是要单独去加载和实例化的</span></span><br><span class="line"><span class="comment"> * 3、因为是在内部类加载和初始化时，创建的，因此线程安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton6</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton6</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton6</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="原型模式的定义与特点"><a href="#原型模式的定义与特点" class="headerlink" title="原型模式的定义与特点"></a>原型模式的定义与特点</h3><p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。</p>
<h4 id="原型模式的优点："><a href="#原型模式的优点：" class="headerlink" title="原型模式的优点："></a>原型模式的优点：</h4><ul>
<li><a href="http://c.biancheng.net/java/">Java</a> 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。</li>
<li>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。</li>
</ul>
<h4 id="原型模式的缺点："><a href="#原型模式的缺点：" class="headerlink" title="原型模式的缺点："></a>原型模式的缺点：</h4><ul>
<li>需要为每一个类都配置一个 clone 方法</li>
<li>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。</li>
<li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li>
</ul>
<h3 id="原型模式的结构与实现"><a href="#原型模式的结构与实现" class="headerlink" title="原型模式的结构与实现"></a>原型模式的结构与实现</h3><p>由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。</p>
<h4 id="1-模式的结构"><a href="#1-模式的结构" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h4><p>原型模式包含以下主要角色。</p>
<ol>
<li>抽象原型类：规定了具体原型对象必须实现的接口。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ol>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-2.png" alt="原型模式的结构图"></p>
<h4 id="2-模式的实现"><a href="#2-模式的实现" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h4><p>原型模式的克隆分为浅克隆和深克隆。</p>
<ul>
<li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li>
<li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li>
</ul>
<p>Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Realizetype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    Realizetype() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型模式的测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Realizetype</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Realizetype</span>();</span><br><span class="line">        <span class="type">Realizetype</span> <span class="variable">obj2</span> <span class="operator">=</span> (Realizetype) obj1.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;obj1==obj2?&quot;</span> + (obj1 == obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">具体原型创建成功！</span><br><span class="line">具体原型复制成功！</span><br><span class="line">obj1==obj2?false</span><br></pre></td></tr></table></figure>

<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="工厂模式的定义"><a href="#工厂模式的定义" class="headerlink" title="工厂模式的定义"></a>工厂模式的定义</h3><p>定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p>
<p>按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是简单工厂模式、工厂方法模式和抽象工厂模式。</p>
<p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。</p>
<p>在简单工厂模式中创建实例的方法通常为静态<code>static</code>方法，因此简单工厂模式<code>Simple Factory Pattern</code>又叫作静态工厂方法模式<code>Static Factory Method Pattern</code>。</p>
<p>简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。</p>
<p>简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。</p>
<blockquote>
<p>“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
</blockquote>
<h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。</li>
<li>客户端无需知道所创建具体产品的类名，只需知道参数即可。</li>
<li>也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。</li>
<li>使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度</li>
<li>系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂</li>
<li>简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。</p>
<h3 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>简单工厂模式的主要角色如下：</p>
<ul>
<li>简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li>
<li>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</li>
<li>具体产品（ConcreteProduct）：是简单工厂模式的创建目标。</li>
</ul>
<p>其结构图如下图所示:</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="简单工厂模式的结构图"></p>
<p>根据上图写出该模式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体产品：ProductA</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体产品：ProductB</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Const</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRODUCT_A</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRODUCT_B</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRODUCT_C</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">makeProduct</span><span class="params">(<span class="type">int</span> kind)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (kind) &#123;</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_A:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_B:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>在《<a href="http://c.biancheng.net/view/8387.html">简单工厂模式</a>》一节我们介绍了简单工厂模式，提到了简单工厂模式违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
<h3 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li>
<li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li>
<li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li>
</ul>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>类的个数容易过多，增加复杂度</li>
<li>增加了系统的抽象性和理解难度</li>
<li>抽象产品只能生产一种产品，此弊端可使用<a href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">抽象工厂模式</a>解决。</li>
</ul>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ul>
<li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li>
<li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li>
<li>客户不关心创建产品的细节，只关心产品的品牌</li>
</ul>
<h3 id="模式的结构与实现-1"><a href="#模式的结构与实现-1" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。本节来分析其基本结构和实现方法。</p>
<h4 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>工厂方法模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
<p>其结构图如图所示：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="工厂方法模式的结构图"></p>
<h4 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>写出该模式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractFactoryTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Product a;</span><br><span class="line">            AbstractFactory af;</span><br><span class="line">            af = (AbstractFactory) ReadXML1.getObject();</span><br><span class="line">            a = af.newProduct();</span><br><span class="line">            a.show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品1：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品2：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂：提供了厂品的生成方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">newProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂1：实现了厂品的生成方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">newProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂1生成--&gt;具体产品1...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂2：实现了厂品的生成方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">newProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂2生成--&gt;具体产品2...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadXML1</span> &#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文档对象</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">            Document doc;</span><br><span class="line">            doc = builder.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/FactoryMethod/config1.xml&quot;</span>));</span><br><span class="line">            <span class="comment">//获取包含类名的文本节点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">classNode</span> <span class="operator">=</span> nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            <span class="type">String</span> <span class="variable">cName</span> <span class="operator">=</span> <span class="string">&quot;FactoryMethod.&quot;</span> + classNode.getNodeValue();</span><br><span class="line">            <span class="comment">//System.out.println(&quot;新类名：&quot;+cName);</span></span><br><span class="line">            <span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">            Class&lt;?&gt; c = Class.forName(cName);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h3><p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>
</ul>
<p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p>
<ul>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>
<li>当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。</li>
<li>抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。</li>
</ul>
<p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。</p>
<h3 id="模式的结构与实现-2"><a href="#模式的结构与实现-2" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。</p>
<h4 id="模式的结构-1"><a href="#模式的结构-1" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>抽象工厂模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li>
</ol>
<p>抽象工厂模式的结构图如图所示：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="抽象工厂模式的结构图"></p>
<h4 id="模式的实现-1"><a href="#模式的实现-1" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>从上图可以看出抽象工厂模式的结构同工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以创建产品的方法也不止一个。下面给出抽象工厂和具体工厂的代码。</p>
<p>(1) 抽象工厂：提供了产品的生成方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product1 <span class="title function_">newProduct1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Product2 <span class="title function_">newProduct2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体工厂：实现了产品的生成方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product1 <span class="title function_">newProduct1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂 1 生成--&gt;具体产品 11...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct11</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Product2 <span class="title function_">newProduct2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂 1 生成--&gt;具体产品 21...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct21</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由 CPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。</p>
<p>生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。</p>
<p>以上所有这些产品都是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。</p>
<h3 id="模式的定义与特点-1"><a href="#模式的定义与特点-1" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h3><p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的<a href="http://c.biancheng.net/design_pattern/">设计模式</a>被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
<p>该模式的主要优点如下：</p>
<ol>
<li>封装性好，构建和表示分离。</li>
<li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦。</li>
<li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li>
</ol>
<p>其缺点如下：</p>
<ol>
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li>
</ol>
<p>建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而<a href="http://c.biancheng.net/view/1348.html">工厂方法模式</a>更注重零部件的创建过程，但两者可以结合使用。</p>
<h3 id="模式的结构与实现-3"><a href="#模式的结构与实现-3" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成，现在我们来分析其基本结构和实现方法。</p>
<h4 id="模式的结构-2"><a href="#模式的结构-2" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>建造者（Builder）模式的主要角色如下。</p>
<ol>
<li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。</li>
<li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li>
<li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li>
<li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li>
</ol>
<p>其结构图如图所示：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="建造者模式的结构图"></p>
<h4 id="模式的实现-2"><a href="#模式的实现-2" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>图 1 给出了建造者（Builder）模式的主要结构，其相关类的代码如下。</p>
<p>(1) 产品角色：包含多个组成部件的复杂对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartA</span><span class="params">(String partA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartB</span><span class="params">(String partB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.partB = partB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartC</span><span class="params">(String partC)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.partC = partC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//显示产品的特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(2) 抽象建造者：包含创建产品各个子部件的抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartB</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartC</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(3) 具体建造者：实现了抽象建造者接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartA</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;建造 PartA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartB</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartB(<span class="string">&quot;建造 PartB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartC</span><span class="params">()</span> &#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;建造 PartC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(4) 指挥者：调用建造者中的方法完成复杂对象的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(5) 客户类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteBuilder</span>();</span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构型模式概述"><a href="#结构型模式概述" class="headerlink" title="结构型模式概述"></a>结构型模式概述</h1><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下 7 种：</p>
<ol>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
</ol>
<p>以上 7 种结构型模式，除了<a href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a>分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式，下面我们会分别、详细地介绍它们的特点、结构与应用。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。</p>
<p>在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。</p>
<h3 id="代理模式的定义与特点"><a href="#代理模式的定义与特点" class="headerlink" title="代理模式的定义与特点"></a>代理模式的定义与特点</h3><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>代理模式的主要优点有：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</li>
</ul>
<p>其主要缺点是：</p>
<ul>
<li>代理模式会造成系统设计中类的数量增加</li>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
</ul>
<blockquote>
<p>那么如何解决以上提到的缺点呢？答案是可以使用动态代理方式</p>
</blockquote>
<h3 id="代理模式的结构与实现"><a href="#代理模式的结构与实现" class="headerlink" title="代理模式的结构与实现"></a>代理模式的结构与实现</h3><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。</p>
<h4 id="模式的结构-3"><a href="#模式的结构-3" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>代理模式的主要角色如下。</p>
<ol>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ol>
<p>其结构图如图所示：</p>
<p><img src="/Users/monochrome/project/blog/hexo-zhaoyangmushiyi/source/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="代理模式的结构图"></p>
<p>在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。</p>
<p>根据代理的创建时期，代理模式分为静态代理和动态代理。</p>
<ul>
<li>静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</li>
<li>动态：在程序运行时，运用反射机制动态创建而成</li>
</ul>
<h4 id="模式的实现-3"><a href="#模式的实现-3" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>代理模式的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="literal">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之前的预处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之后的后续处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问真实主题之前的预处理。</span><br><span class="line">访问真实主题方法...</span><br><span class="line">访问真实主题之后的后续处理。</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式（Adapter模式）"><a href="#适配器模式（Adapter模式）" class="headerlink" title="适配器模式（Adapter模式）"></a>适配器模式（Adapter模式）</h2><p>在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。</p>
<p>在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。</p>
<h3 id="模式的定义与特点-2"><a href="#模式的定义与特点-2" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h3><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>该模式的主要优点如下。</p>
<ul>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
<li>在很多业务场景中符合开闭原则。</li>
</ul>
<p>其缺点是：</p>
<ul>
<li>适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。</li>
<li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li>
</ul>
<h3 id="模式的结构与实现-4"><a href="#模式的结构与实现-4" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h3><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。</p>
<h4 id="模式的结构-4"><a href="#模式的结构-4" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>适配器模式（Adapter）包含以下主要角色。</p>
<ol>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ol>
<p>类适配器模式的结构图：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="类适配器模式的结构图"></p>
<p>对象适配器模式的结构图：</p>
<p><img src="/Users/monochrome/project/blog/hexo-zhaoyangmushiyi/source/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="对象适配器模式的结构图"></p>
<h4 id="模式的实现-4"><a href="#模式的实现-4" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>(1) 类适配器模式的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Target</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span></span><br><span class="line">    &#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;适配者中的业务代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassAdapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassAdapterTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类适配器模式测试：&quot;</span>);</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassAdapter</span>();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类适配器模式测试：</span><br><span class="line">适配者中的业务代码被调用！</span><br></pre></td></tr></table></figure>

<p>(2)对象适配器模式的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//对象适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectAdapterTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象适配器模式测试：&quot;</span>);</span><br><span class="line">        <span class="type">Adaptee</span> <span class="variable">adaptee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adaptee</span>();</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectAdapter</span>(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：对象适配器模式中的“目标接口”和“适配者类”的代码同类适配器模式一样，只要修改适配器类和客户端的代码即可。</p>
<p>程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对象适配器模式测试：</span><br><span class="line">适配者中的业务代码被调用！</span><br></pre></td></tr></table></figure>

<h2 id="桥接模式（Bridge模式）"><a href="#桥接模式（Bridge模式）" class="headerlink" title="桥接模式（Bridge模式）"></a>桥接模式（Bridge模式）</h2><p>在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。</p>
<p>当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。如果用桥接模式就能很好地解决这些问题。</p>
<h3 id="桥接模式的定义与特点"><a href="#桥接模式的定义与特点" class="headerlink" title="桥接模式的定义与特点"></a>桥接模式的定义与特点</h3><p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>通过上面的讲解，我们能很好的感觉到桥接模式遵循了里氏替换原则和依赖倒置原则，最终实现了开闭原则，对修改关闭，对扩展开放。这里将桥接模式的优缺点总结如下。</p>
<p>桥接（Bridge）模式的优点是：</p>
<ul>
<li>抽象与实现分离，扩展能力强</li>
<li>符合开闭原则</li>
<li>符合合成复用原则</li>
<li>其实现细节对客户透明</li>
</ul>
<p>缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。</p>
<h3 id="桥接模式的结构与实现"><a href="#桥接模式的结构与实现" class="headerlink" title="桥接模式的结构与实现"></a>桥接模式的结构与实现</h3><p>可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p>
<h4 id="模式的结构-5"><a href="#模式的结构-5" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>桥接（Bridge）模式包含以下主要角色。</p>
<ol>
<li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li>
</ol>
<p>其结构图：</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="桥接模式的结构图"></p>
<h4 id="模式的实现-5"><a href="#模式的实现-5" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>桥接模式的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BridgeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Implementor</span> <span class="variable">imple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteImplementorA</span>();</span><br><span class="line">        <span class="type">Abstraction</span> <span class="variable">abs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefinedAbstraction</span>(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OperationImpl</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现化角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OperationImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体实现化(Concrete Implementor)角色被访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor imple;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Abstraction</span><span class="params">(Implementor imple)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.imple = imple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展抽象化角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RefinedAbstraction</span><span class="params">(Implementor imple)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(imple);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展抽象化(Refined Abstraction)角色被访问&quot;</span>);</span><br><span class="line">        imple.OperationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">扩展抽象化(Refined Abstraction)角色被访问</span><br><span class="line">具体实现化(Concrete Implementor)角色被访问</span><br></pre></td></tr></table></figure>

<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>上班族大多都有睡懒觉的习惯，每天早上上班时间都很紧张，于是很多人为了多睡一会，就会用方便的方式解决早餐问题。有些人早餐可能会吃煎饼，煎饼中可以加鸡蛋，也可以加香肠，但是不管怎么“加码”，都还是一个煎饼。在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，都是装饰器模式。</p>
<p>在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰器模式来实现。</p>
<h3 id="装饰器模式的定义与特点"><a href="#装饰器模式的定义与特点" class="headerlink" title="装饰器模式的定义与特点"></a>装饰器模式的定义与特点</h3><p>装饰器（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>装饰器模式的主要优点有：</p>
<ul>
<li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用</li>
<li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果</li>
<li>装饰器模式完全遵守开闭原则</li>
</ul>
<p>其主要缺点是：装饰器模式会增加许多子类，过度使用会增加程序得复杂性。</p>
<h3 id="装饰器模式的结构与实现"><a href="#装饰器模式的结构与实现" class="headerlink" title="装饰器模式的结构与实现"></a>装饰器模式的结构与实现</h3><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。下面来分析其基本结构和实现方法。</p>
<h4 id="模式的结构-6"><a href="#模式的结构-6" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>装饰器模式主要包含以下角色。</p>
<ol>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ol>
<p>装饰器模式的结构图:</p>
<p><img src="/images/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%BC%86%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="装饰模式的结构图"></p>
<h4 id="模式的实现-6"><a href="#模式的实现-6" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>装饰器模式的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Component</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDecorator</span>(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteComponent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建具体构件角色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用具体构件角色的方法operation()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addedFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;为具体构件角色增加额外的功能addedFunction()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建具体构件角色</span><br><span class="line">调用具体构件角色的方法operation()</span><br><span class="line">---------------------------------</span><br><span class="line">调用具体构件角色的方法operation()</span><br><span class="line">为具体构件角色增加额外的功能addedFunction()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA 快捷键</title>
    <url>/2018/11/23/IntelliJ%20IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h3 id="Idea快捷键"><a href="#Idea快捷键" class="headerlink" title="Idea快捷键"></a>Idea快捷键</h3><h4 id="一、跳转"><a href="#一、跳转" class="headerlink" title="一、跳转"></a>一、跳转</h4><p>1.ctrl+Alt+[] 项目之间跳转<br>2.ctrl+e 最近的文件<br>3.ctrl+shift+e 最近编辑的文件<br>4.ctrl+shift+backspace 浏览修改位置的跳转<br>5.ctrl+shift+左箭头（win10会改变屏幕方向） 最新浏览位置的修改<br>6.使用书签进行跳转<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+<span class="built_in">shift</span>+数字或字母 标记书签  </span><br><span class="line">ctrl+数字或者字母 跳转书签  </span><br><span class="line"><span class="built_in">shift</span>+F11 总览书签  </span><br></pre></td></tr></table></figure><br>7.Ctrl+Up&#x2F;Down 光标中转到当前界面第一行或最后一行下<br>8.Ctrl+[OR] 可以跑到大括号的开头与结尾<br>9.F2 1跳转到错误位置  </p>
<span id="more"></span>
<h4 id="二、高效定位代码"><a href="#二、高效定位代码" class="headerlink" title="二、高效定位代码"></a>二、高效定位代码</h4><p>1.ctrl+n 定位类<br>2.ctrl+shift+n 定位文件<br>3.ctrl+shift+alt+n 定位函数或者属性<br>4.ctrl+shift+f 定位字符串  </p>
<h4 id="三、列操作"><a href="#三、列操作" class="headerlink" title="三、列操作"></a>三、列操作</h4><p>1.ctrl+shift+alt+j 列操作（多行逻辑操作、批量操作）<br>2.Ctrl+←(→) 移动到一个词的开始(结尾)<br>3.Ctrl+Shift+←(→) 从后到前（从前到后）选中一个词<br>4.Ctrl+Home 第一行代码<br>5.Ctrl+End 最后一行代码<br>6.ctrl+alt+l 代码格式化  </p>
<h4 id="四、Livetemplate"><a href="#四、Livetemplate" class="headerlink" title="四、Livetemplate"></a>四、Livetemplate</h4><p>1.Livetemplate 自定义代码模块快捷键和内容  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">位置:ctrl+<span class="built_in">shift</span>+a查找livetemplates,回车  </span><br><span class="line">    <span class="variable">$VAR1</span>第一个值<span class="variable">$VAR2</span>第一个值<span class="variable">$VAR2</span>第二个值  </span><br><span class="line">    $END$鼠标停留位置  </span><br><span class="line">    回车跳转到到下个值</span><br></pre></td></tr></table></figure>
<h4 id="五、Postfix"><a href="#五、Postfix" class="headerlink" title="五、Postfix"></a>五、Postfix</h4><p>1.postfix 参数后面点函数回车，生成代码位置:ctrl+shift+a查找postfix,回车name.field——可自动添加this.name&#x3D;name以及private String name;<br>  常用：<br>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-foo.fori <span class="keyword">for</span>(int i = 0; i &lt; foo; i++)&#123;&#125;</span><br><span class="line">-foo.return <span class="built_in">return</span> foo;</span><br><span class="line">-foo.sout System.out.println(foo);</span><br><span class="line">-foo.field private Foo foo; this.foo = foo;</span><br><span class="line">-foo.nn <span class="keyword">if</span>(user!=null)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="六、Alter-enter"><a href="#六、Alter-enter" class="headerlink" title="六、Alter+enter"></a>六、Alter+enter</h4><p>1.Alter+enter 智能提示<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-自动创建函数</span><br><span class="line">-list replace 列表替换优化</span><br><span class="line">-字符串format或者build 字符串格式化，build优化减小内存</span><br><span class="line">-接口实现 在接口上回车可自动创建实现类</span><br><span class="line">-单词拼写 波浪线为存在单词问题，可校对单词</span><br><span class="line">-导包</span><br><span class="line">-不知道怎么做就试试Alter+enter</span><br></pre></td></tr></table></figure></p>
<h4 id="七、重构"><a href="#七、重构" class="headerlink" title="七、重构"></a>七、重构</h4><p>1.shift+F6 重构，将某个参数全部修改。<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-重构变量</span><br><span class="line">-重构方法</span><br></pre></td></tr></table></figure></p>
<h4 id="八、抽取"><a href="#八、抽取" class="headerlink" title="八、抽取"></a>八、抽取</h4><p>1.抽取，将常用数据抽取出来变成简单变量或函数。<br>    -抽取变量 Ctrl+Alt+V<br>    -抽取静态变量 Ctrl+Alt+C<br>    -抽取成员变量 Ctrl+Alt+F<br>    -抽取方法参数 Ctrl+Alt+P<br>    -抽取函数 Ctrl+Alt+M  </p>
<h4 id="九、寻找修改轨迹"><a href="#九、寻找修改轨迹" class="headerlink" title="九、寻找修改轨迹"></a>九、寻找修改轨迹</h4><p>1.annotate代码前右击，选中annotate，可以找到代码的所有者，更进一步点击，还可以找到该作者的修改记录<br>2.Ctrl+Alt+Shift+上下箭头 寻找改动的地方<br>3.Ctrl+Alt+Z 撤销，包括单个和项目改动之处<br>4.Local history idea本地历史记录<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Put Label 本地存档说明</span><br><span class="line">Put Label可以用Ctrl+Alt+A的Local History里找到</span><br></pre></td></tr></table></figure></p>
<h4 id="十、关联"><a href="#十、关联" class="headerlink" title="十、关联"></a>十、关联</h4><p>1.spring关联<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl+Alt+Shift+S 中的Facets配置。</span><br><span class="line">可在代码前的行数中看到Spring的关系</span><br></pre></td></tr></table></figure><br>2.与数据库关联<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">添加Database在mapper输入时可以自动提示Database字段。</span><br><span class="line">Shinf+f6重构改表名mapper也可以改。或者直接改。</span><br></pre></td></tr></table></figure></p>
<h4 id="十一、断点调试"><a href="#十一、断点调试" class="headerlink" title="十一、断点调试"></a>十一、断点调试</h4><p>1.Ctrl+F8 添加删除断点<br>2.Shift +f9 dubug运行<br>3.F8 单步运行<br>4.F9 跳到下一个断点<br>5.Ctrl+Shift+F8 查看所有断点位置（在有断点的位置为设置条件断点）<br>6.Alt+F8 查看当前变量值和表达式求值<br>7.Alt+F9 运行到光标位置<br>8.setValue 在debug页面按F2动态设置传递的值<br>9.Ctrl+Shift+f9 运行光标最小上下文<br>10.Shift+Alt+F9 最近运行的历史列表选择运行  </p>
<h4 id="十二、文件操作"><a href="#十二、文件操作" class="headerlink" title="十二、文件操作"></a>十二、文件操作</h4><p>1.Ctrl+Alt+Insert 新建文件<br>2.F5 复制文件<br>3.F6 移动文件  </p>
<h4 id="十三、文本操作"><a href="#十三、文本操作" class="headerlink" title="十三、文本操作"></a>十三、文本操作</h4><p>1.Ctrl+C 复制文件名<br>2.Ctrl+Shift+C 复制文件路径<br>3.Ctrl+Shift+V 剪切板（历史复制）  </p>
<h4 id="十四、结构图"><a href="#十四、结构图" class="headerlink" title="十四、结构图"></a>十四、结构图</h4><p>1.Ctrl+F12 查看当前field,method大纲<br>2.Ctrl+alt+Shift+U查看maven依赖，类图<br>3.Ctrl+H，查看类的继承关系<br>4.Ctrl+Alt+H，查看方法的调用和被调用关系  </p>
<h4 id="十五、其他快捷键"><a href="#十五、其他快捷键" class="headerlink" title="十五、其他快捷键"></a>十五、其他快捷键</h4><p>1.Alt+Q 可以看到当前方法的声明<br>2.Alt+Insert 可以生成构造器&#x2F;Getter&#x2F;Setter等<br>3.Ctrl+&#x2F;或Ctrl+Shift+&#x2F; 注释（&#x2F;&#x2F;或者&#x2F;**&#x2F;）<br>4.Ctrl+J 自动代码（例如：serr）<br>5.Ctrl+Shift+J 整合两行<br>6.Ctrl+Shift+U 大小写转化<br>7.Ctrl+Y 删除当前行<br>8.Ctrl+D 复制当前行<br>9.Shift+Enter 向下插入新行<br>10.Ctrl+”+&#x2F;-”，当前方法展开、折叠<br>11.Ctrl+Shift+”+&#x2F;-”，全部展开、折叠</p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch整合Kibana和Logstash环境搭建</title>
    <url>/2020/01/07/Elasticsearch%E6%95%B4%E5%90%88Kibana%E5%92%8CLogstash%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="Install-Elasticsearch-with-Docker"><a href="#Install-Elasticsearch-with-Docker" class="headerlink" title="Install Elasticsearch with Docker"></a>Install Elasticsearch with Docker</h3><h4 id="Pulling-the-image"><a href="#Pulling-the-image" class="headerlink" title="Pulling the image"></a>Pulling the image</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch</span><br></pre></td></tr></table></figure>

<h4 id="Starting-a-single-node-cluster-with-Docker"><a href="#Starting-a-single-node-cluster-with-Docker" class="headerlink" title="Starting a single node cluster with Docker"></a>Starting a single node cluster with Docker</h4><p>采用Docker启动一个单节点的<code>Elasticsearch</code>集群:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d：后台启动 -p：开放端口 --name：设置名称</span></span><br><span class="line">docker -d run -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; --name elasticsearch-monochrome docker.elastic.co/elasticsearch/elasticsearch:7.5.1</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="Starting-a-multi-node-cluster-with-Docker-Compose"><a href="#Starting-a-multi-node-cluster-with-Docker-Compose" class="headerlink" title="Starting a multi-node cluster with Docker Compose"></a>Starting a multi-node cluster with Docker Compose</h4><p>通过<code>Docker Compose</code>创建一个包含3个节点的<code>Elasticsearch</code>集群 :</p>
<ol>
<li><p>创建一个 <code>docker-compose.yml</code> file:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">es01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.5.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es01</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data01:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.5.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es02</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data02:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.5.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es03</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data03:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">data01:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data02:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data03:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">elastic:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>Run <code>docker-compose</code> 来启动集群:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Install-Kibana-with-Docker"><a href="#Install-Kibana-with-Docker" class="headerlink" title="Install Kibana with Docker"></a>Install Kibana with Docker</h3><h4 id="Pulling-the-image-1"><a href="#Pulling-the-image-1" class="headerlink" title="Pulling the image"></a>Pulling the image</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/kibana/kibana</span><br></pre></td></tr></table></figure>

<h4 id="Configuring-Kibana"><a href="#Configuring-Kibana" class="headerlink" title="Configuring Kibana"></a>Configuring Kibana</h4><p>新建配置文件<code>kibana.yml</code>，很多默认的配置，只需要修改几个配置即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Kibana is served by a back end server. This setting specifies the port to use.</span></span><br><span class="line"><span class="comment">#server.port: 5601</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.</span></span><br><span class="line"><span class="comment"># The default is &#x27;localhost&#x27;, which usually means remote machines will not be able to connect.</span></span><br><span class="line"><span class="comment"># To allow connections from remote users, set this parameter to a non-loopback address.</span></span><br><span class="line"><span class="comment"># 允许远程访问</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="comment">#server.host: &quot;localhost&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enables you to specify a path to mount Kibana at if you are running behind a proxy.</span></span><br><span class="line"><span class="comment"># Use the `server.rewriteBasePath` setting to tell Kibana if it should remove the basePath</span></span><br><span class="line"><span class="comment"># from requests it receives, and to prevent a deprecation warning at startup.</span></span><br><span class="line"><span class="comment"># This setting cannot end in a slash.</span></span><br><span class="line"><span class="comment">#server.basePath: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies whether Kibana should rewrite requests that are prefixed with</span></span><br><span class="line"><span class="comment"># `server.basePath` or require that they are rewritten by your reverse proxy.</span></span><br><span class="line"><span class="comment"># This setting was effectively always `false` before Kibana 6.3 and will</span></span><br><span class="line"><span class="comment"># default to `true` starting in Kibana 7.0.</span></span><br><span class="line"><span class="comment">#server.rewriteBasePath: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The maximum payload size in bytes for incoming server requests.</span></span><br><span class="line"><span class="comment">#server.maxPayloadBytes: 1048576</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Kibana server&#x27;s name.  This is used for display purposes.</span></span><br><span class="line"><span class="comment">#server.name: &quot;your-hostname&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The URLs of the Elasticsearch instances to use for all your queries.</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> [<span class="string">&quot;http://localhost:9200&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># When this setting&#x27;s value is true Kibana uses the hostname specified in the server.host</span></span><br><span class="line"><span class="comment"># setting. When the value of this setting is false, Kibana uses the hostname of the host</span></span><br><span class="line"><span class="comment"># that connects to this Kibana instance.</span></span><br><span class="line"><span class="comment">#elasticsearch.preserveHost: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kibana uses an index in Elasticsearch to store saved searches, visualizations and</span></span><br><span class="line"><span class="comment"># dashboards. Kibana creates a new index if the index doesn&#x27;t already exist.</span></span><br><span class="line"><span class="comment">#kibana.index: &quot;.kibana&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The default application to load.</span></span><br><span class="line"><span class="comment">#kibana.defaultAppId: &quot;home&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If your Elasticsearch is protected with basic authentication, these settings provide</span></span><br><span class="line"><span class="comment"># the username and password that the Kibana server uses to perform maintenance on the Kibana</span></span><br><span class="line"><span class="comment"># index at startup. Your Kibana users still need to authenticate with Elasticsearch, which</span></span><br><span class="line"><span class="comment"># is proxied through the Kibana server.</span></span><br><span class="line"><span class="comment">#elasticsearch.username: &quot;kibana&quot;</span></span><br><span class="line"><span class="comment">#elasticsearch.password: &quot;pass&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enables SSL and paths to the PEM-format SSL certificate and SSL key files, respectively.</span></span><br><span class="line"><span class="comment"># These settings enable SSL for outgoing requests from the Kibana server to the browser.</span></span><br><span class="line"><span class="comment">#server.ssl.enabled: false</span></span><br><span class="line"><span class="comment">#server.ssl.certificate: /path/to/your/server.crt</span></span><br><span class="line"><span class="comment">#server.ssl.key: /path/to/your/server.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional settings that provide the paths to the PEM-format SSL certificate and key files.</span></span><br><span class="line"><span class="comment"># These files validate that your Elasticsearch backend uses the same key files.</span></span><br><span class="line"><span class="comment">#elasticsearch.ssl.certificate: /path/to/your/client.crt</span></span><br><span class="line"><span class="comment">#elasticsearch.ssl.key: /path/to/your/client.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional setting that enables you to specify a path to the PEM file for the certificate</span></span><br><span class="line"><span class="comment"># authority for your Elasticsearch instance.</span></span><br><span class="line"><span class="comment">#elasticsearch.ssl.certificateAuthorities: [ &quot;/path/to/your/CA.pem&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To disregard the validity of SSL certificates, change this setting&#x27;s value to &#x27;none&#x27;.</span></span><br><span class="line"><span class="comment">#elasticsearch.ssl.verificationMode: full</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time in milliseconds to wait for Elasticsearch to respond to pings. Defaults to the value of</span></span><br><span class="line"><span class="comment"># the elasticsearch.requestTimeout setting.</span></span><br><span class="line"><span class="comment">#elasticsearch.pingTimeout: 1500</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time in milliseconds to wait for responses from the back end or Elasticsearch. This value</span></span><br><span class="line"><span class="comment"># must be a positive integer.</span></span><br><span class="line"><span class="comment">#elasticsearch.requestTimeout: 30000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of Kibana client-side headers to send to Elasticsearch. To send *no* client-side</span></span><br><span class="line"><span class="comment"># headers, set this value to [] (an empty list).</span></span><br><span class="line"><span class="comment">#elasticsearch.requestHeadersWhitelist: [ authorization ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Header names and values that are sent to Elasticsearch. Any custom headers cannot be overwritten</span></span><br><span class="line"><span class="comment"># by client-side headers, regardless of the elasticsearch.requestHeadersWhitelist configuration.</span></span><br><span class="line"><span class="comment">#elasticsearch.customHeaders: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time in milliseconds for Elasticsearch to wait for responses from shards. Set to 0 to disable.</span></span><br><span class="line"><span class="comment">#elasticsearch.shardTimeout: 30000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time in milliseconds to wait for Elasticsearch at Kibana startup before retrying.</span></span><br><span class="line"><span class="comment">#elasticsearch.startupTimeout: 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logs queries sent to Elasticsearch. Requires logging.verbose set to true.</span></span><br><span class="line"><span class="comment">#elasticsearch.logQueries: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies the path where Kibana creates the process ID file.</span></span><br><span class="line"><span class="comment">#pid.file: /var/run/kibana.pid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enables you specify a file where Kibana stores log output.</span></span><br><span class="line"><span class="comment">#logging.dest: stdout</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the value of this setting to true to suppress all logging output.</span></span><br><span class="line"><span class="comment">#logging.silent: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the value of this setting to true to suppress all logging output other than error messages.</span></span><br><span class="line"><span class="comment">#logging.quiet: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the value of this setting to true to log all events, including system usage information</span></span><br><span class="line"><span class="comment"># and all requests.</span></span><br><span class="line"><span class="comment">#logging.verbose: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the interval in milliseconds to sample system and process performance</span></span><br><span class="line"><span class="comment"># metrics. Minimum is 100ms. Defaults to 5000.</span></span><br><span class="line"><span class="comment">#ops.interval: 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies locale to be used for all localizable strings, dates and number formats.</span></span><br><span class="line"><span class="comment"># Supported languages are the following: English - en , by default , Chinese - zh-CN .</span></span><br><span class="line"><span class="comment"># 默认语言设置为中文</span></span><br><span class="line"><span class="attr">i18n.locale:</span> <span class="string">&quot;zh-CN&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="编排docker-compose"><a href="#编排docker-compose" class="headerlink" title="编排docker-compose"></a>编排docker-compose</h4><p>新建文件<code>docker-compose.yml</code>，配置特权方式和端口，映射配置kibana.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/kibana/kibana:7.5.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5601:5601&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./kibana.yml:/usr/share/kibana/config/kibana.yml</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="启动Kibana"><a href="#启动Kibana" class="headerlink" title="启动Kibana"></a>启动Kibana</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h3 id="Install-Logstash-with-Docker-and-Auto-Sync-Mysql-data"><a href="#Install-Logstash-with-Docker-and-Auto-Sync-Mysql-data" class="headerlink" title="Install Logstash with Docker and Auto-Sync Mysql data"></a>Install Logstash with Docker and Auto-Sync Mysql data</h3><h4 id="Pulling-the-image-2"><a href="#Pulling-the-image-2" class="headerlink" title="Pulling the image"></a>Pulling the image</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull docker.elastic.co/logstash/logstash:7.5.1</span><br></pre></td></tr></table></figure>

<h4 id="自定义docker镜像"><a href="#自定义docker镜像" class="headerlink" title="自定义docker镜像"></a>自定义docker镜像</h4><ol>
<li><p>新建<code>Dockerfile</code>文件</p>
</li>
<li><p>配置<code>Dockerfile</code></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> docker.elastic.co/logstash/logstash:<span class="number">7.5</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装input插件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> logstash-plugin install logstash-input-jdbc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装output插件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> logstash-plugin install logstash-output-elasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装json_lines插件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> logstash-plugin install logstash-codec-json_lines</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#容器启动时执行的命令.(CMD 能够被 docker run 后面跟的命令行参数替换)</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;-f&quot;</span>,<span class="string">&quot;/usr/share/logstash/config/mysql.conf&quot;</span>]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t my_logstash .</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="创建配置相关的文件"><a href="#创建配置相关的文件" class="headerlink" title="创建配置相关的文件"></a>创建配置相关的文件</h4><ol>
<li><p>创建配置文件夹，所有配置文件都放在这个文件夹下面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /data/logstash/config</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>logstash.yml (空文件就行)</strong></p>
</li>
<li><p><strong>log4j2.properties</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logger.elasticsearchoutput.name</span> = <span class="string">logstash.outputs.elasticsearch</span></span><br><span class="line"><span class="attr">logger.elasticsearchoutput.level</span> = <span class="string">debug</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>pipelines.yml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- pipeline.id: my-logstash</span><br><span class="line">  path.config: &quot;/usr/share/logstash/config/*.conf&quot;</span><br><span class="line">  pipeline.workers: 3</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mysql.conf</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">input <span class="punctuation">&#123;</span></span><br><span class="line">	jdbc <span class="punctuation">&#123;</span></span><br><span class="line">		jdbc_connection_string =&gt;</span><br><span class="line">			<span class="string">&quot;jdbc:mysql://localhost:3306/&lt;database_name&gt;?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true&quot;</span></span><br><span class="line">        ## 数据库账号和密码</span><br><span class="line">		jdbc_user =&gt; <span class="string">&quot;root&quot;</span></span><br><span class="line">		jdbc_password =&gt; <span class="string">&quot;root&quot;</span></span><br><span class="line">		## 数据库驱动的JAR位置</span><br><span class="line">		jdbc_driver_library =&gt; <span class="string">&quot;/usr/share/logstash/config/mysql-connector-java-5.1.47.jar&quot;</span></span><br><span class="line">		jdbc_driver_class =&gt; <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">		jdbc_paging_enabled =&gt; <span class="string">&quot;true&quot;</span></span><br><span class="line">		jdbc_page_size =&gt; <span class="string">&quot;50000&quot;</span></span><br><span class="line">        ## 查询的数据，根据数据库自己定义</span><br><span class="line">		statement =&gt; <span class="string">&quot;select * from tb_user&quot;</span></span><br><span class="line">		## 每分钟执行一次</span><br><span class="line">		schedule =&gt; <span class="string">&quot;* * * * *&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">output <span class="punctuation">&#123;</span></span><br><span class="line">	elasticsearch <span class="punctuation">&#123;</span></span><br><span class="line">		## elasticsearch 地址</span><br><span class="line">		hosts =&gt; <span class="string">&quot;localhost:9200&quot;</span></span><br><span class="line">		## 索引名称</span><br><span class="line">		index =&gt; <span class="string">&quot;index-user&quot;</span></span><br><span class="line">        ## 主键</span><br><span class="line">		document_id =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line">		## 索引类型</span><br><span class="line">		document_type =&gt; <span class="string">&quot;user&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line">	stdout <span class="punctuation">&#123;</span></span><br><span class="line">		codec =&gt; json_lines</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库驱动jar包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://repo1.maven.org/maven2/mysql/mysql-connector-java/5.1.47/mysql-connector-java-5.1.47.jar</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="特权方式启动Logstash"><a href="#特权方式启动Logstash" class="headerlink" title="特权方式启动Logstash"></a>特权方式启动<code>Logstash</code></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --privileged=true -p 4560:4560 -p 9600:9600 -it --name=my_logstash -v /data/logstash/config/:/usr/share/logstash/config/   my_logstash</span><br></pre></td></tr></table></figure>

<p>查看日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f -t --tail 10 my_logstash</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Elastic Stack</category>
        <category>Elasticsearch</category>
        <category>Kibana</category>
        <category>Logstash</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>Kibana</tag>
        <tag>Logstash</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins环境安装</title>
    <url>/2019/01/11/Jenkins%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>　　Jenkins是一款由Java编写的开源的持续集成工具。<br>　　Jenkins提供了软件开发的持续集成服务。它运行在Servlet容器中（例如Apache Tomcat）。它支持软件配置管理（SCM）工具（包括AccuRev SCM、CVS、Subversion、Git、Perforce、Clearcase和RTC），可以执行基于Apache Ant和Apache Maven的项目，以及任意的Shell脚本和Windows批处理命令。Jenkins的主要开发者是川口耕介。Jenkins是在MIT许可证下发布的自由软件。<br>　　可以通过各种手段触发构建。例如提交给版本控制系统时被触发，也可以通过类似Cron的机制调度，也可以在其他的构建已经完成时，还可以通过一个特定的URL进行请求。</p>
<span id="more"></span>

<h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><h3 id="JDK环境安装"><a href="#JDK环境安装" class="headerlink" title="JDK环境安装"></a>JDK环境安装</h3><p>安装wget，wget是一个从网络上自动下载文件的自由工具，支持通过 HTTP、HTTPS、FTP 三个最常见的 TCP&#x2F;IP协议 下载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install wget</span><br></pre></td></tr></table></figure>
<p>下载<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JDK</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F;oraclelicense=accept-securebackup-cookie&quot; https://download.oracle.com/otn-pub/java/jdk/8u191-b12/2787e4a523244c269598db4e85c51e0c/jdk-8u191-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u191-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p>配置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">#set java environment</span><br><span class="line">JAVA_HOME=/usr/java/jdk1.8</span><br><span class="line">CLASS_PATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export PATH JAVA_HOME CLASS_PATH</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h3 id="Maven安装"><a href="#Maven安装" class="headerlink" title="Maven安装"></a>Maven安装</h3><p>下载<a href="http://mirror.bit.edu.cn/apache/maven/maven-3/">Maven</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://mirror.bit.edu.cn/apache/maven/maven-3/3.6.0/binaries/apache-maven-3.6.0-bin.tar.gz</span><br></pre></td></tr></table></figure>
<p>添加阿里的Maven仓库节点配置<code>conf/settings.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>配置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Maven environment</span><br><span class="line">MAVEN_HOME=/usr/maven</span><br><span class="line">PATH=$PATH:$MAVEN_HOME/bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>
<h3 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h3><p>下载<a href="http://updates.jenkins-ci.org/download/war/">Jenkins</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://updates.jenkins-ci.org/download/war/2.157/jenkins.war</span><br></pre></td></tr></table></figure>
<p>启动Jenkins war包，默认8080端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar jenkins.war</span><br></pre></td></tr></table></figure>
<p>开放端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=8080/tcp --permanent   #添加规则</span><br><span class="line">firewall-cmd --reload                          #重新加载防火墙配置</span><br></pre></td></tr></table></figure>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC核心知识点</title>
    <url>/2021/04/20/JUC%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>JMM是指Java<strong>内存模型</strong>，不是Java<strong>内存布局</strong>，不是所谓的栈、堆、方法区。</p>
<p>每个Java线程都有自己的<strong>工作内存</strong>。操作数据，首先从主内存中读，得到一份拷贝，操作完毕后再写回到主内存。</p>
<p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/JMM.png" alt="threadPoolProcedure">JMM可能带来<strong>可见性</strong>、<strong>原子性</strong>和<strong>有序性</strong>问题。所谓可见性，就是某个线程对主内存内容的更改，应该立刻通知到其它线程。原子性是指一个操作是不可分割的，不能执行到一半，就不执行了。所谓有序性，就是指令是有序的，不会被重排。</p>
<span id="more"></span>

<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p><code>volatile</code>关键字是Java提供的一种<strong>轻量级</strong>同步机制。它能够保证<strong>可见性</strong>和<strong>有序性</strong>，但是不能保证<strong>原子性</strong>。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/thread/VolatileDemo.java">可见性测试</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//volatile int number=0;</span></span><br><span class="line"></span><br><span class="line">    AtomicInteger atomicInteger=<span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTo60</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.number=<span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时number前面已经加了volatile，但是不保证原子性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPlusPlus</span><span class="params">()</span>&#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtomic</span><span class="params">()</span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//volatile可以保证可见性，及时通知其它线程主物理内存的值已被修改</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">volatileVisibilityDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;可见性测试&quot;</span>);</span><br><span class="line">    <span class="type">MyData</span> <span class="variable">myData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();<span class="comment">//资源类</span></span><br><span class="line">    <span class="comment">//启动一个线程操作共享数据</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">3</span>);myData.setTo60();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t update number value: &quot;</span>+myData.number);&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;e.printStackTrace();&#125;</span><br><span class="line">    &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">    <span class="keyword">while</span> (myData.number==<span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">//main线程持有共享数据的拷贝，一直为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t mission is over. main get number value: &quot;</span>+myData.number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MyData</code>类是资源类，一开始<code>number</code>变量没有用<code>volatile</code>修饰，所以程序运行的结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">可见性测试</span><br><span class="line">AAA	 come in</span><br><span class="line">AAA	 update number value: <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>虽然一个线程把<code>number</code>修改成了60，但是<code>main</code>线程持有的仍然是最开始的0，所以一直循环，程序不会结束。</p>
<p>如果对<code>number</code>添加了<code>volatile</code>修饰，运行结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AAA	 come in</span><br><span class="line">AAA	 update number value: <span class="number">60</span></span><br><span class="line">main	 mission is over. main get number value: <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>可见某个线程对<code>number</code>的修改，会立刻反映到主内存上。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p><code>volatile</code>并<strong>不能保证操作的原子性</strong>。这是因为，比如一条number++的操作，会形成3条指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getfield        //读</span><br><span class="line">iconst_1	//++常量1</span><br><span class="line">iadd		//加操作</span><br><span class="line">putfield	//写操作</span><br></pre></td></tr></table></figure>

<p>假设有3个线程，分别执行number++，都先从主内存中拿到最开始的值，number&#x3D;0，然后三个线程分别进行操作。假设线程0执行完毕，number&#x3D;1，也立刻通知到了其它线程，但是此时线程1、2已经拿到了number&#x3D;0，所以结果就是写覆盖，线程1、2将number变成1。</p>
<p>解决的方式就是：</p>
<ol>
<li>对<code>addPlusPlus()</code>方法加锁。</li>
<li>使用<code>java.util.concurrent.AtomicInteger</code>类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">atomicDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;原子性测试&quot;</span>);</span><br><span class="line">    MyData myData=<span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                myData.addPlusPlus();</span><br><span class="line">                myData.addAtomic();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t int type finally number value: &quot;</span>+myData.number);</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t AtomicInteger type finally number value: &quot;</span>+myData.atomicInteger);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：可见，由于<code>volatile</code>不能保证原子性，出现了线程重复写的问题，最终结果比20000小。而<code>AtomicInteger</code>可以保证原子性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">原子性测试</span><br><span class="line">main	 <span class="type">int</span> type <span class="keyword">finally</span> number value: <span class="number">17542</span></span><br><span class="line">main	 AtomicInteger type <span class="keyword">finally</span> number value: <span class="number">20000</span></span><br></pre></td></tr></table></figure>

<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p><a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/thread/ResortSeqDemo.java">有序性案例</a></p>
<p>volatile可以保证<strong>有序性</strong>，也就是防止<strong>指令重排序</strong>。所谓指令重排序，就是出于优化考虑，CPU执行指令的顺序跟程序员自己编写的顺序不一致。就好比一份试卷，题号是老师规定的，是程序员规定的，但是考生（CPU）可以先做选择，也可以先做填空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11</span>; <span class="comment">//语句1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">12</span>; <span class="comment">//语句2</span></span><br><span class="line">x = x + <span class="number">5</span>;  <span class="comment">//语句3</span></span><br><span class="line">y = x * x;  <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p>以上例子，可能出现的执行顺序有1234、2134、1342，这三个都没有问题，最终结果都是x &#x3D; 16，y&#x3D;256。但是如果是4开头，就有问题了，y&#x3D;0。这个时候就<strong>不需要</strong>指令重排序。</p>
<p>volatile底层是用CPU的<strong>内存屏障</strong>（Memory Barrier）指令来实现的，有两个作用，一个是保证特定操作的顺序性，二是保证变量的可见性。在指令之间插入一条Memory Barrier指令，告诉编译器和CPU，在Memory Barrier指令之间的指令不能被重排序。</p>
<h2 id="哪些地方用到过volatile？"><a href="#哪些地方用到过volatile？" class="headerlink" title="哪些地方用到过volatile？"></a>哪些地方用到过volatile？</h2><h3 id="单例模式的安全问题"><a href="#单例模式的安全问题" class="headerlink" title="单例模式的安全问题"></a>单例模式的安全问题</h3><p>常见的DCL（Double Check Lock）模式虽然加了同步，但是在多线程下依然会有线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo singletonDemo=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 我是构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DCL模式 Double Check Lock 双端检索机制：在加锁前后都进行判断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonDemo==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo.class)&#123;</span><br><span class="line">                 <span class="keyword">if</span> (singletonDemo==<span class="literal">null</span>)&#123;</span><br><span class="line">                     singletonDemo=<span class="keyword">new</span> <span class="title class_">SingletonDemo</span>();</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonDemo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;,String.valueOf(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个漏洞比较tricky，很难捕捉，但是是存在的。<code>instance=new SingletonDemo();</code>可以大致分为三步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();     <span class="comment">//1.分配内存</span></span><br><span class="line">instance(memory);	 <span class="comment">//2.初始化对象</span></span><br><span class="line">instance = memory;	 <span class="comment">//3.设置引用地址</span></span><br></pre></td></tr></table></figure>

<p>其中2、3没有数据依赖关系，<strong>可能发生重排</strong>。如果发生，此时内存已经分配，那么<code>instance=memory</code>不为null。如果此时线程挂起，<code>instance(memory)</code>还未执行，对象还未初始化。由于<code>instance!=null</code>，所以两次判断都跳过，最后返回的<code>instance</code>没有任何内容，还没初始化。</p>
<p>解决的方法就是对<code>singletondemo</code>对象添加上<code>volatile</code>关键字，禁止指令重排。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS是指<strong>Compare And Swap</strong>，<strong>比较并交换</strong>，是一种很重要的同步思想。如果主内存的值跟期望值一样，那么就进行修改，否则一直重试，直到一致为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AtomicInteger atomicInteger=<span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>)+<span class="string">&quot;\t current data : &quot;</span>+ atomicInteger.get());</span><br><span class="line">        <span class="comment">//修改失败</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>)+<span class="string">&quot;\t current data : &quot;</span>+ atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次修改，期望值为5，主内存也为5，修改成功，为2019。第二次修改，期望值为5，主内存为2019，修改失败。</p>
<p>查看<code>AtomicInteger.getAndIncrement()</code>方法，发现其没有加<code>synchronized</code><strong>也实现了同步</strong>。这是为什么？</p>
<h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><p><code>AtomicInteger</code>内部维护了<code>volatile int value</code>和<code>private  static final Unsafe unsafe</code>两个比较重要的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>,valueOffset,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AtomicInteger.getAndIncrement()</code>调用了<code>Unsafe.getAndAddInt()</code>方法。<code>Unsafe</code>类的大部分方法都是<code>native</code>的，用来像C语言一样从底层操作内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAnddAddInt</span><span class="params">(Object var1,<span class="type">long</span> var2,<span class="type">int</span> var4)</span>&#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的var1和var2，就是根据<strong>对象</strong>和<strong>偏移量</strong>得到在<strong>主内存的快照值</strong>var5。然后<code>compareAndSwapInt</code>方法通过var1和var2得到当前<strong>主内存的实际值</strong>。如果这个<strong>实际值</strong>跟<strong>快照值</strong>相等，那么就更新主内存的值为var5+var4。如果不等，那么就一直循环，一直获取快照，一直对比，直到实际值和快照值相等为止。</p>
<p>比如有A、B两个线程，一开始都从主内存中拷贝了原值为3，A线程执行到<code>var5=this.getIntVolatile</code>，即var5&#x3D;3。此时A线程挂起，B修改原值为4，B线程执行完毕，由于加了volatile，所以这个修改是立即可见的。A线程被唤醒，执行<code>this.compareAndSwapInt()</code>方法，发现这个时候主内存的值不等于快照值3，所以继续循环，<strong>重新</strong>从主内存获取。</p>
<h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><p>CAS实际上是一种自旋锁，</p>
<ol>
<li>一直循环，开销比较大。</li>
<li>只能保证一个变量的原子操作，多个变量依然要加锁。</li>
<li>引出了<strong>ABA问题</strong>。</li>
</ol>
<h1 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h1><p>所谓ABA问题，就是比较并交换的循环，存在一个<strong>时间差</strong>，而这个时间差可能带来意想不到的问题。比如线程T1将值从A改为B，然后又从B改为A。线程T2看到的就是A，但是<strong>却不知道这个A发生了更改</strong>。尽管线程T2 CAS操作成功，但不代表就没有问题。<br>有的需求，比如CAS，<strong>只注重头和尾</strong>，只要首尾一致就接受。但是有的需求，还看重过程，中间不能发生任何修改，这就引出了<code>AtomicReference</code>原子引用。</p>
<h2 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h2><p><code>AtomicInteger</code>对整数进行原子操作，如果是一个POJO呢？可以用<code>AtomicReference</code>来包装这个POJO，使其操作原子化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">25</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Lucy&quot;</span>,<span class="number">21</span>);</span><br><span class="line">AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">atomicReference.set(user1);</span><br><span class="line">System.out.println(atomicReference.compareAndSet(user1,user2)); <span class="comment">// true</span></span><br><span class="line">System.out.println(atomicReference.compareAndSet(user1,user2)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="AtomicStampedReference和ABA问题的解决"><a href="#AtomicStampedReference和ABA问题的解决" class="headerlink" title="AtomicStampedReference和ABA问题的解决"></a>AtomicStampedReference和ABA问题的解决</h2><p>使用<code>AtomicStampedReference</code>类可以解决ABA问题。这个类维护了一个“<strong>版本号</strong>”Stamp，在进行CAS操作的时候，不仅要比较当前值，还要比较<strong>版本号</strong>。只有两者都相等，才执行更新操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicStampedReference.compareAndSet(expectedReference,newReference,oldStamp,newStamp);</span><br></pre></td></tr></table></figure>

<p>详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/thread/ABADemo.java">ABADemo</a>。</p>
<h1 id="集合类不安全问题"><a href="#集合类不安全问题" class="headerlink" title="集合类不安全问题"></a>集合类不安全问题</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><code>ArrayList</code>不是线程安全类，在多线程同时写的情况下，会抛出<code>java.util.ConcurrentModificationException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listNotSafe</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + list);</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：</p>
<ol>
<li>使用<code>Vector</code>（<code>ArrayList</code>所有方法加<code>synchronized</code>，太重）。</li>
<li>使用<code>Collections.synchronizedList()</code>转换成线程安全类。</li>
<li>使用<code>java.concurrent.CopyOnWriteArrayList</code>（推荐）。</li>
</ol>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>这是JUC的类，通过<strong>写时复制</strong>来实现<strong>读写分离</strong>。比如其<code>add()</code>方法，就是先<strong>复制</strong>一个新数组，长度为原数组长度+1，然后将新数组最后一个元素设为添加的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//得到旧数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">//复制新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//设置新元素</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//设置新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>跟List类似，<code>HashSet</code>和<code>TreeSet</code>都不是线程安全的，与之对应的有<code>CopyOnWriteSet</code>这个线程安全类。这个类底层维护了一个<code>CopyOnWriteArrayList</code>数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">    al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet和HashMap"><a href="#HashSet和HashMap" class="headerlink" title="HashSet和HashMap"></a>HashSet和HashMap</h3><p><code>HashSet</code>底层是用<code>HashMap</code>实现的。既然是用<code>HashMap</code>实现的，那<code>HashMap.put()</code>需要传<strong>两个参数</strong>，而<code>HashSet.add()</code>只<strong>传一个参数</strong>，这是为什么？实际上<code>HashSet.add()</code>就是调用的<code>HashMap.put()</code>，只不过<strong>Value</strong>被写死了，是一个<code>private static final Object</code>对象。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>HashMap</code>不是线程安全的，<code>Hashtable</code>是线程安全的，但是跟<code>Vector</code>类似，太重量级。所以也有类似CopyOnWriteMap，只不过叫<code>ConcurrentHashMap</code>。</p>
<p>关于集合不安全类请看<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/thread/ContainerNotSafeDemo.java">ContainerNotSafeDemo</a>。</p>
<h1 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h1><h2 id="公平锁-x2F-非公平锁"><a href="#公平锁-x2F-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h2><p><strong>概念</strong>：所谓<strong>公平锁</strong>，就是多个线程按照<strong>申请锁的顺序</strong>来获取锁，类似排队，先到先得。而<strong>非公平锁</strong>，则是多个线程抢夺锁，会导致<strong>优先级反转</strong>或<strong>饥饿现象</strong>。</p>
<p><strong>区别</strong>：公平锁在获取锁时先查看此锁维护的<strong>等待队列</strong>，<strong>为空</strong>或者当前线程是等待队列的<strong>队首</strong>，则直接占有锁，否则插入到等待队列，FIFO原则。非公平锁比较粗鲁，上来直接<strong>先尝试占有锁</strong>，失败则采用公平锁方式。非公平锁的优点是<strong>吞吐量</strong>比公平锁更大。</p>
<p><code>synchronized</code>和<code>juc.ReentrantLock</code>默认都是<strong>非公平锁</strong>。<code>ReentrantLock</code>在构造的时候传入<code>true</code>则是<strong>公平锁</strong>。</p>
<h2 id="可重入锁-x2F-递归锁"><a href="#可重入锁-x2F-递归锁" class="headerlink" title="可重入锁&#x2F;递归锁"></a>可重入锁&#x2F;递归锁</h2><p>可重入锁又叫递归锁，指的同一个线程在<strong>外层方法</strong>获得锁时，进入<strong>内层方法</strong>会自动获取锁。也就是说，线程可以进入任何一个它已经拥有锁的代码块。比如<code>get</code>方法里面有<code>set</code>方法，两个方法都有同一把锁，得到了<code>get</code>的锁，就自动得到了<code>set</code>的锁。</p>
<p>就像有了家门的锁，厕所、书房、厨房就为你敞开了一样。可重入锁可以<strong>避免死锁</strong>的问题。</p>
<p>ReentrantLockDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Phone phone=<span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        syncTest(phone);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Thread t3=<span class="keyword">new</span> <span class="title class_">Thread</span>(phone);</span><br><span class="line">        Thread t4=<span class="keyword">new</span> <span class="title class_">Thread</span>(phone);</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">syncTest</span><span class="params">(Phone phone)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//Synchronized TEST</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;sendSMS()&quot;</span>);</span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;sendEmail()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Reentrant TEST</span></span><br><span class="line"></span><br><span class="line">    Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;get()&quot;</span>);</span><br><span class="line">            set();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;set()&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="锁的配对"><a href="#锁的配对" class="headerlink" title="锁的配对"></a>锁的配对</h3><p>锁之间要配对，加了几把锁，最后就得解开几把锁，下面的代码编译和运行都没有任何问题，但锁的数量不匹配会导致死循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    someAction();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>所谓自旋锁，就是尝试获取锁的线程不会<strong>立即阻塞</strong>，而是采用<strong>循环的方式去尝试获取</strong>。自己在那儿一直循环获取，就像“<strong>自旋</strong>”一样。这样的好处是减少<strong>线程切换的上下文开销</strong>，缺点是会<strong>消耗CPU</strong>。CAS底层的<code>getAndAddInt</code>就是<strong>自旋锁</strong>思想。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跟CAS类似，一直循环比较。</span></span><br><span class="line"><span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>SpinLockDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋锁Demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLocDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;Thread&gt; threadAtomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;\t come in...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!threadAtomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        threadAtomicReference.compareAndSet(thread, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;\t unlock...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SpinLocDemo</span> <span class="variable">spinLocDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLocDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLocDemo.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLocDemo.unlock();</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLocDemo.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLocDemo.unlock();</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="读写锁-x2F-独占-x2F-共享锁"><a href="#读写锁-x2F-独占-x2F-共享锁" class="headerlink" title="读写锁&#x2F;独占&#x2F;共享锁"></a>读写锁&#x2F;独占&#x2F;共享锁</h2><p><strong>读锁</strong>是<strong>共享的</strong>，<strong>写锁</strong>是<strong>独占的</strong>。<code>juc.ReentrantLock</code>和<code>synchronized</code>都是<strong>独占锁</strong>，独占锁就是<strong>一个锁</strong>只能被<strong>一个线程</strong>所持有。有的时候，需要<strong>读写分离</strong>，那么就要引入读写锁，即<code>juc.ReentrantReadWriteLock</code>。</p>
<p>比如缓存，就需要读写锁来控制。缓存就是一个键值对，以下Demo模拟了缓存的读写操作，读的<code>get</code>方法使用了<code>ReentrantReadWriteLock.ReadLock()</code>，写的<code>put</code>方法使用了<code>ReentrantReadWriteLock.WriteLock()</code>。这样避免了写被打断，实现了多个线程同时读。</p>
<p>ReadWriteLockDemo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyCache</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tempInt</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; myCache.put(tempInt + <span class="string">&quot;&quot;</span>, tempInt + <span class="string">&quot;&quot;</span>), String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tempInt</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; myCache.get(tempInt + <span class="string">&quot;&quot;</span>), String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在写入：&quot;</span> + key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成：&quot;</span> + key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在读取：&quot;</span> + key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            value = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized和Lock的区别"><a href="#Synchronized和Lock的区别" class="headerlink" title="Synchronized和Lock的区别"></a>Synchronized和Lock的区别</h2><p><code>synchronized</code>关键字和<code>java.util.concurrent.locks.Lock</code>都能加锁，两者有什么区别呢？</p>
<ol>
<li><strong>原始构成</strong>：<code>sync</code>是JVM层面的，底层通过<code>monitorenter</code>和<code>monitorexit</code>来实现的。<code>Lock</code>是JDK API层面的。（<code>sync</code>一个enter会有两个exit，一个是正常退出，一个是异常退出）</li>
<li><strong>使用方法</strong>：<code>sync</code>不需要手动释放锁，而<code>Lock</code>需要手动释放。</li>
<li><strong>是否可中断</strong>：<code>sync</code>不可中断，除非抛出异常或者正常运行完成。<code>Lock</code>是可中断的，通过调用<code>interrupt()</code>方法。</li>
<li><strong>是否为公平锁</strong>：<code>sync</code>只能是非公平锁，而<code>Lock</code>既能是公平锁，又能是非公平锁。</li>
<li>**绑定多个条件<code>Condition</code>**：<code>sync</code>不能，只能随机唤醒。而<code>Lock</code>可以通过<code>Condition</code>来绑定多个条件，精确唤醒。</li>
</ol>
<h1 id="CountDownLatch-x2F-CyclicBarrier-x2F-Semaphore"><a href="#CountDownLatch-x2F-CyclicBarrier-x2F-Semaphore" class="headerlink" title="CountDownLatch&#x2F;CyclicBarrier&#x2F;Semaphore"></a>CountDownLatch&#x2F;CyclicBarrier&#x2F;Semaphore</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><code>CountDownLatch</code>内部维护了一个<strong>计数器</strong>，只有当<strong>计数器&#x3D;&#x3D;0</strong>时，某些线程才会停止阻塞，开始执行。</p>
<p><code>CountDownLatch</code>主要有两个方法，<code>countDown()</code>来让计数器-1，<code>await()</code>来让线程阻塞。当<code>count==0</code>时，阻塞线程自动唤醒。</p>
<p><strong>案例一班长关门</strong>：main线程是班长，6个线程是学生。只有6个线程运行完毕，都离开教室后，main线程班长才会关教室门。</p>
<p><strong>案例二秦灭六国</strong>：只有6国都被灭亡后（执行完毕），main线程才会显示“秦国一统天下”。</p>
<h3 id="枚举类的使用"><a href="#枚举类的使用" class="headerlink" title="枚举类的使用"></a>枚举类的使用</h3><p>在<strong>案例二</strong>中会使用到枚举类，因为灭六国，循环6次，想根据<code>i</code>的值来确定输出什么国，比如1代表楚国，2代表赵国。如果用判断则十分繁杂，而枚举类可以简化操作。</p>
<p>枚举类就像一个<strong>简化的数据库</strong>，枚举类名就像数据库名，枚举的项目就像数据表，枚举的属性就像表的字段。</p>
<p>CountDownLatchDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountdownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        closeDoor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeDoor</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 上完课，go&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;***** 班长上完课，关门，go&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CountDownLatch</code>是减，而<code>CyclicBarrier</code>是加，理解了<code>CountDownLatch</code>，<code>CyclicBarrier</code>就很容易。比如召集7颗龙珠才能召唤神龙。</p>
<p>CyclicBarrierDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>, () -&gt; System.out.println(<span class="string">&quot;*****召唤神龙&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 收集到第：&quot;</span> + finalI + <span class="string">&quot;龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>CountDownLatch</code>的问题是<strong>不能复用</strong>。比如<code>count=3</code>，那么加到3，就不能继续操作了。而<code>Semaphore</code>可以解决这个问题，比如6辆车3个停车位，对于<code>CountDownLatch</code><strong>只能停3辆车</strong>，而<code>Semaphore</code>可以停6辆车，车位空出来后，其它车可以占有，这就涉及到了<code>Semaphore.accquire()</code>和<code>Semaphore.release()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//模拟3个停车位</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;量汽车抢到了车位&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;量汽车停车3秒后离开车位&quot;</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p><strong>概念</strong>：当阻塞队列为空时，获取（take）操作是阻塞的；当阻塞队列为满时，添加（put）操作是阻塞的。</p>
<p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/BlockingQueue.png"></p>
<p><strong>好处</strong>：阻塞队列不用手动控制什么时候该被阻塞，什么时候该被唤醒，简化了操作。</p>
<p><strong>体系</strong>：<code>Collection</code>→<code>Queue</code>→<code>BlockingQueue</code>→七个阻塞队列实现类。</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ArrayBlockingQueue</strong></td>
<td>由<strong>数组</strong>构成的<strong>有界</strong>阻塞队列</td>
</tr>
<tr>
<td><strong>LinkedBlockingQueue</strong></td>
<td>由<strong>链表</strong>构成的<strong>有界</strong>阻塞队列</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>支持优先级排序的无界阻塞队列</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>支持优先级的延迟无界阻塞队列</td>
</tr>
<tr>
<td><strong>SynchronousQueue</strong></td>
<td>单个元素的阻塞队列</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>由链表构成的无界阻塞队列</td>
</tr>
<tr>
<td>LinkedBlockingDeque</td>
<td>由链表构成的双向阻塞队列</td>
</tr>
</tbody></table>
<p>粗体标记的三个用得比较多，许多消息中间件底层就是用它们实现的。</p>
<p>需要注意的是<code>LinkedBlockingQueue</code>虽然是有界的，但有个巨坑，其默认大小是<code>Integer.MAX_VALUE</code>，高达21亿，一般情况下内存早爆了（在线程池的<code>ThreadPoolExecutor</code>有体现）。</p>
<p><strong>API</strong>：抛出异常是指当队列满时，再次插入会抛出异常；返回布尔是指当队列满时，再次插入会返回false；阻塞是指当队列满时，再次插入会被阻塞，直到队列取出一个元素，才能插入。超时是指当一个时限过后，才会插入或者取出。</p>
<table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>返回布尔</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(E e)</td>
<td>offer(E e)</td>
<td>put(E e)</td>
<td>offer(E e,Time,TimeUnit)</td>
</tr>
<tr>
<td>取出</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(Time,TimeUnit)</td>
</tr>
<tr>
<td>队首</td>
<td>element()</td>
<td>peek()</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>抛出异常</td>
<td>当阻塞队列满时，再往队列里面add插入元素会抛IllegalStateException: Queue full<br />当阻塞队列空时，再往队列Remove元素时候回抛出NoSuchElementException</td>
</tr>
<tr>
<td>特殊值</td>
<td>插入方法，成功返回true 失败返回false<br />移除方法，成功返回元素，队列里面没有就返回null</td>
</tr>
<tr>
<td>一直阻塞</td>
<td>当阻塞队列满时，生产者继续往队列里面put元素，队列会一直阻塞直到put数据or响应中断退出。<br />当阻塞队列空时，消费者试图从队列take元素，队列会一直阻塞消费者线程直到队列可用。</td>
</tr>
<tr>
<td>超时退出</td>
<td>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过后限时后生产者线程就会退出</td>
</tr>
</tbody></table>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>队列只有一个元素，如果想插入多个，必须等队列元素取出后，才能插入，只能有一个“坑位”，用一个插一个，详见</p>
<p>SynchronousQueueDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 1&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 2&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 3&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + blockingQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h1><p><strong>与Runnable的区别</strong>：</p>
<ol>
<li>Callable带返回值。</li>
<li>会抛出异常。</li>
<li>覆写<code>call()</code>方法，而不是<code>run()</code>方法。</li>
</ol>
<p><strong>Callable接口的使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;come in callable&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1234</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;come in callable&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1234</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask3 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(() -&gt; System.out.println(<span class="string">&quot;come in runnable&quot;</span>), <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask4 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;come in runnable&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="阻塞队列的应用——生产者消费者"><a href="#阻塞队列的应用——生产者消费者" class="headerlink" title="阻塞队列的应用——生产者消费者"></a>阻塞队列的应用——生产者消费者</h1><h2 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h2><p>传统模式使用<code>Lock</code>来进行操作，需要手动加锁、解锁。</p>
<p>ProdConsTradiDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目: 一个初始值为零的变量，两个线程对其交替操作，一个加1，一个减1 ，来5轮</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductConsumerTraditionDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ShareData</span> <span class="variable">shareData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    shareData.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    shareData.decrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareData</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 judge</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 work</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\tincrement &quot;</span> + number);</span><br><span class="line">            <span class="comment">//3 notify to wake</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 judge</span></span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 work</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\tdecrement &quot;</span> + number);</span><br><span class="line">            <span class="comment">//3 notify to wake</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阻塞队列模式"><a href="#阻塞队列模式" class="headerlink" title="阻塞队列模式"></a>阻塞队列模式</h2><p>使用阻塞队列就不需要手动加锁了</p>
<p>ProducerConsumerBlockQueueDemo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerBlockQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyResource</span> <span class="variable">myResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyResource</span>(<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者线程启动！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.product();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者线程启动！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.consume();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;5秒后叫停&quot;</span>);</span><br><span class="line">            myResource.stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyResource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认开启，进行生产和消费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">FLAG</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; blockingQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">product</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> returnVal;</span><br><span class="line">        <span class="keyword">while</span> (FLAG) &#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            returnVal = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (returnVal) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t插入队列&quot;</span> + data + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t插入队列&quot;</span> + data + <span class="string">&quot;失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; STOP，表明FLAG=false，生产结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (FLAG) &#123;</span><br><span class="line">            result = blockingQueue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">null</span> || result.equalsIgnoreCase(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                FLAG = <span class="literal">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t超过2秒没有获取到产品，消费退出&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t消费队列&quot;</span> + result + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; STOP，表明FLAG=false，生产结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">this</span>.FLAG = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="阻塞队列的应用——线程池"><a href="#阻塞队列的应用——线程池" class="headerlink" title="阻塞队列的应用——线程池"></a>阻塞队列的应用——线程池</h1><h2 id="线程池基本概念"><a href="#线程池基本概念" class="headerlink" title="线程池基本概念"></a>线程池基本概念</h2><p><strong>概念</strong>：线程池主要是控制运行线程的数量，将待处理任务放到等待队列，然后创建线程执行这些任务。如果超过了最大线程数，则等待。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>线程复用：不用一直new新线程，重复利用已经创建的线程来降低线程的创建和销毁开销，节省系统资源。</li>
<li>提高响应速度：当任务达到时，不用创建新的线程，直接利用线程池的线程。</li>
<li>管理线程：可以控制最大并发数，控制线程的创建等。</li>
</ol>
<p><strong>体系</strong>：<code>Executor</code>→<code>ExecutorService</code>→<code>AbstractExecutorService</code>→<code>ThreadPoolExecutor</code>。<code>ThreadPoolExecutor</code>是线程池创建的核心类。类似<code>Arrays</code>、<code>Collections</code>工具类，<code>Executor</code>也有自己的工具类<code>Executors</code>。</p>
<h2 id="线程池三种常用创建方式"><a href="#线程池三种常用创建方式" class="headerlink" title="线程池三种常用创建方式"></a>线程池三种常用创建方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newFixedThreadPool(5);//一池5个处理线程       执行一个长期的任务，性能好很多</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newSingleThreadExecutor();//一池1个处理线程   一个任务一个线程执行的任务场景</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();<span class="comment">//一池N个处理线程         执行很多短期异步的小程序或者负载较轻的服务器</span></span><br><span class="line">        <span class="comment">//模拟10个用户来办理业务，每个用户就是一个来自外部的请求线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>newFixedThreadPool</strong>：使用<code>LinkedBlockingQueue</code>实现，定长线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>newSingleThreadExecutor</strong>：使用<code>LinkedBlockingQueue</code>实现，一池只有一个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span>(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>newCachedThreadPool</strong>：使用<code>SynchronousQueue</code>实现，变长线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池创建的七个参数"><a href="#线程池创建的七个参数" class="headerlink" title="线程池创建的七个参数"></a>线程池创建的七个参数</h2><table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>线程池常驻核心线程数</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>能够容纳的最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>空闲线程存活时间</td>
</tr>
<tr>
<td>unit</td>
<td>存活时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>存放提交但未执行任务的队列</td>
</tr>
<tr>
<td>threadFactory</td>
<td>创建线程的工厂类</td>
</tr>
<tr>
<td>handler</td>
<td>等待队列满后的拒绝策略</td>
</tr>
</tbody></table>
<p><strong>理解</strong>：线程池的创建参数，就像一个<strong>银行</strong>。</p>
<p><code>corePoolSize</code>就像银行的“<strong>当值窗口</strong>“，比如今天有<strong>2位柜员</strong>在受理<strong>客户请求</strong>（任务）。如果超过2个客户，那么新的客户就会在<strong>等候区</strong>（等待队列<code>workQueue</code>）等待。当<strong>等候区</strong>也满了，这个时候就要开启“<strong>加班窗口</strong>”，让其它3位柜员来加班，此时达到<strong>最大窗口</strong><code>maximumPoolSize</code>，为5个。如果开启了所有窗口，等候区依然满员，此时就应该启动”<strong>拒绝策略</strong>“<code>handler</code>，告诉不断涌入的客户，叫他们不要进入，已经爆满了。由于不再涌入新客户，办完事的客户增多，窗口开始空闲，这个时候就通过<code>keepAlivetTime</code>将多余的3个”加班窗口“取消，恢复到2个”当值窗口“。</p>
<h2 id="线程池底层原理"><a href="#线程池底层原理" class="headerlink" title="线程池底层原理"></a>线程池底层原理</h2><p><strong>原理图</strong>：上面银行的例子，实际上就是线程池的工作原理。</p>
<p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/threadPool.png" alt="threadPool"></p>
<ol>
<li><p>在创建了线程池后，等待提交过来的任务请求。</p>
</li>
<li><p>当调用<code>execute()</code>方法添加一-个请求任务时，线程池会做如下判断:</p>
<ol>
<li>如果正在运行的线程数量小于<code>corePoolSize</code>，那么马上创建线程运行这个任务</li>
<li>如果正在运行的线程数量大于或等于<code>corePoolSize</code>，那么将这个任务放入队列</li>
<li>如果这时候队列满了且正在运行的线程数量还小于<code>maximumPoolSize</code>，那么还是要创建非核心线程<strong>立刻运行</strong>这个任务</li>
<li>如果队列满了且正在运行的线程数量大于或等于<code>maximumPoolSize</code>，那么线程池会启动饱和拒绝策略来执行</li>
</ol>
</li>
<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>
</li>
<li><p>当一个线程无事可做超过一定的时间(<code>keepAliveTime</code>) 时，线程池会判断:</p>
<p>​	如果当前运行的线程数大于<code>corePoolSize</code>，那么这个线程就被停掉。</p>
</li>
</ol>
<p><strong>流程图</strong>：</p>
<p><img src="/images/Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/threadPoolProcedure.png" alt="threadPoolProcedure"></p>
<p>新任务到达→</p>
<p>如果正在运行的线程数小于<code>corePoolSize</code>，创建核心线程；大于等于<code>corePoolSize</code>，放入等待队列。</p>
<p>如果等待队列已满，但正在运行的线程数小于<code>maximumPoolSize</code>，创建非核心线程；大于等于<code>maximumPoolSize</code>，启动拒绝策略。</p>
<p>当一个线程无事可做一段时间<code>keepAliveTime</code>后，如果正在运行的线程数大于<code>corePoolSize</code>，则关闭非核心线程。</p>
<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>当等待队列满时，且达到最大线程数，再有新任务到来，就需要启动拒绝策略。JDK提供了四种拒绝策略，分别是。</p>
<ol>
<li><strong>AbortPolicy</strong>：默认的策略，直接抛出<code>RejectedExecutionException</code>异常，阻止系统正常运行。</li>
<li><strong>CallerRunsPolicy</strong>：既不会抛出异常，也不会终止任务，而是将任务返回给调用者。</li>
<li><strong>DiscardOldestPolicy</strong>：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交任务。</li>
<li><strong>DiscardPolicy</strong>：直接丢弃任务，不做任何处理。</li>
</ol>
<h2 id="实际生产使用哪一个线程池？"><a href="#实际生产使用哪一个线程池？" class="headerlink" title="实际生产使用哪一个线程池？"></a>实际生产使用哪一个线程池？</h2><p><strong>单一、可变、定长都不用</strong>！原因就是<code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>底层都是用<code>LinkedBlockingQueue</code>实现的，这个队列最大长度为<code>Integer.MAX_VALUE</code>，显然会导致OOM(Out Of Memery)。所以实际生产一般自己通过<code>ThreadPoolExecutor</code>的7个参数，自定义线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>,<span class="number">5</span>,</span><br><span class="line">                        <span class="number">1L</span>,TimeUnit.SECONDS,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                        Executors.defaultThreadFactory(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br></pre></td></tr></table></figure>

<h3 id="自定义线程池参数选择"><a href="#自定义线程池参数选择" class="headerlink" title="自定义线程池参数选择"></a>自定义线程池参数选择</h3><p>查看CPU核数：<code>System.out.println(Runtime.getRuntime().availableProcessors());</code></p>
<p>CPU密集型：CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。CPU密集型任务配置尽可能少的线程数量：一般公式: CPU核 数+1介线程的线程池。</p>
<p>IO密集型任务：任务需要大量的IO，即大量的阻塞，因此尽量多配点，可以是CPU线程数*2，或者CPU线程数&#x2F;(1-阻塞系数)。</p>
<h1 id="死锁编码和定位"><a href="#死锁编码和定位" class="headerlink" title="死锁编码和定位"></a>死锁编码和定位</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HoldLockThread</span>(lockA, lockB), <span class="string">&quot;ThreadAAA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HoldLockThread</span>(lockB, lockA), <span class="string">&quot;ThreadBBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HoldLockThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HoldLockThread</span><span class="params">(String lockA, String lockB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockA = lockA;</span><br><span class="line">        <span class="built_in">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t自己持有&quot;</span> + lockA + <span class="string">&quot;，尝试获取：&quot;</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t自己持有&quot;</span> + lockB + <span class="string">&quot;，尝试获取：&quot;</span> + lockA);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要是两个命令配合起来使用，定位死锁。</p>
<p><strong>jps</strong>指令：<code>jps -l</code>可以查看运行的Java进程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">9688</span> thread.DeadLockDemo</span><br><span class="line"><span class="number">12177</span> sun.tools.jps.Jps</span><br></pre></td></tr></table></figure>

<p><strong>jstack</strong>指令：<code>jstack pid</code>可以查看某个Java进程的堆栈信息，同时分析出死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;ThreadBBB&quot;</span>:</span><br><span class="line">        at com.monochrome.thread.HoldLockThread.run(DeadLockDemo.java:<span class="number">43</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x00000006edd5eae8</span>&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;<span class="number">0x00000006edd5eb20</span>&gt; (a java.lang.String)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">&quot;ThreadAAA&quot;</span>:</span><br><span class="line">        at com.monochrome.thread.HoldLockThread.run(DeadLockDemo.java:<span class="number">43</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x00000006edd5eb20</span>&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;<span class="number">0x00000006edd5eae8</span>&gt; (a java.lang.String)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS开启端口转发</title>
    <url>/2020/07/03/MacOS%E5%BC%80%E5%90%AF%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<h3 id="在-x2F-etc-x2F-pf-anchors-x2F-目录下新建一个名为com-pow文件，内容如下"><a href="#在-x2F-etc-x2F-pf-anchors-x2F-目录下新建一个名为com-pow文件，内容如下" class="headerlink" title="在&#x2F;etc&#x2F;pf.anchors&#x2F;目录下新建一个名为com.pow文件，内容如下"></a>在&#x2F;etc&#x2F;pf.anchors&#x2F;目录下新建一个名为com.pow文件，内容如下</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rdr pass on en0 inet proto tcp from any to any port 8080 -&gt; 127.0.0.1 port 8080</span><br><span class="line">rdr pass on en5 inet proto tcp from any to any port 8080 -&gt; 127.0.0.1 port 8080</span><br></pre></td></tr></table></figure>

<p>上面的配置标表示的意思是将从en0和en5，目的端口为8080的包转发到8080端口上</p>
<h3 id="使用pfctl命令检测配置文件"><a href="#使用pfctl命令检测配置文件" class="headerlink" title="使用pfctl命令检测配置文件"></a>使用<code>pfctl</code>命令检测配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pfctl -vnf /etc/pf.anchors/com.pow</span><br></pre></td></tr></table></figure>

<h3 id="修改-etc-pf-conf配置文件"><a href="#修改-etc-pf-conf配置文件" class="headerlink" title="修改/etc/pf.conf配置文件"></a>修改<code>/etc/pf.conf</code>配置文件</h3><p><code>pf</code>启动时会自动装载<code>/etc/pf.conf</code>文件，因此将<code>anchor</code>文件链接到<code>/etc/pf.conf</code>，转发规则就会自动建立了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在rdr-anchor <span class="string">&quot;com.apple/*&quot;</span>下面增加：</span></span><br><span class="line"></span><br><span class="line">rdr-anchor &quot;pow&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在load anchor <span class="string">&quot;com.apple&quot;</span> from <span class="string">&quot;/etc/pf.anchors/com.apple&quot;</span>后面添加：</span></span><br><span class="line"></span><br><span class="line">load anchor &quot;pow&quot; from &quot;/etc/pf.anchors/com.pow&quot;</span><br></pre></td></tr></table></figure>



<p>修改后的配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrub-anchor &quot;com.apple/*&quot;</span><br><span class="line">nat-anchor &quot;com.apple/*&quot;</span><br><span class="line">rdr-anchor &quot;com.apple/*&quot;</span><br><span class="line">rdr-anchor &quot;pow&quot;</span><br><span class="line">dummynet-anchor &quot;com.apple/*&quot;</span><br><span class="line">anchor &quot;com.apple/*&quot;</span><br><span class="line">load anchor &quot;com.apple&quot; from &quot;/etc/pf.anchors/com.apple&quot;</span><br><span class="line">load anchor &quot;pow&quot; from &quot;/etc/pf.anchors/com.pow&quot;</span><br></pre></td></tr></table></figure>

<p>导入并运行<code>pf</code>命令</p>
<p>一定要导入并允许运行<code>pf</code>的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pfctl -evf /etc/pf.anchors/com.pow</span><br></pre></td></tr></table></figure>


<p>设置<code>pf</code>开机自动打开</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pfctl -e</span><br></pre></td></tr></table></figure>

<p>如果想要关闭<code>pf</code>，命令是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pfctl -d1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro-入门</title>
    <url>/2022/09/28/Shiro-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<ul>
<li>Apache Shiro 是Java的一个安全(权限)框架。</li>
<li>Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 <strong>JavaSE</strong> 环境，也可以用在 <strong>JavaEE</strong> 环境。</li>
<li>Shiro 可以完成:认证、授权、加密、会话管理、与Web 集成、缓存 等。</li>
</ul>
<span id="more"></span>

<h1 id="Shiro-架构"><a href="#Shiro-架构" class="headerlink" title="Shiro 架构"></a>Shiro 架构</h1><h2 id="从外部看"><a href="#从外部看" class="headerlink" title="从外部看"></a>从外部看</h2><p>从外部来看Shiro ，即从应用程序角度的来观察如何使用 Shiro 完成工作:</p>
<p><img src="/../images/Shiro/ShiroBasicArchitecture.png" alt="Shiro Basic Architecture Diagram"></p>
<ul>
<li><strong>Subject</strong>：应用代码直接交互的对象是<strong>Subject</strong>，也就是说 Shiro 的对外 API 核心就是 Subject。<strong>Subject代表了当前“用户”</strong>， 这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；<strong>与Subject的所有交互都会委托给SecurityManager，Subject其实是一个门面，SecurityManager才是实际的执行者</strong>;</li>
<li><strong>SecurityManager</strong>：<strong>安全管理器</strong>；即<strong>所有与安全有关的操作都会与SecurityManager交互</strong>；且其管理着所有 Subject；可以看出它是 <strong>Shiro的核心</strong>，它<strong>负责与Shiro的其他组件进行交互</strong>，它相当于 SpringMVC 中 DispatcherServlet 的角色</li>
<li><strong>Realm</strong>：**Shiro 从Realm获取安全数据(如用户、角色、权限)**，就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色&#x2F; 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource</li>
</ul>
<h2 id="从内部看"><a href="#从内部看" class="headerlink" title="从内部看"></a>从内部看</h2><p><img src="/../images/Shiro/ShiroArchitecture.png" alt="Shiro Architecture Diagram"></p>
<ul>
<li><strong>Subject</strong>：任何可以与应用交互的“用户”。</li>
<li><strong>SecurityManager</strong>：相当于SpringMVC 中的 DispatcherServlet；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证、授权、会话及缓存的管理。</li>
<li><strong>Authenticator</strong>：负责 Subject 认证，是一个扩展点，可以自定义实现；可以使用认证 策略(Authentication Strategy)，即什么情况下算用户认证通过了。</li>
<li><strong>Authorizer</strong>：授权器、即访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能。</li>
<li><strong>Realm</strong>:可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC 实现，也可以是内存实现等等；由用户提供，所以一般在应用中都需要实现自己的 Realm。</li>
<li><strong>SessionManager</strong>：管理 Session 生命周期的组件；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境。<ul>
<li><strong>SessionDAO</strong>：SessionDAO代表SessionManager执行会话持久性（CRUD）操作，这允许将任何数据存储插入会话管理基础设施。</li>
</ul>
</li>
<li><strong>CacheManager</strong>：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据 基本上很少改变，放到缓存中后可以提高访问的性能。</li>
<li><strong>Cryptography</strong>：密码模块，Shiro 提高了一些常见的加密组件用于如密码加密&#x2F;解密。</li>
</ul>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.monochrome<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-reload4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="INI文件"><a href="#INI文件" class="headerlink" title="INI文件"></a>INI文件</h3><p>可以将用户信息存放在shiro.ini配置文件当中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line">zhangsan=z3</span><br><span class="line">lisi=l4</span><br></pre></td></tr></table></figure>

<h2 id="登录认证"><a href="#登录认证" class="headerlink" title="登录认证"></a>登录认证</h2><h3 id="登录认证概念"><a href="#登录认证概念" class="headerlink" title="登录认证概念"></a>登录认证概念</h3><ol>
<li>身份验证：一般需要提供如身份ID等一些标识信息来表明登录者的身份，如提供 email，用户名&#x2F;密码来证明。</li>
<li>在shiro中，用户需要提供principals(身份)和credentials(证明)给shiro，从而应用能验证用户身份。</li>
<li>principals：身份，即主体的标识属性，可以是任何属性，如用户名、邮箱等，唯一即可。一个主体可以有多个principals，但只有一个Primary principals，一般是用户名&#x2F; 邮箱&#x2F;手机号。</li>
<li>credentials：证明&#x2F;凭证，即只有主体知道的安全值，如密码&#x2F;数字证书等。</li>
<li>最常见的principals和credentials组合就是用户名&#x2F;密码</li>
</ol>
<h3 id="登录认证基本流程"><a href="#登录认证基本流程" class="headerlink" title="登录认证基本流程"></a>登录认证基本流程</h3><ol>
<li>收集用户身份&#x2F;凭证，即如用户名&#x2F;密码</li>
<li>调用 Subject.login 进行登录，如果失败将得到相应 的 AuthenticationException 异常，根据异常提示用户错误信息；否则登录成功</li>
<li>创建自定义的 Realm 类，继承 org.apache.shiro.realm.AuthenticatingRealm类， 实现 doGetAuthenticationInfo() 方法</li>
</ol>
<p><img src="/../images/Shiro/ShiroAuthenticationSequence.png" alt="Shiro Authentication Sequence"></p>
<h3 id="登录认证实例"><a href="#登录认证实例" class="headerlink" title="登录认证实例"></a>登录认证实例</h3><p>创建测试类，获取认证对象，进行登录认证，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroRun</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.初始化获取SecurityManager</span></span><br><span class="line">        <span class="type">IniSecurityManagerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IniSecurityManagerFactory</span>(<span class="string">&quot;classpath:shiro.ini&quot;</span>);</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> factory.getInstance();</span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">// 2.获取subject对象</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">// 3.创建token对象，web应用用户名密码从页面传递</span></span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;z3&quot;</span>);</span><br><span class="line">        <span class="comment">// 4.完成登录</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">            System.out.println(<span class="string">&quot;login successful&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;user dose not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;password is wrong&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;login failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h3><ol>
<li>首先调用 Subject.login(token) 进行登录，其会自动委托给 SecurityManager</li>
<li>SecurityManager 负责真正的身份验证逻辑；它会委托给 Authenticator 进行身份 验证</li>
<li>Authenticator 才是真正的身份验证者，Shiro API 中核心的身份 认证入口点，此 处可以自定义插入自己的实现</li>
<li>Authenticator 可能会委托给相应的 AuthenticationStrategy 进行多 Realm 身份 验证，默认 ModularRealmAuthenticator 会调用 AuthenticationStrategy 进行多 Realm 身份验证</li>
<li>Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如 果没有返回&#x2F;抛出异常表示身份验证失败了。此处 可以配置多个Realm，将按照相应的顺序 及策略进行访问</li>
</ol>
<h2 id="角色、授权"><a href="#角色、授权" class="headerlink" title="角色、授权"></a>角色、授权</h2><h3 id="授权概念"><a href="#授权概念" class="headerlink" title="授权概念"></a>授权概念</h3><ol>
<li><strong>授权</strong>，也叫**访问控制，即在应用中控制谁访问哪些资源(如访问页面&#x2F;编辑数据&#x2F;页面操作等)**。在授权中需了解的几个关键对象：主体(Subject)、资源(Resource)、权限 (Permission)、角色(Role)。</li>
<li>**主体(Subject)**：访问应用的用户，在 Shiro 中使用 <strong>Subject</strong> 代表该用户。用户只有授权后才允许访问相应的资源。</li>
<li><strong>资源(Resource)<strong>：</strong>在应用中用户可以访问的 URL</strong>，比如访问 JSP 页面、查看&#x2F;编辑 某些 数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。</li>
<li><strong>权限</strong>(Permission)：安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。<strong>即权限表示在应用中用户能不能访问某个资源</strong>，如：访问用 户列表页面查看&#x2F;新增&#x2F;修改&#x2F;删除用户数据(即很多时候都是CRUD(增查改删)式权限控制)等。权限代表了用户有没有操作某个资源的权利，即反映在某个资源上的操作允不允许。</li>
<li>Shiro 支持粗粒度权限(如用户模块的所有权限)和细粒度权限(操作某个用户的权限， 即实例级别的)</li>
<li><strong>角色(Role)<strong>：</strong>权限的集合</strong>，一般情况下会赋予用户角色而不是权限，即这样用户可 以拥有 一组权限，赋予权限时比较方便。典型的如：项目经理、技术总监、CTO、开发工程师等 都是角色，不同的角色拥有一组不同的权限</li>
</ol>
<h3 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h3><ol>
<li><p>编程式：通过写if&#x2F;else 授权代码块完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(subject.hasRole(<span class="string">&quot;admin&quot;</span>))&#123;</span><br><span class="line">	<span class="comment">// 有权限</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">// 没权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注解式：通过在执行的Java方法上放置相应的注解完成，没有权限将抛出相应的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiresRoles(&quot;admin&quot;)</span></span><br><span class="line">pubic <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">// 有权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSP&#x2F;GSP 标签:在JSP&#x2F;GSP 页面通过相应的标签完成</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:haseRole</span> <span class="attr">name</span>=<span class="string">&quot;admin&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--有权限--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:haseRole</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h3><ol>
<li>首先调用Subject.isPermitted&#x2F;hasRole接口，其会委托给SecurityManager，而 SecurityManager接着会委托给 Authorizer;</li>
<li>Authorizer是真正的授权者，如果调用如isPermitted(“user:view”)，其首先会通 过PermissionResolver把字符串转换成相应的Permission实例;</li>
<li>在进行授权之前，其会调用相应的Realm获取Subject相应的角色&#x2F;权限用于匹配传入的角色&#x2F;权限;</li>
<li>Authorizer会判断Realm的角色&#x2F;权限是否和传入的匹配，如果有多个Realm，会委托 给ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted&#x2F;hasRole 会返回 true，否则返回false表示授权失败</li>
</ol>
<p><img src="/../images/Shiro/ShiroAuthorizationSequence.png" alt="ShiroAuthorizationSequence"></p>
<h3 id="授权实例"><a href="#授权实例" class="headerlink" title="授权实例"></a>授权实例</h3><ol>
<li><p>获取角色信息</p>
<ol>
<li><p>给shiro.ini增加角色配置[users]</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">zhangsan</span>=z3,admin,user</span><br><span class="line"><span class="attr">lisi</span>=l4</span><br></pre></td></tr></table></figure>
</li>
<li><p>给例子添加代码，沟通过hasRole()判断用户是否有指定角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    subject.login(token);</span><br><span class="line">    System.out.println(<span class="string">&quot;login successful&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断角色</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isAdmin</span> <span class="operator">=</span> subject.hasRole(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;has admin role? &quot;</span> + isAdmin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>判断权限信息信息</p>
<ol>
<li><p>给shiro.ini增加权限配置</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="attr">admin</span>=user:insert,user:select</span><br></pre></td></tr></table></figure>
</li>
<li><p>给例子添加代码，判断用户是否有指定权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断权限</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isPermitted</span> <span class="operator">=</span> subject.isPermitted(<span class="string">&quot;user:insert&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;has this permission? &quot;</span> + isPermitted);</span><br><span class="line"><span class="comment">// 也可以用 checkPermission 方法，但没有返回值，没权限抛 AuthenticationException subject.checkPermission(&quot;user:select&quot;);</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="Shiro-加密"><a href="#Shiro-加密" class="headerlink" title="Shiro 加密"></a>Shiro 加密</h2><p>实际系统开发中，一些敏感信息需要进行加密，比如说用户的密码。Shiro 内嵌很多常用的加密算法，比如 MD5 加密。Shiro 可以很简单的使用信息加密。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroMD5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 密码明文</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;z3&quot;</span>;</span><br><span class="line">        <span class="comment">// 使用 md5 加密</span></span><br><span class="line">        <span class="type">Md5Hash</span> <span class="variable">md5Hash</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Md5Hash</span>(password);</span><br><span class="line">        System.out.println(<span class="string">&quot;md5 加密:&quot;</span> + md5Hash.toHex());</span><br><span class="line">        <span class="comment">// 带盐的 md5 加密，盐就是在密码明文后拼接新字符串，然后再进行加密 </span></span><br><span class="line">        <span class="type">Md5Hash</span> <span class="variable">md5Hash2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Md5Hash</span>(password, <span class="string">&quot;salt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;md5 带盐加密:&quot;</span> + md5Hash2.toHex()); </span><br><span class="line">        <span class="comment">//为了保证安全，避免被破解还可以多次迭代加密，保证数据安全</span></span><br><span class="line">        <span class="type">Md5Hash</span> <span class="variable">md5Hash3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Md5Hash</span>(password, <span class="string">&quot;salt&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;md5 带盐三次加密:&quot;</span> + md5Hash3.toHex());</span><br><span class="line">        <span class="comment">// 使用父类实现加密</span></span><br><span class="line">        <span class="type">SimpleHash</span> <span class="variable">simpleHash</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHash</span>(<span class="string">&quot;MD5&quot;</span>, password, <span class="string">&quot;salt&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;父类带盐三次加密:&quot;</span> + simpleHash.toHex());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Shiro-自定义登录认证"><a href="#Shiro-自定义登录认证" class="headerlink" title="Shiro 自定义登录认证"></a>Shiro 自定义登录认证</h2><p>Shiro 默认的登录认证是不带加密的，如果想要实现加密认证需要自定义登录认证，自定义 Realm。</p>
<h3 id="自定义登录认证"><a href="#自定义登录认证" class="headerlink" title="自定义登录认证"></a>自定义登录认证</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.custom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.hash.SimpleHash;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthenticatingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.ByteSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthenticatingRealm</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义的登录认证方法，Shiro 的 login 方法底层会调用该类的认证方法完成登录认证</span></span><br><span class="line">    <span class="comment">// 需要配置自定义的 realm 生效，在 ini 文件中配置，或 Springboot 中配置</span></span><br><span class="line">    <span class="comment">// 该方法只是获取进行对比的信息，认证逻辑还是按照 Shiro 的底层认证逻辑完成认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="comment">// 1 获取身份信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">principal</span> <span class="operator">=</span> authenticationToken.getPrincipal().toString();</span><br><span class="line">        <span class="comment">// 2 获取凭证信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>((<span class="type">char</span>[])</span><br><span class="line">                authenticationToken.getCredentials());</span><br><span class="line">        System.out.println(<span class="string">&quot;认证用户信息:&quot;</span> + principal + <span class="string">&quot;---&quot;</span> + password);</span><br><span class="line">        <span class="comment">// 3 获取数据库中存储的用户信息</span></span><br><span class="line">        <span class="keyword">if</span> (principal.equals(<span class="string">&quot;zhangsan&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 3.1 数据库存储的加盐迭代 3 次密码</span></span><br><span class="line">            <span class="type">SimpleHash</span> <span class="variable">simpleHash</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHash</span>(<span class="string">&quot;MD5&quot;</span>, password, <span class="string">&quot;salt&quot;</span>, <span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 3.2 创建封装了校验逻辑的对象，将要比较的数据给该对象</span></span><br><span class="line">            <span class="type">AuthenticationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(</span><br><span class="line">                    authenticationToken.getPrincipal(),</span><br><span class="line">                    simpleHash,</span><br><span class="line">                    ByteSource.Util.bytes(<span class="string">&quot;salt&quot;</span>), authenticationToken.getPrincipal().toString());</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在custom-shiro-ini中添加配置信息"><a href="#在custom-shiro-ini中添加配置信息" class="headerlink" title="在custom_shiro.ini中添加配置信息"></a>在custom_shiro.ini中添加配置信息</h3><p>custom_shiro.ini</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="attr">md5CredentialsMatcher</span>=org.apache.shiro.authc.credential.Md5CredentialsMatcher</span><br><span class="line"><span class="attr">md5CredentialsMatcher.hashIterations</span>=<span class="number">3</span></span><br><span class="line"><span class="attr">customRealm</span>= com.monochrome.custom.CustomRealm</span><br><span class="line"><span class="attr">customRealm.credentialsMatcher</span>=<span class="variable">$md5CredentialsMatcher</span></span><br><span class="line"><span class="attr">securityManager.realms</span>=<span class="variable">$customRealm</span></span><br><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">zhangsan</span>=<span class="number">7174</span>f64b13022acd3c56e2781e098a5f,admin</span><br><span class="line"><span class="attr">lisi</span>=l4</span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="attr">admin</span>=user:insert,user:select</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM核心知识点</title>
    <url>/2021/06/01/JVM%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="Java8-JVM内存结构"><a href="#Java8-JVM内存结构" class="headerlink" title="Java8  JVM内存结构"></a>Java8  JVM内存结构</h1><p>基本结构与之前类似，只是Java8取消了之前的“永久代”，取而代之的是“元空间”——<strong>Metaspace</strong>，两者本质是一样的。“永久代”使用的是JVM的堆内存，而“元空间”是直接使用的本机物理内存。</p>
<p><img src="/./images/JVM/JVMMem.png"></p>
<span id="more"></span>

<h1 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h1><h2 id="如果判断一个对象可以被回收？"><a href="#如果判断一个对象可以被回收？" class="headerlink" title="如果判断一个对象可以被回收？"></a>如果判断一个对象可以被回收？</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>维护一个计数器，如果有对该对象的引用，计数器+1，反之-1。无法解决循环引用的问题。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>从一组名为“GC Roots”的根节点对象出发，向下遍历。那些没有被遍历到、与GC Roots形成通路的对象，会被标记为“回收”。</p>
<h2 id="哪些对象可以作为GC-Roots？"><a href="#哪些对象可以作为GC-Roots？" class="headerlink" title="哪些对象可以作为GC Roots？"></a>哪些对象可以作为GC Roots？</h2><ol>
<li>虚拟机栈（栈帧中的局部变量）中引用的对象。</li>
<li>本地方法栈（native）中引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
</ol>
<h1 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h1><h2 id="JVM-三种类型参数"><a href="#JVM-三种类型参数" class="headerlink" title="JVM 三种类型参数"></a>JVM 三种类型参数</h2><h3 id="标配参数"><a href="#标配参数" class="headerlink" title="标配参数"></a>标配参数</h3><p>比如<code>-version</code>、<code>-help</code>、<code>-showversion</code>等，几乎不会改变。</p>
<h3 id="X参数"><a href="#X参数" class="headerlink" title="X参数"></a>X参数</h3><p>用得不多，比如<code>-Xint</code>，解释执行模式；<code>-Xcomp</code>，编译模式；<code>-Xmixed</code>，开启混合模式（默认）。</p>
<p><img src="/./images/JVM/InkedJVMXParam_LI.jpg"></p>
<h3 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h3><p>重要，用于JVM调优。</p>
<h2 id="JVM-XX参数"><a href="#JVM-XX参数" class="headerlink" title="JVM XX参数"></a>JVM XX参数</h2><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p><strong>公式</strong>：<code>-XX:+某个属性</code>、<code>-XX:-某个属性</code>，开启或关闭某个功能。比如<code>-XX:+PrintGCDetails</code>，开启GC详细信息。</p>
<h3 id="KV键值类型"><a href="#KV键值类型" class="headerlink" title="KV键值类型"></a>KV键值类型</h3><p><strong>公式</strong>：<code>-XX:属性key=值value</code>。比如<code>-XX:Metaspace=128m</code>、<code>-XX:MaxTenuringThreshold=15</code>。</p>
<h2 id="JVM-Xms-x2F-Xmx参数"><a href="#JVM-Xms-x2F-Xmx参数" class="headerlink" title="JVM Xms&#x2F;Xmx参数"></a>JVM Xms&#x2F;Xmx参数</h2><p><code>-Xms</code>和<code>-Xmx</code>十分常见，用于设置<strong>初始堆大小</strong>和<strong>最大堆大小</strong>。第一眼看上去，既不像X参数，也不像XX参数。实际上<code>-Xms</code>等价于<code>-XX:InitialHeapSize</code>，<code>-Xmx</code>等价于<code>-XX:MaxHeapSize</code>。所以<code>-Xms</code>和<code>-Xmx</code>属于XX参数。</p>
<h2 id="JVM-查看参数"><a href="#JVM-查看参数" class="headerlink" title="JVM 查看参数"></a>JVM 查看参数</h2><h3 id="查看某个参数"><a href="#查看某个参数" class="headerlink" title="查看某个参数"></a>查看某个参数</h3><p>使用<code>jps -l</code>配合<code>jinfo -flag JVM参数 pid</code> 。先用<code>jsp -l</code>查看java进程，选择某个进程号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">17888</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class="line"><span class="number">5360</span> org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line"><span class="number">18052</span> demo3.demo3</span><br></pre></td></tr></table></figure>

<p><code>jinfo -flag PrintGCDetails 18052</code>可以查看18052 Java进程的<code>PrintGCDetails</code>参数信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:-PrintGCDetails</span><br></pre></td></tr></table></figure>

<h3 id="查看所有参数"><a href="#查看所有参数" class="headerlink" title="查看所有参数"></a>查看<strong>所有</strong>参数</h3><p>使用<code>jps -l</code>配合<code>jinfo -flags pid</code>可以查看所有参数。</p>
<p>也可以使用<code>java -XX:+PrintFlagsInitial</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">     <span class="type">intx</span> <span class="variable">ActiveProcessorCount</span>                      <span class="operator">=</span> -<span class="number">1</span>            &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveSizeDecrementScaleFactor</span>          <span class="operator">=</span> <span class="number">4</span>             &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveSizeMajorGCDecayTimeScale</span>         <span class="operator">=</span> <span class="number">10</span>            &#123;product&#125;</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">AdaptiveSizePausePolicy</span>                   <span class="operator">=</span> <span class="number">0</span>             &#123;product&#125;</span><br><span class="line">······</span><br><span class="line">    <span class="type">uintx</span> <span class="variable">YoungPLABSize</span>                             <span class="operator">=</span> <span class="number">4096</span>          &#123;product&#125;</span><br><span class="line">     <span class="type">bool</span> <span class="variable">ZeroTLAB</span>                                  <span class="operator">=</span> <span class="literal">false</span>         &#123;product&#125;</span><br><span class="line">     <span class="type">intx</span> <span class="variable">hashCode</span>                                  <span class="operator">=</span> <span class="number">5</span>             &#123;product&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查看修改后的参数"><a href="#查看修改后的参数" class="headerlink" title="查看修改后的参数"></a>查看<strong>修改</strong>后的参数</h3><p>使用<code>java -XX:PrintFlagsFinal</code>可以查看修改后的参数，与上面类似。只是修改过后是<code>:=</code>而不是<code>=</code>。</p>
<h3 id="查看常见参数"><a href="#查看常见参数" class="headerlink" title="查看常见参数"></a>查看<strong>常见</strong>参数</h3><p>如果不想查看所有参数，可以用<code>-XX:+PrintCommandLineFlags</code>查看常用参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=<span class="number">132375936</span> -XX:MaxHeapSize=<span class="number">2118014976</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure>

<h2 id="JVM-常用参数"><a href="#JVM-常用参数" class="headerlink" title="JVM 常用参数"></a>JVM 常用参数</h2><h3 id="Xmx-x2F-Xms"><a href="#Xmx-x2F-Xms" class="headerlink" title="-Xmx&#x2F;-Xms"></a>-Xmx&#x2F;-Xms</h3><p>最大和初始堆大小。最大默认为物理内存的1&#x2F;4，初始默认为物理内存的1&#x2F;64。</p>
<h3 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h3><p>等价于<code>-XX:ThresholdStackSize</code>。用于设置单个栈的大小，系统默认值是0，<strong>不代表栈大小为0</strong>。而是根据操作系统的不同，有不同的值。比如64位的Linux系统是1024K，而Windows系统依赖于虚拟内存。</p>
<h3 id="Xmn"><a href="#Xmn" class="headerlink" title="-Xmn"></a>-Xmn</h3><p>新生代大小，一般不调。</p>
<h3 id="XX-MetaspaceSize"><a href="#XX-MetaspaceSize" class="headerlink" title="-XX:MetaspaceSize"></a>-XX:MetaspaceSize</h3><p>设置元空间大小。</p>
<h3 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a>-XX:+PrintGCDetails</h3><p>输出GC收集信息，包含<code>GC</code>和<code>Full GC</code>信息。</p>
<h3 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h3><p>新生代中，<code>Eden</code>区和两个<code>Survivor</code>区的比例，默认是<code>8:1:1</code>。通过<code>-XX:SurvivorRatio=4</code>改成<code>4:1:1</code></p>
<h3 id="XX-NewRatio"><a href="#XX-NewRatio" class="headerlink" title="-XX:NewRatio"></a>-XX:NewRatio</h3><p>老生代和新年代的比列，默认是2，即老年代占2，新生代占1。如果改成<code>-XX:NewRatio=4</code>，则老年代占4，新生代占1。</p>
<h3 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h3><p>新生代设置进入老年代的时间，默认是新生代逃过15次GC后，进入老年代。如果改成0，那么对象不会在新生代分配，直接进入老年代。</p>
<h1 id="四大引用"><a href="#四大引用" class="headerlink" title="四大引用"></a>四大引用</h1><p>以下Demo都需要设置<code>-Xmx</code>和<code>-Xms</code>，不然系统默认很大，很难演示。</p>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>使用<code>new</code>方法创造出来的对象，默认都是强引用。GC的时候，就算<strong>内存不够</strong>，抛出<code>OutOfMemoryError</code>也不会回收对象，<strong>死了也不回收</strong>。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/StrongReferenceDemo.java">StrongReferenceDemo</a>。</p>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>需要用<code>Object.Reference.SoftReference</code>来显示创建。<strong>如果内存够</strong>，GC的时候<strong>不回收</strong>。<strong>内存不够</strong>，<strong>则回收</strong>。常用于内存敏感的应用，比如高速缓存。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/SoftReferenceDemo.java">SoftReferenceDemo</a>。</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>需要用<code>Object.Reference.WeakReference</code>来显示创建。<strong>无论内存够不够，GC的时候都回收</strong>，也可以用在高速缓存上。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/WeakReferenceDemo.java">WeakReferenceDemo</a></p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>传统的<code>HashMap</code>就算<code>key==null</code>了，也不会回收键值对。但是如果是<code>WeakHashMap</code>，一旦内存不够用时，且<code>key==null</code>时，会回收这个键值对。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/WeakHashMapDemo.java">WeakHashMapDemo</a>。</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>软应用和弱引用可以通过<code>get()</code>方法获得对象，但是虚引用不行。虚引形同虚设，在任何时候都可能被GC，不能单独使用，必须配合<strong>引用队列（ReferenceQueue）</strong>来使用。设置虚引用的<strong>唯一目的</strong>，就是在这个对象被回收时，收到一个<strong>通知</strong>以便进行后续操作，有点像<code>Spring</code>的后置通知。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/PhantomReferenceDemo.java">PhantomReferenceDemo</a>。</p>
<h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><p>弱引用、虚引用被回收后，会被放到引用队列里面，通过<code>poll</code>方法可以得到。关于引用队列和弱、虚引用的配合使用，见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/ReferenceQueueDemo.java">ReferenceQueueDemo</a>。</p>
<h1 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h1><h2 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h2><p>栈满会抛出该错误。无限递归就会导致StackOverflowError，是<code>java.lang.Throwable</code>→<code>java.lang.Error</code>→<code>java.lang.VirtualMachineError</code>下的错误。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/StackOverflowErrorDemo.java">StackOverflowErrorDemo</a>。</p>
<h2 id="OOM—Java-head-space"><a href="#OOM—Java-head-space" class="headerlink" title="OOM—Java head space"></a>OOM—Java head space</h2><p>栈满会抛出该错误。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/JavaHeapSpaceDemo.java">JavaHeapSpaceDemo</a>。</p>
<h2 id="OOM—GC-overhead-limit-exceeded"><a href="#OOM—GC-overhead-limit-exceeded" class="headerlink" title="OOM—GC overhead limit exceeded"></a>OOM—GC overhead limit exceeded</h2><p>这个错误是指：GC的时候会有“Stop the World”，STW越小越好，正常情况是GC只会占到很少一部分时间。但是如果用超过98%的时间来做GC，而且收效甚微，就会被JVM叫停。下例中，执行了多次<code>Full GC</code>，但是内存回收很少，最后抛出了<code>OOM:GC overhead limit exceeded</code>错误。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/GCOverheadDemo.java">GCOverheadDemo</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;496K(2560K)] 2048K-&gt;960K(9728K), <span class="number">0.0036555</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2544K-&gt;489K(2560K)] 3008K-&gt;2689K(9728K), <span class="number">0.0060306</span> secs] [Times: user=<span class="number">0.08</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2537K-&gt;512K(2560K)] 4737K-&gt;4565K(9728K), <span class="number">0.0050620</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2560K-&gt;496K(2560K)] 6613K-&gt;6638K(9728K), <span class="number">0.0064025</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line"></span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2048K-&gt;860K(2560K)] [ParOldGen: 6264K-&gt;7008K(7168K)] 8312K-&gt;7869K(9728K), [Metaspace: 3223K-&gt;3223K(1056768K)], <span class="number">0.1674947</span> secs] [Times: user=<span class="number">0.63</span> sys=<span class="number">0.00</span>, real=<span class="number">0.17</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2048K-&gt;2006K(2560K)] [ParOldGen: 7008K-&gt;7008K(7168K)] 9056K-&gt;9015K(9728K), [Metaspace: 3224K-&gt;3224K(1056768K)], <span class="number">0.1048666</span> secs] [Times: user=<span class="number">0.45</span> sys=<span class="number">0.00</span>, real=<span class="number">0.10</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7082K-&gt;7082K(7168K)] 9130K-&gt;9130K(9728K), [Metaspace: 3313K-&gt;3313K(1056768K)], <span class="number">0.0742516</span> secs] [Times: user=<span class="number">0.28</span> sys=<span class="number">0.00</span>, real=<span class="number">0.07</span> secs] </span><br><span class="line"></span><br><span class="line">·······</span><br><span class="line"></span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7084K-&gt;7084K(7168K)] 9132K-&gt;9132K(9728K), [Metaspace: 3313K-&gt;3313K(1056768K)], <span class="number">0.0738461</span> secs] [Times: user=<span class="number">0.36</span> sys=<span class="number">0.02</span>, real=<span class="number">0.07</span> secs] </span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> [Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 2047K-&gt;0K(2560K)] [ParOldGen: 7119K-&gt;647K(7168K)] 9167K-&gt;647K(9728K), [Metaspace: 3360K-&gt;3360K(1056768K)], <span class="number">0.0129597</span> secs] [Times: user=<span class="number">0.11</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">	at java.lang.Integer.toString(Integer.java:<span class="number">401</span>)</span><br><span class="line">	at java.lang.String.valueOf(String.java:<span class="number">3099</span>)</span><br><span class="line">	at jvm.GCOverheadDemo.main(GCOverheadDemo.java:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<h2 id="OOM—GC-Direct-buffer-memory"><a href="#OOM—GC-Direct-buffer-memory" class="headerlink" title="OOM—GC Direct buffer memory"></a>OOM—GC Direct buffer memory</h2><p>在写<code>NIO</code>程序的时候，会用到<code>ByteBuffer</code>来读取和存入数据。与Java堆的数据不一样，<code>ByteBuffer</code>使用<code>native</code>方法，直接在<strong>堆外分配内存</strong>。当堆外内存（也即本地物理内存）不够时，就会抛出这个异常。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/DirectBufferMemoryDemo.java">DirectBufferMemoryDemo</a>。</p>
<h2 id="OOM—unable-to-create-new-native-thread"><a href="#OOM—unable-to-create-new-native-thread" class="headerlink" title="OOM—unable to create new native thread"></a>OOM—unable to create new native thread</h2><p>在高并发应用场景时，如果创建超过了系统默认的最大线程数，就会抛出该异常。Linux单个进程默认不能超过1024个线程。<strong>解决方法</strong>要么降低程序线程数，要么修改系统最大线程数<code>vim /etc/security/limits.d/90-nproc.conf</code>。详见<a href="https://github.com/MaJesTySA/JVM-JUC-Core/blob/master/src/jvm/UnableCreateNewThreadDemo.java">UnableCreateNewThreadDemo</a></p>
<h2 id="OOM—Metaspace"><a href="#OOM—Metaspace" class="headerlink" title="OOM—Metaspace"></a>OOM—Metaspace</h2><p>元空间满了就会抛出这个异常。</p>
<h1 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h1><h2 id="四大垃圾收集算法"><a href="#四大垃圾收集算法" class="headerlink" title="四大垃圾收集算法"></a>四大垃圾收集算法</h2><h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p><img src="/./images/JVM/GCbq.png"></p>
<p><img src="/images/JVM/GCbz.png"></p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p><img src="/images/JVM/GCbq.png"></p>
<p><img src="/images/JVM/GCbq2.png"></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img src="/images/JVM/GCfz.png"></p>
<p><img src="/images/JVM/GCfz2.png"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>准确来讲，跟前面三种算法有所区别。分代收集算法就是根据对象的年代，采用上述三种算法来收集。</p>
<ol>
<li>对于新生代：每次GC都有大量对象死去，存活的很少，常采用复制算法，只需要拷贝很少的对象。</li>
<li>对于老年代：常采用标整或者标清算法。</li>
</ol>
<h2 id="四种垃圾收集器"><a href="#四种垃圾收集器" class="headerlink" title="四种垃圾收集器"></a>四种垃圾收集器</h2><p>Java 8可以将垃圾收集器分为四类。</p>
<h3 id="串行收集器Serial"><a href="#串行收集器Serial" class="headerlink" title="串行收集器Serial"></a>串行收集器Serial</h3><p>为单线程环境设计且<strong>只使用一个线程</strong>进行GC，会暂停所有用户线程，不适用于服务器。就像去餐厅吃饭，只有一个清洁工在打扫。</p>
<h3 id="并行收集器Parrallel"><a href="#并行收集器Parrallel" class="headerlink" title="并行收集器Parrallel"></a>并行收集器Parrallel</h3><p>使用<strong>多个线程</strong>并行地进行GC，会暂停所有用户线程，适用于科学计算、大数据后台，交互性不敏感的场合。多个清洁工同时在打扫。</p>
<h3 id="并发收集器CMS"><a href="#并发收集器CMS" class="headerlink" title="并发收集器CMS"></a>并发收集器CMS</h3><p>用户线程和GC线程同时执行（不一定是并行，交替执行），GC时不需要停顿用户线程，互联网公司多用，适用对响应时间有要求的场合。清洁工打扫的时候，也可以就餐。</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>对内存的划分与前面3种很大不同，将堆内存分割成不同的区域，然后并发地进行垃圾回收。</p>
<h2 id="默认垃圾收集器"><a href="#默认垃圾收集器" class="headerlink" title="默认垃圾收集器"></a>默认垃圾收集器</h2><h3 id="默认收集器有哪些？"><a href="#默认收集器有哪些？" class="headerlink" title="默认收集器有哪些？"></a>默认收集器有哪些？</h3><p>有<code>Serial</code>、<code>Parallel</code>、<code>ConcMarkSweep</code>（CMS）、<code>ParNew</code>、<code>ParallelOld</code>、<code>G1</code>。还有一个<code>SerialOld</code>，快被淘汰了。</p>
<h3 id="查看默认垃圾修改器"><a href="#查看默认垃圾修改器" class="headerlink" title="查看默认垃圾修改器"></a>查看默认垃圾修改器</h3><p>使用<code>java -XX:+PrintCommandLineFlags</code>即可看到，Java 8默认使用<code>-XX:+UseParallelGC</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=<span class="number">132375936</span> -XX:MaxHeapSize=<span class="number">2118014976</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure>

<h2 id="七大垃圾收集器"><a href="#七大垃圾收集器" class="headerlink" title="七大垃圾收集器"></a>七大垃圾收集器</h2><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p><code>Serial</code>、<code>Parallel Scavenge</code>、<code>ParNew</code>用户回收新生代；<code>SerialOld</code>、<code>ParallelOld</code>、<code>CMS</code>用于回收老年代。而<code>G1</code>收集器，既可以回收新生代，也可以回收老年代。</p>
<p><img src="/images/JVM/GCqi.png"></p>
<p>连线表示可以搭配使用，红叉表示不推荐一同使用，比如新生代用<code>Serial</code>，老年代用<code>CMS</code>。</p>
<p><img src="/images/JVM/GCqi2.png"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>年代最久远，是<code>Client VM</code>模式下的默认新生代收集器，使用<strong>复制算法</strong>。<strong>优点</strong>：单个线程收集，没有线程切换开销，拥有最高的单线程GC效率。<strong>缺点</strong>：收集的时候会暂停用户线程。</p>
<p>使用<code>-XX:+UseSerialGC</code>可以显式开启，开启后默认使用<code>Serial</code>+<code>SerialOld</code>的组合。</p>
<p><img src="/images/JVM/serial.jpeg"></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>也就是<code>Serial</code>的多线程版本，GC的时候不再是一个线程，而是多个，是<code>Server VM</code>模式下的默认新生代收集器，采用<strong>复制算法</strong>。</p>
<p>使用<code>-XX:+UseParNewGC</code>可以显式开启，开启后默认使用<code>ParNew</code>+<code>SerialOld</code>的组合。但是由于<code>SerialOld</code>已经过时，所以建议配合<code>CMS</code>使用。</p>
<p><img src="/images/JVM/parnew.jpeg"></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p><code>ParNew</code>收集器仅在新生代使用多线程收集，老年代默认是<code>SerialOld</code>，所以是单线程收集。而<code>Parallel Scavenge</code>在新、老两代都采用多线程收集。<code>Parallel Scavenge</code>还有一个特点就是<strong>吞吐量优先收集器</strong>，可以通过自适应调节，保证最大吞吐量。采用<strong>复制算法</strong>。</p>
<p>使用<code>-XX:+UseParallelGC</code>可以开启， 同时也会使用<code>ParallelOld</code>收集老年代。其它参数，比如<code>-XX:ParallelGCThreads=N</code>可以选择N个线程进行GC，<code>-XX:+UseAdaptiveSizePolicy</code>使用自适应调节策略。</p>
<h3 id="SerialOld收集器"><a href="#SerialOld收集器" class="headerlink" title="SerialOld收集器"></a>SerialOld收集器</h3><p><code>Serial</code>的老年代版本，采用<strong>标整算法</strong>。JDK1.5之前跟<code>Parallel Scavenge</code>配合使用，现在已经不了，作为<code>CMS</code>的后备收集器。</p>
<h3 id="ParallelOld收集器"><a href="#ParallelOld收集器" class="headerlink" title="ParallelOld收集器"></a>ParallelOld收集器</h3><p><code>Parallel</code>的老年代版本，JDK1.6之前，新生代用<code>Parallel</code>而老年代用<code>SerialOld</code>，只能保证新生代的吞吐量。JDK1.8后，老年代改用<code>ParallelOld</code>。</p>
<p>使用<code>-XX:+UseParallelOldGC</code>可以开启， 同时也会使用<code>Parallel</code>收集新生代。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>并发标记清除收集器，是一种以获得<strong>最短GC停顿为</strong>目标的收集器。适用在互联网或者B&#x2F;S系统的服务器上，这类应用尤其重视服务器的<strong>响应速度</strong>，希望停顿时间最短。是<code>G1</code>收集器出来之前的首选收集器。使用<strong>标清算法</strong>。在GC的时候，会与用户线程并发执行，不会停顿用户线程。但是在<strong>标记</strong>的时候，仍然会<strong>STW</strong>。</p>
<p>使用<code>-XX:+UseConcMarkSweepGC</code>开启。开启过后，新生代默认使用<code>ParNew</code>，同时老年代使用<code>SerialOld</code>作为备用。</p>
<p><img src="/images/JVM/cms.jpeg"></p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li><strong>初始标记</strong>：只是标记一下GC Roots能直接关联的对象，速度很快，需要<strong>STW</strong>。</li>
<li><strong>并发标记</strong>：主要标记过程，标记全部对象，和用户线程一起工作，不需要STW。</li>
<li><strong>重新标记</strong>：修正在并发标记阶段出现的变动，需要<strong>STW</strong>。</li>
<li><strong>并发清除</strong>：和用户线程一起，清除垃圾，不需要STW。</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong>：停顿时间少，响应速度快，用户体验好。</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>对CPU资源非常敏感：由于需要并发工作，多少会占用系统线程资源。</li>
<li>无法处理浮动垃圾：由于标记垃圾的时候，用户进程仍然在运行，无法有效处理新产生的垃圾。</li>
<li>产生内存碎片：由于使用<strong>标清算法</strong>，会产生内存碎片。</li>
</ol>
<h3 id="G1收集器-1"><a href="#G1收集器-1" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><code>G1</code>收集器与之前垃圾收集器的一个显著区别就是——之前收集器都有三个区域，新、老两代和元空间。而G1收集器只有G1区和元空间。而G1区，不像之前的收集器，分为新、老两代，而是一个一个Region，每个Region既可能包含新生代，也可能包含老年代。</p>
<p><code>G1</code>收集器既可以提高吞吐量，又可以减少GC时间。最重要的是<strong>STW可控</strong>，增加了预测机制，让用户指定停顿时间。</p>
<p>使用<code>-XX:+UseG1GC</code>开启，还有<code>-XX:G1HeapRegionSize=n</code>、<code>-XX:MaxGCPauseMillis=n</code>等参数可调。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><strong>并行和并发</strong>：充分利用多核、多线程CPU，尽量缩短STW。</li>
<li><strong>分代收集</strong>：虽然还保留着新、老两代的概念，但物理上不再隔离，而是融合在Region中。</li>
<li><strong>空间整合</strong>：<code>G1</code>整体上看是<strong>标整</strong>算法，在局部看又是<strong>复制算法</strong>，不会产生内存碎片。</li>
<li><strong>可预测停顿</strong>：用户可以指定一个GC停顿时间，<code>G1</code>收集器会尽量满足。</li>
</ol>
<h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><p>与<code>CMS</code>类似。</p>
<ol>
<li>初始标记。</li>
<li>并发标记。</li>
<li>最终标记。</li>
<li>筛选回收。</li>
</ol>
<h1 id="附—Linux相关指令"><a href="#附—Linux相关指令" class="headerlink" title="附—Linux相关指令"></a>附—Linux相关指令</h1><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>主要查看<code>%CPU</code>、<code>%MEM</code>，还有<code>load average</code>。<code>load average</code>后面的三个数字，表示系统1分钟、5分钟、15分钟的平均负载值。如果三者平均值高于0.6，则复杂比较高了。当然，用<code>uptime</code>也可以查看。</p>
<h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><p>查看进程、内存、I&#x2F;O等多个系统运行状态。2表示每两秒采样一次，3表示一共采样3次。<code>procs</code>的<code>r</code>表示运行和等待CPU时间片的进程数，原则上1核CPU不要超过2。<code>b</code>是等待资源的进程数，比如磁盘I&#x2F;O、网络I&#x2F;O等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ ~]# vmstat -n 2 3</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 2  0      0 173188 239748 1362628    0    0     0     3   17    8  0  0 99  0  0</span><br><span class="line"> 0  0      0 172800 239748 1362636    0    0     0     0  194  485  1  1 99  0  0</span><br><span class="line"> 1  0      0 172800 239748 1362640    0    0     0     0  192  421  1  1 99  0  0</span><br></pre></td></tr></table></figure>

<h2 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h2><p>查看某个进程的运行信息。</p>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>查看内存信息。</p>
<h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>查看磁盘信息。</p>
<h2 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h2><p>查看磁盘I&#x2F;O信息。比如有时候MySQL在查表的时候，会占用大量磁盘I&#x2F;O，体现在该指令的<code>%util</code>字段很大。对于死循环的程序，CPU占用固然很高，但是磁盘I&#x2F;O不高。</p>
<h2 id="ifstat"><a href="#ifstat" class="headerlink" title="ifstat"></a>ifstat</h2><p>查看网络I&#x2F;O信息，需要安装。</p>
<h1 id="CPU占用过高原因定位"><a href="#CPU占用过高原因定位" class="headerlink" title="CPU占用过高原因定位"></a>CPU占用过高原因定位</h1><p>先用<code>top</code>找到CPU占用最高的进程，然后用<code>ps -mp pid -o THREAD,tid,time</code>，得到该<strong>进程</strong>里面占用最高的<strong>线程</strong>。这个线程是10进制的，将其转成16进制，然后用<code>jstack pid | grep tid</code>可以定位到具体哪一行导致了占用过高。</p>
<h1 id="JVM性能调优和监控工具"><a href="#JVM性能调优和监控工具" class="headerlink" title="JVM性能调优和监控工具"></a>JVM性能调优和监控工具</h1><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>Java版的<code>ps -ef</code>查看所有JVM进程。</p>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>查看JVM中运行线程的状态，比较重要。可以定位CPU占用过高位置，定位死锁位置。</p>
<h2 id="jinfo-x2F-jstat"><a href="#jinfo-x2F-jstat" class="headerlink" title="jinfo&#x2F;jstat"></a>jinfo&#x2F;jstat</h2><p><code>jinfo</code>查看JVM的运行环境参数，比如默认的JVM参数等。<code>jstat</code>统计信息监视工具。</p>
<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>JVM内存映像工具。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot使用ELK收集日志</title>
    <url>/2020/01/17/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h3 id="ELK简介"><a href="#ELK简介" class="headerlink" title="ELK简介"></a>ELK简介</h3><p>ELK是有Elastic公司的三个组件配合进行日志收集，分别是：</p>
<ul>
<li><a href="https://www.elastic.co/cn/products/elasticsearch">ElasticSearch</a>:用于存储日志信息。</li>
<li><a href="https://www.elastic.co/cn/products/logstash">Logstash</a>:用于收集、处理和转发日志信息。</li>
<li><a href="https://www.elastic.co/cn/products/kibana">Kibana</a>:提供可搜索的Web可视化界面。</li>
</ul>
<p>ELK也可以配合<a href="https://www.elastic.co/cn/products/beats">Beats</a>进行使用，后续会写一篇文章来介绍。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>之前文章分别介绍了ELK环境的搭建以及Spring Boot与之的整合。</p>
<ul>
<li><a href="https://zhaoyangmushiyi.github.io/2020/01/07/Elasticsearch%E6%95%B4%E5%90%88Kibana%E5%92%8CLogstash%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">Elasticsearch整合Kibana和Logstash环境搭建</a></li>
<li><a href="https://zhaoyangmushiyi.github.io/2020/01/16/Spring-boot%E6%95%B4%E5%90%88Elasticsearch/">Spring-boot整合Elasticsearch</a></li>
</ul>
<span id="more"></span>

<p>本次教程基于上述两篇教程拓展。</p>
<h3 id="项目修改"><a href="#项目修改" class="headerlink" title="项目修改"></a>项目修改</h3><h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><p>添加logstash采集logback日志的相关依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Logback配置"><a href="#Logback配置" class="headerlink" title="Logback配置"></a>Logback配置</h4><p>新建文件<code>logback-spring.xml</code>，放在resource文件夹下面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/console-appender.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--应用名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;APP_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志文件保存路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_FILE_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;&#125;/logs&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>$&#123;APP_NAME&#125;<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--每天记录日志到文件appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_FILE_PATH&#125;/$&#123;APP_NAME&#125;-%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--输出到logstash的appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;LOGSTASH&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--可以访问的logstash日志收集端口--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">destination</span>&gt;</span>localhost:4560<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;LOGSTASH&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Logstash配置"><a href="#Logstash配置" class="headerlink" title="Logstash配置"></a>Logstash配置</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">input <span class="punctuation">&#123;</span></span><br><span class="line">	jdbc <span class="punctuation">&#123;</span></span><br><span class="line">		add_field =&gt; <span class="punctuation">&#123;</span><span class="string">&quot;myid&quot;</span>=&gt;<span class="string">&quot;jdbc&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">		jdbc_connection_string =&gt;</span><br><span class="line">			<span class="string">&quot;&lt;mysql 地址&gt;&quot;</span></span><br><span class="line">		jdbc_user =&gt; <span class="string">&quot;xxxxxxxxxxxxx&quot;</span></span><br><span class="line">		jdbc_password =&gt; <span class="string">&quot;xxxxxxxxxxxx&quot;</span></span><br><span class="line">		##数据库驱动的JAR位置</span><br><span class="line">		jdbc_driver_library =&gt; <span class="string">&quot;/usr/share/logstash/config/mysql-connector-java-5.1.47.jar&quot;</span></span><br><span class="line">		jdbc_driver_class =&gt; <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">		jdbc_paging_enabled =&gt; <span class="string">&quot;true&quot;</span></span><br><span class="line">		jdbc_page_size =&gt; <span class="string">&quot;50000&quot;</span></span><br><span class="line">		statement =&gt; <span class="string">&quot;select id,username,realname,age,birth from tb_user&quot;</span></span><br><span class="line">		## 每分钟执行一次</span><br><span class="line">		schedule =&gt; <span class="string">&quot;* * * * *&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line">	tcp <span class="punctuation">&#123;</span></span><br><span class="line">		add_field =&gt; <span class="punctuation">&#123;</span><span class="string">&quot;myid&quot;</span>=&gt;<span class="string">&quot;aptst-log&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">		mode =&gt; <span class="string">&quot;server&quot;</span></span><br><span class="line">		host =&gt; <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">		port =&gt; <span class="number">4560</span></span><br><span class="line">		codec =&gt; json_lines</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">output <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">	if <span class="punctuation">[</span>myid<span class="punctuation">]</span> == <span class="string">&quot;jdbc&quot;</span> <span class="punctuation">&#123;</span></span><br><span class="line">		elasticsearch <span class="punctuation">&#123;</span></span><br><span class="line">			##elasticsearch 地址</span><br><span class="line">			hosts =&gt; <span class="string">&quot;&lt;elasticsearch 地址&gt;:9200&quot;</span></span><br><span class="line">			##索引名称</span><br><span class="line">			index =&gt; <span class="string">&quot;index-user&quot;</span></span><br><span class="line">			document_id =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line">			##索引类型</span><br><span class="line">			document_type =&gt; <span class="string">&quot;user&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">		stdout <span class="punctuation">&#123;</span></span><br><span class="line">			codec =&gt; json_lines</span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line">	if <span class="punctuation">[</span>myid<span class="punctuation">]</span> == <span class="string">&quot;aptst-log&quot;</span> <span class="punctuation">&#123;</span></span><br><span class="line">		elasticsearch <span class="punctuation">&#123;</span></span><br><span class="line">			##elasticsearch 地址</span><br><span class="line">			hosts =&gt; <span class="string">&quot;&lt;elasticsearch 地址&gt;:9200&quot;</span></span><br><span class="line">			##索引名称</span><br><span class="line">			index =&gt; <span class="string">&quot;springboot-logstash-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line">	</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Kibana管理"><a href="#Kibana管理" class="headerlink" title="Kibana管理"></a>Kibana管理</h4><p>进入Kibana管理页面</p>
<p><img src="/images/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-1.png" alt="Spring-Boot使用ELK收集日志-1"></p>
<p><img src="/images/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-2.png" alt="Spring-Boot使用ELK收集日志-2"></p>
<p>创建索引模式，输入索引模式名称<code>springboot-logstash-*</code></p>
<p><img src="/images/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-3.png" alt="Spring-Boot使用ELK收集日志-3"></p>
<p>选择时间筛选字段名称为<code>@timestamp</code></p>
<p><img src="/images/Spring-Boot%E4%BD%BF%E7%94%A8ELK%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97-4.png" alt="Spring-Boot使用ELK收集日志-4"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Elastic Stack</category>
        <category>Spring boot</category>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring boot整合Elasticsearch</title>
    <url>/2020/01/16/Spring-boot%E6%95%B4%E5%90%88Elasticsearch/</url>
    <content><![CDATA[<h3 id="环境与版本"><a href="#环境与版本" class="headerlink" title="环境与版本"></a>环境与版本</h3><h4 id="Elasticsearch版本"><a href="#Elasticsearch版本" class="headerlink" title="Elasticsearch版本"></a>Elasticsearch版本</h4><p>服务端：elasticsearch 7.5.1  单节点</p>
<p>客户端：elasticsearch 6.8.5</p>
<h4 id="Logstash获取MySQL数据的配置"><a href="#Logstash获取MySQL数据的配置" class="headerlink" title="Logstash获取MySQL数据的配置"></a>Logstash获取MySQL数据的配置</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">input <span class="punctuation">&#123;</span></span><br><span class="line">	jdbc <span class="punctuation">&#123;</span></span><br><span class="line">		add_field =&gt; <span class="punctuation">&#123;</span><span class="string">&quot;myid&quot;</span>=&gt;<span class="string">&quot;jdbc&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">		jdbc_connection_string =&gt;</span><br><span class="line">			<span class="string">&quot;&lt;mysql 地址&gt;&quot;</span></span><br><span class="line">		jdbc_user =&gt; <span class="string">&quot;xxxxxxxxxxxxx&quot;</span></span><br><span class="line">		jdbc_password =&gt; <span class="string">&quot;xxxxxxxxxxxx&quot;</span></span><br><span class="line">		##数据库驱动的JAR位置</span><br><span class="line">		jdbc_driver_library =&gt; <span class="string">&quot;/usr/share/logstash/config/mysql-connector-java-5.1.47.jar&quot;</span></span><br><span class="line">		jdbc_driver_class =&gt; <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">		jdbc_paging_enabled =&gt; <span class="string">&quot;true&quot;</span></span><br><span class="line">		jdbc_page_size =&gt; <span class="string">&quot;50000&quot;</span></span><br><span class="line">		statement =&gt; <span class="string">&quot;select id,username,realname,age,birth from tb_user&quot;</span></span><br><span class="line">		## 每分钟执行一次</span><br><span class="line">		schedule =&gt; <span class="string">&quot;* * * * *&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">output <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">	if <span class="punctuation">[</span>myid<span class="punctuation">]</span> == <span class="string">&quot;jdbc&quot;</span> <span class="punctuation">&#123;</span></span><br><span class="line">		elasticsearch <span class="punctuation">&#123;</span></span><br><span class="line">			##elasticsearch 地址</span><br><span class="line">			hosts =&gt; <span class="string">&quot;&lt;elasticsearch 地址&gt;:9200&quot;</span></span><br><span class="line">			##索引名称</span><br><span class="line">			index =&gt; <span class="string">&quot;index-user&quot;</span></span><br><span class="line">			document_id =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line">			##索引类型</span><br><span class="line">			document_type =&gt; <span class="string">&quot;user&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">		stdout <span class="punctuation">&#123;</span></span><br><span class="line">			codec =&gt; json_lines</span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line">	</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="Spring-版本"><a href="#Spring-版本" class="headerlink" title="Spring 版本"></a>Spring 版本</h4><p>Spring boot:2.2.2.RELEASE</p>
<p>spring-boot-data-elasticsearch:3.2 对应elasticsearch的版本为6.8.5</p>
<h4 id="完整pom文件"><a href="#完整pom文件" class="headerlink" title="完整pom文件"></a>完整pom文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.monochrome<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>elasticsearch-test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for ElasticSearch<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring-boot-admin.version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">spring-boot-admin.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-admin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>PS：项目用到了Spring Cloud，如果不需要可以去除相关依赖。</p>
<h4 id="Spring-Boot配置文件"><a href="#Spring-Boot配置文件" class="headerlink" title="Spring Boot配置文件"></a>Spring Boot配置文件</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">elasticsearch-test</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&lt;Mysql</span> <span class="string">address&gt;</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">xxxxxxxxxx</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxxxxxxxx</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">cluster-name:</span> <span class="string">docker-cluster</span></span><br><span class="line">      <span class="attr">cluster-nodes:</span> <span class="string">&lt;elasticsearch</span> <span class="string">集群地址&gt;</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">rest:</span></span><br><span class="line">      <span class="attr">uris:</span> [<span class="string">&quot;&lt;elasticsearch 地址&gt;&quot;</span>]</span><br><span class="line">      <span class="attr">ipAddrs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&lt;elasticsearch</span> <span class="string">地址&gt;</span></span><br><span class="line"><span class="comment">#  main:</span></span><br><span class="line"><span class="comment">#    allow-bean-definition-overriding: true</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#客户端注册进eureka服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">&lt;Eureka地址&gt;</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">elasticsearch-test</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment">#访问路径可以显示IP地址</span></span><br><span class="line"><span class="comment">#management.endpoints.web.exposure.include=* #开放所有监控端接口，可以指定开放一些</span></span><br><span class="line"><span class="comment">#management.endpoint.health.show-details=always</span></span><br><span class="line"><span class="comment">#management.endpoints.web.base-path=/monitor</span></span><br><span class="line"><span class="comment">#management.endpoint.shutdown.enabled=true #开启接口优雅关闭 Spring Boot 应用</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8091</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">elasticsearch-test</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><p>定义一个<code>User</code>实体类以及<code>EsUser</code>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity(name = &quot;tb_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy= GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String realname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;index-user&quot;, refreshInterval = &quot;0s&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EsUser</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String realname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置Elasticsearch-Rest-High-Level-Client"><a href="#配置Elasticsearch-Rest-High-Level-Client" class="headerlink" title="配置Elasticsearch Rest High Level Client"></a>配置Elasticsearch Rest High Level Client</h4><p>Elasticsearch(ES)有两种连接方式：transport、rest。transport通过TCP方式访问ES(只支持java),rest方式通过http API 访问ES(没有语言限制)。<br>ES官方建议使用rest方式, transport 在7.0版本中不建议使用，在8.X的版本中废弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticsearchRestClientConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractElasticsearchConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ES_IP_ADDRESSES_LENGTH</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HTTP_SCHEME</span> <span class="operator">=</span> <span class="string">&quot;http&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * elasticSearch 服务器地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.elasticsearch.rest.ipAddrs&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ipAddresses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestClientBuilder <span class="title function_">restClientBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        HttpHost[] hosts = ipAddresses.stream()</span><br><span class="line">                .map(<span class="built_in">this</span>::makeHttpHost)</span><br><span class="line">                .filter(Objects::nonNull)</span><br><span class="line">                .toArray(HttpHost[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">return</span> RestClient.builder(hosts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpHost <span class="title function_">makeHttpHost</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> StringUtils.isNotEmpty(s);</span><br><span class="line">        String[] address = s.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (address.length == ES_IP_ADDRESSES_LENGTH) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> address[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> Integer.parseInt(address[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpHost</span>(ip, port, HTTP_SCHEME);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">elasticsearchClient</span><span class="params">()</span> &#123;</span><br><span class="line">        HttpHost[] hosts = ipAddresses.stream()</span><br><span class="line">                .map(<span class="built_in">this</span>::makeHttpHost)</span><br><span class="line">                .filter(Objects::nonNull)</span><br><span class="line">                .toArray(HttpHost[]::<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(hosts));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用Spring-data-Jpa-Repository操作数据库"><a href="#使用Spring-data-Jpa-Repository操作数据库" class="headerlink" title="使用Spring data Jpa Repository操作数据库"></a>使用Spring data Jpa Repository操作数据库</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用Spring-Data-Elasticsearch-Repositories操作Elasticsearch"><a href="#使用Spring-Data-Elasticsearch-Repositories操作Elasticsearch" class="headerlink" title="使用Spring Data Elasticsearch Repositories操作Elasticsearch"></a>使用Spring Data Elasticsearch Repositories操作Elasticsearch</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EsUserRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;EsUser, Long&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名为username的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名为username并且真实姓名为realname的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realname</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameAndRealname</span><span class="params">(String username, String realname)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名为username或者姓名为realname的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameOrRealname</span><span class="params">(String username, String realname)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名不是username的所有用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameNot</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询年龄段为ageFrom到ageTo的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ageFrom</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ageTo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByAgeBetween</span><span class="params">(Integer ageFrom, Integer ageTo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询生日小于birthTo的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByBirthLessThan</span><span class="params">(LocalDateTime birthTo)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询生日段大于birthFrom的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> birthFrom</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByBirthGreaterThan</span><span class="params">(LocalDateTime birthFrom)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询年龄小于或等于ageTo的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByAgeBefore</span><span class="params">(Integer ageTo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询年龄大于或等于ageFrom的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ageFrom</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByAgeAfter</span><span class="params">(Integer ageFrom)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名模糊查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameLike</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名以start开头的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameStartingWith</span><span class="params">(String start)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名以end结尾的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameEndingWith</span><span class="params">(String end)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户名包含word的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameContaining</span><span class="params">(String word)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询名字属于usernames中的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> usernames</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameIn</span><span class="params">(Collection&lt;String&gt; usernames)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询名字不属于usernames中的用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> usernames</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByUsernameNotIn</span><span class="params">(Collection&lt;String&gt; usernames)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *最后来个复杂点的：查询年龄小于ageTo,姓名以start开头，id大于idTo的用户，并且按照年龄倒序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;EsUser&gt; <span class="title function_">findByAgeBeforeAndUsernameStartingWithAndIdGreaterThanOrderByAgeDesc</span><span class="params">(Integer ageTo, String start, Long idTo)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EsUserRepository esUserRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id:\\d+&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        userRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUsers</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; users)</span> &#123;</span><br><span class="line">        userRepository.saveAll(users);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/username/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;EsUser&gt; <span class="title function_">getUserByUsername</span><span class="params">(<span class="meta">@PathVariable</span> String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> esUserRepository.findByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/usernameLike/&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;EsUser&gt; <span class="title function_">getUserByUsernameLike</span><span class="params">(<span class="meta">@PathVariable</span> String username)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;get User By Username Like &#123;&#125;&quot;</span>,username);</span><br><span class="line">        <span class="keyword">return</span> esUserRepository.findByUsernameLike(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/ageTo/&#123;ageTo&#125;/name_start/&#123;nameStart&#125;/id/&#123;id:\\d+&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;EsUser&gt; <span class="title function_">getUserByAgeAndUsernameAndId</span><span class="params">(<span class="meta">@PathVariable</span> Integer ageTo, <span class="meta">@PathVariable</span> String nameStart,</span></span><br><span class="line"><span class="params">                                                     <span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> esUserRepository.findByAgeBeforeAndUsernameStartingWithAndIdGreaterThanOrderByAgeDesc(ageTo, nameStart, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Swagger配置"><a href="#Swagger配置" class="headerlink" title="Swagger配置"></a>Swagger配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.monochrome.elasticsearch&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;Elasticsearch Demo RESTful APIs&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;服务名：elasticsearch Demo&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Elastic Stack</category>
        <category>Spring boot</category>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring知识点</title>
    <url>/2021/07/01/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h1><p>Bean的生命周期指的就是：在Spring中，Bean是如何生成的？</p>
<p>被Spring管理的对象叫做Bean。Bean的生成步骤如下：</p>
<ol>
<li>Spring扫描class得到BeanDefinition</li>
<li>根据得到的BeanDefinition去生成bean</li>
<li>首先根据class推断构造方法</li>
<li>根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象）</li>
<li>填充原始对象中的属性（依赖注入）</li>
<li>如果原始对象中的某个方法被AOP了，那么则需要根据原始对象生成一个代理对象</li>
<li>把最终生成的代理对象放入单例池（源码中叫做singletonObjects）中，下次getBean时就直接从单例池拿即可</li>
</ol>
<span id="more"></span>

<p><img src="/images/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Bean的生命周期"></p>
<h1 id="Spring的循环依赖？"><a href="#Spring的循环依赖？" class="headerlink" title="Spring的循环依赖？"></a>Spring的循环依赖？</h1><p>很简单，就是A对象依赖了B对象，B对象依赖了A对象。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A依赖了B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B依赖了A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么循环依赖是个问题吗？</p>
<p>如果不考虑Spring，循环依赖并不是问题，因为对象之间相互依赖是很正常的事情。</p>
<p>比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"></span><br><span class="line">a.b = b;</span><br><span class="line">b.a = a;</span><br></pre></td></tr></table></figure>

<p>这样，A,B就依赖上了。</p>
<p>但是，在Spring中循环依赖就是一个问题了，为什么？</p>
<p>因为，在Spring中，一个对象并不是简单new出来了，而是会经过一系列的Bean的生命周期，就是因为Bean的生命周期所以才会出现循环依赖问题。当然，在Spring中，出现循环依赖的场景很多，有的场景Spring自动帮我们解决了，而有的场景则需要程序员来解决。</p>
<p>要明白Spring中的循环依赖，得先明白Spring中<a href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Bean的生命周期</a>。</p>
<p>可以发现，在Spring中，构造一个Bean，包括了new这个步骤（第4步构造方法反射）。</p>
<p>得到一个原始对象后，Spring需要给对象中的属性进行依赖注入，那么这个注入过程是怎样的？</p>
<p>比如上文说的A类，A类中存在一个B类的b属性，所以，当A类生成了一个原始对象之后，就会去给b属性去赋值，此时就会根据b属性的类型和属性名去BeanFactory中去获取B类所对应的单例bean。如果此时BeanFactory中存在B对应的Bean，那么直接拿来赋值给b属性；如果此时BeanFactory中不存在B对应的Bean，则需要生成一个B对应的Bean，然后赋值给b属性。</p>
<p>问题就出现在第二种情况，如果此时B类在BeanFactory中还没有生成对应的Bean，那么就需要去生成，就会经过B的Bean的生命周期。</p>
<p>那么在创建B类的Bean的过程中，如果B类中存在一个A类的a属性，那么在创建B的Bean的过程中就需要A类对应的Bean，但是，触发B类Bean的创建的条件是A类Bean在创建过程中的依赖注入，所以这里就出现了循环依赖：</p>
<p>ABean创建–&gt;依赖了B属性–&gt;触发BBean创建—&gt;B依赖了A属性—&gt;需要ABean（但ABean还在创建过程中）</p>
<p>从而导致ABean创建不出来，BBean也创建不出来。</p>
<p>这是循环依赖的场景，但是上文说了，在Spring中，通过某些机制帮开发者解决了部分循环依赖的问题，这个机制就是<strong>三级缓存</strong>。</p>
<h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>三级缓存是通用的叫法。</p>
<p>一级缓存为：<strong>singletonObjects</strong></p>
<p>二级缓存为：<strong>earlySingletonObjects</strong></p>
<p>三级缓存为：<strong>singletonFactories</strong></p>
<p><strong>先稍微解释一下这三个缓存的作用，后面详细分析：</strong></p>
<ul>
<li><p><strong>singletonObjects</strong>中缓存的是已经经历了完整生命周期的bean对象。</p>
</li>
<li><p><strong>earlySingletonObjects</strong>比singletonObjects多了一个early，表示缓存的是早期的bean对象。早期是什么意思？表示Bean的生命周期还没走完就把这个Bean放入了earlySingletonObjects。</p>
</li>
<li><p><strong>singletonFactories</strong>中缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的。</p>
</li>
</ul>
<h2 id="解决循环依赖思路分析"><a href="#解决循环依赖思路分析" class="headerlink" title="解决循环依赖思路分析"></a>解决循环依赖思路分析</h2><p>先来分析为什么缓存能解决循环依赖。</p>
<p>上文分析得到，之所以产生循环依赖的问题，主要是：</p>
<p>A创建时—&gt;需要B—-&gt;B去创建—&gt;需要A，从而产生了循环</p>
<p><img src="/images/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" alt="循环依赖"></p>
<p>那么如何打破这个循环，加个中间人（缓存）</p>
<p><img src="/images/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%89%93%E7%A0%B4%E5%BE%AA%E7%8E%AF.png" alt="打破循环"></p>
<p>A的Bean在创建过程中，在进行依赖注入之前，先把A的原始Bean放入缓存（提早暴露，只要放到缓存了，其他Bean需要时就可以从缓存中拿了），放入缓存后，再进行依赖注入，此时A的Bean依赖了B的Bean，如果B的Bean不存在，则需要创建B的Bean，而创建B的Bean的过程和A一样，也是先创建一个B的原始对象，然后把B的原始对象提早暴露出来放入缓存中，然后在对B的原始对象进行依赖注入A，此时能从缓存中拿到A的原始对象（虽然是A的原始对象，还不是最终的Bean），B的原始对象依赖注入完了之后，B的生命周期结束，那么A的生命周期也能结束。</p>
<p>因为整个过程中，都只有一个A原始对象，所以对于B而言，就算在属性注入时，注入的是A原始对象，也没有关系，因为A原始对象在后续的生命周期中在堆中没有发生变化。</p>
<p>从上面这个分析过程中可以得出，只需要一个缓存就能解决循环依赖了，那么为什么Spring中还需要<strong>singletonFactories</strong>呢？</p>
<p>这是难点，基于上面的场景想一个问题：如果A的原始对象注入给B的属性之后，A的原始对象进行了AOP产生了一个代理对象，此时就会出现，对于A而言，它的Bean对象其实应该是AOP之后的代理对象，而B的a属性对应的并不是AOP之后的代理对象，这就产生了冲突。</p>
<p><strong>B依赖的A和最终的A不是同一个对象</strong>。</p>
<p>那么如何解决这个问题？这个问题可以说没有办法解决。</p>
<p>因为在一个Bean的生命周期最后，Spring提供了BeanPostProcessor可以去对Bean进行加工，这个加工不仅仅只是能修改Bean的属性值，也可以替换掉当前Bean。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper极简入门及部署</title>
    <url>/2020/07/12/ZooKeeper%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8%E5%8F%8A%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apache ZooKeeper是Apache软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。ZooKeeper曾经是Hadoop的一个子项目，但现在是一个独立的顶级项目。</p>
<p>ZooKeeper的架构通过冗余服务实现高可用性。因此，如果第一次无应答，客户端就可以询问另一台ZooKeeper主机。ZooKeeper节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。更新是全序的。</p>
<span id="more"></span>

<h2 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h2><h3 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h3><ul>
<li>操作系统: Mac OS 10.15(其他系统一样)</li>
<li>JDK: 11</li>
</ul>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>打开 <a href="https://archive.apache.org/dist/zookeeper/">Zookeeper 下载页面</a>，选择想要安装的版本。我选择的是 <a href="https://archive.apache.org/dist/zookeeper/stable/">stable</a> 稳定版本，版本是3.5.8，选择编译好的包，<a href="https://archive.apache.org/dist/zookeeper/stable/apache-zookeeper-3.5.8-bin.tar.gz">apache-zookeeper-3.5.8-bin.tar.gz</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载</span></span><br><span class="line">wget https://archive.apache.org/dist/zookeeper/stable/apache-zookeeper-3.5.8-bin.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf apache-zookeeper-3.5.8-bin.tar.gz</span><br><span class="line">cd apache-zookeeper-3.5.8-bin</span><br></pre></td></tr></table></figure>

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>Zookeeper 提供了 <code>conf/zoo_sample.cfg</code> 模版配置文件，作为示例。这里，我们复制一下，复制出一个 <code>conf/zoo.cfg </code>(默认读取的配置文件)，然后在上面进行修改，修改后配置如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line"><span class="comment"># Client-Server 通信心跳时间</span></span><br><span class="line"><span class="comment"># Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。tickTime 以毫秒为单位。</span></span><br><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"># The number of ticks that the initial</span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line"><span class="comment"># Leader-Follower 初始通信时限</span></span><br><span class="line"><span class="comment"># 集群中的 follower 服务器(F)与 leader 服务器(L)之间初始连接时能容忍的最多心跳数（tickTime 的数量）。</span></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># The number of ticks that can pass between</span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line"><span class="comment"># Leader-Follower 同步通信时限</span></span><br><span class="line"><span class="comment"># 集群中的 follower 服务器与 leader 服务器之间请求和应答之间能容忍的最多心跳数（tickTime的数量）。</span></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just</span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="comment"># 数据文件目录</span></span><br><span class="line"><span class="comment"># Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">/Users/monochrome/app/Zookeeper/apache-zookeeper-3.5.8-bin/data</span></span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="comment"># 客户端连接端口</span></span><br><span class="line"><span class="comment"># 客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the</span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to &quot;0&quot; to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br></pre></td></tr></table></figure>

<h4 id="运行Zookeeper-Server"><a href="#运行Zookeeper-Server" class="headerlink" title="运行Zookeeper Server"></a>运行Zookeeper Server</h4><p>执行 <code>bin/zkServer.sh start</code> 命令，启动 Zookeeper Server 服务。此时，控制台会输出如下日志，表示启动成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下，Zookeeper 开启 JMX</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 conf/zoo.cfg 配置文件</span></span><br><span class="line">Using config: /Users/monochrome/app/Zookeeper/apache-zookeeper-3.5.8-bin/bin/../conf/zoo.cfg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 Zookeeper Server 成功（实际不一定成功）</span></span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>

<p>注意，Zookeeper 3.5 版本开始，默认会在 8080 端口，启动一个 Zookeeper <strong>AdminServer</strong>。如果 8080 端口已经被其它服务占用，会导致 Zookeeper Server 启动失败。此时，我们有三种解决方案：</p>
<ul>
<li>方式一，可以修改 <code>conf/zoo.cfg</code> 配置文件的 <code>admin.serverPort</code> 配置项，从而修改 Zookeeper AdminServer 的端口。</li>
<li>方式二，可以修改 <code>conf/zoo.cfg</code> 配置文件的 <code>admin.enableServer=false</code> 配置项，从而关闭 Zookeeper AdminServer 的启动。</li>
<li>方式三，关闭占用 8080 端口的服务。</li>
</ul>
<h4 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h4><p>测试连接到 Zookeeper Server 上，看看是否真的启动成功。操作命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接 Zookeeper Server</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/zkCli.sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出如下日志信息表示连接成功</span></span><br><span class="line">Welcome to ZooKeeper!</span><br><span class="line">JLine support is enabled</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 Zookeeper 命令行中，执行 <span class="built_in">ls</span> / 命令，输出根目录</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[zookeeper]</span><br></pre></td></tr></table></figure>

<h3 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h3><p>待续</p>
<h2 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h2><h3 id="pull-image"><a href="#pull-image" class="headerlink" title="pull image"></a>pull image</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="Start-a-Zookeeper-server-instance"><a href="#Start-a-Zookeeper-server-instance" class="headerlink" title="Start a Zookeeper server instance"></a>Start a Zookeeper server instance</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -d zookeeper</span><br></pre></td></tr></table></figure>

<p>This image includes <code>EXPOSE 2181 2888 3888 8080</code> (the zookeeper client port, follower port, election port, AdminServer port respectively), so standard container linking will make it automatically available to the linked containers. Since the Zookeeper “fails fast” it’s better to always restart it.</p>
<h3 id="Connect-to-Zookeeper-from-an-application-in-another-Docker-container"><a href="#Connect-to-Zookeeper-from-an-application-in-another-Docker-container" class="headerlink" title="Connect to Zookeeper from an application in another Docker container"></a>Connect to Zookeeper from an application in another Docker container</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-app --link some-zookeeper:zookeeper -d application-that-uses-zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="Connect-to-Zookeeper-from-the-Zookeeper-command-line-client"><a href="#Connect-to-Zookeeper-from-the-Zookeeper-command-line-client" class="headerlink" title="Connect to Zookeeper from the Zookeeper command line client"></a>Connect to Zookeeper from the Zookeeper command line client</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -it --rm --link some-zookeeper:zookeeper zookeeper zkCli.sh -server zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="…-via-docker-stack-deploy-or-docker-compose"><a href="#…-via-docker-stack-deploy-or-docker-compose" class="headerlink" title="… via docker stack deploy or docker-compose"></a>… via <a href="https://docs.docker.com/engine/reference/commandline/stack_deploy/"><code>docker stack deploy</code></a> or <a href="https://github.com/docker/compose"><code>docker-compose</code></a></h3><p>Example <code>stack.yml</code> for <code>zookeeper</code>:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zoo1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=0.0.0.0:2888:3888;2181</span> <span class="string">server.2=zoo2:2888:3888;2181</span> <span class="string">server.3=zoo3:2888:3888;2181</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zoo2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2182</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888;2181</span> <span class="string">server.2=0.0.0.0:2888:3888;2181</span> <span class="string">server.3=zoo3:2888:3888;2181</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zoo3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2183</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zoo1:2888:3888;2181</span> <span class="string">server.2=zoo2:2888:3888;2181</span> <span class="string">server.3=0.0.0.0:2888:3888;2181</span></span><br></pre></td></tr></table></figure>

<p><a href="http://play-with-docker.com/?stack=https://raw.githubusercontent.com/docker-library/docs/ef162dce5998011e1753c3337dcbe61200c522d2/zookeeper/stack.yml"><img src="https://github.com/play-with-docker/stacks/raw/cff22438cb4195ace27f9b15784bbb497047afa7/assets/images/button.png" alt="Try in PWD"></a></p>
<p>This will start Zookeeper 3.5 in <a href="https://zookeeper.apache.org/doc/current/zookeeperStarted.html#sc_RunningReplicatedZooKeeper">replicated mode</a>. Please note, that Zookeeper 3.4 has slightly different <code>ZOO_SERVERS</code> format. Run <code>docker stack deploy -c stack.yml zookeeper</code> (or <code>docker-compose -f stack.yml up</code>) and wait for it to initialize completely. Ports <code>2181-2183</code> will be exposed.</p>
<blockquote>
<p>Please be aware that setting up multiple servers on a single machine will not create any redundancy. If something were to happen which caused the machine to die, all of the zookeeper servers would be offline. Full redundancy requires that each server have its own machine. It must be a completely separate physical server. Multiple virtual machines on the same physical host are still vulnerable to the complete failure of that host.</p>
</blockquote>
<p>Consider using <a href="https://www.docker.com/products/docker-swarm">Docker Swarm</a> when running Zookeeper in replicated mode.</p>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>Zookeeper configuration is located in <code>/conf</code>. One way to change it is mounting your config file as a volume:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -d -v $(pwd)/zoo.cfg:/conf/zoo.cfg zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="Environment-variables"><a href="#Environment-variables" class="headerlink" title="Environment variables"></a>Environment variables</h3><p>ZooKeeper recommended defaults are used if <code>zoo.cfg</code> file is not provided. They can be overridden using the following environment variables.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -e &quot;ZOO_INIT_LIMIT=10&quot; --name some-zookeeper --restart always -d zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="ZOO-TICK-TIME"><a href="#ZOO-TICK-TIME" class="headerlink" title="ZOO_TICK_TIME"></a><code>ZOO_TICK_TIME</code></h3><p>Defaults to <code>2000</code>. ZooKeeper’s <code>tickTime</code></p>
<blockquote>
<p>The length of a single tick, which is the basic time unit used by ZooKeeper, as measured in milliseconds. It is used to regulate heartbeats, and timeouts. For example, the minimum session timeout will be two ticks</p>
</blockquote>
<h3 id="ZOO-INIT-LIMIT"><a href="#ZOO-INIT-LIMIT" class="headerlink" title="ZOO_INIT_LIMIT"></a><code>ZOO_INIT_LIMIT</code></h3><p>Defaults to <code>5</code>. ZooKeeper’s <code>initLimit</code></p>
<blockquote>
<p>Amount of time, in ticks (see tickTime), to allow followers to connect and sync to a leader. Increased this value as needed, if the amount of data managed by ZooKeeper is large.</p>
</blockquote>
<h3 id="ZOO-SYNC-LIMIT"><a href="#ZOO-SYNC-LIMIT" class="headerlink" title="ZOO_SYNC_LIMIT"></a><code>ZOO_SYNC_LIMIT</code></h3><p>Defaults to <code>2</code>. ZooKeeper’s <code>syncLimit</code></p>
<blockquote>
<p>Amount of time, in ticks (see tickTime), to allow followers to sync with ZooKeeper. If followers fall too far behind a leader, they will be dropped.</p>
</blockquote>
<h3 id="ZOO-MAX-CLIENT-CNXNS"><a href="#ZOO-MAX-CLIENT-CNXNS" class="headerlink" title="ZOO_MAX_CLIENT_CNXNS"></a><code>ZOO_MAX_CLIENT_CNXNS</code></h3><p>Defaults to <code>60</code>. ZooKeeper’s <code>maxClientCnxns</code></p>
<blockquote>
<p>Limits the number of concurrent connections (at the socket level) that a single client, identified by IP address, may make to a single member of the ZooKeeper ensemble.</p>
</blockquote>
<h3 id="ZOO-STANDALONE-ENABLED"><a href="#ZOO-STANDALONE-ENABLED" class="headerlink" title="ZOO_STANDALONE_ENABLED"></a><code>ZOO_STANDALONE_ENABLED</code></h3><p>Defaults to <code>true</code>. Zookeeper’s <a href="https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html#sc_reconfig_standaloneEnabled"><code>standaloneEnabled</code></a></p>
<blockquote>
<p>Prior to 3.5.0, one could run ZooKeeper in Standalone mode or in a Distributed mode. These are separate implementation stacks, and switching between them during run time is not possible. By default (for backward compatibility) standaloneEnabled is set to true. The consequence of using this default is that if started with a single server the ensemble will not be allowed to grow, and if started with more than one server it will not be allowed to shrink to contain fewer than two participants.</p>
</blockquote>
<h3 id="ZOO-ADMINSERVER-ENABLED"><a href="#ZOO-ADMINSERVER-ENABLED" class="headerlink" title="ZOO_ADMINSERVER_ENABLED"></a><code>ZOO_ADMINSERVER_ENABLED</code></h3><p>Defaults to <code>true</code>. Zookeeper’s <a href="http://zookeeper.apache.org/doc/r3.5.7/zookeeperAdmin.html#sc_adminserver_config"><code>admin.enableServer</code></a></p>
<blockquote>
<p>New in 3.5.0: The AdminServer is an embedded Jetty server that provides an HTTP interface to the four letter word commands. By default, the server is started on port 8080, and commands are issued by going to the URL “&#x2F;commands&#x2F;[command name]”, e.g., <a href="http://localhost:8080/commands/stat">http://localhost:8080/commands/stat</a>.</p>
</blockquote>
<h3 id="ZOO-AUTOPURGE-PURGEINTERVAL"><a href="#ZOO-AUTOPURGE-PURGEINTERVAL" class="headerlink" title="ZOO_AUTOPURGE_PURGEINTERVAL"></a><code>ZOO_AUTOPURGE_PURGEINTERVAL</code></h3><p>Defaults to <code>0</code>. Zookeeper’s <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_advancedConfiguration"><code>autoPurge.purgeInterval</code></a></p>
<blockquote>
<p>The time interval in hours for which the purge task has to be triggered. Set to a positive integer (1 and above) to enable the auto purging. Defaults to 0.</p>
</blockquote>
<h3 id="ZOO-AUTOPURGE-SNAPRETAINCOUNT"><a href="#ZOO-AUTOPURGE-SNAPRETAINCOUNT" class="headerlink" title="ZOO_AUTOPURGE_SNAPRETAINCOUNT"></a><code>ZOO_AUTOPURGE_SNAPRETAINCOUNT</code></h3><p>Defaults to <code>3</code>. Zookeeper’s <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_advancedConfiguration"><code>autoPurge.snapRetainCount</code></a></p>
<blockquote>
<p>When enabled, ZooKeeper auto purge feature retains the autopurge.snapRetainCount most recent snapshots and the corresponding transaction logs in the dataDir and dataLogDir respectively and deletes the rest. Defaults to 3. Minimum value is 3.</p>
</blockquote>
<h3 id="ZOO-4LW-COMMANDS-WHITELIST"><a href="#ZOO-4LW-COMMANDS-WHITELIST" class="headerlink" title="ZOO_4LW_COMMANDS_WHITELIST"></a><code>ZOO_4LW_COMMANDS_WHITELIST</code></h3><p>Defaults to <code>srvr</code>. Zookeeper’s <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_clusterOptions"><code>4lw.commands.whitelist</code></a></p>
<blockquote>
<p>A list of comma separated Four Letter Words commands that user wants to use. A valid Four Letter Words command must be put in this list else ZooKeeper server will not enable the command. By default the whitelist only contains “srvr” command which zkServer.sh uses. The rest of four letter word commands are disabled by default.</p>
</blockquote>
<h2 id="Advanced-configuration"><a href="#Advanced-configuration" class="headerlink" title="Advanced configuration"></a>Advanced configuration</h2><h3 id="ZOO-CFG-EXTRA"><a href="#ZOO-CFG-EXTRA" class="headerlink" title="ZOO_CFG_EXTRA"></a><code>ZOO_CFG_EXTRA</code></h3><p>Not every Zookeeper configuration setting is exposed via the environment variables listed above. These variables are only meant to cover minimum configuration keywords and some often changing options. If <a href="https://hub.docker.com/_/zookeeper#configuration">mounting your custom config file</a> as a volume doesn’t work for you, consider using <code>ZOO_CFG_EXTRA</code> environment variable. You can add arbitrary configuration parameters to Zookeeper configuration file using this variable. The following example shows how to enable Prometheus metrics exporter on port <code>7070</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -e ZOO_CFG_EXTRA=&quot;metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider metricsProvider.httpPort=7070&quot; zookeeper</span><br></pre></td></tr></table></figure>

<h3 id="JVMFLAGS"><a href="#JVMFLAGS" class="headerlink" title="JVMFLAGS"></a><code>JVMFLAGS</code></h3><p>Many of the Zookeeper advanced configuration options can be set there using Java system properties in the form of <code>-Dproperty=value</code>. For example, you can use Netty instead of NIO (default option) as a server communication framework:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -e JVMFLAGS=&quot;-Dzookeeper.serverCnxnFactory=org.apache.zookeeper.server.NettyServerCnxnFactory&quot; zookeeper</span><br></pre></td></tr></table></figure>

<p>See <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_advancedConfiguration">Advanced Configuration</a> for the full list of supported Java system properties.</p>
<p>Another example use case for the <code>JVMFLAGS</code> is setting a maximum JWM heap size of 1 GB:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run --name some-zookeeper --restart always -e JVMFLAGS=&quot;-Xmx1024m&quot; zookeeper</span><br></pre></td></tr></table></figure>

<h2 id="Replicated-mode"><a href="#Replicated-mode" class="headerlink" title="Replicated mode"></a>Replicated mode</h2><p>Environment variables below are mandatory if you want to run Zookeeper in replicated mode.</p>
<h3 id="ZOO-MY-ID"><a href="#ZOO-MY-ID" class="headerlink" title="ZOO_MY_ID"></a><code>ZOO_MY_ID</code></h3><p>The id must be unique within the ensemble and should have a value between 1 and 255. Do note that this variable will not have any effect if you start the container with a <code>/data</code> directory that already contains the <code>myid</code> file.</p>
<h3 id="ZOO-SERVERS"><a href="#ZOO-SERVERS" class="headerlink" title="ZOO_SERVERS"></a><code>ZOO_SERVERS</code></h3><p>This variable allows you to specify a list of machines of the Zookeeper ensemble. Each entry has the form of <code>server.id=host:port:port</code>. Entries are separated with space. Do note that this variable will not have any effect if you start the container with a <code>/conf</code> directory that already contains the <code>zoo.cfg</code> file.</p>
<p>In 3.5, the syntax of this has changed. Servers should be specified as such: <code>server.id=&lt;address1&gt;:&lt;port1&gt;:&lt;port2&gt;[:role];[&lt;client port address&gt;:]&lt;client port&gt;</code> <a href="https://zookeeper.apache.org/doc/r3.5.7/zookeeperReconfig.html">Zookeeper Dynamic Reconfiguration</a></p>
<h2 id="Where-to-store-data"><a href="#Where-to-store-data" class="headerlink" title="Where to store data"></a>Where to store data</h2><p>This image is configured with volumes at <code>/data</code> and <code>/datalog</code> to hold the Zookeeper in-memory database snapshots and the transaction log of updates to the database, respectively.</p>
<blockquote>
<p>Be careful where you put the transaction log. A dedicated transaction log device is key to consistent good performance. Putting the log on a busy device will adversely affect performance.</p>
</blockquote>
<h2 id="How-to-configure-logging"><a href="#How-to-configure-logging" class="headerlink" title="How to configure logging"></a>How to configure logging</h2><p>By default, ZooKeeper redirects stdout&#x2F;stderr outputs to the console. You can redirect to a file located in <code>/logs</code> by passing environment variable <code>ZOO_LOG4J_PROP</code> as follows:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -e ZOO_LOG4J_PROP=&quot;INFO,ROLLINGFILE&quot; zookeeper</span><br></pre></td></tr></table></figure>

<p>This will write logs to <code>/logs/zookeeper.log</code>. Check <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_logging">ZooKeeper Logging</a> for more details.</p>
<p>This image is configured with a volume at <code>/logs</code> for your convenience.</p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown使用指南</title>
    <url>/2018/11/23/markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<h2 id="markdown使用指南"><a href="#markdown使用指南" class="headerlink" title="markdown使用指南"></a>markdown使用指南</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>标题能显示出文章的结构。行首插入1-6个 # ，每增加一个 # 表示更深入层次的内容，对应到标题的深度由 1-6 阶。</p>
<pre><code>H1 :# Header 1
H2 :## Header 2
H3 :### Header 3
H4 :#### Header 4
H5 :##### Header 5
H6 :###### Header 6
</code></pre>
<span id="more"></span>
<h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><p>（带“*”星号的文本样式，在原版Markdown标准中不存在，但在其大部分衍生标准中被添加）</p>
<pre><code>链接 :[Title](URL)
加粗 :**Bold**
斜体字 :*Italics*
*高亮 :==text==
段落 : 段落之间空一行
换行符 : 一行结束时输入两个空格
列表 :* 添加星号成为一个新的列表项。
引用 :&gt; 引用内容
内嵌代码 : `alert(&#39;Hello World&#39;);`
画水平线 (HR) :--------
方框：- [ ] -
</code></pre>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>使用Markdown将图像插入文章，你需要在Markdown编辑器输入 <strong><code>![]()</code></strong> 。 这时在预览面板中会自动创建一个图像上传框。你可以从电脑桌面拖放图片(.png, .gif, .jpg)到上传框, 或者点击图片上传框使用标准的图像上传方式。 如果你想通过链接插入网络上已经存在的图片，只要单击图片上传框的左下角的“链接”图标，这时就会呈现图像URL的输入框。想给图片添加一个标题, 你需要做的是将标题文本插图中的方括号， <strong><code>e.g;![This is a title]()</code></strong> .</p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注不存在于标准Markdown中。<br>使用这样的占位符号可以将脚注添加到文本中:[^1]. 另外，你可以使用“n”而不是数字的[^n]所以你可以不必担心使用哪个号码。在您的文章的结尾，你可以如下图所示定义匹配的注脚，URL将变成链接:<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里是脚注[^1]</span><br><span class="line">[^1]: 这里是脚注的内容</span><br><span class="line">这里是脚注[^n]</span><br><span class="line">[^n]: 这里是脚注的内容</span><br></pre></td></tr></table></figure></p>
<h3 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h3><p>添加内嵌代码可以使用一对回勾号 <strong>`alert(‘Hello World’)`</strong> .对于插入代码, Ghost支持标准的Markdown代码和GitHub Flavored Markdown (GFM) [4]  。标准Markdown基于缩进代码行或者4个空格位:<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\</span><br><span class="line">    insert code</span><br><span class="line">    insert code</span><br><span class="line">    insert code</span><br><span class="line">\</span><br><span class="line"></span><br><span class="line">**删除\**</span><br></pre></td></tr></table></figure></p>
<p>GFM 使用三个回勾号```<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">``\`</span><br><span class="line">insert code</span><br><span class="line">insert code</span><br><span class="line">insert code</span><br><span class="line">``\`</span><br><span class="line"></span><br><span class="line">**删除\**</span><br></pre></td></tr></table></figure></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>链接<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is a paragraph that contains a [link to example]()</span><br></pre></td></tr></table></figure></p>
<p>列表格式<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This paragraph contains a list of items.</span><br><span class="line">* Item 1</span><br><span class="line">* Item 2</span><br><span class="line">* Item three</span><br></pre></td></tr></table></figure></p>
<p>使用Markdown 引用文本：	<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This paragraph has a quote</span><br><span class="line"></span><br><span class="line">&gt; That is pulled out like this</span><br><span class="line">from the text my post.</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器 ECS CentOS 7配置默认防火墙 Firewall</title>
    <url>/2019/01/11/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8-ECS-CentOS-7%E9%85%8D%E7%BD%AE%E9%BB%98%E8%AE%A4%E9%98%B2%E7%81%AB%E5%A2%99-Firewall/</url>
    <content><![CDATA[<p>阿里云服务器的 CentOS7 下默认的防火墙是 Firewall，替代了之前的 iptables，Firewall 有图形界面管理和命令行管理两种方式，本文简要介绍命令行 Firewall 的使用。</p>
<h3 id="配置-Firewall"><a href="#配置-Firewall" class="headerlink" title="配置 Firewall"></a>配置 Firewall</h3><p>进入系统之后，CentOS7 默认是已安装了 Firewall，但是没有启动的，所以需要先启动下 Firewall，同时设置开机自启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld       ##启动Firewall</span><br><span class="line">systemctl enable firewalld.service  ##设置开机自启动</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s &#x27;/usr/lib/systemd/system/firewalld.service&#x27; &#x27;/etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service&#x27;</span><br><span class="line">ln -s &#x27;/usr/lib/systemd/system/firewalld.service&#x27; &#x27;/etc/systemd/system/basic.target.wants/firewalld.service&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="常用命令介绍"><a href="#常用命令介绍" class="headerlink" title="常用命令介绍"></a>常用命令介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state                           ##查看防火墙状态，是否是running</span><br><span class="line">firewall-cmd --reload                          ##重新载入配置，比如添加规则之后，需要执行此命令</span><br><span class="line">firewall-cmd --get-zones                       ##列出支持的zone</span><br><span class="line">firewall-cmd --get-services                    ##列出支持的服务，在列表中的服务是放行的</span><br><span class="line">firewall-cmd --query-service ftp               ##查看ftp服务是否支持，返回yes或者no</span><br><span class="line">firewall-cmd --add-service=ftp                 ##临时开放ftp服务</span><br><span class="line">firewall-cmd --add-service=ftp --permanent     ##永久开放ftp服务</span><br><span class="line">firewall-cmd --remove-service=ftp --permanent  ##永久移除ftp服务</span><br><span class="line">firewall-cmd --add-port=80/tcp --permanent     ##永久添加80端口 </span><br><span class="line">iptables -L -n                                 ##查看规则，这个命令是和iptables的相同的</span><br><span class="line">man firewall-cmd                               ##查看帮助</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ECS</category>
      </categories>
      <tags>
        <tag>ECS</tag>
      </tags>
  </entry>
  <entry>
    <title>在Jenkins上创建多分支流水线</title>
    <url>/2019/12/05/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<h3 id="准备Jenkinsfile配置文件"><a href="#准备Jenkinsfile配置文件" class="headerlink" title="准备Jenkinsfile配置文件"></a>准备Jenkinsfile配置文件</h3><h4 id="准备公共配置文件"><a href="#准备公共配置文件" class="headerlink" title="准备公共配置文件"></a>准备公共配置文件</h4><p>新建远程仓库，文件目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 资源文件</span><br><span class="line">|-- resources</span><br><span class="line"># 执行脚本文件</span><br><span class="line">|-- vars</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>新建配置文件<code>build.groovy</code>，放在<code>vars</code>文件夹下:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">#!groovy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> call(Map map) &#123;</span><br><span class="line"></span><br><span class="line">    pipeline &#123;</span><br><span class="line">        agent any</span><br><span class="line"></span><br><span class="line">        environment &#123;</span><br><span class="line">			APP_NAME = <span class="string">&quot;$&#123;map.APP_NAME&#125;&quot;</span></span><br><span class="line">			APP_PORT = <span class="string">&quot;$&#123;map.APP_PORT&#125;&quot;</span></span><br><span class="line">            <span class="comment">//非必要，可以设置用于发版</span></span><br><span class="line">            REMOTE_HOST = <span class="string">&quot;$&#123;map.REMOTE_HOST&#125;&quot;</span></span><br><span class="line">            <span class="comment">//程序远程仓库地址</span></span><br><span class="line">            REPO_URL = <span class="string">&quot;$&#123;map.REPO_URL&#125;&quot;</span></span><br><span class="line">            BRANCH_NAME = <span class="string">&quot;$&#123;map.BRANCH_NAME&#125;&quot;</span></span><br><span class="line">            <span class="comment">//非必要</span></span><br><span class="line">            STACK_NAME = <span class="string">&quot;$&#123;map.STACK_NAME&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stages &#123;</span><br><span class="line">            stage(<span class="string">&#x27;获取代码&#x27;</span>) &#123;</span><br><span class="line">                steps &#123;</span><br><span class="line">                    git([<span class="attr">url:</span> <span class="string">&quot;$&#123;REPO_URL&#125;&quot;</span>, <span class="attr">branch:</span> <span class="string">&quot;$&#123;BRANCH_NAME&#125;&quot;</span>])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stage(<span class="string">&#x27;编译代码&#x27;</span>) &#123;</span><br><span class="line">                steps &#123;</span><br><span class="line">                    withMaven(<span class="attr">maven:</span> <span class="string">&#x27;maven 3.6&#x27;</span>) &#123;</span><br><span class="line">                        sh <span class="string">&quot;mvn -U -am clean package -DskipTests&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stage(<span class="string">&#x27;构建镜像&#x27;</span>) &#123;</span><br><span class="line">                steps &#123;</span><br><span class="line">					sh <span class="string">&quot;cp ./target/*.jar ./&quot;</span></span><br><span class="line">                    sh <span class="string">&quot;docker build -t $&#123;APP_NAME&#125;/$&#123;BRANCH_NAME&#125;:1.0-SNAPSHOT .&quot;</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">			stage(<span class="string">&#x27;运行镜像&#x27;</span>) &#123;</span><br><span class="line">                steps &#123;</span><br><span class="line">					sh <span class="string">&quot;if docker ps -a | grep $&#123;APP_NAME&#125;-$&#123;BRANCH_NAME&#125;;\n then docker rm -f $&#123;APP_NAME&#125;-$&#123;BRANCH_NAME&#125;\n echo Remove Docker Container: $&#123;APP_NAME&#125;-$&#123;BRANCH_NAME&#125;\n fi&quot;</span></span><br><span class="line">					sh <span class="string">&quot;docker run -d -p $&#123;APP_PORT&#125;:$&#123;APP_PORT&#125; --name $&#123;APP_NAME&#125;-$&#123;BRANCH_NAME&#125; $&#123;APP_NAME&#125;/$&#123;BRANCH_NAME&#125;:1.0-SNAPSHOT&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置Jenkins公共Jenkinsfile库的地址"><a href="#配置Jenkins公共Jenkinsfile库的地址" class="headerlink" title="配置Jenkins公共Jenkinsfile库的地址"></a>配置Jenkins公共Jenkinsfile库的地址</h4><p>进入Jenkins的系统管理的系统配置，找到<code>Global Pipeline Libraries</code>，配置远程仓库地址：<br><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-0.png" alt="在Jenkins上创建多分支流水线-0"></p>
<h4 id="准备程序Jenkinsfile配置文件"><a href="#准备程序Jenkinsfile配置文件" class="headerlink" title="准备程序Jenkinsfile配置文件"></a>准备程序Jenkinsfile配置文件</h4><p>程序根目录新建Jenkinsfile文件，填写配置：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">#!groovy</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在多分支构建下，严格规定Jenkinsfile只存在可以发版的分支上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用在jenkins已经全局定义好的library</span></span><br><span class="line">library <span class="string">&#x27;aptst-pipeline-library&#x27;</span></span><br><span class="line"><span class="keyword">def</span> map = [:]</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序名称</span></span><br><span class="line">map.put(<span class="string">&#x27;APP_NAME&#x27;</span>,<span class="string">&#x27;aptst-config-server&#x27;</span>)</span><br><span class="line"><span class="comment">//程序端口</span></span><br><span class="line">map.put(<span class="string">&#x27;APP_PORT&#x27;</span>,<span class="string">&#x27;3344&#x27;</span>)</span><br><span class="line"><span class="comment">// 远程管理节点地址（用于执行发版）</span></span><br><span class="line">map.put(<span class="string">&#x27;REMOTE_HOST&#x27;</span>,<span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>)</span><br><span class="line"><span class="comment">// 项目github代码地址</span></span><br><span class="line">map.put(<span class="string">&#x27;REPO_URL&#x27;</span>,<span class="string">&#x27;XXX&#x27;</span>)</span><br><span class="line"><span class="comment">// 分支名称</span></span><br><span class="line">map.put(<span class="string">&#x27;BRANCH_NAME&#x27;</span>,<span class="string">&#x27;master&#x27;</span>)</span><br><span class="line"><span class="comment">// 服务栈名称，公共配置没配置可以不需要</span></span><br><span class="line">map.put(<span class="string">&#x27;STACK_NAME&#x27;</span>,<span class="string">&#x27;XXX&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用library中vars目录下的build.groovy脚本</span></span><br><span class="line">build(map)</span><br></pre></td></tr></table></figure>

<h3 id="Blue-Ocean"><a href="#Blue-Ocean" class="headerlink" title="Blue Ocean"></a>Blue Ocean</h3><p>首先进入Jenkins的Blue Ocean页面，在Jenkins页面左边找到按钮或输入网址<code>http://&lt;jenkins address&gt;/blue</code></p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-1.png" alt="在Jenkins上创建多分支流水线-1"></p>
<h3 id="创建Pipeline"><a href="#创建Pipeline" class="headerlink" title="创建Pipeline"></a>创建Pipeline</h3><p>点击<code>创建流水线</code>：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-2.png" alt="在Jenkins上创建多分支流水线-2"></p>
<p>选择代码仓库，根据你远程仓库选择对应的：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-3.png" alt="在Jenkins上创建多分支流水线-3"></p>
<p>添加GitHub服务器：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-4.png" alt="在Jenkins上创建多分支流水线-4"></p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-5.png" alt="在Jenkins上创建多分支流水线-5"></p>
<p>选择仓库然后点击创建流水线：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-6.png" alt="在Jenkins上创建多分支流水线-6"></p>
<p>完整步骤图：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-7.png" alt="在Jenkins上创建多分支流水线-7"></p>
<h3 id="配置webhook"><a href="#配置webhook" class="headerlink" title="配置webhook"></a>配置webhook</h3><p>首先让我们看看 <a href="https://developer.github.com/webhooks/">Github官方</a> 关于Github webhooks的解释： </p>
<blockquote>
<p>Webhooks allow you to build or set up integrations which subscribe to certain events on GitHub.com.</p>
</blockquote>
<p>中文意思就是： webhook允许您构建或设置订阅GitHub.com上某些事件的集成。 通过webhook，我们就可以实现自动化部署。</p>
<p>进入项目GitHub仓库地址，进入**<code>settings</code><strong>，点击</strong><code> hook</code><strong>，再点击</strong><code>Add webhook</code>**：</p>
<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-8.png" alt="在Jenkins上创建多分支流水线-8"></p>
<p>填写Jenkins接收事件地址**<code>Payload URL</code>**：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://&lt;Jenkins address&gt;/github-webhook/</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%9C%A8Jenkins%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF-9.png" alt="在Jenkins上创建多分支流水线-9"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
        <category>Pipeline</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Pipeline</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Hexo framework</title>
    <url>/2019/11/29/%E5%AE%89%E8%A3%85Hexo%20framework/</url>
    <content><![CDATA[<h1 id="安装Hexo-framework"><a href="#安装Hexo-framework" class="headerlink" title="安装Hexo framework"></a>安装Hexo framework</h1><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><ul>
<li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 8.6，建议使用 Node.js 10.0 及以上版本)</li>
<li><a href="http://git-scm.com/">Git</a></li>
</ul>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing index.html from permalinks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Metadata elements</span></span><br><span class="line"><span class="comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span><br><span class="line"><span class="attr">meta_generator:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="comment">## Use post&#x27;s date for updated date unless set in front-matter</span></span><br><span class="line"><span class="attr">use_date_for_updated:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include / Exclude file(s)</span></span><br><span class="line"><span class="comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>title</code></td>
<td align="left">网站标题</td>
</tr>
<tr>
<td align="left"><code>subtitle</code></td>
<td align="left">网站副标题</td>
</tr>
<tr>
<td align="left"><code>description</code></td>
<td align="left">网站描述</td>
</tr>
<tr>
<td align="left"><code>keywords</code></td>
<td align="left">网站的关键词。使用半角逗号 <code>,</code> 分隔多个关键词。</td>
</tr>
<tr>
<td align="left"><code>author</code></td>
<td align="left">您的名字</td>
</tr>
<tr>
<td align="left"><code>language</code></td>
<td align="left">网站使用的语言</td>
</tr>
<tr>
<td align="left"><code>timezone</code></td>
<td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td>
</tr>
</tbody></table>
<p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo-site&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hexo&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hexo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.8.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-archive&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.1.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.1.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.2.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-ejs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.3.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-stylus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.3.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-marked&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.3.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.3.3&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>
<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold&#x2F;post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p>
<h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ol>
<li><p>Install <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>Add the following configurations to <strong>_config.yml</strong>, (remove existing lines if any)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&lt;username&gt;/&lt;project&gt;</span></span><br><span class="line">  <span class="comment"># example, https://github.com/hexojs/hexojs.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gh-pages</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Run <code>hexo clean &amp;&amp; hexo deploy</code>.</p>
</li>
<li><p>Check the webpage at <em>username</em>.github.io.</p>
</li>
</ol>
<h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><h3 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h3><p>安装NexT主题</p>
<h3 id="开启文章字数统计"><a href="#开启文章字数统计" class="headerlink" title="开启文章字数统计"></a>开启文章字数统计</h3><p>安装 hexo-symbols-count-time：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time</span><br></pre></td></tr></table></figure>

<p>配置next _config.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>

<h3 id="配置背景特效"><a href="#配置背景特效" class="headerlink" title="配置背景特效"></a>配置背景特效</h3><p>安装canvas-nest.js：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save canvas-nest.js</span><br></pre></td></tr></table></figure>

<p>配置next _config.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="attr">canvas_nest:</span> <span class="string">//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js</span></span><br></pre></td></tr></table></figure>

<h3 id="配置背景图片："><a href="#配置背景图片：" class="headerlink" title="配置背景图片："></a>配置背景图片：</h3><p>添加文件到<code>next/source/css/_custom/custom.styl</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(/images/uploads/background.jpg) no-repeat;</span><br><span class="line">  <span class="comment">/* 背景图垂直、水平均居中 */</span></span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="comment">/* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 */</span></span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">  <span class="comment">/* 让背景图基于容器大小伸缩 */</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="comment">/* 设置背景颜色，背景图加载过程中会显示背景色 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">	<span class="attribute">background</span>:<span class="built_in">url</span>(/images/uploads/sidebar.jpg);</span><br><span class="line">	<span class="attribute">background-size</span>: cover;</span><br><span class="line">	<span class="attribute">background-position</span>:center;</span><br><span class="line">	<span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">	<span class="selector-tag">p</span>,<span class="selector-tag">span</span>,<span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">            <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">60px</span> <span class="number">30px</span> <span class="number">60px</span>;</span><br><span class="line">            <span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>) none repeat scroll <span class="meta">!important</span>;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="selector-id">#lv-container</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">60px</span> <span class="number">30px</span> <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>) none repeat scroll <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>激活用户自定义配置，打开<code>next/source/css/main.styl</code>，添加配置：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Custom Layer</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;_custom/custom&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
        <category>NexT</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>微信推送消息demo</title>
    <url>/2022/08/08/%E5%BE%AE%E4%BF%A1%E6%8E%A8%E9%80%81%E6%B6%88%E6%81%AFdemo/</url>
    <content><![CDATA[<p>看到一个特别有意思的项目，每天早上微信工作号推送天气什么的，可以自定义很多消息，自己动手实现了下，写了个demo，实现的效果如下，比较简陋，后续有空再完善下吧</p>
<img src="/../images/微信推送消息demo/show.png" alt="效果展示" style="zoom: 25%;" />

<span id="more"></span>

<h1 id="申请微信公众号测试账号"><a href="#申请微信公众号测试账号" class="headerlink" title="申请微信公众号测试账号"></a>申请微信公众号测试账号</h1><p>访问 <code>https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</code> ，扫码登录成功后，就会给我们生成微信公号的appid和appsecret。</p>
<p><img src="/../images/%E5%BE%AE%E4%BF%A1%E6%8E%A8%E9%80%81%E6%B6%88%E6%81%AFdemo/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.png" alt="微信公众号"></p>
<h1 id="新建SpringBoot项目"><a href="#新建SpringBoot项目" class="headerlink" title="新建SpringBoot项目"></a>新建SpringBoot项目</h1><h2 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h2><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.monochrome<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wechat-publisher<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>wechat-publisher<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>wechat-publisher<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.binarywang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wx-java-mp-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.76<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>spring的配置文件application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Wechat-Publisher</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="comment">#公众号配置</span></span><br><span class="line"><span class="attr">wx:</span></span><br><span class="line">  <span class="attr">mp:</span></span><br><span class="line">    <span class="attr">app-id:</span> <span class="string">your</span> <span class="string">app</span> <span class="string">id</span></span><br><span class="line">    <span class="attr">secret:</span> <span class="string">your</span> <span class="string">app</span> <span class="string">secret</span></span><br><span class="line"><span class="comment">#自定义的一些配置，比如微信公众号模板id，天气信息id和key</span></span><br><span class="line"><span class="attr">com:</span></span><br><span class="line">  <span class="attr">monochrome:</span></span><br><span class="line">    <span class="attr">wx:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">good-morning:</span> <span class="string">your</span> <span class="string">WeChat</span> <span class="string">template</span> <span class="string">id</span></span><br><span class="line">    <span class="attr">qweather:</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">qweather</span> <span class="string">id</span></span><br><span class="line">      <span class="attr">key:</span> <span class="string">qweather</span> <span class="string">key</span></span><br><span class="line">      <span class="attr">location:</span> <span class="number">101270106</span> <span class="comment">#双流和风天气location</span></span><br></pre></td></tr></table></figure>

<h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><p>加入@EnableScheduling注解以开启定时任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatPublisherApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(WechatPublisherApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="微信推送"><a href="#微信推送" class="headerlink" title="微信推送"></a>微信推送</h1><h2 id="获取配置的微信模板id"><a href="#获取配置的微信模板id" class="headerlink" title="获取配置的微信模板id"></a>获取配置的微信模板id</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;com.monochrome.wx.template&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxTemplateProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String goodMorning;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGoodMorning</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> goodMorning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGoodMorning</span><span class="params">(String goodMorning)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.goodMorning = goodMorning;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>goodMorning</code>对应上我们<code>application.xml</code>上面的<code>com.monochrome.wx.template.good-morning</code>，目前只配置了这一种模板，对应微信公众号平台上面的模板：</p>
<p><img src="/../images/%E5%BE%AE%E4%BF%A1%E6%8E%A8%E9%80%81%E6%B6%88%E6%81%AFdemo/%E5%BE%AE%E4%BF%A1%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF-GoodMorning.png" alt="微信模板消息-GoodMorning"></p>
<h2 id="模板文本"><a href="#模板文本" class="headerlink" title="模板文本"></a>模板文本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;date.DATA&#125;&#125;</span><br><span class="line">天气：&#123;&#123;textDay.DATA&#125;&#125;</span><br><span class="line">最低温度：&#123;&#123;tempMin.DATA&#125;&#125; 度</span><br><span class="line">最高温度：&#123;&#123;tempMax.DATA&#125;&#125; 度</span><br><span class="line"></span><br><span class="line">&#123;&#123;whisper.DATA&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息推送"><a href="#消息推送" class="headerlink" title="消息推送"></a>消息推送</h2><p>Publisher接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Publisher</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(String openId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GoodMorningPublisher实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodMorningPublisher</span> <span class="keyword">implements</span> <span class="title class_">Publisher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WxMpService wxMpService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Whispers whispers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> QWeatherHelper qWeatherHelper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WxTemplateProperties wxTemplateProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GoodMorningPublisher</span><span class="params">(WxMpService wxMpService, Whispers whispers, WxTemplateProperties wxTemplateProperties, QWeatherHelper qWeatherHelper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wxMpService = wxMpService;</span><br><span class="line">        <span class="built_in">this</span>.whispers = whispers;</span><br><span class="line">        <span class="built_in">this</span>.wxTemplateProperties = wxTemplateProperties;</span><br><span class="line">        <span class="built_in">this</span>.qWeatherHelper = qWeatherHelper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(String openId)</span> &#123;</span><br><span class="line">        <span class="type">WxMpTemplateMessage</span> <span class="variable">templateMessage</span> <span class="operator">=</span> WxMpTemplateMessage.builder()</span><br><span class="line">                .toUser(openId)</span><br><span class="line">                .templateId(wxTemplateProperties.getGoodMorning())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//填写变量信息，比如天气之类的</span></span><br><span class="line">        <span class="type">Daily</span> <span class="variable">weather</span> <span class="operator">=</span> qWeatherHelper.getWeather();</span><br><span class="line">        templateMessage.addData(<span class="keyword">new</span> <span class="title class_">WxMpTemplateData</span>(<span class="string">&quot;date&quot;</span>, weather.getFxDate(), <span class="string">&quot;#00BFFF&quot;</span>));</span><br><span class="line">        templateMessage.addData(<span class="keyword">new</span> <span class="title class_">WxMpTemplateData</span>(<span class="string">&quot;textDay&quot;</span>, weather.getTextDay(), <span class="string">&quot;#00FFFF&quot;</span>));</span><br><span class="line">        templateMessage.addData(<span class="keyword">new</span> <span class="title class_">WxMpTemplateData</span>(<span class="string">&quot;tempMin&quot;</span>, weather.getTempMin(), <span class="string">&quot;#173177&quot;</span>));</span><br><span class="line">        templateMessage.addData(<span class="keyword">new</span> <span class="title class_">WxMpTemplateData</span>(<span class="string">&quot;tempMax&quot;</span>, weather.getTempMax(), <span class="string">&quot;#FF6347&quot;</span>));</span><br><span class="line">        templateMessage.addData(<span class="keyword">new</span> <span class="title class_">WxMpTemplateData</span>(<span class="string">&quot;whisper&quot;</span>, whispers.getRandomWhisper(), <span class="string">&quot;#C71585&quot;</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wxMpService.getTemplateMsgService().sendTemplateMsg(templateMessage);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (WxErrorException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对接和风天气API"><a href="#对接和风天气API" class="headerlink" title="对接和风天气API"></a>对接和风天气API</h1><p>首先先去申请和风天气账号拿到public id和primary key吧</p>
<p>具体实现看源码吧，这里不再贴代码了，照搬就行</p>
<h1 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublisherJob</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GoodMorningPublisher goodMorningPublisher;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WxMpService wxMpService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PublisherJob</span><span class="params">(GoodMorningPublisher goodMorningPublisher, WxMpService wxMpService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.goodMorningPublisher = goodMorningPublisher;</span><br><span class="line">        <span class="built_in">this</span>.wxMpService = wxMpService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 30 7 * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goodMorning</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">WxMpUserList</span> <span class="variable">wxMpUserList</span> <span class="operator">=</span> wxMpService.getUserService().userList(<span class="literal">null</span>);</span><br><span class="line">            List&lt;String&gt; openids = wxMpUserList.getOpenids();</span><br><span class="line">            <span class="keyword">for</span> (String openid : openids) &#123;</span><br><span class="line">                goodMorningPublisher.publish(openid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (WxErrorException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>源码放github上了，有兴趣的小伙伴可以下载下来直接改改配置文件就能使用了哦</p>
<p><a href="https://github.com/zhaoyangmushiyi/wechat-publisher">https://github.com/zhaoyangmushiyi/wechat-publisher</a></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>欢迎小伙伴关注我的微信公众号以获取推送哦</p>
<p><img src="/../images/%E5%BE%AE%E4%BF%A1%E6%8E%A8%E9%80%81%E6%B6%88%E6%81%AFdemo/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.png" alt="微信公众号二维码"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro-整合SpringBoot</title>
    <url>/2022/10/07/Shiro-%E6%95%B4%E5%90%88SpringBoot/</url>
    <content><![CDATA[<h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><h2 id="pom-xml依赖"><a href="#pom-xml依赖" class="headerlink" title="pom.xml依赖"></a>pom.xml依赖</h2><p>用户信息存储在MySQL中，dao层使用Spring Data JPA，因此需要引入相关的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.monochrome<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>shiro-springboot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>shiro-springboot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-web-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="application-yml配置文件"><a href="#application-yml配置文件" class="headerlink" title="application.yml配置文件"></a>application.yml配置文件</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/shirodb?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">username</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br><span class="line"><span class="attr">shiro:</span></span><br><span class="line">  <span class="attr">loginUrl:</span> <span class="string">/user/login</span></span><br></pre></td></tr></table></figure>

<h2 id="数据库表信息"><a href="#数据库表信息" class="headerlink" title="数据库表信息"></a>数据库表信息</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `shirodb` <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</span><br><span class="line">USE `shirodb`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`</span><br><span class="line">(</span><br><span class="line">    `id`   <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">    `pwd`  <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">    `rid`  <span class="type">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色编号&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8 COMMENT <span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shirodb.user (name, pwd, rid) <span class="keyword">VALUES</span> (<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;7174f64b13022acd3c56e2781e098a5f&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shirodb.user (name, pwd, rid) <span class="keyword">VALUES</span> (<span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;7174f64b13022acd3c56e2781e098a5f&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> shiro</span><br><span class="line">    identified <span class="keyword">by</span> <span class="string">&#x27;shiro&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> shirodb.<span class="operator">*</span> <span class="keyword">to</span> shiro;</span><br></pre></td></tr></table></figure>

<h1 id="登录认证实现"><a href="#登录认证实现" class="headerlink" title="登录认证实现"></a>登录认证实现</h1><h2 id="后端接口服务实现"><a href="#后端接口服务实现" class="headerlink" title="后端接口服务实现"></a>后端接口服务实现</h2><h3 id="创建实体"><a href="#创建实体" class="headerlink" title="创建实体"></a>创建实体</h3><p>项目使用了Lombok，因此不需要写getter和settier，@Entity注解标志数据库表名，@Id标志主键，@GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)标志主键自增</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.shiro.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Hibernate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Entity(name = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    <span class="keyword">private</span> Integer rid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || Hibernate.getClass(<span class="built_in">this</span>) != Hibernate.getClass(o)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">        <span class="keyword">return</span> id != <span class="literal">null</span> &amp;&amp; Objects.equals(id, user.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建repository"><a href="#创建repository" class="headerlink" title="创建repository"></a>创建repository</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Integer&gt; &#123;</span><br><span class="line">    User <span class="title function_">findUserByName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-service"><a href="#创建-service" class="headerlink" title="创建 service"></a>创建 service</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserByName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findUserByName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义realm"><a href="#自定义realm" class="headerlink" title="自定义realm"></a>自定义realm</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.shiro.realm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.monochrome.shiro.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.shiro.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.ByteSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomRealm</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义授权方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义登录认证方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="comment">// 1 获取用户身份信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> token.getPrincipal().toString();</span><br><span class="line">        <span class="comment">// 2 调用业务层获取用户信息(数据库中)</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUserByName(name);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">SimpleAuthenticationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(</span><br><span class="line">                    token.getPrincipal(),</span><br><span class="line">                    user.getPwd(),</span><br><span class="line">                    ByteSource.Util.bytes(<span class="string">&quot;salt&quot;</span>),</span><br><span class="line">                    name</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Shiro配置类"><a href="#Shiro配置类" class="headerlink" title="Shiro配置类"></a>Shiro配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.shiro.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.monochrome.shiro.realm.CustomRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.credential.HashedCredentialsMatcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.web.config.DefaultShiroFilterChainDefinition;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomRealm realm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShiroConfig</span><span class="params">(CustomRealm realm)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.realm = realm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置 SecurityManager</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">defaultWebSecurityManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1 创建 defaultWebSecurityManager 对象</span></span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">defaultWebSecurityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        <span class="comment">//2 创建加密对象，并设置相关属性</span></span><br><span class="line">        <span class="type">HashedCredentialsMatcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedCredentialsMatcher</span>();</span><br><span class="line">        <span class="comment">//2.1 采用 md5 加密</span></span><br><span class="line">        matcher.setHashAlgorithmName(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">        <span class="comment">//2.2 迭代加密次数</span></span><br><span class="line">        matcher.setHashIterations(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//3 将加密对象存储到 myRealm 中</span></span><br><span class="line">        realm.setCredentialsMatcher(matcher);</span><br><span class="line">        <span class="comment">//4 将 myRealm 存入 defaultWebSecurityManager 对象</span></span><br><span class="line">        defaultWebSecurityManager.setRealm(realm);</span><br><span class="line">        <span class="comment">//5 返回</span></span><br><span class="line">        <span class="keyword">return</span> defaultWebSecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置 Shiro 内置过滤器拦截范围</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultShiroFilterChainDefinition <span class="title function_">shiroFilterChainDefinition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultShiroFilterChainDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShiroFilterChainDefinition</span>();</span><br><span class="line">        <span class="comment">//设置不认证可以访问的资源</span></span><br><span class="line">        definition.addPathDefinition(<span class="string">&quot;/user/login&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        definition.addPathDefinition(<span class="string">&quot;/user/userLogin&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        <span class="comment">//设置需要进行登录认证的拦截范围</span></span><br><span class="line">        definition.addPathDefinition(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> definition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现controller"><a href="#实现controller" class="headerlink" title="实现controller"></a>实现controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.shiro.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;login&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String name, String pwd)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 获取 Subject 对象</span></span><br><span class="line">            <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">            <span class="comment">//2 封装请求数据到 token 对象中</span></span><br><span class="line">            <span class="type">AuthenticationToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(name, pwd);</span><br><span class="line">            <span class="comment">//3 调用 login 方法进行登录认证 try &#123;</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;登录失败&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动项目，访问<a href="http://localhost:8080/user/login?name=zhangsan&amp;pwd=z3">http://localhost:8080/user/login?name=zhangsan&amp;pwd=z3</a></p>
<h2 id="实现前端页面"><a href="#实现前端页面" class="headerlink" title="实现前端页面"></a>实现前端页面</h2><p>前端采用Thymeleaf实现</p>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="添加-login-页面"><a href="#添加-login-页面" class="headerlink" title="添加 login 页面"></a>添加 login 页面</h4><p>注意一下，thymeleaf文件需要放在 resources&#x2F;templates 文件下面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Shiro 登录认证<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Shiro 登录认证<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user/userLogin&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="添加-main-页面"><a href="#添加-main-页面" class="headerlink" title="添加 main 页面"></a>添加 main 页面</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Shiro 登录认证后主页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Shiro 登录认证后主页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    登录用户为:<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.user&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="添加-controller-方法，改造认证方法"><a href="#添加-controller-方法，改造认证方法" class="headerlink" title="添加 controller 方法，改造认证方法"></a>添加 controller 方法，改造认证方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.shiro.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;userLogin&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">userLogin</span><span class="params">(String name, String pwd, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1 获取 Subject 对象</span></span><br><span class="line">            <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">            <span class="comment">//2 封装请求数据到 token 对象中</span></span><br><span class="line">            <span class="type">AuthenticationToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(name, pwd);</span><br><span class="line">            <span class="comment">//3 调用 login 方法进行登录认证</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">            session.setAttribute(<span class="string">&quot;user&quot;</span>,token.getPrincipal().toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;登录失败&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳转登录页面</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shiro相关配置"><a href="#shiro相关配置" class="headerlink" title="shiro相关配置"></a>shiro相关配置</h4><p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">shiro:</span></span><br><span class="line">  <span class="attr">loginUrl:</span> <span class="string">/user/login</span></span><br></pre></td></tr></table></figure>

<p>ShiroConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置不认证可以访问的资源</span></span><br><span class="line">definition.addPathDefinition(<span class="string">&quot;/user/login&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">definition.addPathDefinition(<span class="string">&quot;/user/userLogin&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line"><span class="comment">//设置需要进行登录认证的拦截范围</span></span><br><span class="line">definition.addPathDefinition(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>启动项目，访问登录页面：<a href="http://localhost:8080/user/login%EF%BC%8C%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E5%90%8E%E8%B7%B3%E8%BD%AC%E5%88%B0%E4%B8%BB%E9%A1%B5%E9%9D%A2">http://localhost:8080/user/login，输入用户名和密码后跳转到主页面</a></p>
<h2 id="多个-realm-的认证策略设置"><a href="#多个-realm-的认证策略设置" class="headerlink" title="多个 realm 的认证策略设置"></a>多个 realm 的认证策略设置</h2><p>当应用程序配置多个 Realm 时，例如：用户名密码校验、手机号验证码校验等等。 Shiro 的 ModularRealmAuthenticator 会使用内部的 AuthenticationStrategy 组件判断认 证是成功还是失败。</p>
<p>AuthenticationStrategy 是一个无状态的组件，它在身份验证尝试中被询问 4 次(这 4 次交互所需的任何必要的状态将被作为方法参数):</p>
<ol>
<li>在所有 Realm 被调用之前</li>
<li>在调用 Realm 的 getAuthenticationInfo 方法之前</li>
<li>在调用 Realm 的 getAuthenticationInfo 方法之后</li>
<li>在所有 Realm 被调用之后</li>
</ol>
<p>认证策略的另外一项工作就是聚合所有 Realm 的结果信息封装至一个 AuthenticationInfo 实例中，并将此信息返回，以此作为 Subject 的身份信息。</p>
<p>Shiro 中定义了 3 种认证策略的实现:</p>
<table>
<thead>
<tr>
<th align="left"><strong>AuthenticationStrategy class</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">AtLeastOneSuccessfulStrategy</td>
<td>只要有一个(或更多)的 Realm 验证成功，那么认证将视为成功</td>
</tr>
<tr>
<td align="left">FirstSuccessfulStrategy</td>
<td>第一个 Realm 验证成功，整体认证将视为成功，且后续 Realm 将被忽略</td>
</tr>
<tr>
<td align="left">AllSuccessfulStrategy</td>
<td>所有 Realm 成功，认证才视为成功</td>
</tr>
</tbody></table>
<p>ModularRealmAuthenticator 内置的认证策略默认实现是 AtLeastOneSuccessfulStrategy 方式。可以通过配置修改策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">defaultWebSecurityManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1 创建 defaultWebSecurityManager 对象</span></span><br><span class="line">    <span class="type">DefaultWebSecurityManager</span> <span class="variable">defaultWebSecurityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">    <span class="comment">//2 创建认证对象，并设置认证策略</span></span><br><span class="line">    <span class="type">ModularRealmAuthenticator</span> <span class="variable">modularRealmAuthenticator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModularRealmAuthenticator</span>();</span><br><span class="line">    <span class="comment">//有多种认证策略，AtLeastOneSuccessfulStrategy，FirstSuccessfulStrategy，AllSuccessfulStrategy</span></span><br><span class="line">    modularRealmAuthenticator.setAuthenticationStrategy(<span class="keyword">new</span> <span class="title class_">AtLeastOneSuccessfulStrategy</span>());</span><br><span class="line">    defaultWebSecurityManager.setAuthenticator(modularRealmAuthenticator);</span><br><span class="line">    <span class="comment">//3 封装Realm集合</span></span><br><span class="line">    List&lt;Realm&gt; realms = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//3.1 创建加密对象，并设置相关属性</span></span><br><span class="line">    <span class="type">HashedCredentialsMatcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedCredentialsMatcher</span>();</span><br><span class="line">    <span class="comment">//3.1.1 采用 md5 加密</span></span><br><span class="line">    matcher.setHashAlgorithmName(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">    <span class="comment">//3.1.2 迭代加密次数</span></span><br><span class="line">    matcher.setHashIterations(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//3.1.2 将加密对象存储到 myRealm 中</span></span><br><span class="line">    realm.setCredentialsMatcher(matcher);</span><br><span class="line">    realms.add(realm);</span><br><span class="line">    <span class="comment">//4 将 realms 集合存入 defaultWebSecurityManager 对象</span></span><br><span class="line">    defaultWebSecurityManager.setRealms(realms);</span><br><span class="line">    <span class="comment">//5 返回</span></span><br><span class="line">    <span class="keyword">return</span> defaultWebSecurityManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="remember-me-功能"><a href="#remember-me-功能" class="headerlink" title="remember me 功能"></a>remember me 功能</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol>
<li>首先在登录页面选中RememberMe然后登录成功;如果是浏览器登录，一般会 把 RememberMe 的 Cookie 写到客户端并保存下来;</li>
<li>关闭浏览器再重新打开;会发现浏览器还是记住你的;</li>
<li>访问一般的网页服务器端，仍然知道你是谁，且能正常访问;</li>
<li>但是，如果我们访问电商平台时，如果要查看我的订单或进行支付时，此时还 是需要再进行身份认证的，以确保当前用户还是你。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.shiro.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.monochrome.shiro.realm.CustomRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.credential.HashedCredentialsMatcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.pam.ModularRealmAuthenticator;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.RememberMeManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.Realm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.web.config.DefaultShiroFilterChainDefinition;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.mgt.CookieRememberMeManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.servlet.Cookie;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.servlet.SimpleCookie;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomRealm realm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShiroConfig</span><span class="params">(CustomRealm realm)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.realm = realm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置 SecurityManager，实现多个Realm</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">defaultWebSecurityManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1 创建 defaultWebSecurityManager 对象</span></span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">defaultWebSecurityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        <span class="comment">//2 创建认证对象，并设置认证策略</span></span><br><span class="line">        <span class="type">ModularRealmAuthenticator</span> <span class="variable">modularRealmAuthenticator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModularRealmAuthenticator</span>();</span><br><span class="line">        <span class="comment">//有多种认证策略，AtLeastOneSuccessfulStrategy，FirstSuccessfulStrategy，AllSuccessfulStrategy</span></span><br><span class="line">        modularRealmAuthenticator.setAuthenticationStrategy(<span class="keyword">new</span> <span class="title class_">AtLeastOneSuccessfulStrategy</span>());</span><br><span class="line">        defaultWebSecurityManager.setAuthenticator(modularRealmAuthenticator);</span><br><span class="line">        <span class="comment">//3 封装Realm集合</span></span><br><span class="line">        List&lt;Realm&gt; realms = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//3.1 创建加密对象，并设置相关属性</span></span><br><span class="line">        <span class="type">HashedCredentialsMatcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedCredentialsMatcher</span>();</span><br><span class="line">        <span class="comment">//3.1.1 采用 md5 加密</span></span><br><span class="line">        matcher.setHashAlgorithmName(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">        <span class="comment">//3.1.2 迭代加密次数</span></span><br><span class="line">        matcher.setHashIterations(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//3.1.2 将加密对象存储到 myRealm 中</span></span><br><span class="line">        realm.setCredentialsMatcher(matcher);</span><br><span class="line">        realms.add(realm);</span><br><span class="line">        <span class="comment">//4 将 realms 集合存入 defaultWebSecurityManager 对象</span></span><br><span class="line">        defaultWebSecurityManager.setRealms(realms);</span><br><span class="line">        <span class="comment">//5 设置 remember me</span></span><br><span class="line">        defaultWebSecurityManager.setRememberMeManager(createRememberMeManager());</span><br><span class="line">        <span class="comment">//6 返回</span></span><br><span class="line">        <span class="keyword">return</span> defaultWebSecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建rememberMeManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> rememberMeManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RememberMeManager <span class="title function_">createRememberMeManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CookieRememberMeManager</span> <span class="variable">cookieRememberMeManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CookieRememberMeManager</span>();</span><br><span class="line">        cookieRememberMeManager.setCookie(createRememberMeCookie());</span><br><span class="line">        cookieRememberMeManager.setCipherKey(<span class="string">&quot;1234567890987654&quot;</span>.getBytes());</span><br><span class="line">        <span class="keyword">return</span> cookieRememberMeManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Cookie</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> cookie</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Cookie <span class="title function_">createRememberMeCookie</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SimpleCookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCookie</span>(<span class="string">&quot;rememberMe&quot;</span>);</span><br><span class="line">        <span class="comment">//设置跨域</span></span><br><span class="line">        <span class="comment">//cookie.setDomain(domain);</span></span><br><span class="line">        cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        cookie.setHttpOnly(<span class="literal">true</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">30</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        <span class="keyword">return</span> cookie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置 Shiro 内置过滤器拦截范围</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultShiroFilterChainDefinition <span class="title function_">shiroFilterChainDefinition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultShiroFilterChainDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShiroFilterChainDefinition</span>();</span><br><span class="line">        <span class="comment">//设置不认证可以访问的资源</span></span><br><span class="line">        definition.addPathDefinition(<span class="string">&quot;/user/login&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        definition.addPathDefinition(<span class="string">&quot;/user/userLogin&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        <span class="comment">//设置需要进行登录认证的拦截范围</span></span><br><span class="line">        definition.addPathDefinition(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        <span class="comment">//添加存在用户的过滤器(rememberMe)</span></span><br><span class="line">        definition.addPathDefinition(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> definition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改-controller"><a href="#修改-controller" class="headerlink" title="修改 controller"></a>修改 controller</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;userLogin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">userLogin</span><span class="params">(String name, String pwd, <span class="meta">@RequestParam(defaultValue = &quot;false&quot;)</span> <span class="type">boolean</span> rememberMe, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1 获取 Subject 对象</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//2 封装请求数据到 token 对象中</span></span><br><span class="line">        <span class="type">AuthenticationToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(name, pwd, rememberMe);</span><br><span class="line">        <span class="comment">//3 调用 login 方法进行登录认证</span></span><br><span class="line">        subject.login(token);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>, token.getPrincipal().toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登录失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//登录认证验证 rememberMe </span></span><br><span class="line"><span class="meta">@GetMapping(&quot;userLoginRm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">userLogin</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;rememberMe&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="改造页面-login-html"><a href="#改造页面-login-html" class="headerlink" title="改造页面 login.html"></a>改造页面 login.html</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Shiro 登录认证<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Shiro 登录认证<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user/userLogin&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>记住我:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rememberMe&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><ol>
<li>通过地址访问 userLoginRm <a href="http://localhost:8080/user/userLoginRm">http://localhost:8080/user/userLoginRm</a></li>
<li>过滤器拦截跳回登录页面</li>
<li>输入用户名和密码并勾上RememberMe</li>
<li>重新访问 userLoginRm <a href="http://localhost:8080/user/userLoginRm%EF%BC%8C%E6%98%BE%E7%A4%BAuser%E4%B8%BArememberMe">http://localhost:8080/user/userLoginRm，显示user为rememberMe</a></li>
</ol>
<h2 id="用户登录认证后登出"><a href="#用户登录认证后登出" class="headerlink" title="用户登录认证后登出"></a>用户登录认证后登出</h2><p>用户登录后，配套的有登出操作。直接通过Shiro过滤器即可实现登出</p>
<h3 id="修改登录后的-main-html"><a href="#修改登录后的-main-html" class="headerlink" title="修改登录后的 main.html"></a>修改登录后的 main.html</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Shiro 登录认证后主页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    登录用户为:<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.user&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/logout&quot;</span>&gt;</span>登出<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改配置类，添加-logout-过滤器"><a href="#修改配置类，添加-logout-过滤器" class="headerlink" title="修改配置类，添加 logout 过滤器"></a>修改配置类，添加 logout 过滤器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置 Shiro 内置过滤器拦截范围</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DefaultShiroFilterChainDefinition <span class="title function_">shiroFilterChainDefinition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DefaultShiroFilterChainDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShiroFilterChainDefinition</span>();</span><br><span class="line">    <span class="comment">//设置不认证可以访问的资源</span></span><br><span class="line">    definition.addPathDefinition(<span class="string">&quot;/user/login&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">    definition.addPathDefinition(<span class="string">&quot;/user/userLogin&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">    <span class="comment">//配置登出过滤器</span></span><br><span class="line">    definition.addPathDefinition(<span class="string">&quot;/logout&quot;</span>, <span class="string">&quot;logout&quot;</span>);</span><br><span class="line">    <span class="comment">//设置需要进行登录认证的拦截范围</span></span><br><span class="line">    definition.addPathDefinition(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">    <span class="comment">//添加存在用户的过滤器(rememberMe)</span></span><br><span class="line">    definition.addPathDefinition(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="授权、角色认证"><a href="#授权、角色认证" class="headerlink" title="授权、角色认证"></a>授权、角色认证</h2><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>用户登录后，需要验证是否具有指定角色指定权限。Shiro也提供了方便的工具进行判断。</p>
<p>这个工具就是Realm的doGetAuthorizationInfo方法进行判断。触发权限判断的有两种方式</p>
<ol>
<li>在页面中通过shiro:****属性判断</li>
<li>在接口服务中通过注解@Requires****进行判断</li>
</ol>
<h3 id="后端接口服务注解"><a href="#后端接口服务注解" class="headerlink" title="后端接口服务注解"></a>后端接口服务注解</h3><p>通过给接口服务方法添加注解可以实现权限校验，可以加在控制器方法上，也可以加 在业务方法上，一般加在控制器方法上。</p>
<h4 id="RequiresAuthentication"><a href="#RequiresAuthentication" class="headerlink" title="@RequiresAuthentication"></a>@RequiresAuthentication</h4><p>验证用户是否登录，等同于方法subject.isAuthenticated()</p>
<h4 id="RequiresUser"><a href="#RequiresUser" class="headerlink" title="@RequiresUser"></a>@RequiresUser</h4><p>验证用户是否被记忆: 登录认证成功subject.isAuthenticated()为true 登录后被记忆subject.isRemembered()为true</p>
<h4 id="RequiresGuest"><a href="#RequiresGuest" class="headerlink" title="@RequiresGuest"></a>@RequiresGuest</h4><p>验证是否是一个guest的请求，是否是游客的请求</p>
<p>此时subject.getPrincipal()为null</p>
<h4 id="RequiresRoles"><a href="#RequiresRoles" class="headerlink" title="@RequiresRoles"></a>@RequiresRoles</h4><p>验证subject是否有相应角色，有角色访问方法，没有则会抛出异常 AuthorizationException。</p>
<p>例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiresRoles(“aRoleName”)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span>; </span><br></pre></td></tr></table></figure>

<p>只有subject有aRoleName角色才能访问方法someMethod()</p>
<h4 id="RequiresPermissions"><a href="#RequiresPermissions" class="headerlink" title="@RequiresPermissions"></a>@RequiresPermissions</h4><p>验证subject是否有相应权限，有权限访问方法，没有则会抛出异常 AuthorizationException。</p>
<p>例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiresPermissions</span> (“file:read”,”wite:aFile.txt”)</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span>; </span><br></pre></td></tr></table></figure>

<p>subject必须同时含有file:read和wite:aFile.txt权限才能访问方法someMethod()</p>
<h3 id="授权验证-没有角色无法访问"><a href="#授权验证-没有角色无法访问" class="headerlink" title="授权验证-没有角色无法访问"></a>授权验证-没有角色无法访问</h3><h4 id="添加-controller-方法，并添加验证角色注解"><a href="#添加-controller-方法，并添加验证角色注解" class="headerlink" title="添加 controller 方法，并添加验证角色注解"></a>添加 controller 方法，并添加验证角色注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//登录认证验证角色</span></span><br><span class="line"><span class="meta">@RequiresRoles(&quot;admin&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;userLoginRoles&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">userLoginRoles</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;登录认证验证角色&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;验证角色成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改-main-html"><a href="#修改-main-html" class="headerlink" title="修改 main.html"></a>修改 main.html</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Shiro 登录认证后主页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    登录用户为:<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.user&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/logout&quot;</span>&gt;</span>登出<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/myController/userLoginRoles&quot;</span>&gt;</span>测试授权<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="修改-CustomRealm-方法"><a href="#修改-CustomRealm-方法" class="headerlink" title="修改 CustomRealm 方法"></a>修改 CustomRealm 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义授权方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;进入自定义授权方法&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><p><a href="http://localhost:8080/user/userLoginRoles">http://localhost:8080/user/userLoginRoles</a></p>
<p><img src="/../images/Shiro/Shiro%E6%9C%AA%E6%8E%88%E6%9D%83role%E6%8A%A5%E9%94%99.png" alt="Shiro未授权role报错"></p>
<h3 id="授权验证-获取角色进行验证"><a href="#授权验证-获取角色进行验证" class="headerlink" title="授权验证-获取角色进行验证"></a>授权验证-获取角色进行验证</h3><h4 id="修改-CustomRealm-方法-1"><a href="#修改-CustomRealm-方法-1" class="headerlink" title="修改 CustomRealm 方法"></a>修改 CustomRealm 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;进入自定义授权方法&quot;</span>);</span><br><span class="line">    <span class="comment">//1 创建对象，存储当前登录的用户的权限和角色</span></span><br><span class="line">    <span class="type">SimpleAuthorizationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">    <span class="comment">//2 存储角色</span></span><br><span class="line">    info.addRole(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行测试-1"><a href="#运行测试-1" class="headerlink" title="运行测试"></a>运行测试</h4><p><a href="http://localhost:8080/user/userLoginRoles">http://localhost:8080/user/userLoginRoles</a></p>
<p><img src="/../images/Shiro/Shiro%E6%8E%88%E6%9D%83role%E6%88%90%E5%8A%9F.png" alt="Shiro授权role成功"></p>
<h4 id="新增角色信息以及角色用户映射表"><a href="#新增角色信息以及角色用户映射表" class="headerlink" title="新增角色信息以及角色用户映射表"></a>新增角色信息以及角色用户映射表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `role`</span><br><span class="line">(</span><br><span class="line">    `id`       <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    `name`     <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色名&#x27;</span>,</span><br><span class="line">    `<span class="keyword">desc</span>`     <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">    `role_name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色显示名&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8 COMMENT <span class="operator">=</span><span class="string">&#x27;角色表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shirodb.role (name, `<span class="keyword">desc</span>`, role_name) <span class="keyword">VALUES</span> (<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;所有权限&#x27;</span>, <span class="string">&#x27;管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shirodb.role (name, `<span class="keyword">desc</span>`, role_name) <span class="keyword">VALUES</span> (<span class="string">&#x27;user_manager&#x27;</span>, <span class="string">&#x27;用户管理员权限&#x27;</span>, <span class="string">&#x27;用户管理员&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `role_mapping`</span><br><span class="line">(</span><br><span class="line">    `id`  <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    `uid` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    `rid` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色id&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8 COMMENT <span class="operator">=</span><span class="string">&#x27;角色用户映射表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shirodb.role_user (uid, rid) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shirodb.role_user (uid, rid) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shirodb.role_user (uid, rid) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h4 id="新增角色以及角色用户映射实体类和dao层"><a href="#新增角色以及角色用户映射实体类和dao层" class="headerlink" title="新增角色以及角色用户映射实体类和dao层"></a>新增角色以及角色用户映射实体类和dao层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Entity(name = &quot;role&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Entity(name = &quot;role_mapping&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleMapping</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    Integer id;</span><br><span class="line">    Integer uid;</span><br><span class="line">    Integer rid;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RoleRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Role, Integer&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;Role&gt; <span class="title function_">findRolesByIdIn</span><span class="params">(List&lt;Integer&gt; ids)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RoleMappingRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;RoleMapping, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;RoleMapping&gt; <span class="title function_">findRoleMappingsByUid</span><span class="params">(Integer uid)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改CustomRealm"><a href="#修改CustomRealm" class="headerlink" title="修改CustomRealm"></a>修改CustomRealm</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义授权方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;进入自定义授权方法&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> principals.getPrimaryPrincipal().toString();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUserByName(username);</span><br><span class="line">    List&lt;RoleMapping&gt; roleMappings = roleMappingRepository.findRoleMappingsByUid(user.getId());</span><br><span class="line">    List&lt;Integer&gt; roleIds = roleMappings.stream()</span><br><span class="line">            .map(RoleMapping::getRid)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    List&lt;Role&gt; roles = roleRepository.findRolesByIdIn(roleIds);</span><br><span class="line">    List&lt;String&gt; roleNames = roles.stream()</span><br><span class="line">            .map(Role::getName)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    logger.info(<span class="string">&quot;current user&#x27;s roles:&#123;&#125;&quot;</span>, roleNames);</span><br><span class="line">    <span class="comment">//1 创建对象，存储当前登录的用户的权限和角色</span></span><br><span class="line">    <span class="type">SimpleAuthorizationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">    <span class="comment">//2 存储角色</span></span><br><span class="line">    info.addRoles(roleNames);</span><br><span class="line">    <span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h4><p>访问<a href="http://localhost:8080/user/userLoginRoles%EF%BC%8C%E7%9C%8B%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%97%A5%E5%BF%97">http://localhost:8080/user/userLoginRoles，看控制台日志</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022-10-29 16:11:11.725  INFO 27675 --- [nio-8080-exec-6] com.monochrome.shiro.realm.CustomRealm   : 进入自定义授权方法</span><br><span class="line">2022-10-29 16:11:11.874  INFO 27675 --- [nio-8080-exec-6] com.monochrome.shiro.realm.CustomRealm   : current user&#x27;s roles:[admin, user_manager]</span><br><span class="line">2022-10-29 16:11:11.875  INFO 27675 --- [nio-8080-exec-6] c.m.shiro.controller.UserController      : 登录认证验证角色</span><br></pre></td></tr></table></figure>

<h2 id="实现缓存"><a href="#实现缓存" class="headerlink" title="实现缓存"></a>实现缓存</h2><h3 id="缓存工具EhCache"><a href="#缓存工具EhCache" class="headerlink" title="缓存工具EhCache"></a>缓存工具EhCache</h3><p>EhCache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。可以和大部分Java项目无缝整合，例如:Hibernate中的缓存就是基于EhCache实现的。</p>
<p>EhCache支持内存和磁盘存储，默认存储在内存中，如内存不够时把缓存数据同步到磁盘中。EhCache支持基于Filter的Cache实现，也支持Gzip压缩算法。</p>
<p>EhCache直接在JVM虚拟机中缓存，速度快，效率高;</p>
<p>EhCache缺点是缓存共享麻烦，集群分布式应用使用不方便</p>
<h3 id="EhCache搭建使用"><a href="#EhCache搭建使用" class="headerlink" title="EhCache搭建使用"></a>EhCache搭建使用</h3><ol>
<li><p>创建模块</p>
<p>在shir-springboot的模块下新建子模块shiro、ehcache，将原来的父模块的shiro相关代码移到新建的shiro模块下</p>
<p><img src="/../images/Shiro/%E6%B7%BB%E5%8A%A0ehcache%E5%90%8E%E7%9A%84%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84.png" alt="添加ehcache后的模块结构"></p>
<p>父pom：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.monochrome<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>shiro-springboot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>shiro-springboot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>shiro<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>shiro模块pom：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-web-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ehcache模块添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.monochrome<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在resources目录下添加配置文件ehcache.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--磁盘的缓存位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;java.io.tmpdir/ehcache&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxEntriesLocalHeap</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxEntriesLocalDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">persistence</span> <span class="attr">strategy</span>=<span class="string">&quot;localTempSwap&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--helloworld 缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;HelloWorldCache&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        defaultCache:默认缓存策略，当 ehcache 找不到定义的缓存时，则使用这个缓存策略。只能定义一个。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        name:缓存名称。</span></span><br><span class="line"><span class="comment">        maxElementsInMemory:缓存最大数目</span></span><br><span class="line"><span class="comment">        maxElementsOnDisk:硬盘最大缓存个数。</span></span><br><span class="line"><span class="comment">        eternal:对象是否永久有效，一但设置了，timeout 将不起作用。</span></span><br><span class="line"><span class="comment">        overflowToDisk:是否保存到磁盘，当系统宕机时</span></span><br><span class="line"><span class="comment">        timeToIdleSeconds:设置对象在失效前的允许闲置时间(单位:秒)。仅当 eternal=false 对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</span></span><br><span class="line"><span class="comment">        timeToLiveSeconds:设置对象在失效前允许存活时间(单位:秒)。最大时间介于创建时间和失效时间之间。仅当 eternal=false 对象不是永久有效时使用，默认是0，也就是对象存活时间无穷大。</span></span><br><span class="line"><span class="comment">        diskPersistent:是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.</span></span><br><span class="line"><span class="comment">        diskSpoolBufferSizeMB:这个参数设置 DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个 Cache 都应该有自己的一个缓冲区。</span></span><br><span class="line"><span class="comment">        diskExpiryThreadIntervalSeconds:磁盘失效线程运行时间间隔，默认是 120 秒。</span></span><br><span class="line"><span class="comment">        memoryStoreEvictionPolicy:当达到 maxElementsInMemory 限制时， Ehcache 将会根据指定的策略去清理内存。默认策略是 LRU(最近最少使用)。你可以设置为 FIFO(先进先出)或是 LFU(较少使用)。</span></span><br><span class="line"><span class="comment">        clearOnFlush:内存数量最大时是否清除。</span></span><br><span class="line"><span class="comment">        memoryStoreEvictionPolicy:可选策略有:LRU(最近最少使用，默认策略)、FIFO(先进先出)、LFU(最少访问次数)。</span></span><br><span class="line"><span class="comment">        FIFO，first in first out，这个是大家最熟的，先进先出。</span></span><br><span class="line"><span class="comment">        LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是 讲一直以来最少被使用的。如上面所讲，缓存的元素有一个 hit 属性，hit 值最小的将 会被清出缓存。</span></span><br><span class="line"><span class="comment">        LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建测试类，操作缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EhCacheTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取编译目录下的资源的流对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getResourceAsStream(<span class="string">&quot;/ehcache.xml&quot;</span>); <span class="comment">//获取 EhCache 的缓存管理对象</span></span><br><span class="line">        <span class="type">CacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheManager</span>(input); <span class="comment">//获取缓存对象</span></span><br><span class="line">        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> cacheManager.getCache(<span class="string">&quot;HelloWorldCache&quot;</span>); <span class="comment">//创建缓存数据</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">element</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Element</span>(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zhang3&quot;</span>); <span class="comment">//存入缓存</span></span><br><span class="line">        cache.put(element);</span><br><span class="line">        <span class="comment">//从缓存中取出</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">element1</span> <span class="operator">=</span> cache.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(element1.getObjectValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Shiro</category>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Shiro</tag>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列学习</title>
    <url>/2021/07/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><h2 id="消息中间件的含义"><a href="#消息中间件的含义" class="headerlink" title="消息中间件的含义"></a>消息中间件的含义</h2><ol>
<li>利用可靠的消息传递机制进行系统和系统直接的通讯</li>
<li>通过提供消息传递和消息的派对机制，它可以在分布式系统环境下扩展进程间的通讯</li>
</ol>
<h2 id="消息中间件应用的场景"><a href="#消息中间件应用的场景" class="headerlink" title="消息中间件应用的场景"></a>消息中间件应用的场景</h2><ol>
<li>跨系统数据传递</li>
<li>高并发的流量削峰</li>
<li>数据的并发和异步处理</li>
<li>大数据分析与传递</li>
<li>分布式事务比如你有一个数据要进行迁移或者请求并发过多的时候，</li>
</ol>
<h2 id="常见的消息中间件"><a href="#常见的消息中间件" class="headerlink" title="常见的消息中间件"></a>常见的消息中间件</h2><p>ActiveMQ、RabbitMQ、Kafka、RocketMQ等</p>
<h2 id="消息中间件的本质及设计"><a href="#消息中间件的本质及设计" class="headerlink" title="消息中间件的本质及设计"></a>消息中间件的本质及设计</h2><p>它是一种接受数据、接受请求、存储数据、发送数据等功能的技术服务</p>
<p>MQ消息队列：负责数据的传接受，存储和传递，所以性能要高于普通服务和技术</p>
<h2 id="消息中间件的核心组成部分"><a href="#消息中间件的核心组成部分" class="headerlink" title="消息中间件的核心组成部分"></a>消息中间件的核心组成部分</h2><p>消息的协议<br>消息的持久化机制<br>消息的分发策略<br>消息的高可用，高可靠<br>消息的容错机制</p>
<span id="more"></span>

<h1 id="消息队列协议"><a href="#消息队列协议" class="headerlink" title="消息队列协议"></a>消息队列协议</h1><h2 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h2><p>AMQP：（全称：Advanced Message Queuing Protocol）是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现由 RabbitMQ等</p>
<p>特性：</p>
<ol>
<li>分布式事务支持</li>
<li>消息的持久化支持</li>
<li>高性能和高可靠的消息处理优势</li>
</ol>
<p>支持者：RabbitMQ，ActiveMQ</p>
<h2 id="MQTT协议"><a href="#MQTT协议" class="headerlink" title="MQTT协议"></a>MQTT协议</h2><p>MQTT协议（Message Queueing Telemetry Transport）消息队列是 IBM开放的及时通讯协议，物联网系统架构中的重要组成部分</p>
<p>特点：</p>
<ol>
<li>轻量</li>
<li>结构简单</li>
<li>传输快，不支持事务</li>
<li>没有持久化设计</li>
</ol>
<p>应用场景：</p>
<ol>
<li>适用于计算能力有限</li>
<li>低带宽</li>
<li>网络不稳定的场景</li>
</ol>
<p>支持者：RabbitMQ，ActiveMQ</p>
<h2 id="OpenMessage协议"><a href="#OpenMessage协议" class="headerlink" title="OpenMessage协议"></a>OpenMessage协议</h2><p>是近几年由阿里、雅虎和滴滴出行、Stremalio等公司共同参与创立的分布式信息中间件、流处理等领域的应用开发标准</p>
<p>特点：</p>
<ol>
<li>结构简单</li>
<li>解析速度快</li>
<li>支持事务和持久化设计</li>
</ol>
<p>支持者：RocketMQ </p>
<h2 id="Kafka协议"><a href="#Kafka协议" class="headerlink" title="Kafka协议"></a>Kafka协议</h2><p>Kafka协议是基于 TCP&#x2F;IP的二进制协议。消息内部是 通过长度来分割，由一些基本数据类型组成</p>
<p>特点：</p>
<ol>
<li>结构简单</li>
<li>解析速度快</li>
<li>无事务支持</li>
<li>有持久化设计</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>协议：实在 tcp&#x2F;ip协议基础之上构建的一种约定俗称的规范和机制、它的主要目的可以让客户端（应用程序 java，go）进行沟通和通讯。并且这种写一下规范必须具有持久性，高可用，高可靠的性能</p>
<h2 id="消息的分发策略"><a href="#消息的分发策略" class="headerlink" title="消息的分发策略"></a>消息的分发策略</h2><table>
<thead>
<tr>
<th></th>
<th align="center">ActiveMQ</th>
<th align="center">RabbitMQ</th>
<th align="center">Kafka</th>
<th align="center">RocketMQ</th>
</tr>
</thead>
<tbody><tr>
<td>发布订阅</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td>轮询分发</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">&#x2F;</td>
</tr>
<tr>
<td>公平分发</td>
<td align="center">&#x2F;</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">&#x2F;</td>
</tr>
<tr>
<td>重发</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">&#x2F;</td>
<td align="center">支持</td>
</tr>
<tr>
<td>消息拉取</td>
<td align="center">&#x2F;</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="Docker安装RabbitMQ"><a href="#Docker安装RabbitMQ" class="headerlink" title="Docker安装RabbitMQ"></a>Docker安装RabbitMQ</h2><h3 id="获取rabbit镜像"><a href="#获取rabbit镜像" class="headerlink" title="获取rabbit镜像"></a>获取rabbit镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure>

<h3 id="创建并运行容器"><a href="#创建并运行容器" class="headerlink" title="创建并运行容器"></a>创建并运行容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -id --name docker-rabbitmq-management -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br></pre></td></tr></table></figure>

<h3 id="添加用户并授权权限"><a href="#添加用户并授权权限" class="headerlink" title="添加用户并授权权限"></a>添加用户并授权权限</h3><h4 id="新增用户"><a href="#新增用户" class="headerlink" title="新增用户"></a>新增用户</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl add_user admin admin</span><br></pre></td></tr></table></figure>

<h4 id="设置用户分配操作权限"><a href="#设置用户分配操作权限" class="headerlink" title="设置用户分配操作权限"></a>设置用户分配操作权限</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure>

<p>用户级别：</p>
<ol>
<li><p>administrator：可以登录控制台、查看所有信息、可以对 rabbitmq进行管理</p>
<p>policymaker和monitoring可以做的任何事外加:<br>创建和删除virtual hosts<br>查看、创建和删除users<br>查看创建和删除permissions<br>关闭其他用户的connections</p>
</li>
<li><p>monitoring：监控者 登录控制台，查看所有信息</p>
<p>management可以做的任何事外加：</p>
<p>列出所有virtual hosts，包括他们不能登录的virtual hosts<br>查看其他用户的connections和channels<br>查看节点级别的数据如clustering和memory使用情况<br>查看真正的关于所有virtual hosts的全局的统计信息</p>
</li>
<li><p>policymaker：策略制定者 登录控制台，指定策略</p>
<p>management可以做的任何事外加：</p>
<p>查看、创建和删除自己的virtual hosts所属的policies和parameters</p>
</li>
<li><p>managment 普通管理员 登录控制台</p>
<p>用户可以通过AMQP做的任何事外加：<br>列出自己可以通过AMQP登入的virtual hosts<br>查看自己的virtual hosts中的queues, exchanges 和 bindings<br>查看和关闭自己的channels 和 connections<br>查看有关自己的virtual hosts的“全局”的统计信息，包含其他用户在这些virtual hosts中的活动。</p>
</li>
</ol>
<h4 id="为用户添加资源权限"><a href="#为用户添加资源权限" class="headerlink" title="为用户添加资源权限"></a>为用户添加资源权限</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p / admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure>

<h2 id="RabbitMQ入门案例-Simple-简单模式"><a href="#RabbitMQ入门案例-Simple-简单模式" class="headerlink" title="RabbitMQ入门案例 - Simple 简单模式"></a>RabbitMQ入门案例 - Simple 简单模式</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;monochrome&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//2.创建通道</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//3.通过创建交换机，声明队列，绑定关系，路由key，发送消息和接受消息</span></span><br><span class="line">            <span class="comment">/*参数1:是否持久化，非持久化消息会存盘吗？会存盘，但是会随着重启服务器而丢失</span></span><br><span class="line"><span class="comment">              参数2:是否独占队列</span></span><br><span class="line"><span class="comment">              参数3:是否自动删除，随着最后一个消费者消息完毕消息以后是否把队列自动删除</span></span><br><span class="line"><span class="comment">              参数4:携带附属属性</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;queue1&quot;</span>;</span><br><span class="line">            channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.发送消息给队列queue</span></span><br><span class="line">            <span class="comment">/*参数1:交换机</span></span><br><span class="line"><span class="comment">              参数2:队列、路由key</span></span><br><span class="line"><span class="comment">              参数3:消息的状态控制</span></span><br><span class="line"><span class="comment">              参数4:消息主题</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//面试题：可以存在没有交换机的队列吗？不可能，虽然没有指定交换机但是一定会存在一个默认的交换机</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5.关闭</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;monochrome&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">            <span class="comment">//2.创建通道</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;queue1&quot;</span>;</span><br><span class="line"></span><br><span class="line">            channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DeliverCallback</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> <span class="title class_">CancelCallback</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收消息失败！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;开始接收消息&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5.关闭</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>AMQP全称：Advanced Message Queuing Protocol（高级消息队列协议）。是应用层协议的一个开发标准，为面向消息的中间件设计</p>
<h3 id="AMQP生产者流转过程"><a href="#AMQP生产者流转过程" class="headerlink" title="AMQP生产者流转过程"></a>AMQP生产者流转过程</h3><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/AMQP%E7%94%9F%E4%BA%A7%E8%80%85%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B.png" alt="AMQP生产者流转过程"></p>
<h3 id="AMQP消费者流转过程"><a href="#AMQP消费者流转过程" class="headerlink" title="AMQP消费者流转过程"></a>AMQP消费者流转过程</h3><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/AMQP%E6%B6%88%E8%B4%B9%E8%80%85%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B.png" alt="AMQP消费者流转过程"></p>
<h2 id="RabbitMQ的核心组成部分"><a href="#RabbitMQ的核心组成部分" class="headerlink" title="RabbitMQ的核心组成部分"></a>RabbitMQ的核心组成部分</h2><h3 id="RabbitMQ的核心组成部分-1"><a href="#RabbitMQ的核心组成部分-1" class="headerlink" title="RabbitMQ的核心组成部分"></a>RabbitMQ的核心组成部分</h3><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/RabbitMQ%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png" alt="RabbitMQ的核心组成部分"></p>
<p>Server：又被称为Broker,接受客户端的连接，实现AMQP服务。就是我们自己安装的rabbitmq-server<br>Connection：连接，应用程序与Broker的网络连接（使用的是TCP&#x2F;IP连接）<br>Channel：网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，每个通道Channel代表一个会话任务。<br>Message：消息，服务于应用程序之间传递的数据，由Properties和body组成，Properties可以对消息进行修饰，比如消息的优先级，延迟等高级特征，Body则是消息体的内容。<br>Virtual Host：虚拟地址，用于逻辑层隔离，最上层的消息路由，一个虚拟机理由可以有若干的Exchange和Queueu，同一个虚拟机里面不能有相同名字的Exchange。<br>Exchange：交换机，接收消息，根据路由键发送消息到绑定的队列（不具备储存消息的能力）<br>Bindings：Exchange和Queue之间的虚拟连接，Binding中可以保护多个routing key.<br>Routing key：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。<br>Queue：队列，也是MessageQueue队列，保存消息转发给消费者</p>
<h3 id="RabbitMQ的操作流程"><a href="#RabbitMQ的操作流程" class="headerlink" title="RabbitMQ的操作流程"></a>RabbitMQ的操作流程</h3><p>第一：获取Conection<br>第二：获取Channel<br>第三：定义Exchange，Queue<br>第四：使用一个RoutingKey将Queue Binding到一个Exchange上<br>第五：通过指定一个Exchange和一个RoutingKey来将消息发送到对应的Queue上，<br>第六：Consumer在接收时也是获取connection，接着获取channel，然后指定一个Queue，到Queue上取消息，它对Exchange，RoutingKey及如何Binding都不关心，到对应的Queue上去取消息就行了。</p>
<p>注意：一个PublisherClient发送消息，哪些ConsumerClient可以收到消息，在于Exchange，RoutingKey，Queue的关系上</p>
<h3 id="RabbitMQ支持的消息模型"><a href="#RabbitMQ支持的消息模型" class="headerlink" title="RabbitMQ支持的消息模型"></a>RabbitMQ支持的消息模型</h3><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/RabbitMQ%E6%94%AF%E6%8C%81%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B-1.png" alt="RabbitMQ支持的消息模型-1"></p>
<p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/RabbitMQ%E6%94%AF%E6%8C%81%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B-2.png" alt="RabbitMQ支持的消息模型-2"></p>
<ol>
<li>简单模式 Simple</li>
<li>工作模式 Work</li>
<li>发布订阅模式</li>
<li>路由模式</li>
<li>主题 Topic模式</li>
<li>参数模式</li>
</ol>
<h2 id="RabbitMQ-fanout-模式"><a href="#RabbitMQ-fanout-模式" class="headerlink" title="RabbitMQ - fanout 模式"></a>RabbitMQ - fanout 模式</h2><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/fanout%E6%A8%A1%E5%BC%8F.png" alt="fanout模式"></p>
<p><strong>发布订阅模式的具体实现</strong></p>
<ol>
<li>类型：fanout</li>
<li>特点：Fanout - 发布与订阅模式，是一种广播机制，它是没有路由 key的模式</li>
</ol>
<h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    connectionFactory.setHost(<span class="string">&quot;10.15.0.9&quot;</span>);</span><br><span class="line">    connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">    connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">    <span class="comment">//2.创建通道</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">    <span class="comment">//3.通过创建交换机，声明队列，绑定关系，路由key，发送消息和接受消息</span></span><br><span class="line">    <span class="comment">/*参数1: 是否持久化，非持久化消息会存盘吗？会存盘，但是会随着重启服务器而丢失</span></span><br><span class="line"><span class="comment">      参数2:是否独占队列 </span></span><br><span class="line"><span class="comment">      参数3:是否自动删除，随着最后一个消费者消息完毕消息以后是否把队列自动删除</span></span><br><span class="line"><span class="comment">  	  参数4:携带附属属性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;queue1&quot;</span>;</span><br><span class="line">    channel.queueDeclare(queueName,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//4.发送消息给队列queue</span></span><br><span class="line">    <span class="comment">/*参数1: 交换机</span></span><br><span class="line"><span class="comment">      参数2:队列、路由key</span></span><br><span class="line"><span class="comment">      参数3:消息的状态控制</span></span><br><span class="line"><span class="comment">  	  参数4:消息主题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//面试题：可以存在没有交换机的队列吗？不可能，虽然没有指定交换机但是一定会存在一个默认的交换机</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="comment">//5.准备交换机</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;fanout-exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//6.定义路由key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">routeKey</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//7.指定交换机的类型</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;fanout&quot;</span>;</span><br><span class="line">    channel.basicPublish(exchangeName,routeKey, <span class="literal">null</span>,message.getBytes());</span><br><span class="line">    <span class="comment">//8.关闭</span></span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RabbitMQ-direct-模式"><a href="#RabbitMQ-direct-模式" class="headerlink" title="RabbitMQ - direct 模式"></a>RabbitMQ - direct 模式</h2><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/direct%E6%A8%A1%E5%BC%8F.png" alt="direct模式"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6.定义路由key</span></span><br><span class="line"><span class="type">String</span> <span class="variable">routeKey</span> <span class="operator">=</span> <span class="string">&quot;email&quot;</span>;</span><br><span class="line"><span class="comment">//7.指定交换机的类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;direct&quot;</span>;</span><br><span class="line">channel.basicPublish(exchangeName,routeKey, <span class="literal">null</span>,message.getBytes());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="RabbitMQ-topic-模式"><a href="#RabbitMQ-topic-模式" class="headerlink" title="RabbitMQ - topic 模式"></a>RabbitMQ - topic 模式</h2><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/topic%E6%A8%A1%E5%BC%8F.png" alt="topic模式"></p>
<p>#：匹配0、1或多个<br>*：匹配一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6.定义路由key</span></span><br><span class="line"><span class="type">String</span> <span class="variable">routeKey</span> <span class="operator">=</span> <span class="string">&quot;com.order.test.xxx&quot;</span>;</span><br><span class="line"><span class="comment">//7.指定交换机的类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;direct&quot;</span>;</span><br><span class="line">channel.basicPublish(exchangeName, routeKey, <span class="literal">null</span>,message.getBytes());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="代码创建及绑定"><a href="#代码创建及绑定" class="headerlink" title="代码创建及绑定"></a>代码创建及绑定</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.准备交换机</span></span><br><span class="line"><span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;direct_message_exchange&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">exchangeType</span> <span class="operator">=</span> <span class="string">&quot;direct&quot;</span>;</span><br><span class="line"><span class="comment">//如果你用界面把queue和exchange的关系先绑定话，代码就不需要在编写这些声明代码可以让代码变得更简洁</span></span><br><span class="line"><span class="comment">//如果用代码的方式去声明，我们要学习一下</span></span><br><span class="line"><span class="comment">//6.声明交换机 所谓的持久化就是指，交换机会不会随着服务器重启造成丢失</span></span><br><span class="line">channel.exchangeDeclare(exchangeName,exchangeType,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.声明队列</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;queue5&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;queue6&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;queue7&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.绑定队列和交换机的关系</span></span><br><span class="line">channel.queueBind(<span class="string">&quot;queue5&quot;</span>,exchangeName,<span class="string">&quot;order&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;queue6&quot;</span>,exchangeName,<span class="string">&quot;order&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;queue7&quot;</span>,exchangeName,<span class="string">&quot;course&quot;</span>);</span><br><span class="line"></span><br><span class="line">channel.basicPublish(exchangeName,course, <span class="literal">null</span>,message.getBytes());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="RabbitMQ-header模式"><a href="#RabbitMQ-header模式" class="headerlink" title="RabbitMQ - header模式"></a>RabbitMQ - header模式</h2><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/headers%E6%A8%A1%E5%BC%8F.png" alt="headers模式"></p>
<h2 id="RabbitMQ-work模式"><a href="#RabbitMQ-work模式" class="headerlink" title="RabbitMQ - work模式"></a>RabbitMQ - work模式</h2><p>当有多个消费者时，我们的消息会被哪个消费者消费呢，我们又该如何均衡消费者消费信息的多少呢？</p>
<p>主要有两种模式：</p>
<ol>
<li>轮询模式的分发：一个消费者一条，按均分配</li>
<li>公平分发：根据消费者的消费能力进行公平分发，处理快的处理的多，处理慢的处理的少；按劳分配</li>
</ol>
<h3 id="work模式轮询模式（Round-Robin）"><a href="#work模式轮询模式（Round-Robin）" class="headerlink" title="work模式轮询模式（Round-Robin）"></a>work模式轮询模式（Round-Robin）</h3><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/work%E6%A8%A1%E5%BC%8F-%E8%BD%AE%E8%AF%A2%E6%A8%A1%E5%BC%8F.png" alt="work模式-轮询模式"></p>
<h4 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.rabbitmq.work.polling;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;monochrome&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//2.创建通道</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//3.通过创建交换机，声明队列，绑定关系，路由key，发送消息和接受消息</span></span><br><span class="line">            <span class="comment">/*参数1:是否持久化，非持久化消息会存盘吗？会存盘，但是会随着重启服务器而丢失</span></span><br><span class="line"><span class="comment">              参数2:是否独占队列</span></span><br><span class="line"><span class="comment">              参数3:是否自动删除，随着最后一个消费者消息完毕消息以后是否把队列自动删除</span></span><br><span class="line"><span class="comment">              参数4:携带附属属性</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;queue-polling&quot;</span>;</span><br><span class="line">            channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.发送消息给队列queue</span></span><br><span class="line">            <span class="comment">/*参数1:交换机</span></span><br><span class="line"><span class="comment">              参数2:队列、路由key</span></span><br><span class="line"><span class="comment">              参数3:消息的状态控制</span></span><br><span class="line"><span class="comment">              参数4:消息主题</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + i;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5.关闭</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.rabbitmq.work.polling;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建连接工厂</span></span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">            connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            connectionFactory.setPassword(<span class="string">&quot;monochrome&quot;</span>);</span><br><span class="line">            connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection = connectionFactory.newConnection(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">                <span class="comment">//2.创建通道</span></span><br><span class="line">                channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">workName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                <span class="type">String</span> <span class="variable">routingName</span> <span class="operator">=</span> <span class="string">&quot;queue-polling&quot;</span>;</span><br><span class="line"></span><br><span class="line">                channel.basicConsume(routingName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DeliverCallback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        System.out.println(workName + <span class="string">&quot;收到消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">                        <span class="keyword">switch</span> (workName) &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&quot;work1&quot;</span>:</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&quot;work2&quot;</span>:</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> <span class="title class_">CancelCallback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        System.out.println(workName + <span class="string">&quot;接收消息失败！&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                System.out.println(<span class="string">&quot;开始接收消息：&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//5.关闭</span></span><br><span class="line">                <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        channel.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="literal">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        connection.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;work1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;work2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="work模式公平分发模式"><a href="#work模式公平分发模式" class="headerlink" title="work模式公平分发模式"></a>work模式公平分发模式</h3><p><img src="/images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/RabbitMQ%E5%AD%A6%E4%B9%A0/work%E6%A8%A1%E5%BC%8F-%E5%85%AC%E5%B9%B3%E6%A8%A1%E5%BC%8F.png" alt="work模式-公平模式"></p>
<p>生产者同轮询模式</p>
<h4 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.rabbitmq.work.fair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建连接工厂</span></span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">            connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            connectionFactory.setPassword(<span class="string">&quot;monochrome&quot;</span>);</span><br><span class="line">            connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection = connectionFactory.newConnection(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">                <span class="comment">//2.创建通道</span></span><br><span class="line">                channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">workName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                <span class="type">String</span> <span class="variable">routingName</span> <span class="operator">=</span> <span class="string">&quot;queue-polling&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//公平分发需要改成手动应答</span></span><br><span class="line">                <span class="type">Channel</span> <span class="variable">finalChannel</span> <span class="operator">=</span> channel;</span><br><span class="line">                <span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line">                <span class="comment">//这告诉 RabbitMQ 一次不要给一个工人多个消息。或者，换句话说，在处理并确认前一条消息之前，不要向工作人员发送新消息。相反，它会将它分派给下一个不忙的工人。</span></span><br><span class="line">                finalChannel.basicQos(prefetchCount);</span><br><span class="line">                channel.basicConsume(routingName, <span class="literal">false</span>, <span class="keyword">new</span> <span class="title class_">DeliverCallback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        System.out.println(workName + <span class="string">&quot;收到消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">                        <span class="keyword">switch</span> (workName) &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&quot;work1&quot;</span>:</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&quot;work2&quot;</span>:</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        finalChannel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> <span class="title class_">CancelCallback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        System.out.println(workName + <span class="string">&quot;接收消息失败！&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                System.out.println(<span class="string">&quot;开始接收消息：&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//5.关闭</span></span><br><span class="line">                <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        channel.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="literal">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        connection.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;work1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">&quot;work2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Springboot集成RabbitMQ"><a href="#Springboot集成RabbitMQ" class="headerlink" title="Springboot集成RabbitMQ"></a>Springboot集成RabbitMQ</h2><h3 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a><strong>application.yml</strong></h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">monochrome</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>

<h3 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;生成订单：&quot;</span> + uuid);</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;fanout-order-exchange&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, routingKey, uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者-3"><a href="#消费者-3" class="headerlink" title="消费者"></a>消费者</h3><p>配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutOrderExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;fanout-order-exchange&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">smsQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;sms.fanout.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">emailQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;email.fanout.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">wechatQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;wechat.fanout.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">smsBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(smsQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">emailBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(emailQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">wechatBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(wechatQueue()).to(fanoutOrderExchange());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Consumer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;email.fanout.queue&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutEmailConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;email接收到消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;sms.fanout.queue&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutSmsConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sms接收到消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;wechat.fanout.queue&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutWechatConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;wechat接收到消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：<a href="https://github.com/zhaoyangmushiyi/springboot-rabbitmq">https://github.com/zhaoyangmushiyi/springboot-rabbitmq</a></p>
]]></content>
      <categories>
        <category>消息队列</category>
        <category>RabbitMQ</category>
        <category>Kafka</category>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
        <tag>Kafka</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码学习笔记</title>
    <url>/2021/03/25/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Spring源码学习笔记"><a href="#Spring源码学习笔记" class="headerlink" title="Spring源码学习笔记"></a>Spring源码学习笔记</h1><h2 id="Spring-IoC介绍"><a href="#Spring-IoC介绍" class="headerlink" title="Spring IoC介绍"></a>Spring IoC介绍</h2><p>IoC 全称为 <code>Inversion of Control</code>，翻译为 “控制反转”，它还有一个别名为 DI（<code>Dependency Injection</code>）,即依赖注入。</p>
<blockquote>
<p><strong>所谓 IoC ，就是由 Spring IoC 容器来负责对象的生命周期和对象之间的关系</strong></p>
</blockquote>
<ol>
<li><strong>谁控制谁</strong>：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IoC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象</li>
<li><strong>控制什么</strong>：控制对象。</li>
<li><strong>为何是反转</strong>：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li>
<li><strong>哪些方面反转了</strong>：所依赖对象的获取被反转了。</li>
</ol>
<span id="more"></span>

<h2 id="调试环境搭建"><a href="#调试环境搭建" class="headerlink" title="调试环境搭建"></a>调试环境搭建</h2><h3 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h3><ul>
<li>Gradle</li>
<li>Git</li>
<li>JDK1.8+</li>
<li>IntelliJ IDEA</li>
</ul>
<h3 id="源码拉取"><a href="#源码拉取" class="headerlink" title="源码拉取"></a>源码拉取</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/spring-projects/spring-framework.git</span><br></pre></td></tr></table></figure>

<h3 id="预编译-spring-oxm-项目"><a href="#预编译-spring-oxm-项目" class="headerlink" title="预编译 spring-oxm 项目"></a>预编译 <code>spring-oxm</code> 项目</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure>

<h2 id="Spring-统一资源加载策略"><a href="#Spring-统一资源加载策略" class="headerlink" title="Spring 统一资源加载策略"></a>Spring 统一资源加载策略</h2><h3 id="统一资源：Resource"><a href="#统一资源：Resource" class="headerlink" title="统一资源：Resource"></a>统一资源：Resource</h3><p><code>org.springframework.core.io.Resource</code> 为 Spring 框架所有资源的抽象和访问接口，它继承 <code>org.springframework.core.io.InputStreamSource</code>接口。作为所有资源的统一抽象，Resource 定义了一些通用的方法，由子类 <code>AbstractResource</code> 提供统一的默认实现。</p>
<p>如果我们想要实现自定义的 Resource ，记住不要实现 Resource 接口，而应该继承 AbstractResource 抽象类，然后根据当前的具体资源特性覆盖相应的方法即可。</p>
<h3 id="统一资源定位：ResourceLoader"><a href="#统一资源定位：ResourceLoader" class="headerlink" title="统一资源定位：ResourceLoader"></a>统一资源定位：ResourceLoader</h3><p><code>org.springframework.core.io.ResourceLoader</code> 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为统一资源定位器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">CLASSPATH_URL_PREFIX</span> <span class="operator">=</span> ResourceUtils.CLASSPATH_URL_PREFIX; <span class="comment">// CLASSPATH URL 前缀。默认为：&quot;classpath:&quot;</span></span><br><span class="line"></span><br><span class="line">	Resource <span class="title function_">getResource</span><span class="params">(String location)</span>;</span><br><span class="line"></span><br><span class="line">	ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>#getResource(String location)</code>方法，根据所提供资源的路径 location 返回 Resource 实例，但是它不确保该 Resource 一定存在，需要调用<code>Resource#exist()</code>方法来判断。<ul>
<li>该方法支持以下模式的资源加载：<ul>
<li>URL位置资源，如 <code>&quot;file:C:/test.dat&quot;</code> 。</li>
<li>ClassPath位置资源，如 <code>&quot;classpath:test.dat&quot;</code> 。</li>
<li>相对路径资源，如 <code>&quot;WEB-INF/test.dat&quot;</code> ，此时返回的Resource 实例，根据实现不同而不同。</li>
</ul>
</li>
<li>该方法的主要实现是在其子类 DefaultResourceLoader 中实现，具体过程我们在分析 DefaultResourceLoader 时做详细说明。</li>
</ul>
</li>
<li><code>#getClassLoader()</code> 方法，返回 ClassLoader 实例，对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用该方法来获取。在分析 Resource 时，提到了一个类 ClassPathResource ，这个类是可以根据指定的 ClassLoader 来加载资源的。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此 Spring 整个资源记载过程已经分析完毕。下面简要总结下：</p>
<ul>
<li>Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其定位。使得资源与资源的定位有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。</li>
<li>AbstractResource 为 Resource 的默认抽象实现，它对 Resource 接口做了一个统一的实现，子类继承该类后只需要覆盖相应的方法即可，同时对于自定义的 Resource 我们也是继承该类。</li>
<li>DefaultResourceLoader 同样也是 ResourceLoader 的默认实现，在自定 ResourceLoader 的时候我们除了可以继承该类外还可以实现 ProtocolResolver 接口来实现自定资源加载协议。</li>
<li>DefaultResourceLoader 每次只能返回单一的资源，所以 Spring 针对这个提供了另外一个接口 ResourcePatternResolver ，该接口提供了根据指定的 locationPattern 返回多个资源的策略。其子类 PathMatchingResourcePatternResolver 是一个集大成者的 ResourceLoader ，因为它即实现了 <code>Resource getResource(String location)</code> 方法，也实现了 <code>Resource[] getResources(String locationPattern)</code> 方法。</li>
</ul>
<h2 id="加载-BeanDefinition"><a href="#加载-BeanDefinition" class="headerlink" title="加载 BeanDefinition"></a>加载 BeanDefinition</h2><p>先看一段熟悉的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPathResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;bean.xml&quot;</span>); <span class="comment">// &lt;1&gt;</span></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>(); <span class="comment">// &lt;2&gt;</span></span><br><span class="line"><span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(factory); <span class="comment">// &lt;3&gt;</span></span><br><span class="line">reader.loadBeanDefinitions(resource); <span class="comment">// &lt;4&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码是 Spring 中编程式使用 IoC 容器，通过这四段简单的代码，我们可以初步判断 IoC 容器的使用过程。</p>
<ol>
<li>获取资源</li>
<li>获取 BeanFactory</li>
<li>根据新建的 BeanFactory 创建一个 BeanDefinitionReader 对象，该 Reader 对象为资源的<strong>解析器</strong></li>
<li>装载资源</li>
</ol>
<p>整个过程就分为三个步骤：资源定位、装载、注册：</p>
<ul>
<li><strong>资源定位</strong>。我们一般用外部资源来描述 Bean 对象，所以在初始化 IoC 容器的第一步就是需要定位这个外部资源。</li>
<li><strong>装载</strong>。装载就是 BeanDefinition 的载入。BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IoC 容器的内部数据结构：BeanDefinition 。<ul>
<li>在 IoC 容器内部维护着一个 BeanDefinition Map 的数据结构</li>
<li>在配置文件中每一个 <code>&lt;bean&gt;</code> 都对应着一个 BeanDefinition 对象。</li>
<li>本文，我们分享的就是<strong>装载</strong>这个步骤。</li>
</ul>
</li>
<li><strong>注册</strong>。向 IoC 容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistry 接口来实现的。在 IoC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IoC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。<ul>
<li>在这里需要注意的一点是这个过程并没有完成依赖注入（Bean 创建），Bean 创建是发生在应用第一次调用 <code>#getBean(...)</code> 方法，向容器索要 Bean 时。</li>
<li>当然我们可以通过设置预处理，即对某个 Bean 设置 <code>lazyinit = false</code> 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。</li>
</ul>
</li>
</ul>
<blockquote>
<p>简单的说，上面步骤的结果是，XML Resource &#x3D;&gt; XML Document &#x3D;&gt; Bean Definition 。</p>
</blockquote>
<h3 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions"></a>loadBeanDefinitions</h3><p>资源定位在前面已经分析了，下面我们直接分析<strong>加载</strong>，上面看到的 <code>reader.loadBeanDefinitions(resource)</code> 代码，才是加载资源的真正实现，所以我们直接从该方法入手。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// XmlBeanDefinitionReader.java</span><br><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从指定的 xml 文件加载 Bean Definition ，这里会先对 Resource 资源封装成 <code>org.springframework.core.io.support.EncodedResource</code> 对象。这里为什么需要将 Resource 封装成 EncodedResource 呢？主要是为了对 Resource 进行编码，保证内容读取的正确性。</li>
<li>然后，再调用 <code>#loadBeanDefinitions(EncodedResource encodedResource)</code> 方法，执行真正的逻辑实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程，正在加载的 EncodedResource 集合。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;EncodedResource&gt;&gt; resourcesCurrentlyBeingLoaded = <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;&gt;(<span class="string">&quot;XML bean definition resources currently being loaded&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &lt;1&gt; 获取已经加载过的资源</span></span><br><span class="line">	Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">	<span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">		currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">		<span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123; <span class="comment">// 将当前资源加入记录中。如果已存在，抛出异常</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// &lt;2&gt; 从 EncodedResource 获取封装的 Resource ，并从 Resource 中获取其中的 InputStream</span></span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">			<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123; <span class="comment">// 设置编码</span></span><br><span class="line">				inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 核心逻辑部分，执行加载 BeanDefinition</span></span><br><span class="line">			<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			inputStream.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 从缓存中剔除该资源 &lt;3&gt;</span></span><br><span class="line">		currentResources.remove(encodedResource);</span><br><span class="line">		<span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">			<span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;1&gt;</code>处，通过<code>resourcesCurrentlyBeingLoaded.get()</code>代码，来获取已经加载过的资源，然后将<code>encodedResource</code>加入其中，如果<code>resourcesCurrentlyBeingLoaded</code>中已经存在该资源，则抛出 BeanDefinitionStoreException 异常。<ul>
<li>为什么需要这么做呢？答案在 <code>&quot;Detected cyclic loading&quot;</code> ，避免一个 EncodedResource 在加载时，还没加载完成，又加载自身，从而导致<strong>死循环</strong>。</li>
<li>也因此，在 <code>&lt;3&gt;</code> 处，当一个 EncodedResource 加载完成后，需要从缓存中剔除。</li>
</ul>
</li>
<li><code>&lt;2&gt;</code> 处理，从 <code>encodedResource</code> 获取封装的 Resource 资源，并从 Resource 中获取相应的 InputStream ，然后将 InputStream 封装为 InputSource ，最后调用 <code>#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code> 方法，执行加载 Bean Definition 的真正逻辑。</li>
</ul>
<h3 id="doLoadBeanDefinitions"><a href="#doLoadBeanDefinitions" class="headerlink" title="doLoadBeanDefinitions"></a>doLoadBeanDefinitions</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doLoadDocument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerBeanDefinitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// &lt;1&gt; 获取 XML Document 实例</span></span><br><span class="line">		<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">		<span class="comment">// &lt;2&gt; 根据 Document 实例，注册 Bean 信息</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">                <span class="string">&quot;Line &quot;</span> + ex.getLineNumber() + <span class="string">&quot; in XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;XML document from &quot;</span> + resource + <span class="string">&quot; is invalid&quot;</span>, ex);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Parser configuration exception parsing XML from &quot;</span> + resource, ex);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;IOException parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(resource.getDescription(),</span><br><span class="line">				<span class="string">&quot;Unexpected exception parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>&lt;1&gt;</code> 处，调用 <code>#doLoadDocument(InputSource inputSource, Resource resource)</code> 方法，根据 xml 文件，获取 Document 实例。</li>
<li>在 <code>&lt;2&gt;</code> 处，调用 <code>#registerBeanDefinitions(Document doc, Resource resource)</code> 方法，根据获取的 Document 实例，注册 Bean 信息。</li>
</ul>
<h3 id="doLoadDocument"><a href="#doLoadDocument" class="headerlink" title="doLoadDocument"></a>doLoadDocument</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 XML Document 实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Actually load the specified document using the configured DocumentLoader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the DOM Document</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception when thrown from the DocumentLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setDocumentLoader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DocumentLoader#loadDocument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Document <span class="title function_">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="built_in">this</span>.errorHandler,</span><br><span class="line">			getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>调用 <code>#getValidationModeForResource(Resource resource)</code> 方法，获取指定资源（xml）的<strong>验证模式</strong>。详细解析，见 <a href="#%E8%8E%B7%E5%8F%96%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9E%8B-ValidationMode">《获取验证模型》</a> 。</p>
</li>
<li><p>调用 <code>DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，获取 XML Document 实例。详细解析，见 [《获取 Document 对象》](#获取 Document 对象) 。</p>
</li>
</ol>
<h3 id="registerBeanDefinitions"><a href="#registerBeanDefinitions" class="headerlink" title="registerBeanDefinitions"></a>registerBeanDefinitions</h3><p>该方法的详细解析，见 [《注册 BeanDefinition》](#注册 BeanDefinition) 。</p>
<h2 id="获取验证模型-ValidationMode"><a href="#获取验证模型-ValidationMode" class="headerlink" title="获取验证模型(ValidationMode)"></a>获取验证模型(ValidationMode)</h2><p>在核心逻辑方法 <code>#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code> 方法中，中主要是做三件事情：</p>
<ol>
<li>调用 <code>#getValidationModeForResource(Resource resource)</code> 方法，获取指定资源（xml）的<strong>验证模式</strong>。</li>
<li>调用 <code>DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver,ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，获取 XML Document 实例。</li>
<li>调用 <code>#registerBeanDefinitions(Document doc, Resource resource)</code> 方法，根据获取的 Document 实例，注册 Bean 信息。</li>
</ol>
<p>这章主要<strong>第 1 步</strong>，分析获取 xml 文件的验证模式。为什么需要获取验证模式呢？原因如下：</p>
<blockquote>
<p>XML 文件的验证模式保证了 XML 文件的正确性。</p>
</blockquote>
<h3 id="DTD-与-XSD-的区别"><a href="#DTD-与-XSD-的区别" class="headerlink" title="DTD 与 XSD 的区别"></a>DTD 与 XSD 的区别</h3><h4 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h4><p>DTD(Document Type Definition)，即文档类型定义，为 XML 文件的验证机制，属于 XML 文件中组成的一部分。DTD 是一种保证 XML 文档格式正确的有效验证方式，它定义了相关 XML 文档的元素、属性、排列方式、元素的内容类型以及元素的层次结构。其实 DTD 就相当于 XML 中的 “词汇”和“语法”，我们可以通过比较 XML 文件和 DTD 文件 来看文档是否符合规范，元素和标签使用是否正确。</p>
<p>要在 Spring 中使用 DTD，需要在 Spring XML 文件头部声明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">beans</span> <span class="keyword">PUBLIC</span>  <span class="string">&quot;-//SPRING//DTD BEAN//EN&quot;</span>  <span class="string">&quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DTD 在一定的阶段推动了 XML 的发展，但是它本身存在着一些<strong>缺陷</strong>：</p>
<ol>
<li>它没有使用 XML 格式，而是自己定义了一套格式，相对解析器的重用性较差；而且 DTD 的构建和访问没有标准的编程接口，因而解析器很难简单的解析 DTD 文档。</li>
<li>DTD 对元素的类型限制较少；同时其他的约束力也叫弱。</li>
<li>DTD 扩展能力较差。</li>
<li>基于正则表达式的 DTD 文档的描述能力有限。</li>
</ol>
<h4 id="XSD"><a href="#XSD" class="headerlink" title="XSD"></a>XSD</h4><p>针对 DTD 的缺陷，W3C 在 2001 年推出 XSD。XSD（XML Schemas Definition）即 XML Schema 语言。XML Schema 本身就是一个 XML文档，使用的是 XML 语法，因此可以很方便的解析 XSD 文档。相对于 DTD，XSD 具有如下<strong>优势</strong>：</p>
<ol>
<li>XML Schema 基于 XML ，没有专门的语法。</li>
<li>XML Schema 可以象其他 XML 文件一样解析和处理。</li>
<li>XML Schema 比 DTD 提供了更丰富的数据类型。</li>
<li>XML Schema 提供可扩充的数据模型。</li>
<li>XML Schema 支持综合命名空间。</li>
<li>XML Schema 支持属性组。</li>
</ol>
<h3 id="getValidationModeForResource"><a href="#getValidationModeForResource" class="headerlink" title="getValidationModeForResource"></a>getValidationModeForResource</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VALIDATION_NONE</span> <span class="operator">=</span> XmlValidationModeDetector.VALIDATION_NONE;</span><br><span class="line"><span class="comment">// 自动获取验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VALIDATION_AUTO</span> <span class="operator">=</span> XmlValidationModeDetector.VALIDATION_AUTO;</span><br><span class="line"><span class="comment">// DTD 验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VALIDATION_DTD</span> <span class="operator">=</span> XmlValidationModeDetector.VALIDATION_DTD;</span><br><span class="line"><span class="comment">// XSD 验证模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VALIDATION_XSD</span> <span class="operator">=</span> XmlValidationModeDetector.VALIDATION_XSD;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证模式。默认为自动模式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">validationMode</span> <span class="operator">=</span> VALIDATION_AUTO;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getValidationModeForResource</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">	<span class="comment">// &lt;1&gt; 获取指定的验证模式</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">validationModeToUse</span> <span class="operator">=</span> getValidationMode();</span><br><span class="line">	<span class="comment">// 首先，如果手动指定，则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (validationModeToUse != VALIDATION_AUTO) &#123;</span><br><span class="line">		<span class="keyword">return</span> validationModeToUse;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 其次，自动获取验证模式</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">detectedMode</span> <span class="operator">=</span> detectValidationMode(resource);</span><br><span class="line">	<span class="keyword">if</span> (detectedMode != VALIDATION_AUTO) &#123;</span><br><span class="line">		<span class="keyword">return</span> detectedMode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后，使用 VALIDATION_XSD 做为默认</span></span><br><span class="line">	<span class="comment">// Hmm, we didn&#x27;t get a clear indication... Let&#x27;s assume XSD,</span></span><br><span class="line">	<span class="comment">// since apparently no DTD declaration has been found up until</span></span><br><span class="line">	<span class="comment">// detection stopped (before finding the document&#x27;s root tag).</span></span><br><span class="line">	<span class="keyword">return</span> VALIDATION_XSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取-Document-对象"><a href="#获取-Document-对象" class="headerlink" title="获取 Document 对象"></a>获取 Document 对象</h2><p>在 <code>XmlBeanDefinitionReader#doLoadDocument(InputSource inputSource, Resource resource)</code> 方法，中做了两件事情：</p>
<ul>
<li>调用<code>#getValidationModeForResource(Resource resource)</code>方法，获取指定资源（xml）的验证模式。</li>
<li>调用 <code>DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware)</code> 方法，获取 XML Document 实例。</li>
</ul>
<h3 id="DocumentLoader"><a href="#DocumentLoader" class="headerlink" title="DocumentLoader"></a>DocumentLoader</h3><p>获取 Document 的策略，由接口 <code>org.springframework.beans.factory.xml.DocumentLoader</code> 定义。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DocumentLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">	Document <span class="title function_">loadDocument</span><span class="params">(</span></span><br><span class="line"><span class="params">			InputSource inputSource, EntityResolver entityResolver,</span></span><br><span class="line"><span class="params">			ErrorHandler errorHandler, <span class="type">int</span> validationMode, <span class="type">boolean</span> namespaceAware)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>inputSource</code> 方法参数，加载 Document 的 Resource 资源。</li>
<li><code>entityResolver</code> 方法参数，解析文件的解析器。</li>
<li><code>errorHandler</code> 方法参数，处理加载 Document 对象的过程的错误。</li>
<li><code>validationMode</code> 方法参数，验证模式。</li>
<li><code>namespaceAware</code> 方法参数，命名空间支持。如果要提供对 XML 名称空间的支持，则需要值为 <code>true</code> 。</li>
</ul>
<h4 id="DefaultDocumentLoader"><a href="#DefaultDocumentLoader" class="headerlink" title="DefaultDocumentLoader"></a>DefaultDocumentLoader</h4><p>该方法由 DocumentLoader 的默认实现类 <code>org.springframework.beans.factory.xml.DefaultDocumentLoader</code> 实现。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the &#123;<span class="doctag">@link</span> Document&#125; at the supplied &#123;<span class="doctag">@link</span> InputSource&#125; using the standard JAXP-configured</span></span><br><span class="line"><span class="comment"> * XML parser.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Document <span class="title function_">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span><br><span class="line"><span class="params">		ErrorHandler errorHandler, <span class="type">int</span> validationMode, <span class="type">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// &lt;1&gt; 创建 DocumentBuilderFactory</span></span><br><span class="line">	<span class="type">DocumentBuilderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Using JAXP provider [&quot;</span> + factory.getClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// &lt;2&gt; 创建 DocumentBuilder</span></span><br><span class="line">	<span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">	<span class="comment">// &lt;3&gt; 解析 XML InputSource 返回 Document 对象</span></span><br><span class="line">	<span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先，调用 #<code>createDocumentBuilderFactory(...)</code> 方法，创建 <code>javax.xml.parsers.DocumentBuilderFactory</code> 对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JAXP attribute used to configure the schema language for validation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHEMA_LANGUAGE_ATTRIBUTE</span> <span class="operator">=</span> <span class="string">&quot;http://java.sun.com/xml/jaxp/properties/schemaLanguage&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JAXP attribute value indicating the XSD schema language.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">XSD_SCHEMA_LANGUAGE</span> <span class="operator">=</span> <span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>;</span><br><span class="line"><span class="keyword">protected</span> DocumentBuilderFactory <span class="title function_">createDocumentBuilderFactory</span><span class="params">(<span class="type">int</span> validationMode, <span class="type">boolean</span> namespaceAware)</span></span><br><span class="line">        <span class="keyword">throws</span> ParserConfigurationException &#123;</span><br><span class="line">    <span class="comment">// 创建 DocumentBuilderFactory</span></span><br><span class="line">    <span class="type">DocumentBuilderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">    factory.setNamespaceAware(namespaceAware); <span class="comment">// 设置命名空间支持</span></span><br><span class="line">    <span class="keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;</span><br><span class="line">        factory.setValidating(<span class="literal">true</span>); <span class="comment">// 开启校验</span></span><br><span class="line">        <span class="comment">// XSD 模式下，设置 factory 的属性</span></span><br><span class="line">        <span class="keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;</span><br><span class="line">            <span class="comment">// Enforce namespace aware for XSD...</span></span><br><span class="line">            factory.setNamespaceAware(<span class="literal">true</span>); <span class="comment">// XSD 模式下，强制设置命名空间支持</span></span><br><span class="line">            <span class="comment">// 设置 SCHEMA_LANGUAGE_ATTRIBUTE</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">                <span class="type">ParserConfigurationException</span> <span class="variable">pcex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParserConfigurationException</span>(</span><br><span class="line">                        <span class="string">&quot;Unable to validate using XSD: Your JAXP provider [&quot;</span> + factory +</span><br><span class="line">                        <span class="string">&quot;] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;</span>);</span><br><span class="line">                pcex.initCause(ex);</span><br><span class="line">                <span class="keyword">throw</span> pcex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，调用 <code>#createDocumentBuilder(DocumentBuilderFactory factory, EntityResolver entityResolver,ErrorHandler errorHandler)</code> 方法，创建 <code>javax.xml.parsers.DocumentBuilder</code> 对象。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected DocumentBuilder createDocumentBuilder(DocumentBuilderFactory factory,</span><br><span class="line">		@Nullable EntityResolver entityResolver, @Nullable ErrorHandler errorHandler)</span><br><span class="line">		throws ParserConfigurationException &#123;</span><br><span class="line">	// 创建 DocumentBuilder 对象</span><br><span class="line">	DocumentBuilder docBuilder = factory.newDocumentBuilder();</span><br><span class="line">	// &lt;x&gt; 设置 EntityResolver 属性</span><br><span class="line">	if (entityResolver != null) &#123;</span><br><span class="line">		docBuilder.setEntityResolver(entityResolver);</span><br><span class="line">	&#125;</span><br><span class="line">	// 设置 ErrorHandler 属性</span><br><span class="line">	if (errorHandler != null) &#123;</span><br><span class="line">		docBuilder.setErrorHandler(errorHandler);</span><br><span class="line">	&#125;</span><br><span class="line">	return docBuilder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>&lt;x&gt;</code> 处，设置 DocumentBuilder 的 <strong>EntityResolver</strong> 属性。</li>
</ul>
</li>
<li><p>最后，调用 <code>DocumentBuilder#parse(InputSource)</code> 方法，解析 InputSource ，返回 Document 对象。</p>
</li>
</ul>
<h2 id="注册-BeanDefinitions"><a href="#注册-BeanDefinitions" class="headerlink" title="注册 BeanDefinitions"></a>注册 BeanDefinitions</h2><p>获取 XML Document 对象后，会根据该对象和 Resource 资源对象调用 <code>XmlBeanDefinitionReader#registerBeanDefinitions(Document doc, Resource resource)</code> 方法，开始注册 BeanDefinitions 之旅。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractBeanDefinitionReader.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="comment">// &lt;1&gt; 创建 BeanDefinitionDocumentReader 对象</span></span><br><span class="line">	<span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="comment">// &lt;2&gt; 获取已注册的 BeanDefinition 数量</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">	<span class="comment">// &lt;3&gt; 创建 XmlReaderContext 对象</span></span><br><span class="line">	<span class="comment">// &lt;4&gt; 注册 BeanDefinition</span></span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="comment">// 计算新注册的 BeanDefinition 数量</span></span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;1&gt;</code> 处，调用 <code>#createBeanDefinitionDocumentReader()</code> 方法，实例化 BeanDefinitionDocumentReader 对象。</p>
</li>
<li><p><code>&lt;2&gt;</code> 处，调用 <code>BeanDefinitionRegistry#getBeanDefinitionCount()</code> 方法，获取<strong>已注册</strong>的 BeanDefinition 数量。</p>
</li>
<li><p><code>&lt;3&gt;</code> 处，调用 <code>#createReaderContext(Resource resource)</code> 方法，创建 XmlReaderContext 对象。</p>
</li>
<li><p><code>&lt;4&gt;</code> 处，调用 <code>BeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</code> 方法，读取 XML 元素，注册 BeanDefinition 们。</p>
</li>
<li><p><code>&lt;5&gt;</code> 处，计<strong>算新注册</strong>的 BeanDefinition 数量。</p>
</li>
</ul>
<h3 id="createBeanDefinitionDocumentReader"><a href="#createBeanDefinitionDocumentReader" class="headerlink" title="createBeanDefinitionDocumentReader"></a>createBeanDefinitionDocumentReader</h3><p><code>#createBeanDefinitionDocumentReader()</code>，实例化 BeanDefinitionDocumentReader 对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * documentReader 的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #createBeanDefinitionDocumentReader() </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionDocumentReader</span>&gt; documentReaderClass = DefaultBeanDefinitionDocumentReader.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title function_">createBeanDefinitionDocumentReader</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> BeanUtils.instantiateClass(<span class="built_in">this</span>.documentReaderClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>documentReaderClass</code> 的默认值为 <code>DefaultBeanDefinitionDocumentReader.class</code> 。关于它，我们在后续的文章，详细解析。</li>
</ul>
<h3 id="registerBeanDefinitions-1"><a href="#registerBeanDefinitions-1" class="headerlink" title="registerBeanDefinitions"></a>registerBeanDefinitions</h3><p><code>BeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</code> 方法，注册 BeanDefinition ，在接口 BeanDefinitionDocumentReader 中定义。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionDocumentReader</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Read bean definitions from the given DOM document and</span></span><br><span class="line"><span class="comment">	 * register them with the registry in the given reader context.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> doc the DOM document</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> readerContext the current context of the reader</span></span><br><span class="line"><span class="comment">	 * (includes the target registry and the resource being parsed)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of parsing errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span></span><br><span class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从给定的 Document 对象中解析定义的 BeanDefinition 并将他们注册到注册表中</strong>。方法接收两个参数：</p>
<ul>
<li><code>doc</code> 方法参数：待解析的 Document 对象。</li>
<li><code>readerContext</code> 方法，解析器的当前上下文，包括目标注册表和被解析的资源。</li>
</ul>
<h4 id="DefaultBeanDefinitionDocumentReader"><a href="#DefaultBeanDefinitionDocumentReader" class="headerlink" title="DefaultBeanDefinitionDocumentReader"></a>DefaultBeanDefinitionDocumentReader</h4><p>BeanDefinitionDocumentReader 有且只有一个默认实现类 DefaultBeanDefinitionDocumentReader 。它对 <code>#registerBeanDefinitions(...)</code> 方法的实现代码如下：</p>
<p>DefaultBeanDefinitionDocumentReader 对该方法提供了实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> XmlReaderContext readerContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> BeanDefinitionParserDelegate delegate;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation parses bean definitions according to the &quot;spring-beans&quot; XSD</span></span><br><span class="line"><span class="comment"> * (or DTD, historically).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Opens a DOM Document; then initializes the default settings</span></span><br><span class="line"><span class="comment"> * specified at the &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; level; then parses the contained bean definitions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">    <span class="comment">// 获得 XML Document Root Element</span></span><br><span class="line">    <span class="comment">// 执行注册 BeanDefinition</span></span><br><span class="line">    doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register each bean definition within the given root &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span>  <span class="comment">// for Environment.acceptsProfiles(String...)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">    <span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">    <span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">    <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">    <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">    <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">    <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">    <span class="comment">// 记录老的 BeanDefinitionParserDelegate 对象</span></span><br><span class="line">    <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">    <span class="comment">// &lt;1&gt; 创建 BeanDefinitionParserDelegate 对象，并进行设置到 delegate</span></span><br><span class="line">    <span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    <span class="comment">// &lt;2&gt; 检查 &lt;beans /&gt; 根标签的命名空间是否为空，或者是 http://www.springframework.org/schema/beans</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        <span class="comment">// &lt;2.1&gt; 处理 profile 属性。可参见《Spring3自定义环境配置 &lt;beans profile=&quot;&quot;&gt;》http://nassir.iteye.com/blog/1535799</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            <span class="comment">// &lt;2.2&gt; 使用分隔符切分，可能有多个 profile 。</span></span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="comment">// &lt;2.3&gt; 如果所有 profile 都无效，则不进行注册</span></span><br><span class="line">            <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">            <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">            <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                            <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;3&gt; 解析前处理</span></span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    <span class="comment">// &lt;4&gt; 解析</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">    <span class="comment">// &lt;5&gt; 解析后处理</span></span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 delegate 回老的 BeanDefinitionParserDelegate 对象</span></span><br><span class="line">    <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;1&gt;</code> 处，创建 BeanDefinitionParserDelegate 对象，并进行设置到 <code>delegate</code> 。BeanDefinitionParserDelegate 是一个重要的类，它负责<strong>解析 BeanDefinition</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title function_">createDelegate</span><span class="params">(</span></span><br><span class="line"><span class="params">        XmlReaderContext readerContext, Element root, <span class="meta">@Nullable</span> BeanDefinitionParserDelegate parentDelegate)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 BeanDefinitionParserDelegate 对象</span></span><br><span class="line">    <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">delegate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionParserDelegate</span>(readerContext);</span><br><span class="line">    <span class="comment">// 初始化默认</span></span><br><span class="line">    delegate.initDefaults(root, parentDelegate);</span><br><span class="line">    <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;2&gt;</code> 处，检查 <code>&lt;beans /&gt;</code> <strong>根</strong>标签的命名空间是否为空，或者是 <a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a> 。</p>
<ul>
<li><code>&lt;2.1&gt;</code> 处，判断是否 <code>&lt;beans /&gt;</code> 上配置了 <code>profile</code> 属性。</li>
<li><code>&lt;2.2&gt;</code> 处，使用分隔符切分，可能有<strong>多个</strong> profile 。</li>
<li><code>&lt;2.3&gt;</code> 处，判断，如果所有 profile 都无效，则 <code>return</code> 不进行注册。</li>
</ul>
</li>
<li><p><code>&lt;4&gt;</code> 处，调用 <code>#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)</code> 方法，进行解析逻辑。详细解析，见 <a href="http://svip.iocoder.cn/Spring/IoC-register-BeanDefinitions/#">「3.1 parseBeanDefinitions」</a> 。</p>
</li>
<li><p><code>&lt;3&gt;</code> &#x2F; <code>&lt;5&gt;</code> 处，解析<strong>前后</strong>的处理，目前这两个方法都是空实现，交由子类来实现。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">preProcessXml</span><span class="params">(Element root)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessXml</span><span class="params">(Element root)</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="parseBeanDefinitions"><a href="#parseBeanDefinitions" class="headerlink" title="parseBeanDefinitions"></a>parseBeanDefinitions</h5><p><code>#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)</code> 方法，进行解析逻辑。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the elements at the root level in the document:</span></span><br><span class="line"><span class="comment"> * &quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root the DOM root element of the document</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="comment">// &lt;1&gt; 如果根节点使用默认命名空间，执行默认解析</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        <span class="comment">// 遍历子节点</span></span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">                <span class="comment">// &lt;1&gt; 如果该节点使用默认命名空间，执行默认解析</span></span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                <span class="comment">// 如果该节点非默认命名空间，执行自定义解析</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// &lt;2&gt; 如果根节点非默认命名空间，执行自定义解析</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Spring 有两种Bean 声明方式：</p>
<ul>
<li>配置文件式声明：<code>&lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.StudentService&quot; /&gt;</code> 。对应 <code>&lt;1&gt;</code> 处。</li>
<li>自定义注解方式：<code>&lt;tx:annotation-driven&gt;</code> 。对应 <code>&lt;2&gt;</code> 处。</li>
</ul>
</li>
<li><p><code>&lt;1&gt;</code> 处，如果<strong>根</strong>节点或<strong>子</strong>节点<strong>使用</strong>默认命名空间，调用 <code>#parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate)</code> 方法，执行默认解析。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; <span class="comment">// import</span></span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; <span class="comment">// alias</span></span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; <span class="comment">// bean</span></span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; <span class="comment">// beans</span></span><br><span class="line">		<span class="comment">// recurse</span></span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>详细的解析，见后续文章。</li>
</ul>
</li>
<li><p><code>&lt;2&gt;</code> 处，如果<strong>根</strong>节点或<strong>子</strong>节点<strong>不使用</strong>默认命名空间，调用<code>BeanDefinitionParserDelegate#parseCustomElement(Element ele)</code> 方法，执行<strong>自定义</strong>解析。详细的解析，见后续文章。</p>
</li>
</ul>
<h3 id="createReaderContext"><a href="#createReaderContext" class="headerlink" title="createReaderContext"></a>createReaderContext</h3><p><code>#createReaderContext(Resource resource)</code> 方法，创建 XmlReaderContext 对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ProblemReporter</span> <span class="variable">problemReporter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FailFastProblemReporter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReaderEventListener</span> <span class="variable">eventListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmptyReaderEventListener</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">SourceExtractor</span> <span class="variable">sourceExtractor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullSourceExtractor</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> NamespaceHandlerResolver namespaceHandlerResolver;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the &#123;<span class="doctag">@link</span> XmlReaderContext&#125; to pass over to the document reader.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> XmlReaderContext <span class="title function_">createReaderContext</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlReaderContext</span>(resource, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.eventListener,</span><br><span class="line">			<span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 XmlReaderContext 的详细解析，见后续文章。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习</title>
    <url>/2021/06/26/Redis%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Redis 是一种开源（BSD 许可）、内存中数据结构存储，用作数据库、缓存和消息代理。Redis 提供了诸如字符串、散列、列表、集合、带范围查询的排序集合、位图、超级日志、地理空间索引和流等数据结构。Redis 内置复制、Lua 脚本、LRU 驱逐、事务和不同级别的磁盘持久化，并通过 Redis Sentinel 和 Redis Cluster 自动分区提供高可用性。</p>
<span id="more"></span>

<h1 id="Docker安装Redis"><a href="#Docker安装Redis" class="headerlink" title="Docker安装Redis"></a>Docker安装Redis</h1><ol>
<li><p>获取镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --name docker-redis -p 6379:6379 redis</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定配置文件</span></span><br><span class="line">docker run -d --privileged=true -p 6379:6379 -v /Users/monochrome/app/redis/redis.conf:/usr/local/etc/redis.conf --name docker-redis redis redis-server /usr/local/etc/redis.conf --appendonly yes </span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>redis-cli</code>连接测试使用<code>redis</code>服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it docker-redis /bin/bash</span><br><span class="line">redis-cli</span><br><span class="line">set test 1</span><br><span class="line">get test</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Docker%E5%AE%89%E8%A3%85Redis%E6%B5%8B%E8%AF%95.png" alt="截屏2021-06-26 18.40.43"></p>
</li>
</ol>
<h1 id="Redis键-key"><a href="#Redis键-key" class="headerlink" title="Redis键(key)"></a>Redis键(key)</h1><p>keys * 查看当前库所有key  (匹配：keys *1)</p>
<p>exists key 判断某个key是否存在</p>
<p>type key 查看你的key是什么类型</p>
<p>del key    删除指定的key数据</p>
<p>unlink key  根据value选择非阻塞删除</p>
<p>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</p>
<p>expire key 10  10秒钟：为给定的key设置过期时间</p>
<p>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>
<p>select命令切换数据库</p>
<p>dbsize查看当前数据库的key的数量</p>
<p>flushdb清空当前库</p>
<p>flushall通杀全部库</p>
<h1 id="常用五大数据类型"><a href="#常用五大数据类型" class="headerlink" title="常用五大数据类型"></a>常用五大数据类型</h1><h2 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a>Redis字符串(String)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>set  key value  添加键值对</p>
<p> <img src="/images/Redis%E5%AD%A6%E4%B9%A0/String-set.png" alt="截屏2021-06-26 21.53.41"></p>
<p>*NX：当数据库中key不存在时，可以将key-value添加数据库</p>
<p>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</p>
<p>*EX：key的超时秒数</p>
<p>*PX：key的超时毫秒数，与EX互斥</p>
<p>get  key 查询对应键值</p>
<p>append key value 将给定的value  追加到原值的末尾</p>
<p>strlen key 获得值的长度</p>
<p>setnx key value 只有在 key 不存在时  设置 key 的值</p>
<p>incr key  </p>
<p>将 key 中储存的数字值增1(原子操作，不会被线程调度机制打断)</p>
<p>只能对数字值操作，如果为空，新增值为1</p>
<p>decr key </p>
<p>将 key 中储存的数字值减1</p>
<p>只能对数字值操作，如果为空，新增值为-1</p>
<p>incrby &#x2F; decrby key 步长 将 key 中储存的数字值增减。自定义步长。</p>
<img src="/images/Redis学习/String-命令1.png" alt="String-命令1.png" style="zoom:50%;" />

<p>mset key1 value1 key2 value2  ….. </p>
<p>同时设置一个或多个 key-value对 </p>
<p>mget key1 key2 key3  …..</p>
<p>同时获取一个或多个 value </p>
<p>msetnx key1 value1 key2 value2  ….. </p>
<p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<strong>原子性，有一个失败则都失败</strong></p>
<p>getrange key 起始位置 结束位置 </p>
<p>获得值的范围，类似java中的substring，<strong>前包，后包</strong></p>
<p>setrange key 起始位置 value </p>
<p>用 value  覆写key 所储存的字符串值，从起始位置 开始(<strong>索引从0开始</strong>)。</p>
<p>setex key 过期时间 value </p>
<p>设置键值的同时，设置过期时间，单位秒。</p>
<p>getset key value </p>
<p>以新换旧，设置了新值同时获得旧值。</p>
<img src="/images/Redis学习/String-命令2.png" alt="String-命令2.png" style="zoom:50%;" />

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/String-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="image-20210626220837603"></p>
<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h2 id="Redis列表-List"><a href="#Redis列表-List" class="headerlink" title="Redis列表(List)"></a><strong>Redis列表(List)</strong></h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>单键多值</p>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/List-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="List-双向链表"></p>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>lpush&#x2F;rpush  key value1 value2 value3 …. 从左边&#x2F;右边插入一个或多个值。</p>
<p>lpop&#x2F;rpop  key从左边&#x2F;右边吐出一个值。值在键在，值光键亡。</p>
<p>rpoplpush  key1 key2 从key1列表右边吐出一个值，插到 key2列表左边。</p>
<p>lrange key start stop 按照索引下标获得元素(从左到右)</p>
<p>lrange mylist 0 -1  0左边第一个，-1右边第一个，（0 -1表示获取所有）</p>
<p>lindex  key index 按照索引下标获得元素(从左到右)</p>
<p>llen key 获得列表长度 </p>
<p>linsert  key before&#x2F;after  value newvalue 在 value的后面插入newvalue插入值</p>
<p>lrem key n value 从左边删除n个value(从左到右)</p>
<p>lset key index value 将列表key下标为index的值替换成value</p>
<p> <img src="/images/Redis%E5%AD%A6%E4%B9%A0/List-%E5%91%BD%E4%BB%A4.png" alt="List-命令"></p>
<p><strong>数据结构</strong></p>
<p>List的数据结构为快速链表quickList。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成quicklist。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/List-quicklist.png" alt="List-quicklist"></p>
<p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h2 id="Redis集合-Set"><a href="#Redis集合-Set" class="headerlink" title="Redis集合(Set)"></a><strong>Redis集合(Set)</strong></h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的*<em>复杂度都是</em>***O(1)**。</p>
<p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p>
<h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>sadd key value1 value2  ….. </p>
<p>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</p>
<p>smembers key 取出该集合的所有值。</p>
<p>sismember key value 判断集合key 是否为含有该value 值，有1，没有0</p>
<p>scard key 返回该集合的元素个数。</p>
<p>srem key value1 value2  …. 删除集合中的某个元素。</p>
<p>spop key <strong>随机从该集合中吐出一个值。</strong></p>
<p>srandmember key n 随机从该集合中取出n个值。不会从集合中删除 。</p>
<p>smove source destination value 把集合中一个值从一个集合移动到另一个集合</p>
<p>sinter key1 key2 返回两个集合的交集元素。</p>
<p>sunion key1 key2 返回两个集合的并集元素。</p>
<p>sdiff key1 key2 返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Set-%E5%91%BD%E4%BB%A4.png" alt="Set-命令"></p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>Set数据结构是dict字典，字典是用哈希表实现的。</p>
<p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h2 id="Redis哈希-Hash"><a href="#Redis哈希-Hash" class="headerlink" title="Redis哈希(Hash)"></a><strong>Redis哈希(Hash)</strong></h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>Redis hash 是一个键值对集合。</p>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>类似Java里面的Map&lt;String,Object&gt;</p>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key&#x2F;value结构来存储</p>
<p>主要有以下2种存储方，然后衍生出我们Hash的存储方式：</p>
<ol>
<li><p>第一种</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Hash-store1-1.png" alt="image-20210627211632603">  </p>
<p>每次修改用户的某个属性需要，先反序列化改好后再序列化回去。开销较大。</p>
</li>
<li><p>第二种</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Hash-store1-2.png" alt="image-20210627211728406"></p>
<p>用户ID数据冗余</p>
</li>
<li><p>第三种，Hash</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Hash-store2.png" alt="image-20210627212109516"></p>
<p>通过 <code>key(用户ID)</code> + <code>field(属性标签)</code>就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</p>
</li>
</ol>
<h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>hset key field value 给key 集合中的 field 键赋值value </p>
<p>hget key field 从key集合field取出value </p>
<p>hmset key field1 value1 field2 value2 … 批量设置hash的值</p>
<p>hexists key field 查看哈希表 key 中，给定域 field 是否存在。 </p>
<p>hkeys key 列出该hash集合的所有field</p>
<p>hvals key 列出该hash集合的所有value</p>
<p>hincrby key field increment 为哈希表 key 中的域 field 的值加上增量 1  -1</p>
<p>hsetnx key field value 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</p>
<p>hgetall key 获取该hash集合的所有field以及value</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Hash-%E5%91%BD%E4%BB%A4.png" alt="Hash-命令"></p>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
<h2 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a><strong>Redis有序集合Zset(sorted set)</strong></h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>Redis有序集合zset与普通集合set非常相似，是一个<strong>没有重复元素</strong>的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。<strong>集合的成员是唯一的，但是评分可以是重复了 。</strong></p>
<p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><p>zadd key score1 value1 score2 value2 …</p>
<p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p>
<p><strong>zrange key start stop  [WITHSCORES]</strong>  </p>
<p>返回有序集 key 中，下标在start stop之间的元素，带WITHSCORES，可以让分数一起和值返回到结果集。</p>
<p>zrangebyscore key minmax [withscores] [limit offset count]</p>
<p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </p>
<p>zrevrangebyscore key maxmin [withscores] [limit offset count]        </p>
<p>同上，改为从大到小排列。 </p>
<p>zincrby key increment value    为元素的score加上增量</p>
<p>zrem key value 删除该集合下，指定值的元素</p>
<p>zcount key min max 统计该集合，分数区间内的元素个数 </p>
<p>zrank key value 返回该值在集合中的排名，从0开始。</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Zset-%E5%91%BD%E4%BB%A4.png" alt="截屏2021-06-28 15.23.53"></p>
<p>案例：如何利用zset实现一个文章访问量的排行榜？</p>
<h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层使用了两个数据结构</p>
<p>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p>
<p>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
<h3 id="跳跃表（跳表）"><a href="#跳跃表（跳表）" class="headerlink" title="跳跃表（跳表）"></a><strong>跳跃表（跳表）</strong></h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p>  有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>  对比有序链表和跳跃表，从链表中查询出51</p>
<p>（1） 有序链表</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Zset-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.png" alt="Zset-有序链表">                               </p>
<p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p>
<p>（2） 跳跃表</p>
<p> <img src="/images/Redis%E5%AD%A6%E4%B9%A0/Zset-%E8%B7%B3%E8%B7%83%E8%A1%A8.png" alt="Zset-跳跃表"></p>
<p>从第2层开始，1节点比51节点小，向后比较。</p>
<p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</p>
<p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p>
<p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p>
<p>从此可以看出跳跃表比有序链表效率要高</p>
<h1 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a><strong>Redis的发布和订阅</strong></h1><h2 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a><strong>什么是发布和订阅</strong></h2><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<h2 id="Redis的发布和订阅-1"><a href="#Redis的发布和订阅-1" class="headerlink" title="Redis的发布和订阅"></a><strong>Redis的发布和订阅</strong></h2><p><strong>发布订阅命令行实现</strong></p>
<p>1、 打开一个客户端订阅channel1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">subscribe channel1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85-%E8%AE%A2%E9%98%85channel1.png" alt="Redis发布和订阅-订阅channel1">     </p>
<p>2、打开另一个客户端，给channel1发布消息hello</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">publish channel1 hello</span><br></pre></td></tr></table></figure>

<p> <img src="/images/Redis%E5%AD%A6%E4%B9%A0/Redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85-%E7%BB%99channel1%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF.png" alt="Redis发布和订阅-给channel1发布消息"></p>
<p>返回的1是订阅者数量</p>
<p>3、打开第一个客户端可以看到发送的消息</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85-%E4%BB%8Echannel1%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF.png" alt="Redis发布和订阅-从channel1接收消息"></p>
<p>注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息</p>
<h1 id="Redis与Spring-Boot整合"><a href="#Redis与Spring-Boot整合" class="headerlink" title="Redis与Spring Boot整合"></a><strong>Redis与Spring Boot整合</strong></h1><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="application-yml配置Redis配置"><a href="#application-yml配置Redis配置" class="headerlink" title="application.yml配置Redis配置"></a>application.yml配置Redis配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">#Redis服务器地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span> <span class="comment">#Redis服务器连接端口</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">18000000</span> <span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">20</span> <span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span> <span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">5</span> <span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#连接池中的最小空闲连接</span></span><br></pre></td></tr></table></figure>

<h2 id="添加redis配置类"><a href="#添加redis配置类" class="headerlink" title="添加redis配置类"></a>添加redis配置类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonTypeInfo;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><span class="comment">//我们可以自定义一个RedisTemplate来替换默认的</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        serializer.setObjectMapper(mapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hash的key也采用StringRedisSerializer的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span><span class="comment">//由于String是redis中最常使用的类型，所以单独提出了一个bean!</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">StringRedisTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(mapper);</span><br><span class="line">        <span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="完成一个手机验证码功能"><a href="#完成一个手机验证码功能" class="headerlink" title="完成一个手机验证码功能"></a><strong>完成一个手机验证码功能</strong></h2><p>要求：</p>
<ol>
<li><p>输入手机号，点击发送后随机生成6位数字码，30分钟有效</p>
<p>用Random类</p>
</li>
<li><p>输入验证码，点击验证，返回成功或失败</p>
<p>把验证码放到Redis里面，设置过期时间为30分钟</p>
</li>
<li><p>每个手机号每天只能输入3次</p>
<p>把发送验证码的数量也放到Redis里面，设置过期时间为1天</p>
<p>incr每次发送后+1</p>
<p>大于2(也就是已经发送3次后)不能再发送</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getVerificationCode</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">verifyCodeCountKey</span> <span class="operator">=</span> <span class="string">&quot;verifyCode&quot;</span> + phone + <span class="string">&quot;:count&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">verifyCodeKey</span> <span class="operator">=</span> <span class="string">&quot;verifyCode&quot;</span> + phone + <span class="string">&quot;:code&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForValue().get(verifyCodeCountKey);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(verifyCodeCountKey, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.parseInt(count) &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        redisTemplate.opsForValue().increment(verifyCodeCountKey);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;今天输入次数已超过3次！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">verificationCode</span> <span class="operator">=</span> getRandomVerificationCode();</span><br><span class="line">    log.info(verifyCodeKey + <span class="string">&quot;------&quot;</span> + verificationCode);</span><br><span class="line">    redisTemplate.opsForValue().set(verifyCodeKey, verificationCode, <span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;验证码已发送到手机，请尽快输入，验证码将于30分钟后失效！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">verifyPhoneAndVerificationCode</span><span class="params">(String phone, String verificationCode)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">verifyCodeKey</span> <span class="operator">=</span> <span class="string">&quot;verifyCode&quot;</span> + phone + <span class="string">&quot;:code&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">verifyCodeKeyByRedis</span> <span class="operator">=</span> redisTemplate.opsForValue().get(verifyCodeKey);</span><br><span class="line">    <span class="keyword">if</span> (verificationCode.equals(verifyCodeKeyByRedis)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;验证成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;验证失败！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getRandomVerificationCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">verificationCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        verificationCode.append(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> verificationCode.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Redis-事务-锁机制-秒杀"><a href="#Redis-事务-锁机制-秒杀" class="headerlink" title="Redis_事务_锁机制_秒杀"></a><strong>Redis_事务_锁机制_秒杀</strong></h1><h2 id="Redis的事务定义"><a href="#Redis的事务定义" class="headerlink" title="Redis的事务定义"></a><strong>Redis的事务定义</strong></h2><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>Redis事务的主要作用就是<strong>串联多个命令</strong>防止别的命令插队。</p>
<h2 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a><strong>Multi</strong>、<strong>Exec</strong>、<strong>discard</strong></h2><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。</p>
<p>组队的过程中可以通过discard来放弃组队。 </p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1-%E6%AD%A3%E5%B8%B8.png" alt="事务-正常"></p>
<h2 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a><strong>事务的错误处理</strong></h2><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1-%E7%BB%84%E9%98%9F%E6%97%B6%E9%94%99%E8%AF%AF.png" alt="事务-组队时错误"></p>
<p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1-%E6%89%A7%E8%A1%8C%E6%97%B6%E5%87%BA%E9%94%99.png" alt="事务-执行时出错"></p>
<h3 id="WATCH-key-key-…"><a href="#WATCH-key-key-…" class="headerlink" title="WATCH key [key …]"></a><strong>WATCH</strong> <strong>key</strong> <strong>[key …]</strong></h3><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key被其他命令所改动，那么事务将被打断。</strong>                              </p>
<h3 id="unwatch"><a href="#unwatch" class="headerlink" title="unwatch"></a><strong>unwatch</strong></h3><p>取消 WATCH 命令对所有 key 的监视。</p>
<p>如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a><strong>Redis持久化</strong></h1><p>Redis 提供了2个不同形式的持久化方式。</p>
<ul>
<li>RDB（Redis DataBase）</li>
<li>AOF（Append Of File）</li>
</ul>
<h2 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a><strong>RDB(Redis DataBase)</strong></h2><p>在指定的<strong>时间间隔</strong>内将内存中的数据集<strong>快照</strong>写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<h3 id="备份是如何执行的"><a href="#备份是如何执行的" class="headerlink" title="备份是如何执行的"></a>备份是如何执行的</h3><p>Redis会单独创建（fork）一个子进程来进行持久化，会<strong>先</strong>将数据<strong>写</strong>入到 一个<strong>临时文件</strong>中，待持久化过程都结束了，再用这个<strong>临时文件替换</strong>上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是<strong>最后一次持久化后的数据可能丢失</strong>。</p>
<h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><ul>
<li>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为<strong>原进程的子进程</strong></li>
<li>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”</li>
<li>一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li>
</ul>
<h3 id="RDB持久化流程"><a href="#RDB持久化流程" class="headerlink" title="RDB持久化流程"></a>RDB持久化流程</h3><p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/RDB%E6%8C%81%E4%B9%85%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt="RDB持久化流程"></p>
<h3 id="如何触发RDB快照；保持策略"><a href="#如何触发RDB快照；保持策略" class="headerlink" title="如何触发RDB快照；保持策略"></a><strong>如何触发RDB快照；保持策略</strong></h3><h4 id="配置文件中默认的快照配置"><a href="#配置文件中默认的快照配置" class="headerlink" title="配置文件中默认的快照配置"></a><strong>配置文件中默认的快照配置</strong></h4><p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/%E9%BB%98%E8%AE%A4%E5%BF%AB%E7%85%A7%E9%85%8D%E7%BD%AE.png" alt="默认快照配置"></p>
<h4 id="命令save-VS-bgsave"><a href="#命令save-VS-bgsave" class="headerlink" title="命令save VS bgsave"></a>命令save VS bgsave</h4><p>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。<br>bgsave：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。<br>可以通过 lastsave 命令获取最后一次成功执行快照的时间</p>
<h4 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h4><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p>
<h4 id="SNAPSHOTTING快照"><a href="#SNAPSHOTTING快照" class="headerlink" title="###SNAPSHOTTING快照###"></a>###SNAPSHOTTING快照###</h4><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>格式：save 秒钟 写操作次数</p>
<p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。</p>
<p>禁用：不设置save指令，或者给save传入空字符串</p>
<h4 id="stop-writes-on-bgsave-error"><a href="#stop-writes-on-bgsave-error" class="headerlink" title="stop-writes-on-bgsave-error"></a>stop-writes-on-bgsave-error</h4><p>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</p>
<h4 id="rdbcompression-压缩文件"><a href="#rdbcompression-压缩文件" class="headerlink" title="rdbcompression 压缩文件"></a>rdbcompression 压缩文件</h4><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。<br>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p>
<h4 id="rdbchecksum-检查完整性"><a href="#rdbchecksum-检查完整性" class="headerlink" title="rdbchecksum 检查完整性"></a>rdbchecksum 检查完整性</h4><p>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。推荐yes.</p>
<h4 id="rdb的备份"><a href="#rdb的备份" class="headerlink" title="rdb的备份"></a>rdb的备份</h4><ul>
<li>先通过config get dir  查询rdb文件的目录 </li>
<li>将*.rdb的文件拷贝到别的地方</li>
</ul>
<h4 id="rdb的恢复"><a href="#rdb的恢复" class="headerlink" title="rdb的恢复"></a>rdb的恢复</h4><ul>
<li>关闭Redis</li>
<li>先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb</li>
<li>启动Redis, 备份数据会直接加载</li>
</ul>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高更适合使用</li>
<li>节省磁盘空间</li>
<li>恢复速度快</li>
</ul>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
<li>虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能</li>
<li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改</li>
</ul>
<h4 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h4><p>动态停止RDB：redis-cli config set save “”   #save后给空值，表示禁用保存策略</p>
<h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/RDB-%E5%B0%8F%E6%80%BB%E7%BB%93.png" alt="RDB-小总结"></p>
<h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a><strong>AOF(Append Only File)</strong></h3><p>以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<h4 id="AOF持久化流程"><a href="#AOF持久化流程" class="headerlink" title="AOF持久化流程"></a>AOF持久化流程</h4><ol>
<li>客户端的请求写命令会被append追加到AOF缓冲区内；</li>
<li>AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</li>
<li>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</li>
<li>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；</li>
</ol>
<h4 id="AOF默认不开启"><a href="#AOF默认不开启" class="headerlink" title="AOF默认不开启"></a>AOF默认不开启</h4><p>可以在redis.conf中配置文件名称，默认为 appendonly.aof<br>AOF文件的保存路径，同RDB的路径一致。</p>
<h4 id="AOF和RDB同时开启，redis听谁的？"><a href="#AOF和RDB同时开启，redis听谁的？" class="headerlink" title="AOF和RDB同时开启，redis听谁的？"></a>AOF和RDB同时开启，redis听谁的？</h4><p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</p>
<h4 id="AOF启动-x2F-修复-x2F-恢复"><a href="#AOF启动-x2F-修复-x2F-恢复" class="headerlink" title="AOF启动&#x2F;修复&#x2F;恢复"></a>AOF启动&#x2F;修复&#x2F;恢复</h4><p>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p>
<p>正常恢复</p>
<ul>
<li>修改默认的appendonly no，改为yes</li>
<li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li>
<li>恢复：重启redis然后重新加载</li>
</ul>
<p>异常恢复</p>
<ul>
<li>修改默认的appendonly no，改为yes</li>
<li>如遇到AOF文件损坏，通过&#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-check-aof–fix appendonly.aof进行恢复</li>
<li>备份被写坏的AOF文件</li>
<li>恢复：重启redis，然后重新加载</li>
</ul>
<h4 id="AOF同步频率设置"><a href="#AOF同步频率设置" class="headerlink" title="AOF同步频率设置"></a>AOF同步频率设置</h4><p>appendfsync always 始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好<br>appendfsync everysec 每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。<br>appendfsync no redis不主动进行同步，把同步时机交给操作系统。</p>
<h4 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a>Rewrite压缩</h4><p>1.是什么：</p>
<p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p>
<p>2.重写原理，如何实现重写<br>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。<br>no-appendfsync-on-rewrite：<br>如果 no-appendfsync-on-rewrite&#x3D;yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）<br>    如果 no-appendfsync-on-rewrite&#x3D;no,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）<br>触发机制，何时重写<br>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发<br>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。<br>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）<br>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。<br>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB<br>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,<br>如果Redis的AOF当前大小&gt;&#x3D; base_size +base_size*100% (默认)且当前大小&gt;&#x3D;64mb(默认)的情况下，Redis会对AOF进行重写。 </p>
<p>3、重写流程<br>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。<br>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。<br>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。<br>（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。<br>（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p>
<img src="/images/Redis学习/AOF-重写流程.png" alt="AOF-重写流程" style="zoom:50%;" />

<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul>
<li>备份机制更稳健，丢失数据概率更低。</li>
<li>可读的日志文本，通过操作AOF稳健，可以处理误操作。</li>
</ul>
<h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li>比起RDB占用更多的磁盘空间。</li>
<li>恢复备份速度要慢。</li>
<li>每次读写都同步的话，有一定的性能压力。</li>
<li>存在个别Bug，造成恢复不能。</li>
</ul>
<h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/AOF-%E5%B0%8F%E6%80%BB%E7%BB%93.png" alt="AOF-小总结"></p>
<h4 id="用哪个好"><a href="#用哪个好" class="headerlink" title="用哪个好"></a>用哪个好</h4><p>官方推荐两个都启用。<br>如果对数据不敏感，可以选单独用RDB。<br>不建议单独用 AOF，因为可能会出现Bug。<br>如果只是做纯内存缓存，可以都不用。</p>
<h4 id="官网建议"><a href="#官网建议" class="headerlink" title="官网建议"></a><strong>官网建议</strong></h4><ul>
<li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li>
<li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. </li>
<li>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</li>
<li>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li>
</ul>
<p>同时开启两种持久化方式</p>
<ul>
<li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li>
</ul>
<p>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ </p>
<ul>
<li>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li>
</ul>
<p>l 性能建议</p>
<blockquote>
<p>因为RDB文件只用作后备用途，建议只在<strong>Slave上持久化RDB文件</strong>，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。     如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。  代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。  只要硬盘许可，应该尽量减少AOF  rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。  默认超过原大小100%大小时重写可以改到适当的数值。  </p>
</blockquote>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h2><ol>
<li>纯内存操作</li>
<li>数据结构简单，底层深度优化</li>
<li>单线程操作，无锁竞争，避免了频繁的上下文切换</li>
<li>采用了非阻塞I&#x2F;O多路复用机制</li>
</ol>
<h2 id="为什么Redis是单线程的"><a href="#为什么Redis是单线程的" class="headerlink" title="为什么Redis是单线程的"></a><strong>为什么Redis是单线程的</strong></h2><p><strong>1.官方答案</strong></p>
<p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<p><strong>2.性能指标</strong></p>
<p>关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>
<p><strong>3.详细原因</strong></p>
<p><strong>1）不需要各种锁的性能消耗</strong></p>
<p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除</p>
<p>一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p>
<p>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p>
<p><strong>2）单线程多进程集群方案</strong></p>
<p>单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p>
<p><strong>所以单线程、多进程的集群不失为一个时髦的解决方案。</strong></p>
<p><strong>3）CPU消耗</strong></p>
<p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p>
<p>但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p>
<p>可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p>
<h2 id="Redis有哪些优缺点"><a href="#Redis有哪些优缺点" class="headerlink" title="Redis有哪些优缺点"></a>Redis有哪些优缺点</h2><p>优点</p>
<ul>
<li>读写性能优异， Redis能读的速度是110000次&#x2F;s，写的速度是81000次&#x2F;s。</li>
<li>支持数据持久化，支持AOF和RDB两种持久化方式。</li>
<li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li>
<li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
<p>缺点</p>
<ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h2 id="Redis-默认支持多少个数据库？怎么修改？"><a href="#Redis-默认支持多少个数据库？怎么修改？" class="headerlink" title="Redis 默认支持多少个数据库？怎么修改？"></a>Redis 默认支持多少个数据库？怎么修改？</h2><p>Redis 默认支持 16 个数据库。</p>
<p>可以通过修改 Redis 配置文件 redis.conf 中的 databases 一值进行变更。</p>
<h2 id="最大Key大小"><a href="#最大Key大小" class="headerlink" title="最大Key大小"></a>最大Key大小</h2><p>512MB，最大value是String的话也是512MB</p>
<h2 id="为什么要用-Redis-x2F-为什么要用缓存"><a href="#为什么要用-Redis-x2F-为什么要用缓存" class="headerlink" title="为什么要用 Redis &#x2F;为什么要用缓存"></a>为什么要用 Redis &#x2F;为什么要用缓存</h2><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<h3 id="高性能："><a href="#高性能：" class="headerlink" title="高性能："></a>高性能：</h3><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<h3 id="高并发："><a href="#高并发：" class="headerlink" title="高并发："></a>高并发：</h3><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<h2 id="Redis有哪些数据类型"><a href="#Redis有哪些数据类型" class="headerlink" title="Redis有哪些数据类型"></a>Redis有哪些数据类型</h2><p>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求</p>
<h2 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h2><ul>
<li>计数器</li>
</ul>
<p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<ul>
<li>缓存</li>
</ul>
<p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<ul>
<li>会话缓存</li>
</ul>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<ul>
<li>全页缓存（FPC）</li>
</ul>
<p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
<ul>
<li>查找表</li>
</ul>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<ul>
<li>消息队列(发布&#x2F;订阅功能)</li>
</ul>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<ul>
<li>分布式锁实现</li>
</ul>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<ul>
<li>其它</li>
</ul>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
<h2 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h2><h3 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h3><p>我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<p>过期策略通常有以下三种：</p>
<ul>
<li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</li>
</ul>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h3 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h3><p>EXPIRE和PERSIST命令。</p>
<h3 id="我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢"><a href="#我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢" class="headerlink" title="我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?"></a>我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<ol>
<li>定时去清理过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ol>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h2><h3 id="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</h3><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h3 id="Redis的内存淘汰策略有哪些"><a href="#Redis的内存淘汰策略有哪些" class="headerlink" title="Redis的内存淘汰策略有哪些"></a>Redis的内存淘汰策略有哪些</h3><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<p>全局的键空间选择性移除</p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
</ul>
<p>设置过期时间的键空间选择性移除</p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p>
<h3 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h3><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<h3 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h3><p>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面</p>
<h2 id="事务相关"><a href="#事务相关" class="headerlink" title="事务相关"></a>事务相关</h2><h3 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h3><p>Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<h3 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
<h3 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h3><p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h2 id="集群相关"><a href="#集群相关" class="headerlink" title="集群相关"></a>集群相关</h2><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="哨兵模式结构图"></p>
<p>哨兵的介绍</p>
<p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<p>哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<ul>
<li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li>
</ul>
<p>哨兵的核心知识</p>
<ul>
<li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li>
<li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</li>
<li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
</ul>
<h3 id="Redis-主从架构"><a href="#Redis-主从架构" class="headerlink" title="Redis 主从架构"></a>Redis 主从架构</h3><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。</p>
<p>redis-master-slave</p>
<p>redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p>
<p>redis replication 的核心机制</p>
<ul>
<li>redis 采用异步方式复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li>
<li>一个 master node 是可以配置多个 slave node 的；</li>
<li>slave node 也可以连接其他的 slave node；</li>
<li>slave node 做复制的时候，不会 block master node 的正常工作；</li>
<li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li>
<li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li>
</ul>
<p>注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</p>
<p>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p>
<h2 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h2><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p>
<p>当且仅当 key 不存在，将 key 的值设为 value。若给定的 key 已经存在，则 SETNX 不做任何动作</p>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>返回值：设置成功，返回 1 。设置失败，返回 0 。</p>
<ul>
<li><p>使用SETNX完成同步锁的流程及事项如下：</p>
<p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</p>
<p>为了防止获取锁后程序出现异常，导致其他线程&#x2F;进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p>
</li>
<li><p>释放锁，使用DEL命令将锁数据删除</p>
</li>
</ul>
<h3 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h3><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p>
<p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
<p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p>
<h3 id="分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>分布式Redis是前期做还是后期规模上来了再做好？为什么？</h3><p>既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p>
<h3 id="什么是-RedLock"><a href="#什么是-RedLock" class="headerlink" title="什么是 RedLock"></a>什么是 RedLock</h3><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 <em>Redlock</em>，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li>
<li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li>
</ol>
<h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案</p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</li>
</ol>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案</p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p>解决方案</p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，互斥锁</li>
</ol>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作一下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h3 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h3 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h3><p>热点数据，缓存才有价值</p>
<p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</p>
<p>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p>
<p>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p>
<p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p>
<h3 id="缓存热点key"><a href="#缓存热点key" class="headerlink" title="缓存热点key"></a>缓存热点key</h3><p>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p><strong>解决方案</strong></p>
<p>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询</p>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>Redis支持的Java客户端都有哪些？官方推荐用哪个？</h3><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>
<h3 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h3><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, HyperLogLog)。</p>
<h3 id="Jedis与Redisson对比有什么优缺点？"><a href="#Jedis与Redisson对比有什么优缺点？" class="headerlink" title="Jedis与Redisson对比有什么优缺点？"></a>Jedis与Redisson对比有什么优缺点？</h3><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h3><p>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/Redis%E4%B8%8EMemcached%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="Redis与Memcached的区别"></p>
<p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p>
<p>(2) redis的速度比memcached快很多</p>
<p>(3) redis可以持久化其数据</p>
<ul>
<li>Redis和Memcached都是将数据存放在内存中，都是内存数据库，不过memcache还用于缓存其他东西，例如：图片、视频等等</li>
<li>Redis不仅仅支持简单的k&#x2F;v类型的数据，同时还提供list、set、hash等数据结构的存储</li>
<li>虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value交换到磁盘</li>
<li>过期策略–memcache在set时就指定，例如set key1 0 0 8，即永不过期。Redis可以通过例如expire设定，例如expire name 10；</li>
<li>分布式–设定memcached集群，利用magent做一主多从；redis可以做一主多从。都可以一主一从</li>
<li>存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）</li>
<li>灾难恢复–memcached挂掉后，数据不可恢复；redis数据丢失后可以通过aof恢复</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份</li>
<li>memcached是高性能的分布式内存缓存服务器。<em>一般使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态web应用的速度、提高可扩展性。</em></li>
<li>redis是一个开源的内存<a href="http://lib.csdn.net/base/mysql">数据库</a>，它以键值对的形式存储数据。由于数据存储在内存中，因此Redis的速度很快，但是每次重启Redis服务时，其中的数据也会丢失，因此，Redis也提供了持久化存储机制，将数据以某种形式保存在文件中，每次重启时，可以自动从文件加载数据到内存当中。</li>
</ul>
<h3 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h3><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p>
<p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是<strong>先更新数据库，然后再删除缓存。</strong></p>
<p><img src="/images/Redis%E5%AD%A6%E4%B9%A0/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%97%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7.png" alt="缓存与数据库双写时数据的一致性"></p>
<h3 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h3><ol>
<li>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库</li>
<li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li>
<li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li>
</ol>
<h3 id="一个字符串类型的值能存储最大容量是多少？"><a href="#一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="一个字符串类型的值能存储最大容量是多少？"></a>一个字符串类型的值能存储最大容量是多少？</h3><p>512M</p>
<h3 id="Redis如何做大量数据插入？"><a href="#Redis如何做大量数据插入？" class="headerlink" title="Redis如何做大量数据插入？"></a>Redis如何做大量数据插入？</h3><p>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p>
<h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。</p>
<p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p>
<p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h3 id="Redis回收进程如何工作的？"><a href="#Redis回收进程如何工作的？" class="headerlink" title="Redis回收进程如何工作的？"></a>Redis回收进程如何工作的？</h3><ol>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
</ol>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<h3 id="Redis回收使用的是什么算法？"><a href="#Redis回收使用的是什么算法？" class="headerlink" title="Redis回收使用的是什么算法？"></a>Redis回收使用的是什么算法？</h3><p>LRU算法，LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<h2 id="Redis如何统计独立用户访问量"><a href="#Redis如何统计独立用户访问量" class="headerlink" title="Redis如何统计独立用户访问量"></a>Redis如何统计独立用户访问量</h2><h3 id="使用Hash"><a href="#使用Hash" class="headerlink" title="使用Hash"></a><strong>使用Hash</strong></h3><p>哈希是Redis的一种基础数据结构，Redis底层维护的是一个开散列，会把不同的key映射到哈希表上，如果是遇到关键字冲突，那么就会拉出一个链表出来。</p>
<p>当一个用户访问的时候，如果用户登陆过，那么我们就使用用户的id，如果用户没有登陆过，那么我们也能够前端页面随机生成一个key用来标识用户，当用户访问的时候，我们可以使用<strong>HSET</strong>命令，key可以选择URI与对应的日期进行拼凑，field可以使用用户的id或者随机标识，value可以简单设置为1。</p>
<p>当我们要统计某一个网站某一天的访问量的时候，就可以直接使用<strong>HLEN</strong>来得到最终的结果了。</p>
<p><strong>优点：</strong>简单，容易实现，查询也是非常方便，数据准确性非常高。</p>
<p><strong>缺点：</strong>占用内存过大，。随着key的增多，性能也会下降。小网站还行，拼多多这种数亿PV的网站肯定受不了</p>
<h3 id="使用Bitset"><a href="#使用Bitset" class="headerlink" title="使用Bitset"></a><strong>使用Bitset</strong></h3><p>我们知道，对于一个32位的int，如果我们只用来记录id，那么只能够记录一个用户，但如果我们转成2进制，每位用来表示一个用户，那么我们就能够一口气表示32个用户，空间节省了32倍！对于有大量数据的场景，如果我们使用bitset，那么，可以节省非常多的内存。对于没有登陆的用户，我们也可以使用哈希算法，把对应的用户标识哈希成一个数字id。bitset非常的节省内存，假设有1亿个用户，也只需要100000000&#x2F;8&#x2F;1024&#x2F;1024约等于12兆内存。</p>
<p>Redis已经为我们提供了SETBIT的方法，使用起来非常的方便，我们可以看看下面的例子，我们在item页面可以不停地使用SETBIT命令，设置用户已经访问了该页面，也可以使用GETBIT的方法查询某个用户是否访问。最后我们通过BITCOUNT可以统计该网页每天的访问数量。</p>
<p><strong>优点</strong>占用内存更小，查询方便，可以指定查询某个用户，数据可能略有瑕疵，对于非登陆的用户，可能不同的key映射到同一个id，否则需要维护一个非登陆用户的映射，有额外的开销。</p>
<p><strong>缺点</strong>如果用户非常的稀疏，那么占用的内存可能比方法一更大。</p>
<h3 id="使用概率算法"><a href="#使用概率算法" class="headerlink" title="使用概率算法"></a><strong>使用概率算法</strong></h3><p>对于拼多多这种多个页面都可能非常多访问量的网站，如果所需要的数量不用那么准确，可以使用概率算法，事实上，我们对一个网站的UV的统计，1亿跟1亿零30万其实是差不多的。在Redis中，已经封装了HyperLogLog算法，他是一种基数评估算法。这种算法的特征，一般都是数据不存具体的值，而是存用来计算概率的一些相关数据。</p>
<p>当用户访问网站的时候，我们可以使用<strong>PFADD</strong>命令，设置对应的命令，最后我们只要通过<strong>PFCOUNT</strong>就能顺利计算出最终的结果，因为这个只是一个概率算法，所以可能存在0.81%的误差。</p>
<p><strong>优点</strong>占用内存极小，对于一个key，只需要12kb。对于拼多多这种超多用户的特别适用。</p>
<p><strong>缺点</strong>查询指定用户的时候，可能会出错，毕竟存的不是具体的数据。总数也存在一定的误差。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-中介模式</title>
    <url>/2022/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="中介模式的原理和实现"><a href="#中介模式的原理和实现" class="headerlink" title="中介模式的原理和实现"></a>中介模式的原理和实现</h1><p>中介模式的英文翻译是 Mediator Design Pattern。在 GoF 中的《设计模式》一书中，它是这样定义的：</p>
<blockquote>
<p>Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.</p>
</blockquote>
<p>翻译成中文就是：中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p>
<span id="more"></span>

<p>实际上，中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p>
<p><img src="/../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AF%B9%E6%AF%94%E5%9B%BE.png" alt="对象交互关系的对比图"></p>
<p>提到中介模式，有一个比较经典的例子不得不说，那就是航空管制。为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位</p>
<p>假设我们有一个比较复杂的对话框，对话框中有很多控件，比如按钮、文本框、下拉框等。当我们对某个控件进行操作的时候，其他控件会做出相应的反应，比如，我们在下拉框中选择“注册”，注册相关的控件就会显示在对话框中。如果我们在下拉框中选择“登陆”，登陆相关的控件就会显示在对话框中。</p>
<p>用中介模式来实现的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">handleEvent</span><span class="params">(Component component, String event)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LandingPageDialog</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Button loginButton;</span><br><span class="line">  <span class="keyword">private</span> Button regButton;</span><br><span class="line">  <span class="keyword">private</span> Selection selection;</span><br><span class="line">  <span class="keyword">private</span> Input usernameInput;</span><br><span class="line">  <span class="keyword">private</span> Input passwordInput;</span><br><span class="line">  <span class="keyword">private</span> Input repeatedPswdInput;</span><br><span class="line">  <span class="keyword">private</span> Text hintText;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleEvent</span><span class="params">(Component component, String event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (component.equals(loginButton)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> usernameInput.text();</span><br><span class="line">      <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> passwordInput.text();</span><br><span class="line">      <span class="comment">//校验数据...</span></span><br><span class="line">      <span class="comment">//做业务处理...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (component.equals(regButton)) &#123;</span><br><span class="line">      <span class="comment">//获取usernameInput、passwordInput、repeatedPswdInput数据...</span></span><br><span class="line">      <span class="comment">//校验数据...</span></span><br><span class="line">      <span class="comment">//做业务处理...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (component.equals(selection)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">selectedItem</span> <span class="operator">=</span> selection.select();</span><br><span class="line">      <span class="keyword">if</span> (selectedItem.equals(<span class="string">&quot;login&quot;</span>)) &#123;</span><br><span class="line">        usernameInput.show();</span><br><span class="line">        passwordInput.show();</span><br><span class="line">        repeatedPswdInput.hide();</span><br><span class="line">        hintText.hide();</span><br><span class="line">        <span class="comment">//...省略其他代码</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectedItem.equals(<span class="string">&quot;register&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UIControl</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_BTN_ID</span> <span class="operator">=</span> <span class="string">&quot;login_btn&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REG_BTN_ID</span> <span class="operator">=</span> <span class="string">&quot;reg_btn&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME_INPUT_ID</span> <span class="operator">=</span> <span class="string">&quot;username_input&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD_INPUT_ID</span> <span class="operator">=</span> <span class="string">&quot;pswd_input&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REPEATED_PASSWORD_INPUT_ID</span> <span class="operator">=</span> <span class="string">&quot;repeated_pswd_input&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HINT_TEXT_ID</span> <span class="operator">=</span> <span class="string">&quot;hint_text&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SELECTION_ID</span> <span class="operator">=</span> <span class="string">&quot;selection&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Button</span> <span class="variable">loginButton</span> <span class="operator">=</span> (Button)findViewById(LOGIN_BTN_ID);</span><br><span class="line">    <span class="type">Button</span> <span class="variable">regButton</span> <span class="operator">=</span> (Button)findViewById(REG_BTN_ID);</span><br><span class="line">    <span class="type">Input</span> <span class="variable">usernameInput</span> <span class="operator">=</span> (Input)findViewById(USERNAME_INPUT_ID);</span><br><span class="line">    <span class="type">Input</span> <span class="variable">passwordInput</span> <span class="operator">=</span> (Input)findViewById(PASSWORD_INPUT_ID);</span><br><span class="line">    <span class="type">Input</span> <span class="variable">repeatedPswdInput</span> <span class="operator">=</span> (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);</span><br><span class="line">    <span class="type">Text</span> <span class="variable">hintText</span> <span class="operator">=</span> (Text)findViewById(HINT_TEXT_ID);</span><br><span class="line">    <span class="type">Selection</span> <span class="variable">selection</span> <span class="operator">=</span> (Selection)findViewById(SELECTION_ID);</span><br><span class="line"></span><br><span class="line">    <span class="type">Mediator</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LandingPageDialog</span>();</span><br><span class="line">    dialog.setLoginButton(loginButton);</span><br><span class="line">    dialog.setRegButton(regButton);</span><br><span class="line">    dialog.setUsernameInput(usernameInput);</span><br><span class="line">    dialog.setPasswordInput(passwordInput);</span><br><span class="line">    dialog.setRepeatedPswdInput(repeatedPswdInput);</span><br><span class="line">    dialog.setHintText(hintText);</span><br><span class="line">    dialog.setSelection(selection);</span><br><span class="line"></span><br><span class="line">    loginButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        dialog.handleEvent(loginButton, <span class="string">&quot;click&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    regButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        dialog.handleEvent(regButton, <span class="string">&quot;click&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中我们可以看出，原本业务逻辑会分散在各个控件中，现在都集中到了中介类中。实际上，这样做既有好处，也有坏处。好处是简化了控件之间的交互，坏处是中介类有可能会变成大而复杂的“上帝类”（God Class）。所以，在使用中介模式的时候，我们要根据实际的情况，平衡对象之间交互的复杂度和中介类本身的复杂度。</p>
<h1 id="中介模式-VS-观察者模式"><a href="#中介模式-VS-观察者模式" class="headerlink" title="中介模式 VS 观察者模式"></a>中介模式 VS 观察者模式</h1><p>前面讲观察者模式的时候，我们讲到，观察者模式有多种实现方式。虽然经典的实现方式没法彻底解耦观察者和被观察者，观察者需要注册到被观察者中，被观察者状态更新需要调用观察者的 update() 方法。但是，在跨进程的实现方式中，我们可以利用消息队列实现彻底解耦，观察者和被观察者都只需要跟消息队列交互，观察者完全不知道被观察者的存在，被观察者也完全不知道观察者的存在。</p>
<p>中介模式也是为了解耦对象之间的交互，所有的参与者都只与中介进行交互。而观察者模式中的消息队列，就有点类似中介模式中的“中介”，观察者模式的中观察者和被观察者，就有点类似中介模式中的“参与者”。那问题来了：中介模式和观察者模式的区别在哪里呢？什么时候选择使用中介模式？什么时候选择使用观察者模式呢？</p>
<p>在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理。</p>
<p>而中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，前面也讲到，它有可能会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库知识</title>
    <url>/2021/07/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h1><p>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般来说，数据库只需满足第三范式(3NF）就行了。</p>
<span id="more"></span>

<h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 1NF"></a><strong>第一范式 1NF</strong></h2><p><strong>定义：</strong> 属于第一范式关系的所有属性都不可再分，即数据项不可分。</p>
<p><strong>理解：</strong> 第一范式强调数据表的原子性，是其他范式的基础。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F.png" alt="第一范式"></p>
<h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 2NF"></a><strong>第二范式 2NF</strong></h2><p>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</p>
<p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F.png" alt="第二范式"></p>
<h2 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 3NF"></a><strong>第三范式 3NF</strong></h2><p>在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</p>
<p>第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F.png" alt="第三范式"></p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行 。事务是一个不可分割的工作逻辑单元 事务必须具备以下四个属性，简称 ACID 属性：</p>
<ol>
<li><p>原子性（<strong>Atomicity</strong>） </p>
<p>事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执行。</p>
</li>
<li><p>一致性（<strong>Consistency</strong>） </p>
<p>当事务完成时，数据必须处于一致状态。</p>
</li>
<li><p>隔离性（<strong>Isolation</strong>） </p>
<p>对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。</p>
</li>
<li><p>持久性（<strong>Durability</strong>） </p>
<p>事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。</p>
</li>
</ol>
<h1 id="数据库并发策略"><a href="#数据库并发策略" class="headerlink" title="数据库并发策略"></a>数据库并发策略</h1><p>并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据;悲观锁就刚好相反，觉得自 己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度;时间 戳就是不加锁，通过时间戳来控制并发出现的问题。</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加 锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数 据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允 许其他用户访问那部分数据。</p>
<h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字 段也读出来，当写回去的时候，把该字段加 1，提交之前 ，跟数据库的该字段比较一次，如果比数 据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁 机制，但是这种方法可以大大提高数据库处理的并发量，</p>
<p>以上悲观锁所说的加“锁”，其实分为几种锁，分别是:排它锁(写锁)和共享锁(读锁)。 </p>
<h1 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h1><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁是一种排他锁，防止其他事务修改此行;在使用以下语句时，Oracle 会自动应用行级锁:</p>
<ol>
<li>INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];</li>
<li>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新</li>
<li>使用 COMMIT 或 ROLLBACK 语句释放锁。</li>
</ol>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使 用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁(共享锁)与表独占写锁 (排他锁)。</p>
<h2 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h2><p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁</p>
<h2 id="基于-Redis-分布式锁"><a href="#基于-Redis-分布式锁" class="headerlink" title="基于 Redis 分布式锁"></a>基于 <strong>Redis</strong> 分布式锁</h2><ol>
<li>获取锁的时候，使用 setnx(SETNX key val:当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1;若 key 存在，则什么都不做，返回 0)加锁，锁的 value 值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添 加一个超时时间，超过该时间则自动释放锁。</li>
<li>获取锁的时候调用 setnx，如果返回 0，则该锁正在被别人使用，返回 1 则成功获取 锁。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ol>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="MySQL-有哪些数据类型？"><a href="#MySQL-有哪些数据类型？" class="headerlink" title="MySQL 有哪些数据类型？"></a>MySQL 有哪些数据类型？</h2><p>MySQL 支持多种类型，大致可以分为三类：数值、日期&#x2F;时间和字符串(字符)类型。具体可以看看 <a href="http://www.runoob.com/mysql/mysql-data-types.html">《MySQL 数据类型》</a> 文档。</p>
<ul>
<li>正确的使用数据类型，对数据库的优化是非常重要的。</li>
</ul>
<h3 id="MySQL-中-varchar-与-char-的区别？varchar-50-中的-50-代表的涵义？"><a href="#MySQL-中-varchar-与-char-的区别？varchar-50-中的-50-代表的涵义？" class="headerlink" title="MySQL 中 varchar 与 char 的区别？varchar(50) 中的 50 代表的涵义？"></a><strong>MySQL 中 varchar 与 char 的区别？varchar(50) 中的 50 代表的涵义？</strong></h3><ul>
<li><p>1、varchar 与 char 的区别，char 是一种固定长度的类型，varchar 则是一种可变长度的类型。</p>
</li>
<li><p>2、varchar(50) 中 50 的涵义最多存放 50 个字符。varchar(50) 和 (200) 存储 hello 所占空间一样，</p>
<p>但后者在排序时会消耗更多内存，因为 <code>ORDER BY col</code> 采用 fixed_length 计算 col 长度(memory引擎也一样)。</p>
<blockquote>
<p>所以，实际场景下，选择合适的 varchar 长度还是有必要的。</p>
</blockquote>
</li>
</ul>
<h3 id="int-11-中的-11-代表什么涵义？"><a href="#int-11-中的-11-代表什么涵义？" class="headerlink" title="int(11) 中的 11 代表什么涵义？"></a><strong>int(11) 中的 11 代表什么涵义？</strong></h3><p>int(11) 中的 11 ，不影响字段存储的范围，只影响展示效果。具体可以看看 <a href="https://blog.csdn.net/qmhball/article/details/51544484">《MySQL 中 int 长度的意义》</a> 文章。</p>
<h3 id="金额-金钱-相关的数据，选择什么数据类型？"><a href="#金额-金钱-相关的数据，选择什么数据类型？" class="headerlink" title="金额(金钱)相关的数据，选择什么数据类型？"></a><strong>金额(金钱)相关的数据，选择什么数据类型？</strong></h3><ul>
<li>方式一，使用 int 或者 bigint 类型。如果需要存储到分的维度，需要 *100 进行放大。</li>
<li>方式二，使用 decimal 类型，避免精度丢失。如果使用 Java 语言时，需要使用 BigDecimal 进行对应。</li>
</ul>
<h3 id="一张表，里面有-ID-自增主键，当-insert-了-17-条记录之后，删除了第-15-16-17-条记录，再把-MySQL-重启，再-insert-一条记录，这条记录的-ID-是-18-还是-15？"><a href="#一张表，里面有-ID-自增主键，当-insert-了-17-条记录之后，删除了第-15-16-17-条记录，再把-MySQL-重启，再-insert-一条记录，这条记录的-ID-是-18-还是-15？" class="headerlink" title="一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 MySQL 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15？"></a><strong>一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 MySQL 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15？</strong></h3><ul>
<li>一般情况下，我们创建的表的类型是 InnoDB ，如果新增一条记录（不重启 MySQL 的情况下），这条记录的 ID 是18 ；但是如果重启 MySQL 的话，这条记录的 ID 是 15 。因为 InnoDB 表只把自增主键的最大 ID 记录到内存中，所以重启数据库或者对表 OPTIMIZE 操作，都会使最大 ID 丢失。</li>
<li>但是，如果我们使用表的类型是 MyISAM ，那么这条记录的 ID 就是 18 。因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里面，重启 MYSQL 后，自增主键的最大 ID 也不会丢失。</li>
</ul>
<p>最后，还可以跟面试官装个 x ，生产数据，不建议进行物理删除记录。</p>
<h3 id="表中有大字段-X-例如：text-类型-，且字段-X-不会经常更新，以读为为主，请问您是选择拆成子表，还是继续放一起-写出您这样选择的理由"><a href="#表中有大字段-X-例如：text-类型-，且字段-X-不会经常更新，以读为为主，请问您是选择拆成子表，还是继续放一起-写出您这样选择的理由" class="headerlink" title="表中有大字段 X(例如：text 类型)，且字段 X 不会经常更新，以读为为主，请问您是选择拆成子表，还是继续放一起?写出您这样选择的理由"></a><strong>表中有大字段 X(例如：text 类型)，且字段 X 不会经常更新，以读为为主，请问您是选择拆成子表，还是继续放一起?写出您这样选择的理由</strong></h3><ul>
<li><p>拆带来的问题：连接消耗 + 存储拆分空间。</p>
<blockquote>
<p>如果能容忍拆分带来的空间问题，拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序 IO ，减少连接消耗，最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗。</p>
</blockquote>
</li>
<li><p>不拆可能带来的问题：查询性能。</p>
<blockquote>
<p>如果能容忍不拆分带来的查询性能损失的话，上面的方案在某个极致条件下肯定会出现问题，那么不拆就是最好的选择。</p>
</blockquote>
</li>
</ul>
<p>实际场景下，例如说商品表数据量比较大的情况下，会将商品描述单独存储到一个表中。即，使用拆的方案。</p>
<h2 id="MySQL-有哪些存储引擎？"><a href="#MySQL-有哪些存储引擎？" class="headerlink" title="MySQL 有哪些存储引擎？"></a>MySQL 有哪些存储引擎？</h2><p>MySQL 提供了多种的存储引擎：</p>
<ul>
<li>InnoDB</li>
<li>MyISAM</li>
<li>MRG_MYISAM</li>
<li>MEMORY</li>
<li>CSV</li>
<li>ARCHIVE</li>
<li>BLACKHOLE</li>
<li>PERFORMANCE_SCHEMA</li>
<li>FEDERATED</li>
<li>…</li>
</ul>
<p>具体每种存储引擎的介绍，可以看看 <a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md">《数据库存储引擎》</a> 。</p>
<h3 id="如何选择合适的存储引擎？"><a href="#如何选择合适的存储引擎？" class="headerlink" title="如何选择合适的存储引擎？"></a><strong>如何选择合适的存储引擎？</strong></h3><p>提供几个选择标准，然后按照标准，选择对应的存储引擎即可，也可以根据 <a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E5%B8%B8%E7%94%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94">常用引擎对比</a> 来选择你使用的存储引擎。使用哪种引擎需要根据需求灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎，将会提高整个数据库的性能。</p>
<ol>
<li><p>是否需要支持事务。</p>
</li>
<li><p>对索引和缓存的支持。</p>
</li>
<li><p>是否需要使用热备。</p>
</li>
<li><p>崩溃恢复，能否接受崩溃。</p>
</li>
<li><p>存储的限制。</p>
</li>
<li><p>是否需要外键支持。</p>
<blockquote>
<p>目前开发已经不考虑外键，主要原因是性能。具体可以看看 <a href="http://www.justabug.net/think-in-mysql-foreign-key/">《从 MySQL 物理外键开始的思考》</a> 文章。</p>
</blockquote>
</li>
</ol>
<p>目前，MySQL 默认的存储引擎是 InnoDB ，并且也是最主流的选择。主要原因如下：</p>
<ul>
<li>【最重要】支持事务。</li>
<li>支持行级锁和表级锁，能支持更多的并发量。</li>
<li>查询不加锁，完全不影响查询。</li>
<li>支持崩溃后恢复。</li>
</ul>
<p>在 MySQL5.1 以及之前的版本，默认的存储引擎是 MyISAM ，但是目前已经不再更新，且它有几个比较关键的缺点：</p>
<ul>
<li>不支持事务。</li>
<li>使用表级锁，如果数据量大，一个插入操作锁定表后，其他请求都将阻塞。</li>
</ul>
<h3 id="请说明-InnoDB-和-MyISAM-的区别"><a href="#请说明-InnoDB-和-MyISAM-的区别" class="headerlink" title="请说明 InnoDB 和 MyISAM 的区别"></a><strong>请说明 InnoDB 和 MyISAM 的区别</strong></h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">InnoDB</th>
<th align="left">MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td align="left">事务</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">存储限制</td>
<td align="left">64TB</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">锁粒度</td>
<td align="left">行锁</td>
<td align="left">表锁</td>
</tr>
<tr>
<td align="left">崩溃后的恢复</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">外键</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">全文检索</td>
<td align="left">5.7 版本后支持</td>
<td align="left">支持</td>
</tr>
</tbody></table>
<h3 id="请说说-InnoDB-的-4-大特性"><a href="#请说说-InnoDB-的-4-大特性" class="headerlink" title="请说说 InnoDB 的 4 大特性"></a><strong>请说说 InnoDB 的 4 大特性</strong></h3><ul>
<li>插入缓冲(insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<h3 id="为什么-SELECT-COUNT-FROM-table-在-InnoDB-比-MyISAM-慢？"><a href="#为什么-SELECT-COUNT-FROM-table-在-InnoDB-比-MyISAM-慢？" class="headerlink" title="为什么 SELECT COUNT(*) FROM table 在 InnoDB 比 MyISAM 慢？"></a><strong>为什么 SELECT COUNT(*) FROM table 在 InnoDB 比 MyISAM 慢？</strong></h3><p>对于 <code>SELECT COUNT(*) FROM table</code> 语句，在没有 <code>WHERE</code> 条件的情况下，InnoDB 比 MyISAM 可能会慢很多，尤其在大表的情况下。因为，InnoDB 是去实时统计结果，会全表扫描；而 MyISAM 内部维持了一个计数器，预存了结果，所以直接返回即可。</p>
<p>详细的原因，胖友可以看看 <a href="https://blog.csdn.net/qq_15037231/article/details/81179383">《高性能 MySQL 之 Count 统计查询》</a> 博客。</p>
<h3 id="各种不同-MySQL-版本的-Innodb-的改进？-了解"><a href="#各种不同-MySQL-版本的-Innodb-的改进？-了解" class="headerlink" title="各种不同 MySQL 版本的 Innodb 的改进？(了解)"></a><strong>各种不同 MySQL 版本的 Innodb 的改进？(了解)</strong></h3><p>MySQL5.6 下 Innodb 引擎的主要改进：</p>
<ol>
<li>online DDL</li>
<li>memcached NoSQL 接口</li>
<li>transportable tablespace（ alter table discard&#x2F;import tablespace）</li>
<li>MySQL 正常关闭时，可以 dump 出 buffer pool 的（ space， page_no），重启时 reload，加快预热速度</li>
<li>索引和表的统计信息持久化到 mysql.innodb_table_stats 和 mysql.innodb_index_stats，可提供稳定的执行计划</li>
<li>Compressed row format 支持压缩表</li>
</ol>
<p>MySQL5.7 下 Innodb 引擎的主要改进：</p>
<ul>
<li><p>1、修改 varchar 字段长度有时可以使用</p>
<blockquote>
<p>这里的“有时”，指的是也有些限制。可见 <a href="https://yq.aliyun.com/articles/581726">《MySQL 5.7 online ddl 的一些改进》</a> 。</p>
</blockquote>
</li>
<li><p>2、Buffer pool 支持在线改变大小</p>
</li>
<li><p>3、Buffer pool 支持导出部分比例</p>
</li>
<li><p>4、支持新建 innodb tablespace，并可以在其中创建多张表</p>
</li>
<li><p>5、磁盘临时表采用 innodb 存储，并且存储在 innodb temp tablespace 里面，以前是 MyISAM 存储</p>
</li>
<li><p>6、透明表空间压缩功能</p>
</li>
</ul>
<h2 id="【重点】什么是索引？"><a href="#【重点】什么是索引？" class="headerlink" title="【重点】什么是索引？"></a>【重点】什么是索引？</h2><p>索引，类似于书籍的目录，想找到一本书的某个特定的主题，需要先找到书的目录，定位对应的页码。</p>
<p>MySQL 中存储引擎使用类似的方式进行查询，先去索引中查找对应的值，然后根据匹配的索引找到对应的数据行。</p>
<h3 id="索引有什么好处？"><a href="#索引有什么好处？" class="headerlink" title="索引有什么好处？"></a><strong>索引有什么好处？</strong></h3><ol>
<li>提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。</li>
<li>降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则正好降低了排序的成本。</li>
</ol>
<h3 id="索引有什么坏处？"><a href="#索引有什么坏处？" class="headerlink" title="索引有什么坏处？"></a><strong>索引有什么坏处？</strong></h3><ol>
<li>占用存储空间：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。</li>
<li>降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更，从而减低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。</li>
</ol>
<h3 id="索引的使用场景？"><a href="#索引的使用场景？" class="headerlink" title="索引的使用场景？"></a><strong>索引的使用场景？</strong></h3><ul>
<li><p>1、对非常小的表，大部分情况下全表扫描效率更高。</p>
</li>
<li><p>2、对中大型表，索引非常有效。</p>
</li>
<li><p>3、特大型的表，建立和使用索引的代价随着增长，可以使用分区技术来解决。</p>
<blockquote>
<p>实际场景下，MySQL 分区表很少使用，原因可以看看 <a href="https://blog.csdn.net/admin1973/article/details/55504018">《互联网公司为啥不使用 MySQL 分区表？》</a> 文章。</p>
<p>对于特大型的表，更常用的是“分库分表”，目前解决方案有 Sharding Sphere、MyCAT 等等。</p>
</blockquote>
</li>
</ul>
<h3 id="索引的类型？"><a href="#索引的类型？" class="headerlink" title="索引的类型？"></a><strong>索引的类型？</strong></h3><p>索引，都是实现在存储引擎层的。主要有六种类型：</p>
<ul>
<li><p>1、普通索引：最基本的索引，没有任何约束。</p>
</li>
<li><p>2、唯一索引：与普通索引类似，但具有唯一性约束。</p>
</li>
<li><p>3、主键索引：特殊的唯一索引，不允许有空值。</p>
</li>
<li><p>4、复合索引：将多个列组合在一起创建索引，可以覆盖多个列。</p>
</li>
<li><p>5、外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。</p>
</li>
<li><p>6、全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎。</p>
<blockquote>
<p>常用的全文索引引擎的解决方案有 Elasticsearch、Solr 等等。最为常用的是 Elasticsearch 。</p>
</blockquote>
</li>
</ul>
<p>具体的使用，可以看看 <a href="http://blog.720ui.com/2017/mysql_core_03_how_use_index/">《服务端指南 数据存储篇 | MySQL（03） 如何设计索引》</a> 。</p>
<h3 id="MySQL-索引的“创建”原则？"><a href="#MySQL-索引的“创建”原则？" class="headerlink" title="MySQL 索引的“创建”原则？"></a><strong>MySQL 索引的“创建”原则？</strong></h3><ul>
<li><p>1、最适合索引的列是出现在 <code>WHERE</code> 子句中的列，或连接子句中的列，而不是出现在 <code>SELECT</code> 关键字后的列。</p>
</li>
<li><p>2、索引列的基数越大，索引效果越好。</p>
<blockquote>
<p>具体为什么，可以看看如下两篇文章：</p>
<ul>
<li><a href="https://blog.csdn.net/mingyundezuoan/article/details/79038989">《MySQL 索引基数》</a> 理解相对简单</li>
<li><a href="https://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1309cardinal/index.html">《低基数索引为什么会对性能产生负面影响》</a> 写的更原理，所以较为难懂。</li>
</ul>
</blockquote>
</li>
<li><p>3、根据情况创建复合索引，复合索引可以提高查询效率。</p>
<blockquote>
<p>因为复合索引的基数会更大。</p>
</blockquote>
</li>
<li><p>4、避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率。</p>
</li>
<li><p>5、主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用提高查询效率。</p>
</li>
<li><p>6、对字符串进行索引，应该定制一个前缀长度，可以节省大量的索引空间。</p>
</li>
</ul>
<h3 id="MySQL-索引的“使用”注意事项？"><a href="#MySQL-索引的“使用”注意事项？" class="headerlink" title="MySQL 索引的“使用”注意事项？"></a><strong>MySQL 索引的“使用”注意事项？</strong></h3><ul>
<li><p>1、应尽量避免在 <code>WHERE</code> 子句中使用 <code>!=</code> 或 <code>&lt;&gt;</code> 操作符，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。</p>
<blockquote>
<p>注意，<code>column IS NULL</code> 也是不可以使用索引的。</p>
</blockquote>
</li>
<li><p>2、应尽量避免在 <code>WHERE</code> 子句中使用 <code>OR</code> 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：<code>SELECT id FROM t WHERE num = 10 OR num = 20</code> 。</p>
</li>
<li><p>3、应尽量避免在 <code>WHERE</code> 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</p>
</li>
<li><p>4、应尽量避免在 <code>WHERE</code> 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</p>
</li>
<li><p>5、不要在 <code>WHERE</code> 子句中的 <code>=</code> 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
<li><p>6、复合索引遵循前缀原则。</p>
</li>
<li><p>7、如果 MySQL 评估使用索引比全表扫描更慢，会放弃使用索引。如果此时想要索引，可以在语句中添加强制索引。</p>
</li>
<li><p>8、列类型是字符串类型，查询时一定要给值加引号，否则索引失效。</p>
</li>
<li><p>9、<code>LIKE</code>查询，<code>%</code>不能在前，因为无法使用索引。如果需要模糊匹配，可以使用全文索引。</p>
</li>
</ul>
<p>关于这块，可以看看 <a href="http://blog.720ui.com/2017/mysql_core_04_index_item/">《服务端指南 数据存储篇 | MySQL（04） 索引使用的注意事项》</a> 文章，写的更加细致。</p>
<h3 id="以下三条-SQL-如何建索引，只建一条怎么建？"><a href="#以下三条-SQL-如何建索引，只建一条怎么建？" class="headerlink" title="以下三条 SQL 如何建索引，只建一条怎么建？"></a><strong>以下三条 SQL 如何建索引，只建一条怎么建？</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE a = 1 AND b = 1</span><br><span class="line">WHERE b = 1</span><br><span class="line">WHERE b = 1 ORDER BY time DESC</span><br></pre></td></tr></table></figure>

<ul>
<li>以顺序 b , a, time 建立复合索引，<code>CREATE INDEX table1_b_a_time ON index_test01(b, a, time)</code>。</li>
<li>对于第一条 SQL ，因为最新 MySQL 版本会优化 <code>WHERE</code> 子句后面的列顺序，以匹配复合索引顺序。</li>
</ul>
<h3 id="想知道一个查询用到了哪个索引，如何查看"><a href="#想知道一个查询用到了哪个索引，如何查看" class="headerlink" title="想知道一个查询用到了哪个索引，如何查看?"></a><strong>想知道一个查询用到了哪个索引，如何查看?</strong></h3><p><code>EXPLAIN</code> 显示了 MYSQL 如何使用索引来处理 SELECT 语句以及连接表,可以帮助选择更好的索引和写出更优化的查询语句。</p>
<p>使用方法，在 <code>SELECT</code> 语句前加上 <code>EXPLAIN</code> 就可以了。感兴趣的胖友，可以详细看看 <a href="http://www.jfox.info/2017/mysql-explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A.html">《MySQL explain 执行计划详细解释》</a> 。</p>
<h2 id="【重点】MySQL-索引的原理？"><a href="#【重点】MySQL-索引的原理？" class="headerlink" title="【重点】MySQL 索引的原理？"></a>【重点】MySQL 索引的原理？</h2><p>解释 MySQL 索引的原理，篇幅会比较长，并且网络上已经有靠谱的资料可以看，所以艿艿这里整理了几篇，胖友可以对照着看。</p>
<ul>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">《MySQL索引背后的数据结构及算法原理》</a></li>
<li><a href="https://blog.csdn.net/u013235478/article/details/50625677">《MySQL 索引原理》</a></li>
<li><a href="https://blog.csdn.net/tongdanping/article/details/79878302">《深入理解 MySQL 索引原理和实现 —— 为什么索引可以加速查询？》</a></li>
</ul>
<h3 id="MySQL-有哪些索引方法？"><a href="#MySQL-有哪些索引方法？" class="headerlink" title="MySQL 有哪些索引方法？"></a><strong>MySQL 有哪些索引方法？</strong></h3><blockquote>
<p>艿艿：这个问题是索引方法 Index Method ，上面的索引类型 Index Type 。</p>
</blockquote>
<p>在 MySQL 中，我们可以看到两种索引方式：</p>
<ul>
<li>B-Tree 索引。</li>
<li>Hash 索引。</li>
</ul>
<p>实际场景下，我们基本仅仅使用 B-Tree 索引。详细的对比可以看看 <a href="https://blog.csdn.net/oChangWen/article/details/54024063">《MySQL BTree 索引和 hash 索引的区别》</a> 。</p>
<p>对于 Hash 索引，我们了解即可，面试重点是掌握 B-Tree 索引的原理。</p>
<p><strong>什么是 B-Tree 索引？</strong></p>
<p>B-Tree 是为磁盘等外存储设备设计的一种平衡查找树。因此在讲 B-Tree 之前先了解下磁盘的相关知识。</p>
<ul>
<li><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
</li>
<li><p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16 KB，可通过参数 innodb_page_size 将页的大小设置为 4K、8K、16K ，在 MySQL 中可通过如下命令查看页的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_page_size&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB 。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I&#x2F;O 次数，提高查询效率。</p>
</li>
</ul>
<p>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组 [key, data] ，key 为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p>
<p>一棵 m 阶的 B-Tree 有如下特性：</p>
<ol>
<li>每个节点最多有 m 个孩子。<ul>
<li>除了根节点和叶子节点外，其它每个节点至少有 Ceil(m&#x2F;2) 个孩子。</li>
<li>若根节点不是叶子节点，则至少有 2 个孩子。</li>
</ul>
</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息。</li>
<li>每个非叶子节点包含 n 个关键字信息（P0,P1,…Pn, k1,…kn）<ul>
<li>关键字的个数 n 满足：ceil(m&#x2F;2)-1 &lt;&#x3D; n &lt;&#x3D; m-1</li>
<li>ki(i&#x3D;1,…n) 为关键字，且关键字升序排序。</li>
<li>Pi(i&#x3D;0,…n) 为指向子树根节点的指针。P(i-1) 指向的子树的所有节点关键字均小于 ki ，但都大于 k(i-1) 。</li>
</ul>
</li>
</ol>
<p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/B-Tree%E7%BB%93%E6%9E%84.png" alt="B-Tree结构"></p>
<ul>
<li>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的 key 和三个指向子树根节点的 point ，point 存储的是子节点所在磁盘块的地址。两个 key 划分成的三个范围域，对应三个 point 指向的子树的数据的范围域。</li>
<li>以根节点为例，key 为 17 和 35 ，P1 指针指向的子树的数据范围为小于 17 ，P2 指针指向的子树的数据范围为 [17~35] ，P3 指针指向的子树的数据范围为大于 35 。</li>
</ul>
<p>模拟查找 key 为 29 的过程：</p>
<ul>
<li>1、根据根节点找到磁盘块 1 ，读入内存。【磁盘I&#x2F;O操作第1次】</li>
<li>2、比较 key 29 在区间（17,35），找到磁盘块 1 的指针 P2 。</li>
<li>3、根据 P2 指针找到磁盘块 3 ，读入内存。【磁盘I&#x2F;O操作第2次】</li>
<li>4、比较 key 29 在区间（26,30），找到磁盘块3的指针P2。</li>
<li>5、根据 P2 指针找到磁盘块 8 ，读入内存。【磁盘I&#x2F;O操作第3次】</li>
<li>6、在磁盘块 8 中的 key 列表中找到 key 29 。</li>
</ul>
<p>分析上面过程，发现需要 3 次磁盘 I&#x2F;O 操作，和 3 次内存查找操作。由于内存中的 key 是一个有序表结构，可以利用二分法查找提高效率。而 3 次磁盘 I&#x2F;O 操作是影响整个 B-Tree 查找效率的决定因素。B-Tree 相对于 AVLTree 缩减了节点个数，使每次磁盘 I&#x2F;O 取到内存的数据都发挥了作用，从而提高了查询效率。</p>
<h3 id="什么是-B-Tree-索引？"><a href="#什么是-B-Tree-索引？" class="headerlink" title="什么是 B+Tree 索引？"></a><strong>什么是 B+Tree 索引？</strong></h3><p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用 B+Tree 实现其索引结构。</p>
<blockquote>
<p>下面这一段，面试非常关键。</p>
</blockquote>
<p>从上一节中的 B-Tree 结构图中可以看到，每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I&#x2F;O 次数，进而影响查询效率。在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。</p>
<p>B+Tree 相对于 B-Tree 有几点不同：</p>
<ul>
<li>非叶子节点只存储键值信息。</li>
<li>所有叶子节点之间都有一个链指针。</li>
<li>数据记录都存放在叶子节点中。</li>
</ul>
<p>将上一节中的 B-Tree 优化，由于 B+Tree 的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 B+Tree 后其结构如下图所示：</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/B+Tree%E7%BB%93%E6%9E%84.png" alt="B+Tree结构"></p>
<ul>
<li>通常在 B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对 B+Tree 进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</li>
</ul>
<p>可能上面例子中只有 22 条数据记录，看不出 B+Tree 的优点，下面做一个推算：</p>
<ul>
<li>InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用4个字节） 或 BIGINT（占用8个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 16KB&#x2F;(8B+8B)&#x3D;1K 个键值（因为是估值，为方便计算，这里的 K 取值为〖10〗^3）。也就是说一个深度为 3 的 B+Tree 索引可以维护10^3 <em>10^3</em> 10^3 &#x3D; 10亿 条记录。</li>
<li>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2<del>4 层。MySQL 的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1</del>3 次磁盘 I&#x2F;O 操作。</li>
</ul>
<h3 id="B-Tree-有哪些索引类型？"><a href="#B-Tree-有哪些索引类型？" class="headerlink" title="B-Tree 有哪些索引类型？"></a><strong>B-Tree 有哪些索引类型？</strong></h3><p>在 B+Tree 中，根据叶子节点的内容，索引类型分为<strong>主键索引</strong>和<strong>非主键索引</strong>。</p>
<blockquote>
<p>注意，这里的索引类型，和上面的索引类型，还是对的上的噢。</p>
</blockquote>
<ul>
<li><p>主键索引的叶子节点存的数据是整行数据( 即具体数据 )。在 InnoDB 里，主键索引也被称为<strong>聚集索引</strong>（clustered index）。</p>
</li>
<li><p>非主键索引的叶子节点存的数据是整行数据的主键，键值是索引。在 InnoDB 里，非主键索引也被称为</p>
<p>辅助索引</p>
<p>（secondary index）。</p>
<blockquote>
<p>二级索引的叶节点存储的是主键值，而不是行指针，这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</p>
</blockquote>
</li>
</ul>
<p>辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，需要进过两步：</p>
<ul>
<li>首先，InnoDB 存储引擎会遍历辅助索引找到主键。</li>
<li>然后，再通过主键在聚集索引中找到完整的行记录数据。</li>
</ul>
<p>另外，InnoDB 通过主键聚簇数据，如果没有定义主键，会选择一个唯一的非空索引代替，如果没有这样的索引，会隐式定义个主键作为聚簇索引。</p>
<p>再另外，可能有胖友有和艿艿的一样疑惑，在<strong>辅助索引</strong>如果相同的索引怎么存储？最终存储到 B+Tree 非子节点中时，它们对应的主键 ID 是不同的，所以妥妥的。</p>
<h3 id="聚簇索引的注意点有哪些？"><a href="#聚簇索引的注意点有哪些？" class="headerlink" title="聚簇索引的注意点有哪些？"></a><strong>聚簇索引的注意点有哪些？</strong></h3><p>聚簇索引表最大限度地提高了 I&#x2F;O 密集型应用的性能，但它也有以下几个限制：</p>
<ul>
<li><p>1、插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。</p>
<blockquote>
<p>关于这一点，可能面试官会换一个问法。例如，为什么主键需要是自增 ID ，又或者为什么主键需要带有时间性关联。</p>
</blockquote>
</li>
<li><p>2、更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB 表，我们一般定义主键为不可更新。</p>
<blockquote>
<p>MySQL 默认情况下，主键是允许更新的。对于 MongoDB ，其 主键是不允许更新的。</p>
</blockquote>
</li>
<li><p>3、二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
<blockquote>
<p>当然，有一种情况可以无需二次查找，基于非主键索引查询，但是查询字段只有主键 ID ，那么在二级索引中就可以查找到。</p>
</blockquote>
</li>
<li><p>4、主键 ID 建议使用整型。因为，每个主键索引的 B+Tree 节点的键值可以存储更多主键 ID ，每个非主键索引的 B+Tree 节点的数据可以存储更多主键 ID 。</p>
</li>
</ul>
<h3 id="什么是索引的最左匹配特性？"><a href="#什么是索引的最左匹配特性？" class="headerlink" title="什么是索引的最左匹配特性？"></a><strong>什么是索引的最左匹配特性？</strong></h3><p>当 B+Tree 的数据项是复合的数据结构，比如索引 <code>(name, age, sex)</code> 的时候，B+Tree 是按照从左到右的顺序来建立搜索树的。</p>
<ul>
<li>比如当 <code>(张三, 20, F)</code> 这样的数据来检索的时候，B+Tree 会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex ，最后得到检索的数据。</li>
<li>但当 <code>(20, F)</code> 这样的没有 name 的数据来的时候，B+Tree 就不知道下一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。</li>
<li>比如当 <code>(张三, F)</code> 这样的数据来检索时，B+Tree 可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了。</li>
</ul>
<p>这个是非常重要的性质，即索引的最左匹配特性。</p>
<h2 id="【重点】请说说-MySQL-的四种事务隔离级别？"><a href="#【重点】请说说-MySQL-的四种事务隔离级别？" class="headerlink" title="【重点】请说说 MySQL 的四种事务隔离级别？"></a>【重点】请说说 MySQL 的四种事务隔离级别？</h2><p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。</p>
<p>这样可以防止出现脏数据，防止数据库数据出现问题。</p>
<h3 id="事务的特性指的是？"><a href="#事务的特性指的是？" class="headerlink" title="事务的特性指的是？"></a><strong>事务的特性指的是？</strong></h3><ol>
<li><strong>原子性</strong> Atomicity ：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li><strong>一致性</strong> Consistency ：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">约束</a>、<a href="https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93)">触发器</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A&action=edit&redlink=1">级联回滚</a>等。</li>
<li><strong>隔离性</strong> Isolation ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性</strong> Durability ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ol>
<h3 id="事务的并发问题？"><a href="#事务的并发问题？" class="headerlink" title="事务的并发问题？"></a><strong>事务的并发问题？</strong></h3><p>实际场景下，事务并不是串行的，所以会带来如下三个问题：</p>
<ul>
<li>1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。</li>
<li>2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。</li>
<li>3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>
</ul>
<p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p>
<h3 id="MySQL-事务隔离级别会产生的并发问题？"><a href="#MySQL-事务隔离级别会产生的并发问题？" class="headerlink" title="MySQL 事务隔离级别会产生的并发问题？"></a><strong>MySQL 事务隔离级别会产生的并发问题？</strong></h3><p>事务定义了四种事务隔离级别，不同数据库在实现时，产生的并发问题是不同的。</p>
<blockquote>
<p>不同的隔离级别有不同的现象，并有不同的锁定&#x2F;并发机制，隔离级别越高，数据库的并发性就越差。</p>
</blockquote>
<ul>
<li><p>READ UNCOMMITTED（未提交读）：事务中的修改，即使没有提交，对其他事务也都是可见的。</p>
<blockquote>
<p>会导致脏读。</p>
</blockquote>
</li>
<li><p>READ COMMITTED（提交读）：事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。</p>
<blockquote>
<p>会导致不可重复读。</p>
<p>这个隔离级别，也可以叫做“不可重复读”。</p>
</blockquote>
</li>
<li><p>REPEATABLE READ（可重复读）：一个事务按相同的查询条件读取以前检索过的数据，其他事务插入了满足其查询条件的新数据。产生幻行。</p>
<blockquote>
<p>会导致幻读。</p>
</blockquote>
</li>
<li><p>SERIALIZABLE（可串行化）：强制事务串行执行。</p>
</li>
</ul>
<p>MySQL InnoDB 采用 <strong>MVCC</strong> 来支持高并发，实现结果如下表所示：</p>
<blockquote>
<p>关于 Oracle 和 PostgreSQL ，需要胖友自己去搜索资料。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">事务隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读未提交（read-uncommitted）</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">读已提交（read-committed）</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">可重复读（repeatable-read）</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">是（x）</td>
</tr>
<tr>
<td align="left">串行化（serializable）</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
</tbody></table>
<ul>
<li><p>MySQL 默认的事务隔离级别为可重复读（repeatable-read） 。</p>
</li>
<li><p>上图的 <code>&lt;X&gt;</code> 处，<strong>MySQL 通过 MVCC + 事务第一次调用 <code>SELECT</code> 语句才生成快照，实现其在可重复读（repeatable-read）的隔离级别下，不存在幻读问题。</strong>也就是说，上图 <code>&lt;X&gt;</code> 处，需要改成“否”！！！！想要进一步了解的，可以看看 <a href="https://blog.csdn.net/cxm19881208/article/details/79415726">《MySQL InnoDB 事务 —— 一致性读(快照读)》</a>、<a href="https://blog.csdn.net/z69183787/article/details/81709743">《MYSQL 当前读和快照读》</a>、<a href="https://www.cnblogs.com/wwcom123/p/10727194.html">《【MySQL】当前读、快照读、MVCC》</a> 文章。</p>
<blockquote>
<p>艿艿：实际上，艿艿在看完上述几篇文章，仿佛理解了，仿佛又有一点懵逼。后来在看完丁奇老师的 <a href="http://www.iocoder.cn/images/jikeshijian/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2.jpg">《MySQL 实战 45 讲》</a> 的「08 | 事务到底是隔离的还是不隔离的？」后，稳了，通透了。</p>
</blockquote>
</li>
<li><p>😈 记住这个表的方式，我们会发现它是自左上向右下是一个对角线。当然，最好是去理解。</p>
</li>
<li><p>具体的实验，胖友可以看看 <a href="https://www.cnblogs.com/huanongying/p/7021555.html">《MySQL 的四种事务隔离级别》</a> 。</p>
</li>
<li><p>有些资料说可重复读解决了幻读，实际是存在的，可以通过 <code>SELECT xxx FROM t WHERE id = ? FOR UPDATE</code> 的方式，获得到悲观锁，禁止其它事务操作对应的数据，从而解决幻读问题。感兴趣的胖友，可以看看如下文章：</p>
<ul>
<li><p>必读 <a href="https://segmentfault.com/a/1190000016566788">《MySQL 幻读的详解、实例及解决办法》</a> 案例性更强，易懂。</p>
<blockquote>
<p>其实 RR 也是可以避免幻读的，通过对 select 操作手动加 行X锁（SELECT … FOR UPDATE 这也正是 SERIALIZABLE 隔离级别下会隐式为你做的事情），同时还需要知道，即便当前记录不存在，比如 id &#x3D; 1 是不存在的，当前事务也会获得一把记录锁（因为InnoDB的行锁锁定的是索引，故记录实体存在与否没关系，存在就加 行X锁，不存在就加 next-key lock间隙X锁），其他事务则无法插入此索引的记录，故杜绝了幻读。</p>
</blockquote>
</li>
<li><p>选读 <a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html">《MySQL 的 InnoDB 的幻读问题》</a> 原理性更强，读懂会很爽。</p>
</li>
<li><p>随意 <a href="https://github.com/Yhzhtk/note/issues/42">《Innodb 中 RR 隔离级别能否防止幻读？》</a> 一个简单的讨论。</p>
</li>
</ul>
</li>
</ul>
<h2 id="【重点】请说说-MySQL-的锁机制？"><a href="#【重点】请说说-MySQL-的锁机制？" class="headerlink" title="【重点】请说说 MySQL 的锁机制？"></a>【重点】请说说 MySQL 的锁机制？</h2><p>表锁是日常开发中的常见问题，因此也是面试当中最常见的考察点，当多个查询同一时刻进行数据修改时，就会产生并发控制的问题。MySQL 的共享锁和排他锁，就是读锁和写锁。</p>
<ul>
<li>共享锁：不堵塞，多个用户可以同时读一个资源，互不干扰。</li>
<li>排他锁：一个写锁会阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他用户读取正在写入的资源。</li>
</ul>
<h3 id="锁的粒度？"><a href="#锁的粒度？" class="headerlink" title="锁的粒度？"></a><strong>锁的粒度？</strong></h3><ul>
<li>表锁：系统开销最小，会锁定整张表，MyIsam 使用表锁。</li>
<li>行锁：最大程度的支持并发处理，但是也带来了最大的锁开销，InnoDB 使用行锁。</li>
</ul>
<h3 id="什么是悲观锁？什么是乐观锁？"><a href="#什么是悲观锁？什么是乐观锁？" class="headerlink" title="什么是悲观锁？什么是乐观锁？"></a><strong>什么是悲观锁？什么是乐观锁？</strong></h3><p>1）悲观锁</p>
<p>它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p>
<blockquote>
<p>艿艿：悲观锁，就是我们上面看到的共享锁和排他锁。</p>
</blockquote>
<p>2）乐观锁</p>
<p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p>
<p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<blockquote>
<p>艿艿：乐观锁，实际就是通过版本号，从而实现 CAS 原子性更新。</p>
</blockquote>
<h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a><strong>什么是死锁？</strong></h3><p>多数情况下，可以认为如果一个资源被锁定，它总会在以后某个时间被释放。而死锁发生在当多个进程访问同一数据库时，其中每个进程拥有的锁都是其他进程所需的，由此造成每个进程都无法继续下去。简单的说，进程 A 等待进程 B 释放他的资源，B 又等待 A 释放他的资源，这样就互相等待就形成死锁。</p>
<p>虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件：</p>
<ul>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合 {P0，P1，P2，•••，Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。</li>
</ul>
<p>下列方法有助于最大限度地降低死锁：</p>
<ul>
<li><p>设置获得锁的超时时间。</p>
<blockquote>
<p>通过超时，至少保证最差最差最差情况下，可以有退出的口子。</p>
</blockquote>
</li>
<li><p>按同一顺序访问对象。</p>
<blockquote>
<p>这个是最重要的方式。</p>
</blockquote>
</li>
<li><p>避免事务中的用户交互。</p>
</li>
<li><p>保持事务简短并在一个批处理中。</p>
</li>
<li><p>使用低隔离级别。</p>
</li>
<li><p>使用绑定连接。</p>
</li>
</ul>
<h3 id="MySQL-中-InnoDB-引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？？"><a href="#MySQL-中-InnoDB-引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？？" class="headerlink" title="MySQL 中 InnoDB 引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？？"></a><strong>MySQL 中 InnoDB 引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？？</strong></h3><p>InnoDB 是基于索引来完成行锁。例如：<code>SELECT * FROM tab_with_index WHERE id = 1 FOR UPDATE</code> 。</p>
<ul>
<li><code>FOR UPDATE</code> 可以根据条件来完成<strong>行锁</strong>锁定，并且 id 是有索引键的列,如果 id 不是索引键那么 InnoDB 将完成<strong>表锁</strong>，并发将无从谈起。</li>
</ul>
<h2 id="【重要】MySQL-查询执行顺序？"><a href="#【重要】MySQL-查询执行顺序？" class="headerlink" title="【重要】MySQL 查询执行顺序？"></a>【重要】MySQL 查询执行顺序？</h2><p>MySQL 查询执行的顺序是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)     SELECT</span><br><span class="line">(2)     DISTINCT &lt;select_list&gt;</span><br><span class="line">(3)     FROM &lt;left_table&gt;</span><br><span class="line">(4)     &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">(5)     ON &lt;join_condition&gt;</span><br><span class="line">(6)     WHERE &lt;where_condition&gt;</span><br><span class="line">(7)     GROUP BY &lt;group_by_list&gt;</span><br><span class="line">(8)     HAVING &lt;having_condition&gt;</span><br><span class="line">(9)     ORDER BY &lt;order_by_condition&gt;</span><br><span class="line">(10)    LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<p>具体的，可以看看 <a href="http://zouzls.github.io/2017/03/23/SQL%E6%9F%A5%E8%AF%A2%E4%B9%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E8%A7%A3%E6%9E%90/">《SQL 查询之执行顺序解析》</a> 文章。</p>
<h2 id="【重要】聊聊-MySQL-SQL-优化？"><a href="#【重要】聊聊-MySQL-SQL-优化？" class="headerlink" title="【重要】聊聊 MySQL SQL 优化？"></a>【重要】聊聊 MySQL SQL 优化？</h2><p>可以看看如下几篇文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/ab958a4823d1">《PHP 面试之 MySQL 查询优化》</a></li>
<li><a href="https://blog.csdn.net/DERRANTCM/article/details/51534411">《【面试】【MySQL常见问题总结】【03】》</a> 第 078、095、105 题</li>
</ul>
<p>另外，除了从 SQL 层面进行优化，也可以从服务器硬件层面，进一步优化 MySQL 。具体可以看看 <a href="https://blog.csdn.net/bemavery/article/details/46241533">《MySQL 数据库性能优化之硬件优化》</a> 。</p>
<h2 id="【加分】什么是-MVCC-？"><a href="#【加分】什么是-MVCC-？" class="headerlink" title="【加分】什么是 MVCC ？"></a>【加分】什么是 MVCC ？</h2><p>多版本并发控制（MVCC），是一种用来<strong>解决读-写冲突</strong>的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。</p>
<p>推荐可以看看如下资料：</p>
<ul>
<li><p>沈询 <a href="https://www.imooc.com/learn/272">《在线分布式数据库原理与实践》</a></p>
<blockquote>
<p>一共 1 小时 53 分钟，有趣，牛逼，强烈推荐！！！</p>
</blockquote>
</li>
<li><p>钟延辉</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/sOxLZlXRYR-zZKStE7qAwg">《分布式数据库 MVCC 技术探秘 (1)》</a></li>
<li><a href="https://mp.weixin.qq.com/s/8lX3Gyq4J5vLHETtG01EdA">《分布式数据库 MVCC 技术探秘(2): 混合逻辑时钟》</a></li>
</ul>
</li>
</ul>
<h2 id="编写-SQL-查询语句的考题合集"><a href="#编写-SQL-查询语句的考题合集" class="headerlink" title="编写 SQL 查询语句的考题合集"></a>编写 SQL 查询语句的考题合集</h2><p>因为考题比较多，艿艿就不一一列举，瞄了一些还不错的文章，如下：</p>
<ul>
<li><a href="https://www.yanxurui.cc/posts/mysql/2016-11-10-10-sql-interview-questions/">《10 道 MySQL 查询语句面试题》</a></li>
<li><a href="https://www.cnblogs.com/geaozhang/p/6839297.html">《MySQL 开发面试题》</a></li>
<li><a href="https://juejin.im/entry/5b57ebdcf265da0f61320e6f">《企业面试题｜最常问的 MySQL 面试题集合（二）》</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Jenkins集群</title>
    <url>/2019/11/28/%E6%90%AD%E5%BB%BAJenkins%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h3 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h3><p>下载<a href="http://updates.jenkins-ci.org/download/war/">Jenkins</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://updates.jenkins-ci.org/latest/jenkins.war</span><br></pre></td></tr></table></figure>

<p>启动Jenkins war包，默认8080端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar jenkins.war</span><br></pre></td></tr></table></figure>

<p>后台启动Jenkins</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup java -jar jenkins.war --httpPort=8080 &amp;</span><br></pre></td></tr></table></figure>

<p>查看日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -f nohup.out</span><br></pre></td></tr></table></figure>

<p>开放端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看想开的端口是否已开：</span><br><span class="line">firewall-cmd --query-port=9090/tcp </span><br><span class="line">添加指定需要开放的端口：</span><br><span class="line">firewall-cmd --add-port=9090/tcp --permanent</span><br><span class="line">重载入添加的端口：</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">查询指定端口是否开启成功：</span><br><span class="line">firewall-cmd --query-port=9090/tcp</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>

<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>进入系统管理–&gt;节点管理–&gt;新建节点：</p>
<p><img src="/images/%E6%90%AD%E5%BB%BAJenkins%E9%9B%86%E7%BE%A4-1.png" alt="搭建Jenkins集群-1"></p>
<p>写入节点名称，选择固定节点，配置节点：</p>
<p><img src="/images/%E6%90%AD%E5%BB%BAJenkins%E9%9B%86%E7%BE%A4-2.png" alt="搭建Jenkins集群-2"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-代理、桥接、装饰器、适配器模式的区别</title>
    <url>/2022/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E3%80%81%E6%A1%A5%E6%8E%A5%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper(包装) 模式，也就是通过 Wrapper 类二次封装原始类。</p>
<p>尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。</p>
<ul>
<li>代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</li>
<li>桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</li>
<li>装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</li>
<li>适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-享元模式</title>
    <url>/2022/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="享元模式原理与实现"><a href="#享元模式原理与实现" class="headerlink" title="享元模式原理与实现"></a>享元模式原理与实现</h1><p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p>
<p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。</p>
<span id="more"></span>

<p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。具体的代码如下所示。其中，ChessPiece 类表示棋子，ChessBoard 类表示一个棋局，里面保存了象棋中 30 个棋子的信息。</p>
<p>所有棋子的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 享元类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPieceUnit</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String text;</span><br><span class="line">  <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChessPieceUnit</span><span class="params">(<span class="type">int</span> id, String text, Color color)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.text = text;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED, BLACK</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...省略其他属性和getter方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPieceUnitFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    pieces.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ChessPieceUnit</span>(<span class="number">1</span>, <span class="string">&quot;車&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    pieces.put(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ChessPieceUnit</span>(<span class="number">2</span>, <span class="string">&quot;馬&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">    <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ChessPieceUnit <span class="title function_">getChessPiece</span><span class="params">(<span class="type">int</span> chessPieceId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pieces.get(chessPieceId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPiece</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ChessPieceUnit chessPieceUnit;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> positionX;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> positionY;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChessPiece</span><span class="params">(ChessPieceUnit unit, <span class="type">int</span> positionX, <span class="type">int</span> positionY)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.chessPieceUnit = unit;</span><br><span class="line">    <span class="built_in">this</span>.positionX = positionX;</span><br><span class="line">    <span class="built_in">this</span>.positionY = positionY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略getter、setter方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessBoard</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ChessBoard</span><span class="params">()</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    chessPieces.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ChessPiece</span>(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(<span class="number">1</span>), <span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    chessPieces.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ChessPiece</span>(</span><br><span class="line">            ChessPieceUnitFactory.getChessPiece(<span class="number">2</span>), <span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> chessPieceId, <span class="type">int</span> toPositionX, <span class="type">int</span> toPositionY)</span> &#123;</span><br><span class="line">    <span class="comment">//...省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="享元模式-vs-单例、缓存、对象池"><a href="#享元模式-vs-单例、缓存、对象池" class="headerlink" title="享元模式 vs 单例、缓存、对象池"></a>享元模式 vs 单例、缓存、对象池</h1><p>在上面的讲解中，我们多次提到“共享”“缓存”“复用”这些字眼，那它跟单例、缓存、对象池这些概念有什么区别呢？我们来简单对比一下。</p>
<h2 id="享元模式跟单例的区别"><a href="#享元模式跟单例的区别" class="headerlink" title="享元模式跟单例的区别"></a>享元模式跟单例的区别</h2><p>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例。</p>
<p>我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。</p>
<h2 id="享元模式跟缓存的区别"><a href="#享元模式跟缓存的区别" class="headerlink" title="享元模式跟缓存的区别"></a>享元模式跟缓存的区别</h2><p>在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，跟我们平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓存”是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。</p>
<h2 id="享元模式跟对象池的区别"><a href="#享元模式跟对象池的区别" class="headerlink" title="享元模式跟对象池的区别"></a>享元模式跟对象池的区别</h2><p>对象池、连接池（比如数据库连接池）、线程池等也是为了复用，那它们跟享元模式有什么区别呢？</p>
<p>你可能对连接池、线程池比较熟悉，对对象池比较陌生，所以，这里我简单解释一下对象池。像 C++ 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。</p>
<p>虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果我们再细致地抠一抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中的“复用”实际上是不同的概念。</p>
<p>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-代理模式</title>
    <url>/2022/07/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User [&quot;</span>+username+<span class="string">&quot;] logins!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceStaticProxy</span> <span class="keyword">extends</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;login start：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">        <span class="built_in">super</span>.login(username, password);</span><br><span class="line">        System.out.println(<span class="string">&quot;login end：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p>
<p>Java实现动态代理采用的是反射。</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>动态代理有两种，一种是被代理的类是实体类，而不是接口，这种情况在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p>
<h3 id="java代理"><a href="#java代理" class="headerlink" title="java代理"></a>java代理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicInvocationHandler</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.proxiedObject = proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;login start：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(proxiedObject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;login end：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceDynamicProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceDynamicProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">        Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class="line">        <span class="type">DynamicInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicInvocationHandler</span>(userService);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceStaticProxy</span>();</span><br><span class="line">        userService.login(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">UserServiceDynamicProxy</span> <span class="variable">userServiceDynamicProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceDynamicProxy</span>();</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService1</span> <span class="operator">=</span> (UserService) userServiceDynamicProxy.createProxy(<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>());</span><br><span class="line">        userService1.login(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h3><p>动态代理需要被代理类实现接口，如果被代理类没有实现接口，就需要用到CGLib了。这种代理方式就叫做CGlib代理。</p>
<p>Cglib代理也叫作子类代理，他是通过在内存中构建一个子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，然后加入自己需要的操作。因为使用的是继承的方式，所以不能代理final 类。</p>
<p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CglibProxyFactory</span><span class="params">(T target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// cglib工具类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置父类</span></span><br><span class="line">        enhancer.setSuperclass(<span class="built_in">this</span>.target.getClass());</span><br><span class="line">        <span class="comment">// 设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;login start：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;login end：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyInterfaceFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxyInstance</span><span class="params">(Class&lt;T&gt; clz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Enhancer.create(clz, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;login start：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;login end：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>())));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-剖析Spring框架中蕴含的经典设计思想或原则</title>
    <url>/2022/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%89%96%E6%9E%90Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%95%B4%E5%90%AB%E7%9A%84%E7%BB%8F%E5%85%B8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E6%88%96%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>我们常说的 Spring 框架，是指 Spring Framework 基础框架。Spring Framework 是整个 Spring 生态（也被称作 Spring 全家桶）的基石。除了 Spring Framework，Spring 全家桶中还有更多基于 Spring Framework 开发出来的、整合更多功能的框架，比如 Spring Boot、Spring Cloud。</p>
<p>在 Spring 全家桶中，Spring Framework 是最基础、最底层的一部分。它提供了最基础、最核心的 IOC 和 AOP 功能。当然，它包含的功能还不仅如此，还有其他比如事务管理（Transactions）、MVC 框架（Spring MVC）等很多功能。</p>
<span id="more"></span>

<h1 id="Spring-框架蕴含的设计思想"><a href="#Spring-框架蕴含的设计思想" class="headerlink" title="Spring 框架蕴含的设计思想"></a>Spring 框架蕴含的设计思想</h1><h2 id="约定优于配置"><a href="#约定优于配置" class="headerlink" title="约定优于配置"></a>约定优于配置</h2><p>在使用 Spring 开发的项目中，配置往往会比较复杂、繁琐。比如，我们利用 Spring MVC 来开发 Web 应用，需要配置每个 Controller 类以及 Controller 类中的接口对应的 URL。</p>
<p>如何来简化配置呢？一般来讲，有两种方法，一种是基于注解，另一种是基于约定。这两种配置方式在 Spring 中都有用到。Spring 在最小化配置方面做得淋漓尽致，有很多值得我们借鉴的地方。</p>
<p>基于注解的配置方式，我们在指定类上使用指定的注解，来替代集中的 XML 配置。比如，我们使用 @RequestMapping 注解，在 Controller 类或者接口上，标注对应的 URL；使用 @Transaction 注解表明支持事务等。</p>
<p>基于约定的配置方式，也常叫作“约定优于配置”或者“规约优于配置”（Convention over Configuration）。通过约定的代码结构或者命名来减少配置。说直白点，就是提供配置的默认值，优先使用默认值。程序员只需要设置那些偏离约定的配置就可以了。</p>
<p>比如，在 Spring JPA（基于 ORM 框架、JPA 规范的基础上，封装的一套 JPA 应用框架）中，我们约定类名默认跟表名相同，属性名默认跟表字段名相同，String 类型对应数据库中的 varchar 类型，long 类型对应数据库中的 bigint 类型等等。</p>
<p>基于刚刚的约定，代码中定义的 Order 类就对应数据库中的“order”表。只有在偏离这一约定的时候，例如数据库中表命名为“order_info”而非“order”，我们才需要显示地去配置类与表的映射关系（Order 类 -&gt;order_info 表）。</p>
<p>实际上，约定优于配置，很好地体现了“二八法则”。在平时的项目开发中，80% 的配置使用默认配置就可以了，只有 20% 的配置必须用户显式地去设置。所以，基于约定来配置，在没有牺牲配置灵活性的前提下，节省了我们大量编写配置的时间，省掉了很多不动脑子的纯体力劳动，提高了开发效率。除此之外，基于相同的约定来做开发，也减少了项目的学习成本和维护成本。</p>
<h2 id="低侵入、松耦合"><a href="#低侵入、松耦合" class="headerlink" title="低侵入、松耦合"></a>低侵入、松耦合</h2><p>框架的侵入性是衡量框架好坏的重要指标。所谓低侵入指的是，框架代码很少耦合在业务代码中。低侵入意味着，当我们要替换一个框架的时候，对原有的业务代码改动会很少。相反，如果一个框架是高度侵入的，代码高度侵入到业务代码中，那替换成另一个框架的成本将非常高，甚至几乎不可能。这也是一些长期维护的老项目，使用的框架、技术比较老旧，又无法更新的一个很重要的原因。</p>
<p>实际上，低侵入是 Spring 框架遵循的一个非常重要的设计思想。</p>
<p>Spring 提供的 IOC 容器，在不需要 Bean 继承任何父类或者实现任何接口的情况下，仅仅通过配置，就能将它们纳入进 Spring 的管理中。如果我们换一个 IOC 容器，也只是重新配置一下就可以了，原有的 Bean 都不需要任何修改。</p>
<p>除此之外，Spring 提供的 AOP 功能，也体现了低侵入的特性。在项目中，对于非业务功能，比如请求日志、数据采点、安全校验、事务等等，我们没必要将它们侵入进业务代码中。因为一旦侵入，这些代码将分散在各个业务代码中，删除、修改的成本就变得很高。而基于 AOP 这种开发模式，将非业务代码集中放到切面中，删除、修改的成本就变得很低了。</p>
<h2 id="模块化、轻量级"><a href="#模块化、轻量级" class="headerlink" title="模块化、轻量级"></a>模块化、轻量级</h2><p>我们知道，十几年前，EJB 是 Java 企业级应用的主流开发框架。但是，它非常臃肿、复杂，侵入性、耦合性高，开发、维护和学习成本都不低。所以，为了替代笨重的 EJB，Rod Johnson 开发了一套开源的 Interface21 框架，提供了最基本的 IOC 功能。实际上，Interface21 框架就是 Spring 框架的前身。</p>
<p>但是，随着不断的发展，Spring 现在也不单单只是一个只包含 IOC 功能的小框架了，它显然已经壮大成了一个“平台”或者叫“生态”，包含了各种五花八门的功能。尽管如此，但它也并没有重蹈覆辙，变成一个像 EJB 那样的庞大难用的框架。那 Spring 是怎么做到的呢？</p>
<p>这就要归功于 Spring 的模块化设计思想。Spring 在分层、模块化方面做得非常好。每个模块都只负责一个相对独立的功能。模块之间关系，仅有上层对下层的依赖关系，而同层之间以及下层对上层，几乎没有依赖和耦合。除此之外，在依赖 Spring 的项目中，开发者可以有选择地引入某几个模块，而不会因为需要一个小的功能，就被强迫引入整个 Spring 框架。所以，尽管 Spring Framework 包含的模块很多，已经有二十几个，但每个模块都非常轻量级，都可以单独拿来使用。正因如此，到现在，Spring 框架仍然可以被称为是一个轻量级的开发框架。</p>
<h2 id="再封装、再抽象"><a href="#再封装、再抽象" class="headerlink" title="再封装、再抽象"></a>再封装、再抽象</h2><p>Spring 不仅仅提供了各种 Java 项目开发的常用功能模块，而且还对市面上主流的中间件、系统的访问类库，做了进一步的封装和抽象，提供了更高层次、更统一的访问接口。</p>
<p>比如，Spring 提供了 spring-data-redis 模块，对 Redis Java 开发类库（比如 Jedis、Lettuce）做了进一步的封装，适配 Spring 的访问方式，让编程访问 Redis 更加简单。比如 Spring Cache，实际上也是一种再封装、再抽象。它定义了统一、抽象的 Cache 访问接口，这些接口不依赖具体的 Cache 实现（Redis、Guava Cache、Caffeine 等）。在项目中，我们基于 Spring 提供的抽象统一的接口来访问 Cache。这样，我们就能在不修改代码的情况下，实现不同 Cache 之间的切换。</p>
<p>在模板模式中，介绍过的 JdbcTemplate ，实际上，它也是对 JDBC 的进一步封装和抽象，为的是进一步简化数据库编程。不仅如此，Spring 对 JDBC 异常也做了进一步的封装。封装的数据库异常继承自 DataAccessException 运行时异常。这类异常在开发中无需强制捕获，从而减少了不必要的异常捕获和处理。除此之外，Spring 封装的数据库异常，还屏蔽了不同数据库异常的细节（比如，不同的数据库对同一报错定义了不同的错误码），让异常的处理更加简单。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-剖析Google Guava中用到的几种设计模式</title>
    <url>/2022/10/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%89%96%E6%9E%90Google-Guava%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>Google Guava 是 Google 公司内部 Java 开发工具库的开源版本。Google 内部的很多 Java 项目都在使用它。它提供了一些 JDK 没有提供的功能，以及对 JDK 已有功能的增强功能。其中就包括：集合（Collections）、缓存（Caching）、原生类型支持（Primitives Support）、并发库（Concurrency Libraries）、通用注解（Common Annotation）、字符串处理（Strings Processing）、数学计算（Math）、I&#x2F;O、事件总线（EventBus）等等。</p>
<p>做业务开发也会涉及很多非业务功能的开发。我们要有善于发现、善于抽象的能力，并且具有扎实的设计、开发能力，能够发现这些非业务的、可复用的功能点，并且从业务逻辑中将其解耦抽象出来，设计并开发成独立的功能模块，比如类库、框架、功能组件。</p>
<p>实际上，不管是类库、框架还是功能组件，这些通用功能模块最大的两个特点就是复用和业务无关。如果你开发的这块代码，业务无关并且可能会被复用，那就可以考虑将它独立出来，开发成类库、框架、功能组件等。</p>
<span id="more"></span>

<h1 id="Builder-模式在-Guava-中的应用"><a href="#Builder-模式在-Guava-中的应用" class="headerlink" title="Builder 模式在 Guava 中的应用"></a>Builder 模式在 Guava 中的应用</h1><p>常用的缓存系统有 Redis、Memcache 等。但是，如果要缓存的数据比较少，我们完全没必要在项目中独立部署一套缓存系统。毕竟系统都有一定出错的概率，项目中包含的系统越多，那组合起来，项目整体出错的概率就会升高，可用性就会降低。同时，多引入一个系统就要多维护一个系统，项目维护的成本就会变高。</p>
<p>取而代之，我们可以在系统内部构建一个内存缓存，跟系统集成在一起开发、部署。那如何构建内存缓存呢？我们可以基于 JDK 提供的类，比如 HashMap，从零开始开发内存缓存。不过，从零开发一个内存缓存，涉及的工作就会比较多，比如缓存淘汰策略等。为了简化开发，我们就可以使用 Google Guava 提供的现成的缓存工具类 com.google.common.cache.*。</p>
<p>使用 Google Guava 来构建内存缓存非常简单，我写了一个例子贴在了下面，你可以看下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CacheDemo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">            .initialCapacity(100)</span><br><span class="line">            .maximumSize(1000)</span><br><span class="line">            .expireAfterWrite(10, TimeUnit.MINUTES)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    cache.put(&quot;key1&quot;, &quot;value1&quot;);</span><br><span class="line">    String value = cache.getIfPresent(&quot;key1&quot;);</span><br><span class="line">    System.out.println(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以发现，Cache 对象是通过 CacheBuilder 这样一个 Builder 类来创建的。为什么要这么做呢？</p>
<p>为了避免构造函数的参数列表过长、不同的构造函数过多，我们一般有两种解决方案。其中，一个解决方案是使用 Builder 模式；另一个方案是先通过无参构造函数创建对象，然后再通过 setXXX() 方法来逐一设置需要的设置的成员变量。为什么 Guava 选择第一种而不是第二种解决方案呢？使用第二种解决方案是否也可以呢？答案是不行的。至于为什么，我们看下源码就清楚了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;K1 <span class="keyword">extends</span> <span class="title class_">K</span>, V1 <span class="keyword">extends</span> <span class="title class_">V</span>&gt; Cache&lt;K1, V1&gt; <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.checkWeightWithWeigher();</span><br><span class="line">  <span class="built_in">this</span>.checkNonLoadingCache();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalManualCache</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkNonLoadingCache</span><span class="params">()</span> &#123;</span><br><span class="line">  Preconditions.checkState(<span class="built_in">this</span>.refreshNanos == -<span class="number">1L</span>, <span class="string">&quot;refreshAfterWrite requires a LoadingCache&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkWeightWithWeigher</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.weigher == <span class="literal">null</span>) &#123;</span><br><span class="line">    Preconditions.checkState(<span class="built_in">this</span>.maximumWeight == -<span class="number">1L</span>, <span class="string">&quot;maximumWeight requires weigher&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.strictParsing) &#123;</span><br><span class="line">    Preconditions.checkState(<span class="built_in">this</span>.maximumWeight != -<span class="number">1L</span>, <span class="string">&quot;weigher requires maximumWeight&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.maximumWeight == -<span class="number">1L</span>) &#123;</span><br><span class="line">    logger.log(Level.WARNING, <span class="string">&quot;ignoring weigher specified without maximumWeight&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须使用 Builder 模式的主要原因是，在真正构造 Cache 对象的时候，我们必须做一些必要的参数校验，也就是 build() 函数中前两行代码要做的工作。如果采用无参默认构造函数加 setXXX() 方法的方案，这两个校验就无处安放了。而不经过校验，创建的 Cache 对象有可能是不合法、不可用的。</p>
<h1 id="Wrapper-模式在-Guava-中的应用"><a href="#Wrapper-模式在-Guava-中的应用" class="headerlink" title="Wrapper 模式在 Guava 中的应用"></a>Wrapper 模式在 Guava 中的应用</h1><p>在 Google Guava 的 collection 包路径下，有一组以 Forwarding 开头命名的类。这组 Forwarding 类很多，但实现方式都很相似。其中的 ForwardingCollection 中的部分代码到这里，可以看出这组 Forwarding 类是干什么用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ForwardingCollection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">ForwardingObject</span> <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">ForwardingCollection</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> Collection&lt;E&gt; <span class="title function_">delegate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.delegate().iterator();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.delegate().size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; collection)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.delegate().removeAll(collection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.delegate().isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.delegate().contains(object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.delegate().add(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.delegate().remove(object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; collection)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.delegate().containsAll(collection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; collection)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.delegate().addAll(collection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; collection)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.delegate().retainAll(collection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.delegate().clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.delegate().toArray();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...省略部分代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>光看 ForwardingCollection 的代码实现，可能想不到它的作用。举一个它的用法示例，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddLoggingCollection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">ForwardingCollection</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(AddLoggingCollection.class);</span><br><span class="line">  <span class="keyword">private</span> Collection&lt;E&gt; originalCollection;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AddLoggingCollection</span><span class="params">(Collection&lt;E&gt; originalCollection)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.originalCollection = originalCollection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> Collection <span class="title function_">delegate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.originalCollection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;Add element: &quot;</span> + element);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.delegate().add(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; collection)</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;Size of elements to add: &quot;</span> + collection.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.delegate().addAll(collection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，AddLoggingCollection 是基于代理模式实现的一个代理类，它在原始 Collection 类的基础之上，针对“add”相关的操作，添加了记录日志的功能。</p>
<p>代理模式、装饰器、适配器模式可以统称为 Wrapper 模式，通过 Wrapper 类二次封装原始类。它们的代码实现也很相似，都可以通过组合的方式，将 Wrapper 类的函数实现委托给原始类的函数来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interf</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OriginalClass</span> <span class="keyword">implements</span> <span class="title class_">Interf</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrapperClass</span> <span class="keyword">implements</span> <span class="title class_">Interf</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> OriginalClass oc;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WrapperClass</span><span class="params">(OriginalClass oc)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.oc = oc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...附加功能...</span></span><br><span class="line">    <span class="built_in">this</span>.oc.f1();</span><br><span class="line">    <span class="comment">//...附加功能...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.oc.f2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这个 ForwardingCollection 类是一个“默认 Wrapper 类”或者叫“缺省 Wrapper 类”。</p>
<p>如果我们不使用这个 ForwardinCollection 类，而是让 AddLoggingCollection 代理类直接实现 Collection 接口，那 Collection 接口中的所有方法，都要在 AddLoggingCollection 类中实现一遍，而真正需要添加日志功能的只有 add() 和 addAll() 两个函数，其他函数的实现，都只是类似 Wrapper 类中 f2() 函数的实现那样，简单地委托给原始 collection 类对象的对应函数。</p>
<p>为了简化 Wrapper 模式的代码实现，Guava 提供一系列缺省的 Forwarding 类。用户在实现自己的 Wrapper 类的时候，基于缺省的 Forwarding 类来扩展，就可以只实现自己关心的方法，其他不关心的方法使用缺省 Forwarding 类的实现，就像 AddLoggingCollection 类的实现那样。</p>
<h1 id="Immutable-模式在-Guava-中的应用"><a href="#Immutable-模式在-Guava-中的应用" class="headerlink" title="Immutable 模式在 Guava 中的应用"></a>Immutable 模式在 Guava 中的应用</h1><p>Immutable 模式，中文叫作不变模式，它并不属于经典的 23 种设计模式，但作为一种较常用的设计思路，可以总结为一种设计模式来学习。之前在理论部分，我们只稍微提到过 Immutable 模式，但没有独立的拿出来详细讲解，我们这里借 Google Guava 再补充讲解一下。</p>
<p>一个对象的状态在对象创建之后就不再改变，这就是所谓的不变模式。其中涉及的类就是<strong>不变类</strong>（Immutable Class），对象就是<strong>不变对象</strong>（Immutable Object）。在 Java 中，最常用的不变类就是 String 类，String 对象一旦创建之后就无法改变。</p>
<p>不变模式可以分为两类，一类是<strong>普通不变模式</strong>，另一类是深度不变模式（Deeply Immutable Pattern）。普通的不变模式指的是，对象中包含的引用对象是可以改变的。如果不特别说明，通常我们所说的不变模式，指的就是普通的不变模式。深度不变模式指的是，对象包含的引用对象也不可变。它们两个之间的关系，有点类似之前讲过的浅拷贝和深拷贝之间的关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 普通不变模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> Address addr;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age, Address addr)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.addr = addr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有getter方法，无setter方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String province;</span><br><span class="line">  <span class="keyword">private</span> String city;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String province, String city)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.province = province;</span><br><span class="line">    <span class="built_in">this</span>.city= city;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有getter方法，也有setter方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度不变模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> Address addr;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age, Address addr)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.addr = addr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有getter方法，无setter方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String province;</span><br><span class="line">  <span class="keyword">private</span> String city;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String province, String city)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.province = province;</span><br><span class="line">    <span class="built_in">this</span>.city= city;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有getter方法，无setter方法..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某个业务场景下，如果一个对象符合创建之后就不会被修改这个特性，那我们就可以把它设计成不变类。显式地强制它不可变，这样能避免意外被修改。那如何将一个类设置为不变类呢？其实方法很简单，只要这个类满足：所有的成员变量都通过构造函数一次性设置好，不暴露任何 set 等修改成员变量的方法。除此之外，因为数据不变，所以不存在并发读写问题，因此不变模式常用在多线程环境下，来避免线程加锁。所以，不变模式也常被归类为多线程设计模式。</p>
<p>接下来，我们来看一种特殊的不变类，那就是不变集合。Google Guava 针对集合类（Collection、List、Set、Map…）提供了对应的不变集合类（ImmutableCollection、ImmutableList、ImmutableSet、ImmutableMap…）。刚刚我们讲过，不变模式分为两种，普通不变模式和深度不变模式。Google Guava 提供的不变集合类属于前者，也就是说，集合中的对象不会增删，但是对象的成员变量（或叫属性值）是可以改变的。</p>
<p>实际上，Java JDK 也提供了不变集合类（UnmodifiableCollection、UnmodifiableList、UnmodifiableSet、UnmodifiableMap…）。那它跟 Google Guava 提供的不变集合类的区别在哪里呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; originalList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        originalList.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        originalList.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        originalList.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(originalList);</span><br><span class="line">        ImmutableList&lt;String&gt; immutableList = ImmutableList.copyOf(originalList);</span><br><span class="line">        <span class="comment">// jdkUnmodifiableList.add(&quot;d&quot;); // 抛出UnsupportedOperationException</span></span><br><span class="line">        <span class="comment">// guavaImmutableList.add(&quot;d&quot;); // 抛出UnsupportedOperationException</span></span><br><span class="line">        originalList.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        print(originalList); <span class="comment">// a b c d</span></span><br><span class="line">        print(unmodifiableList); <span class="comment">// a b c d</span></span><br><span class="line">        print(immutableList); <span class="comment">// a b c</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，ImmutableList对原来list做了改变自身也不会发生改变。原因是JDK用的是浅拷贝，Guava用的是深拷贝，一个复制引用，一个复制值。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-剖析Spring框架中用来支持扩展的两种设计模式</title>
    <url>/2022/10/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%89%96%E6%9E%90Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E6%9D%A5%E6%94%AF%E6%8C%81%E6%89%A9%E5%B1%95%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>常用来实现扩展特性的设计模式有：观察者模式、模板模式、职责链模式、策略模式等。今天，我们再剖析 Spring 框架为了支持可扩展特性用的 2 种设计模式：观察者模式和模板模式。</p>
<h1 id="观察者模式在-Spring-中的应用"><a href="#观察者模式在-Spring-中的应用" class="headerlink" title="观察者模式在 Spring 中的应用"></a>观察者模式在 Spring 中的应用</h1><p>Java、Google Guava 都提供了观察者模式的实现框架。Java 提供的框架比较简单，只包含 java.util.Observable 和 java.util.Observer 两个类。Google Guava 提供的框架功能比较完善和强大：通过 EventBus 事件总线来实现观察者模式。实际上，Spring 也提供了观察者模式的实现框架。</p>
<p>Spring 中实现的观察者模式包含三部分：Event 事件（相当于消息）、Listener 监听者（相当于观察者）、Publisher 发送者（相当于被观察者）。</p>
<span id="more"></span>

<h2 id="Event事件"><a href="#Event事件" class="headerlink" title="Event事件"></a>Event事件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoEvent</span><span class="params">(Object source, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Listener监听者"><a href="#Listener监听者" class="headerlink" title="Listener监听者"></a>Listener监听者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;DemoEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(DemoEvent event)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> event.getMessage();</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Publisher发送者"><a href="#Publisher发送者" class="headerlink" title="Publisher发送者"></a>Publisher发送者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoPublisher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoPublisher</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(DemoEvent demoEvent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext.publishEvent(demoEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中，我们可以看出，框架使用起来并不复杂，主要包含三部分工作：定义一个继承 ApplicationEvent 的事件（DemoEvent）；定义一个实现了 ApplicationListener 的监听器（DemoListener）；定义一个发送者（DemoPublisher），发送者调用 ApplicationContext 来发送事件消息。</p>
<p>其中，ApplicationEvent 和 ApplicationListener 的代码实现都非常简单，内部并不包含太多属性和方法。实际上，它们最大的作用是做类型标识之用（继承自 ApplicationEvent 的类是事件，实现 ApplicationListener 的类是监听器）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title class_">EventObject</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7099057708183571937L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ApplicationEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(source);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getTimestamp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.timestamp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventObject</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">5516075349620653480L</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> Object  source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EventObject</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;null source&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;[source=&quot;</span> + source + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(E var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面讲到观察者模式的时候，我们提到，观察者需要事先注册到被观察者（JDK 的实现方式）或者事件总线（EventBus 的实现方式）中。那在 Spring 的实现中，观察者注册到了哪里呢？又是如何注册的呢？</p>
<p>Spring把观察者注册到了 ApplicationContext 对象中。这里的 ApplicationContext 就相当于 Google EventBus 框架中的“事件总线”。ApplicationContext 这个类并不只是为观察者模式服务的。它底层依赖 BeanFactory（IOC 的主要实现类），提供应用启动、运行时的上下文信息，是访问这些信息的最顶层接口。</p>
<p>ApplicationContext 只是一个接口，具体的代码实现包含在它的实现类 AbstractApplicationContext 中。我把跟观察者模式相关的代码，摘抄到了下面。我们只需关注它是如何发送事件和注册监听者就好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractApplicationContext</span> extends ... &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AbstractApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.applicationListeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.publishEvent(event, (ResolvableType)<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.publishEvent(event, (ResolvableType)<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event, ResolvableType eventType)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    Object applicationEvent;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">      applicationEvent = (ApplicationEvent)event;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      applicationEvent = <span class="keyword">new</span> <span class="title class_">PayloadApplicationEvent</span>(<span class="built_in">this</span>, event);</span><br><span class="line">      <span class="keyword">if</span> (eventType == <span class="literal">null</span>) &#123;</span><br><span class="line">        eventType = ((PayloadApplicationEvent)applicationEvent).getResolvableType();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationEvents != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.getApplicationEventMulticaster().multicastEvent(</span><br><span class="line">            (ApplicationEvent)applicationEvent, eventType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">        ((AbstractApplicationContext)<span class="built_in">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent.publishEvent(event);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span> &#123;</span><br><span class="line">    Assert.notNull(listener, <span class="string">&quot;ApplicationListener must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.applicationEventMulticaster != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.applicationEventMulticaster.addApplicationListener(listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.applicationListeners.add(listener);</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.applicationListeners;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="built_in">this</span>.getApplicationListeners().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">      ApplicationListener&lt;?&gt; listener = (ApplicationListener)var1.next();     <span class="built_in">this</span>.getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] listenerBeanNames = <span class="built_in">this</span>.getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    String[] var7 = listenerBeanNames;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var3</span> <span class="operator">=</span> listenerBeanNames.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">listenerBeanName</span> <span class="operator">=</span> var7[var4];</span><br><span class="line">      <span class="built_in">this</span>.getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="built_in">this</span>.earlyApplicationEvents;</span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (earlyEventsToProcess != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">Iterator</span> <span class="variable">var9</span> <span class="operator">=</span> earlyEventsToProcess.iterator();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(var9.hasNext()) &#123;</span><br><span class="line">        <span class="type">ApplicationEvent</span> <span class="variable">earlyEvent</span> <span class="operator">=</span> (ApplicationEvent)var9.next();</span><br><span class="line">        <span class="built_in">this</span>.getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们发现，真正的消息发送，实际上是通过 ApplicationEventMulticaster 这个类来完成的。这个类的源码我只摘抄了最关键的一部分，也就是 multicastEvent() 这个消息发送函数。它通过线程池，支持异步非阻塞、同步阻塞这两种类型的观察者模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.multicastEvent(event, <span class="built_in">this</span>.resolveDefaultEventType(event));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> &#123;</span><br><span class="line">  <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> eventType != <span class="literal">null</span> ? eventType : <span class="built_in">this</span>.resolveDefaultEventType(event);</span><br><span class="line">  <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.getApplicationListeners(event, type).iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">final</span> ApplicationListener&lt;?&gt; listener = (ApplicationListener)var4.next();</span><br><span class="line">    <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="built_in">this</span>.getTaskExecutor();</span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">      executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          SimpleApplicationEventMulticaster.<span class="built_in">this</span>.invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.invokeListener(listener, event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.multicastEvent(event, <span class="built_in">this</span>.resolveDefaultEventType(event));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> &#123;</span><br><span class="line">  <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> eventType != <span class="literal">null</span> ? eventType : <span class="built_in">this</span>.resolveDefaultEventType(event);</span><br><span class="line">  <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.getApplicationListeners(event, type).iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">final</span> ApplicationListener&lt;?&gt; listener = (ApplicationListener)var4.next();</span><br><span class="line">    <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="built_in">this</span>.getTaskExecutor();</span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">      executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          SimpleApplicationEventMulticaster.<span class="built_in">this</span>.invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.invokeListener(listener, event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借助 Spring 提供的观察者模式的骨架代码，如果我们要在 Spring 下实现某个事件的发送和监听，只需要做很少的工作，定义事件、定义监听器、往 ApplicationContext 中发送事件就可以了，剩下的工作都由 Spring 框架来完成。实际上，这也体现了 Spring 框架的扩展性，也就是在不需要修改任何代码的情况下，扩展新的事件和监听。</p>
<h1 id="模板模式在-Spring-中的应用"><a href="#模板模式在-Spring-中的应用" class="headerlink" title="模板模式在 Spring 中的应用"></a>模板模式在 Spring 中的应用</h1><p>我们来看下一下经常在面试中被问到的一个问题：请你说下 Spring Bean 的创建过程包含哪些主要的步骤。这其中就涉及模板模式。它也体现了 Spring 的扩展性。利用模板模式，Spring 能让用户定制 Bean 的创建过程。</p>
<p>Spring Bean 的创建过程，可以大致分为两大步：对象的创建和对象的初始化。</p>
<p>对象的创建是通过反射来动态生成对象，而不是 new 方法。不管是哪种方式，说白了，总归还是调用构造函数来生成对象，没有什么特殊的。对象的初始化有两种实现方式。一种是在类中自定义一个初始化函数，并且通过配置文件，显式地告知 Spring，哪个函数是初始化函数。我举了一个例子解释一下。如下所示，在配置文件中，我们通过 init-method 属性来指定初始化函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoClass</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...初始化..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置：需要通过init-method显式地指定初始化方法</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;demoBean&quot;</span> class=<span class="string">&quot;com.xzg.cd.DemoClass&quot;</span> init-method=<span class="string">&quot;initDemo&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>这种初始化方式有一个缺点，初始化函数并不固定，由用户随意定义，这就需要 Spring 通过反射，在运行时动态地调用这个初始化函数。而反射又会影响代码执行的性能，那有没有替代方案呢？</p>
<p>Spring 提供了另外一个定义初始化函数的方法，那就是让类实现 Initializingbean 接口。这个接口包含一个固定的初始化函数定义（afterPropertiesSet() 函数）。Spring 在初始化 Bean 的时候，可以直接通过 bean.afterPropertiesSet() 的方式，调用 Bean 对象上的这个函数，而不需要使用反射来调用了。我举个例子解释一下，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoClass</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//...初始化...      </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置：不需要显式地指定初始化方法</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;demoBean&quot;</span> class=<span class="string">&quot;com.xzg.cd.DemoClass&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>尽管这种实现方式不会用到反射，执行效率提高了，但业务代码（DemoClass）跟框架代码（InitializingBean）耦合在了一起。框架代码侵入到了业务代码中，替换框架的成本就变高了。所以，我并不是太推荐这种写法。</p>
<p>实际上，在 Spring 对 Bean 整个生命周期的管理中，还有一个跟初始化相对应的过程，那就是 Bean 的销毁过程。我们知道，在 Java 中，对象的回收是通过 JVM 来自动完成的。但是，我们可以在将 Bean 正式交给 JVM 垃圾回收前，执行一些销毁操作（比如关闭文件句柄等等）。</p>
<p>销毁过程跟初始化过程非常相似，也有两种实现方式。一种是通过配置 destroy-method 指定类中的销毁函数，另一种是让类实现 DisposableBean 接口。因为 destroy-method、DisposableBean 跟 init-method、InitializingBean 非常相似。</p>
<p>实际上，Spring 针对对象的初始化过程，还做了进一步的细化，将它拆分成了三个小步骤：</p>
<ol>
<li>初始化前置操作</li>
<li>初始化</li>
<li>初始化后置操作。</li>
</ol>
<p>其中，中间的初始化操作就是我们刚刚讲的那部分，初始化的前置和后置操作，定义在接口 BeanPostProcessor 中。BeanPostProcessor 的接口定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">  Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object var1, String var2)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">  Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object var1, String var2)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看下，如何通过 BeanPostProcessor 来定义初始化前置和后置操作？</p>
<p>我们只需要定义一个实现了 BeanPostProcessor 接口的处理器类，并在配置文件中像配置普通 Bean 一样去配置就可以了。Spring 中的 ApplicationContext 会自动检测在配置文件中实现了 BeanPostProcessor 接口的所有 Bean，并把它们注册到 BeanPostProcessor 处理器列表中。在 Spring 容器创建 Bean 的过程中，Spring 会逐一去调用这些处理器。</p>
<p>通过上面的分析，我们基本上弄清楚了 Spring Bean 的整个生命周期（创建加销毁）。针对这个过程，下面有张过程图：</p>
<p><img src="/../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%BF%87%E7%A8%8B.png" alt="Spring Bean生命周期过程"></p>
<p>一般情况，模板模式是需要定义一个包含模板方法的抽象模板类，以及定义子类实现模板方法。</p>
<p>这里的模板模式的实现，并不是标准的抽象类的实现方式，而是有点类似 Callback 回调的实现方式，也就是将要执行的函数封装成对象（比如，初始化方法封装成 InitializingBean 对象），传递给模板（BeanFactory）来执行。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-剖析Spring框架用到的11种设计模式</title>
    <url>/2022/10/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%89%96%E6%9E%90Spring%E6%A1%86%E6%9E%B6%E7%94%A8%E5%88%B0%E7%9A%8411%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>实际上，Spring 框架中用到的设计模式非常多，不下十几种。我们今天就总结罗列一下它们。</p>
<h1 id="适配器模式在-Spring-中的应用"><a href="#适配器模式在-Spring-中的应用" class="headerlink" title="适配器模式在 Spring 中的应用"></a>适配器模式在 Spring 中的应用</h1><p>在 Spring MVC 中，定义一个 Controller 最常用的方式是，通过 @Controller 注解来标记某个类是 Controller 类，通过 @RequesMapping 注解来标记函数对应的 URL。不过，定义一个 Controller 远不止这一种方法。我们还可以通过让类实现 Controller 接口或者 Servlet 接口，来定义一个 Controller。针对这三种定义方式，我写了三段示例代码，如下所示：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：通过@Controller、@RequestMapping来定义</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/employname&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">getEmployeeName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;Greeting&quot;</span>);        </span><br><span class="line">        model.addObject(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Dinesh&quot;</span>);       </span><br><span class="line">        <span class="keyword">return</span> model; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：实现Controller接口 + xml配置文件:配置DemoController与URL的对应关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;Greeting&quot;</span>);</span><br><span class="line">        model.addObject(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Dinesh Madhwal&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：实现Servlet接口 + xml配置文件:配置DemoController类与URL的对应关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;Hello World.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在应用启动的时候，Spring 容器会加载这些 Controller 类，并且解析出 URL 对应的处理函数，封装成 Handler 对象，存储到 HandlerMapping 对象中。当有请求到来的时候，DispatcherServlet 从 HanderMapping 中，查找请求 URL 对应的 Handler，然后调用执行 Handler 对应的函数代码，最后将执行结果返回给客户端。</p>
<p>但是，不同方式定义的 Controller，其函数的定义（函数名、入参、返回值等）是不统一的。如上示例代码所示，方法一中的函数的定义很随意、不固定，方法二中的函数定义是 handleRequest()、方法三中的函数定义是 service()（看似是定义了 doGet()、doPost()，实际上，这里用到了模板模式，Servlet 中的 service() 调用了 doGet() 或 doPost() 方法，DispatcherServlet 调用的是 service() 方法）。DispatcherServlet 需要根据不同类型的 Controller，调用不同的函数。下面是具体的伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> handlerMapping.get(URL);</span><br><span class="line"><span class="keyword">if</span> (handler <span class="keyword">instanceof</span> Controller) &#123;</span><br><span class="line">  ((Controller)handler).handleRequest(...);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> Servlet) &#123;</span><br><span class="line">  ((Servlet)handler).service(...);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hanlder 对应通过注解来定义的Controller) &#123;</span><br><span class="line">  反射调用方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中我们可以看出，这种实现方式会有很多 if-else 分支判断，而且，如果要增加一个新的 Controller 的定义方法，我们就要在 DispatcherServlet 类代码中，对应地增加一段如上伪代码所示的 if 逻辑。这显然不符合开闭原则。</p>
<p>实际上，我们可以利用适配器模式对代码进行改造，让其满足开闭原则，能更好地支持扩展。适配器其中一个作用是“统一多个类的接口设计”。利用适配器模式，我们将不同方式定义的 Controller 类中的函数，适配为统一的函数定义。这样，我们就能在 DispatcherServlet 类代码中，移除掉 if-else 分支判断逻辑，调用统一的函数。</p>
<p>Spring 定义了统一的接口 HandlerAdapter，并且对每种 Controller 定义了对应的适配器类。这些适配器类包括：AnnotationMethodHandlerAdapter、SimpleControllerHandlerAdapter、SimpleServletHandlerAdapter 等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object var1)</span>;</span><br><span class="line"></span><br><span class="line">  ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2, Object var3)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="title function_">getLastModified</span><span class="params">(HttpServletRequest var1, Object var2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应实现Controller接口的Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SimpleControllerHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> handler <span class="keyword">instanceof</span> Controller;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> ((Controller)handler).handleRequest(request, response);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> handler <span class="keyword">instanceof</span> LastModified ? ((LastModified)handler).getLastModified(request) : -<span class="number">1L</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应实现Servlet接口的Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleServletHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SimpleServletHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> handler <span class="keyword">instanceof</span> Servlet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ((Servlet)handler).service(request, response);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AnnotationMethodHandlerAdapter对应通过注解实现的Controller，</span></span><br><span class="line"><span class="comment">//代码太多了，就不贴了</span></span><br></pre></td></tr></table></figure>

<p>在 DispatcherServlet 类中，我们就不需要区分对待不同的 Controller 对象了，统一调用 HandlerAdapter 的 handle() 函数就可以了。按照这个思路实现的伪代码如下所示。你看，这样就没有烦人的 if-else 逻辑了吧？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前的实现方式</span></span><br><span class="line"><span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> handlerMapping.get(URL);</span><br><span class="line"><span class="keyword">if</span> (handler <span class="keyword">instanceof</span> Controller) &#123;</span><br><span class="line">  ((Controller)handler).handleRequest(...);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> Servlet) &#123;</span><br><span class="line">  ((Servlet)handler).service(...);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hanlder 对应通过注解来定义的Controller) &#123;</span><br><span class="line">  反射调用方法...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在实现方式</span></span><br><span class="line"><span class="type">HandlerAdapter</span> <span class="variable">handlerAdapter</span> <span class="operator">=</span> handlerMapping.get(URL);</span><br><span class="line">handlerAdapter.handle(...);</span><br></pre></td></tr></table></figure>

<h1 id="策略模式在-Spring-中的应用"><a href="#策略模式在-Spring-中的应用" class="headerlink" title="策略模式在 Spring 中的应用"></a>策略模式在 Spring 中的应用</h1><p>Spring AOP 是通过动态代理来实现的。Spring 支持两种动态代理实现方式，一种是 JDK 提供的动态代理实现方式，另一种是 Cglib 提供的动态代理实现方式。<br>前者需要被代理的类有抽象的接口定义，后者不需要。针对不同的被代理类，Spring 会在运行时动态地选择不同的动态代理实现方式。这个应用场景实际上就是策略模式的典型应用场景。</p>
<p>我们前面讲过，策略模式包含三部分，策略的定义、创建和使用。接下来，我们具体看下，这三个部分是如何体现在 Spring 源码中的。</p>
<p>在策略模式中，策略的定义这一部分很简单。我们只需要定义一个策略接口，让不同的策略类都实现这一个策略接口。对应到 Spring 源码，AopProxy 是策略接口，JdkDynamicAopProxy、CglibAopProxy 是两个实现了 AopProxy 接口的策略类。其中，AopProxy 接口的定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AopProxy</span> &#123;</span><br><span class="line">  Object <span class="title function_">getProxy</span><span class="params">()</span>;</span><br><span class="line">  Object <span class="title function_">getProxy</span><span class="params">(ClassLoader var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在策略模式中，策略的创建一般通过工厂方法来实现。对应到 Spring 源码，AopProxyFactory 是一个工厂类接口，DefaultAopProxyFactory 是一个默认的工厂类，用来创建 AopProxy 对象。两者的源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AopProxyFactory</span> &#123;</span><br><span class="line">  AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport var1)</span> <span class="keyword">throws</span> AopConfigException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">AopProxyFactory</span>, Serializable &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DefaultAopProxyFactory</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !<span class="built_in">this</span>.hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">      <span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass) ? <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config) : <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//用来判断用哪个动态代理实现方式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line">    <span class="keyword">return</span> ifcs.length == <span class="number">0</span> || ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>策略模式的典型应用场景，一般是通过环境变量、状态值、计算结果等动态地决定使用哪个策略。对应到 Spring 源码中，我们可以参看刚刚给出的 DefaultAopProxyFactory 类中的 createAopProxy() 函数的代码实现。其中，第 10 行代码是动态选择哪种策略的判断条件。</p>
<h1 id="组合模式在-Spring-中的应用"><a href="#组合模式在-Spring-中的应用" class="headerlink" title="组合模式在 Spring 中的应用"></a>组合模式在 Spring 中的应用</h1><p>上节课讲到 Spring“再封装、再抽象”设计思想的时候，我们提到了 Spring Cache。Spring Cache 提供了一套抽象的 Cache 接口。使用它我们能够统一不同缓存实现（Redis、Google Guava…）的不同的访问方式。Spring 中针对不同缓存实现的不同缓存访问类，都依赖这个接口，比如：EhCacheCache、GuavaCache、NoOpCache、RedisCache、JCacheCache、ConcurrentMapCache、CaffeineCache。Cache 接口的源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">  String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">  Object <span class="title function_">getNativeCache</span><span class="params">()</span>;</span><br><span class="line">  Cache.ValueWrapper <span class="title function_">get</span><span class="params">(Object var1)</span>;</span><br><span class="line">  &lt;T&gt; T <span class="title function_">get</span><span class="params">(Object var1, Class&lt;T&gt; var2)</span>;</span><br><span class="line">  &lt;T&gt; T <span class="title function_">get</span><span class="params">(Object var1, Callable&lt;T&gt; var2)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Object var1, Object var2)</span>;</span><br><span class="line">  Cache.ValueWrapper <span class="title function_">putIfAbsent</span><span class="params">(Object var1, Object var2)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">evict</span><span class="params">(Object var1)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ValueRetrievalException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ValueRetrievalException</span><span class="params">(Object key, Callable&lt;?&gt; loader, Throwable ex)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(String.format(<span class="string">&quot;Value for key &#x27;%s&#x27; could not be loaded using &#x27;%s&#x27;&quot;</span>, key, loader), ex);</span><br><span class="line">      <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ValueWrapper</span> &#123;</span><br><span class="line">    Object <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际的开发中，一个项目有可能会用到多种不同的缓存，比如既用到 Google Guava 缓存，也用到 Redis 缓存。除此之外，同一个缓存实例，也可以根据业务的不同，分割成多个小的逻辑缓存单元（或者叫作命名空间）。</p>
<p>为了管理多个缓存，Spring 还提供了缓存管理功能。不过，它包含的功能很简单，主要有这样两部分：一个是根据缓存名字（创建 Cache 对象的时候要设置 name 属性）获取 Cache 对象；另一个是获取管理器管理的所有缓存的名字列表。对应的 Spring 源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CacheManager</span> &#123;</span><br><span class="line">  Cache <span class="title function_">getCache</span><span class="params">(String var1)</span>;</span><br><span class="line">  Collection&lt;String&gt; <span class="title function_">getCacheNames</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚刚给出的是 CacheManager 接口的定义，那如何来实现这两个接口呢？实际上，这就要用到组合模式。</p>
<p>组合模式主要应用在能表示成树形结构的一组数据上。树中的结点分为叶子节点和中间节点两类。对应到 Spring 源码，EhCacheManager、SimpleCacheManager、NoOpCacheManager、RedisCacheManager 等表示叶子节点，CompositeCacheManager 表示中间节点。</p>
<p>叶子节点包含的是它所管理的 Cache 对象，中间节点包含的是其他 CacheManager 管理器，既可以是 CompositeCacheManager，也可以是具体的管理器，比如 EhCacheManager、RedisManager 等。</p>
<p>我把 CompositeCacheManger 的代码贴到了下面，你可以结合着讲解一块看下。其中，getCache()、getCacheNames() 两个函数的实现都用到了递归。这正是树形结构最能发挥优势的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompositeCacheManager</span> <span class="keyword">implements</span> <span class="title class_">CacheManager</span>, InitializingBean &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CacheManager&gt; cacheManagers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">fallbackToNoOpCache</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CompositeCacheManager</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CompositeCacheManager</span><span class="params">(CacheManager... cacheManagers)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setCacheManagers(Arrays.asList(cacheManagers));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCacheManagers</span><span class="params">(Collection&lt;CacheManager&gt; cacheManagers)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cacheManagers.addAll(cacheManagers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFallbackToNoOpCache</span><span class="params">(<span class="type">boolean</span> fallbackToNoOpCache)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fallbackToNoOpCache = fallbackToNoOpCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.fallbackToNoOpCache) &#123;</span><br><span class="line">      <span class="built_in">this</span>.cacheManagers.add(<span class="keyword">new</span> <span class="title class_">NoOpCacheManager</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Cache <span class="title function_">getCache</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">this</span>.cacheManagers.iterator();</span><br><span class="line"></span><br><span class="line">    Cache cache;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!var2.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">CacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> (CacheManager)var2.next();</span><br><span class="line">      cache = cacheManager.getCache(name);</span><br><span class="line">    &#125; <span class="keyword">while</span>(cache == <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Collection&lt;String&gt; <span class="title function_">getCacheNames</span><span class="params">()</span> &#123;</span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">this</span>.cacheManagers.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">      <span class="type">CacheManager</span> <span class="variable">manager</span> <span class="operator">=</span> (CacheManager)var2.next();</span><br><span class="line">      names.addAll(manager.getCacheNames());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableSet(names);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="装饰器模式在-Spring-中的应用"><a href="#装饰器模式在-Spring-中的应用" class="headerlink" title="装饰器模式在 Spring 中的应用"></a>装饰器模式在 Spring 中的应用</h1><p>我们知道，缓存一般都是配合数据库来使用的。如果写缓存成功，但数据库事务回滚了，那缓存中就会有脏数据。为了解决这个问题，我们需要将缓存的写操作和数据库的写操作，放到同一个事务中，要么都成功，要么都失败。</p>
<p>实现这样一个功能，Spring 使用到了装饰器模式。TransactionAwareCacheDecorator 增加了对事务的支持，在事务提交、回滚的时候分别对 Cache 的数据进行处理。</p>
<p>TransactionAwareCacheDecorator 实现 Cache 接口，并且将所有的操作都委托给 targetCache 来实现，对其中的写操作添加了事务功能。这是典型的装饰器模式的应用场景和代码实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionAwareCacheDecorator</span> <span class="keyword">implements</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Cache targetCache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TransactionAwareCacheDecorator</span><span class="params">(Cache targetCache)</span> &#123;</span><br><span class="line">    Assert.notNull(targetCache, <span class="string">&quot;Target Cache must not be null&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.targetCache = targetCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Cache <span class="title function_">getTargetCache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.targetCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.targetCache.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getNativeCache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.targetCache.getNativeCache();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> ValueWrapper <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.targetCache.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(Object key, Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.targetCache.get(key, type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(Object key, Callable&lt;T&gt; valueLoader)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.targetCache.get(key, valueLoader);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="keyword">final</span> Object key, <span class="keyword">final</span> Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">      TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> <span class="title class_">TransactionSynchronizationAdapter</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCommit</span><span class="params">()</span> &#123;</span><br><span class="line">          TransactionAwareCacheDecorator.<span class="built_in">this</span>.targetCache.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.targetCache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> ValueWrapper <span class="title function_">putIfAbsent</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.targetCache.putIfAbsent(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evict</span><span class="params">(<span class="keyword">final</span> Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">      TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> <span class="title class_">TransactionSynchronizationAdapter</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCommit</span><span class="params">()</span> &#123;</span><br><span class="line">          TransactionAwareCacheDecorator.<span class="built_in">this</span>.targetCache.evict(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.targetCache.evict(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">      TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> <span class="title class_">TransactionSynchronizationAdapter</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCommit</span><span class="params">()</span> &#123;</span><br><span class="line">          TransactionAwareCacheDecorator.<span class="built_in">this</span>.targetCache.clear();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.targetCache.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="工厂模式在-Spring-中的应用"><a href="#工厂模式在-Spring-中的应用" class="headerlink" title="工厂模式在 Spring 中的应用"></a>工厂模式在 Spring 中的应用</h1><p>在 Spring 中，工厂模式最经典的应用莫过于实现 IOC 容器，对应的 Spring 源码主要是 BeanFactory 类和 ApplicationContext 相关类（AbstractApplicationContext、ClassPathXmlApplicationContext、FileSystemXmlApplicationContext…）。除此之外，在理论部分，我还带你手把手实现了一个简单的 IOC 容器。你可以回过头去再看下。</p>
<p>在 Spring 中，创建 Bean 的方式有很多种，比如前面提到的纯构造函数、无参构造函数加 setter 方法。我写了一个例子来说明这两种创建方式，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">long</span> id, String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 使用构造函数来创建Bean</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xzg.cd.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wangzheng&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 使用无参构造函数+setter方法来创建Bean</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xzg.cd.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wangzheng&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实际上，除了这两种创建 Bean 的方式之外，我们还可以通过工厂方法来创建 Bean。还是刚刚这个例子，用这种方式来创建 Bean 的话就是下面这个样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long, Student&gt; students = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>,<span class="string">&quot;wang&quot;</span>));</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>,<span class="string">&quot;zheng&quot;</span>));</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>,<span class="string">&quot;xzg&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title function_">getStudent</span><span class="params">(<span class="type">long</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> students.get(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过工厂方法getStudent(2)来创建BeanId=&quot;zheng&quot;&quot;的Bean</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;zheng&quot;</span> class=<span class="string">&quot;com.xzg.cd.StudentFactory&quot;</span> factory-method=<span class="string">&quot;getStudent&quot;</span>&gt;</span><br><span class="line">    &lt;constructor-arg value=<span class="string">&quot;2&quot;</span>&gt;&lt;/constructor-arg&gt;           </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h1 id="其他模式在-Spring-中的应用"><a href="#其他模式在-Spring-中的应用" class="headerlink" title="其他模式在 Spring 中的应用"></a>其他模式在 Spring 中的应用</h1><p>SpEL，全称叫 Spring Expression Language，是 Spring 中常用来编写配置的表达式语言。它定义了一系列的语法规则。我们只要按照这些语法规则来编写表达式，Spring 就能解析出表达式的含义。实际上，这就是我们前面讲到的解释器模式的典型应用场景。</p>
<p>因为解释器模式没有一个非常固定的代码实现结构，而且 Spring 中 SpEL 相关的代码也比较多，所以这里就不带你一块阅读源码了。如果感兴趣或者项目中正好要实现类似的功能的时候，你可以再去阅读、借鉴它的代码实现。代码主要集中在 spring-expresssion 这个模块下面。</p>
<p>单例模式有很多弊端，比如单元测试不友好等。应对策略就是通过 IOC 容器来管理对象，通过 IOC 容器来实现对象的唯一性的控制。实际上，这样实现的单例并非真正的单例，它的唯一性的作用范围仅仅在同一个 IOC 容器内。</p>
<p>除此之外，Spring 还用到了观察者模式、模板模式、职责链模式、代理模式。</p>
<p>实际上，在 Spring 中，只要后缀带有 Template 的类，基本上都是模板类，而且大部分都是用 Callback 回调来实现的，比如 JdbcTemplate、RedisTemplate 等。剩下的两个模式在 Spring 中的应用应该人尽皆知了。职责链模式在 Spring 中的应用是拦截器（Interceptor），代理模式经典应用是 AOP。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-备忘录模式</title>
    <url>/2022/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="备忘录模式的原理与实现"><a href="#备忘录模式的原理与实现" class="headerlink" title="备忘录模式的原理与实现"></a>备忘录模式的原理与实现</h1><p>备忘录模式，也叫快照（Snapshot）模式，英文翻译是 Memento Design Pattern。在 GoF 的《设计模式》一书中，备忘录模式是这么定义的：</p>
<blockquote>
<p>Captures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.</p>
</blockquote>
<p>翻译成中文就是：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</p>
<span id="more"></span>

<p>这个模式的定义主要表达了两部分内容。一部分是，存储副本以便后期恢复。这一部分很好理解。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。这部分不太好理解。</p>
<p>接下来，我就结合一个例子来解释一下，特别带你搞清楚这两个问题：</p>
<ul>
<li>为什么存储和恢复副本会违背封装原则？</li>
<li>备忘录模式是如何做到不违背封装原则的？</li>
</ul>
<p>假设有这样一道面试题，希望你编写一个小程序，可以接收命令行的输入。用户输入文本时，程序将其追加存储在内存文本中；用户输入“:list”，程序在命令行中输出内存文本的内容；用户输入“:undo”，程序会撤销上一次输入的文本，也就是从内存文本中将上次输入的文本删除掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;hello</span><br><span class="line">&gt;:list</span><br><span class="line">hello</span><br><span class="line">&gt;world</span><br><span class="line">&gt;:list</span><br><span class="line">helloworld</span><br><span class="line">&gt;:undo</span><br><span class="line">&gt;:list</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputText</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> text.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(String input)</span> &#123;</span><br><span class="line">    text.append(input);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.text.replace(<span class="number">0</span>, <span class="built_in">this</span>.text.length(), text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotHolder</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;InputText&gt; snapshots = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> InputText <span class="title function_">popSnapshot</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> snapshots.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushSnapshot</span><span class="params">(InputText inputText)</span> &#123;</span><br><span class="line">    <span class="type">InputText</span> <span class="variable">deepClonedInputText</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputText</span>();</span><br><span class="line">    deepClonedInputText.setText(inputText.getText());</span><br><span class="line">    snapshots.push(deepClonedInputText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationMain</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">InputText</span> <span class="variable">inputText</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputText</span>();</span><br><span class="line">    <span class="type">SnapshotHolder</span> <span class="variable">snapshotsHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SnapshotHolder</span>();</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">      <span class="keyword">if</span> (input.equals(<span class="string">&quot;:list&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(inputText.getText());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.equals(<span class="string">&quot;:undo&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">InputText</span> <span class="variable">snapshot</span> <span class="operator">=</span> snapshotsHolder.popSnapshot();</span><br><span class="line">        inputText.setText(snapshot.getText());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        snapshotsHolder.pushSnapshot(inputText);</span><br><span class="line">        inputText.append(input);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，备忘录模式的实现很灵活，也没有很固定的实现方式，在不同的业务需求、不同编程语言下，代码实现可能都不大一样。上面的代码基本上已经实现了最基本的备忘录的功能。但是，如果我们深究一下的话，还有一些问题要解决，那就是前面定义中提到的第二点：要在不违背封装原则的前提下，进行对象的备份和恢复。而上面的代码并不满足这一点，主要体现在下面两方面：</p>
<p>第一，为了能用快照恢复 InputText 对象，我们在 InputText 类中定义了 setText() 函数，但这个函数有可能会被其他业务使用，所以，暴露不应该暴露的函数违背了封装原则；</p>
<p>第二，快照本身是不可变的，理论上讲，不应该包含任何 set() 等修改内部状态的函数，但在上面的代码实现中，“快照“这个业务模型复用了 InputText 类的定义，而 InputText 类本身有一系列修改内部状态的函数，所以，用 InputText 类来表示快照违背了封装原则。</p>
<p>针对以上问题，我们对代码做两点修改。其一，定义一个独立的类（Snapshot 类）来表示快照，而不是复用 InputText 类。这个类只暴露 get() 方法，没有 set() 等任何修改内部状态的方法。其二，在 InputText 类中，我们把 setText() 方法重命名为 restoreSnapshot() 方法，用意更加明确，只用来恢复对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputText</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> text.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(String input)</span> &#123;</span><br><span class="line">    text.append(input);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Snapshot <span class="title function_">createSnapshot</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Snapshot</span>(text.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreSnapshot</span><span class="params">(Snapshot snapshot)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.text.replace(<span class="number">0</span>, <span class="built_in">this</span>.text.length(), snapshot.getText());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Snapshot</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Snapshot</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.text = text;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.text;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotHolder</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Snapshot&gt; snapshots = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Snapshot <span class="title function_">popSnapshot</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> snapshots.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushSnapshot</span><span class="params">(Snapshot snapshot)</span> &#123;</span><br><span class="line">    snapshots.push(snapshot);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationMain</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">InputText</span> <span class="variable">inputText</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputText</span>();</span><br><span class="line">    <span class="type">SnapshotHolder</span> <span class="variable">snapshotsHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SnapshotHolder</span>();</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">      <span class="keyword">if</span> (input.equals(<span class="string">&quot;:list&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(inputText.toString());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.equals(<span class="string">&quot;:undo&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">Snapshot</span> <span class="variable">snapshot</span> <span class="operator">=</span> snapshotsHolder.popSnapshot();</span><br><span class="line">        inputText.restoreSnapshot(snapshot);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        snapshotsHolder.pushSnapshot(inputText.createSnapshot());</span><br><span class="line">        inputText.append(input);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，上面的代码实现就是典型的备忘录模式的代码实现，也是很多书籍（包括 GoF 的《设计模式》）中给出的实现方法。</p>
<p>除了备忘录模式，还有一个跟它很类似的概念，“备份”，它在我们平时的开发中更常听到。那备忘录模式跟“备份”有什么区别和联系呢？实际上，这两者的应用场景很类似，都应用在防丢失、恢复、撤销等场景中。它们的区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p>
<h1 id="如何优化内存和时间消耗？"><a href="#如何优化内存和时间消耗？" class="headerlink" title="如何优化内存和时间消耗？"></a>如何优化内存和时间消耗？</h1><p>前面我们只是简单介绍了备忘录模式的原理和经典实现，现在我们再继续深挖一下。如果要备份的对象数据比较大，备份频率又比较高，那快照占用的内存会比较大，备份和恢复的耗时会比较长。这个问题该如何解决呢？</p>
<p>不同的应用场景下有不同的解决方法。比如，我们前面举的那个例子，应用场景是利用备忘录来实现撤销操作，而且仅仅支持顺序撤销，也就是说，每次操作只能撤销上一次的输入，不能跳过上次输入撤销之前的输入。在具有这样特点的应用场景下，为了节省内存，我们不需要在快照中存储完整的文本，只需要记录少许信息，比如在获取快照当下的文本长度，用这个值结合 InputText 类对象存储的文本来做撤销操作。</p>
<p>我们再举一个例子。假设每当有数据改动，我们都需要生成一个备份，以备之后恢复。如果需要备份的数据很大，这样高频率的备份，不管是对存储（内存或者硬盘）的消耗，还是对时间的消耗，都可能是无法接受的。想要解决这个问题，我们一般会采用“低频率全量备份”和“高频率增量备份”相结合的方法。</p>
<p>全量备份就不用讲了，它跟我们上面的例子类似，就是把所有的数据“拍个快照”保存下来。所谓“增量备份”，指的是记录每次操作或数据变动。当我们需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，我们直接拿来恢复就可以了。如果这一时间点没有对应的全量备份，我们就先找到最近的一次全量备份，然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的操作或者数据变动。这样就能减少全量备份的数量和频率，减少对时间、内存的消耗。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式-依赖注入容器</title>
    <url>/2022/07/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。</p>
<p>DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p>
<p>除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。</p>
<span id="more"></span>

<h1 id="DI-容器的核心功能"><a href="#DI-容器的核心功能" class="headerlink" title="DI 容器的核心功能"></a>DI 容器的核心功能</h1><ul>
<li>配置解析</li>
<li>对象创建</li>
<li>对象生命周期管理</li>
</ul>
<h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><p>我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</p>
<p>容器读取这个配置文件，解析出要创建的两个对象：<code>rateLimiter</code> 和 <code>redisCounter</code>，并且得到两者的依赖关系：<code>rateLimiter</code> 依赖 <code>redisCounter</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisCounter redisCounter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RateLimiter</span><span class="params">(RedisCounter redisCounter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisCounter = redisCounter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> RedisCounter <span class="title function_">getRedisCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisCounter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(redisCounter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String ipAddress;</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCounter</span><span class="params">(String ipAddress, String port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ipAddress = ipAddress;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件<code>beans.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;rateLimiter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mono.monochrome.bean.RateLimiter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;redisCounter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisCounter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mono.monochrome.bean.RedisCounter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span>127.0.0.1<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span>1234<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 <code>BeansFactory</code>。</p>
<p>如果要创建的类对象非常多，<code>BeansFactory</code> 利用<code>Java</code>的“反射”机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。</p>
<h2 id="对象的生命周期管理"><a href="#对象的生命周期管理" class="headerlink" title="对象的生命周期管理"></a>对象的生命周期管理</h2><p>简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope&#x3D;prototype 表示返回新创建的对象，scope&#x3D;singleton 表示返回单例对象。</p>
<p>除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init&#x3D;true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init&#x3D;false，对象在应用启动的时候就事先创建好。</p>
<h1 id="实现一个简单的-DI-容器"><a href="#实现一个简单的-DI-容器" class="headerlink" title="实现一个简单的 DI 容器"></a>实现一个简单的 DI 容器</h1><h2 id="最小原型设计"><a href="#最小原型设计" class="headerlink" title="最小原型设计"></a>最小原型设计</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">RedisCounter</span> <span class="variable">redisCounter</span> <span class="operator">=</span> (RedisCounter) applicationContext.getBean(<span class="string">&quot;redisCounter&quot;</span>);</span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> (RateLimiter) applicationContext.getBean(<span class="string">&quot;rateLimiter&quot;</span>);</span><br><span class="line">        System.out.println(redisCounter);</span><br><span class="line">        rateLimiter.test();</span><br><span class="line">        System.out.println(redisCounter == rateLimiter.getRedisCounter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提供执行入口"><a href="#提供执行入口" class="headerlink" title="提供执行入口"></a>提供执行入口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String beanId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeansFactory beansFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanConfigParser beanConfigParser;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beansFactory = <span class="keyword">new</span> <span class="title class_">BeansFactory</span>();</span><br><span class="line">        <span class="built_in">this</span>.beanConfigParser = <span class="keyword">new</span> <span class="title class_">XmlBeanConfigParser</span>();</span><br><span class="line">        <span class="built_in">this</span>.loadBeanDefinitions(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(String configLocation)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="built_in">this</span>.getClass().getResourceAsStream(<span class="string">&quot;/&quot;</span> + configLocation);</span><br><span class="line">            <span class="keyword">if</span> (inputStream == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can not find config file: &quot;</span> + configLocation);</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(inputStream);</span><br><span class="line">            beansFactory.addBeanDefinitions(beanDefinitions);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String beanId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beansFactory.getBean(beanId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClassPathXmlApplicationContext</code> 负责组装 <code>BeansFactory</code> 和 <code>BeanConfigParser</code> 两个类，串联执行流程：从 <code>classpath</code> 中加载 <code>xml</code> 格式的配置文件，通过 <code>BeanConfigParser</code> 解析为统一的 <code>BeanDefinition</code> 格式，然后，<code>BeansFactory</code> 根据 <code>BeanDefinition</code> 来创建对象。</p>
<h2 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h2><p>配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。</p>
<p>pom文件中引入解析xml文件的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>BeanDefinition：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> Scope.SINGLETON;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">lazyInit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//setter and getter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Scope</span> &#123;</span><br><span class="line">        SINGLETON,</span><br><span class="line">        PROTOTYPE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConstructorArg</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isRef</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">private</span> Class type;</span><br><span class="line">        <span class="keyword">private</span> Object arg;</span><br><span class="line">        <span class="comment">//settier and getter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanConfigParser：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanConfigParser</span> &#123;</span><br><span class="line">    List&lt;BeanDefinition&gt; <span class="title function_">parse</span><span class="params">(InputStream inputStream)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlBeanConfigParser</span> <span class="keyword">implements</span> <span class="title class_">BeanConfigParser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">SAXReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XmlBeanConfigParser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;BeanDefinition&gt; <span class="title function_">parse</span><span class="params">(InputStream inputStream)</span> &#123;</span><br><span class="line">        List&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> reader.read(inputStream);<span class="comment">// 获取根节点</span></span><br><span class="line">            <span class="type">Element</span> <span class="variable">beans</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">            <span class="comment">// 获取迭代器</span></span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">beanIt</span> <span class="operator">=</span> beans.elementIterator();</span><br><span class="line">            <span class="comment">// 遍历迭代器，获取根节点信息</span></span><br><span class="line">            <span class="keyword">while</span>(beanIt.hasNext())&#123;</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>();</span><br><span class="line">                <span class="type">Element</span> <span class="variable">bean</span> <span class="operator">=</span> (Element) beanIt.next();</span><br><span class="line"></span><br><span class="line">                List&lt;Attribute&gt; attributes = bean.attributes();</span><br><span class="line">                <span class="comment">// 获取bean属性名和属性值</span></span><br><span class="line">                <span class="keyword">for</span> (Attribute attribute : attributes) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;id&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                        beanDefinition.setId(attribute.getValue());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;class&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                        beanDefinition.setClassName(attribute.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Iterator</span> <span class="variable">argsIt</span> <span class="operator">=</span> bean.elementIterator();</span><br><span class="line">                List&lt;BeanDefinition.ConstructorArg&gt; constructorArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span>(argsIt.hasNext())&#123;</span><br><span class="line">                    BeanDefinition.<span class="type">ConstructorArg</span> <span class="variable">constructorArg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>.ConstructorArg();</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">arg</span> <span class="operator">=</span> (Element) argsIt.next();</span><br><span class="line">                    List&lt;Attribute&gt; argAttributes = arg.attributes();</span><br><span class="line">                    <span class="comment">// 获取bean属性名和属性值</span></span><br><span class="line">                    <span class="keyword">for</span> (Attribute attribute : argAttributes) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;type&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                constructorArg.setType(Class.forName(attribute.getValue()));</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                            constructorArg.setArg(arg.getText());</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;ref&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                            constructorArg.setRef(<span class="literal">true</span>);</span><br><span class="line">                            constructorArg.setArg(attribute.getValue());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    constructorArgs.add(constructorArg);</span><br><span class="line">                    beanDefinition.setConstructorArgs(constructorArgs);</span><br><span class="line">                &#125;</span><br><span class="line">                beanDefinitions.add(beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂类设计"><a href="#工厂类设计" class="headerlink" title="工厂类设计"></a>工厂类设计</h2><p>如果对象的 <code>scope</code> 属性是 <code>singleton</code>，那对象创建之后会缓存在 <code>singletonObjects</code> 这样一个 <code>map</code> 中，下次再请求此对象的时候，直接从 <code>map</code> 中取出返回，不需要重新创建。如果对象的 <code>scope</code> 属性是 <code>prototype</code>，那每次请求对象，<code>BeansFactory</code> 都会创建一个新的对象返回。实际上，<code>BeansFactory</code> 创建对象用到的主要技术点就是 <code>Java</code> 中的反射语法：一种动态加载类和创建对象的机制。我们知道，<code>JVM</code> 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 <code>JVM</code> 帮我们自动完成了，我们需要利用 <code>Java</code> 提供的反射语法自己去编写代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeanDefinitions</span><span class="params">(List&lt;BeanDefinition&gt; beanDefinitions)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitions) &#123;</span><br><span class="line">            <span class="built_in">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!beanDefinition.isLazyInit() &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> createBean(beanDefinition);</span><br><span class="line">                singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String beanId)</span> &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> beanDefinitions.get(beanId);</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Bean is not defined:&quot;</span> + beanId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> createBean(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.containsKey(beanDefinition.getId())) &#123;</span><br><span class="line">            <span class="keyword">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">beanClass</span> <span class="operator">=</span> Class.forName(beanDefinition.getClassName());</span><br><span class="line">            List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();</span><br><span class="line">            <span class="keyword">if</span> (args.isEmpty()) &#123;</span><br><span class="line">                bean = beanClass.newInstance();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Class[] argClasses = <span class="keyword">new</span> <span class="title class_">Class</span>[args.size()];</span><br><span class="line">                Object[] argObjects = <span class="keyword">new</span> <span class="title class_">Object</span>[args.size()];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.size(); i++) &#123;</span><br><span class="line">                    BeanDefinition.<span class="type">ConstructorArg</span> <span class="variable">arg</span> <span class="operator">=</span> args.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (!arg.isRef()) &#123;</span><br><span class="line">                        argClasses[i] = arg.getType();</span><br><span class="line">                        argObjects[i] = arg.getArg();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">BeanDefinition</span> <span class="variable">refBeanDefinition</span> <span class="operator">=</span> beanDefinitions.get(arg.getArg());</span><br><span class="line">                        <span class="keyword">if</span> (refBeanDefinition == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(<span class="string">&quot;Bean is not defined: &quot;</span> + arg.getArg());</span><br><span class="line">                        &#125;</span><br><span class="line">                        argClasses[i] = Class.forName(refBeanDefinition.getClassName());</span><br><span class="line">                        <span class="comment">// 依赖的bean还未创建，先去创建依赖的bean</span></span><br><span class="line">                        argObjects[i] = createBean(refBeanDefinition);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                bean = beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException |</span><br><span class="line">                 NoSuchBeanDefinitionException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition.isSingleton()) &#123;</span><br><span class="line">            singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeansFactory</code> 类中的 <code>createBean()</code> 函数是一个递归函数。当构造函数的参数是 <code>ref</code> 类型时，会递归地创建 <code>ref</code> 属性指向的对象。如果我们在配置文件中错误地配置了对象之间的依赖关系，导致存在循环依赖，后续再解决循环依赖吧。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-命令模式</title>
    <url>/2022/09/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>命令模式的原理解读命令模式的英文翻译是 Command Design Pattern。在 GoF 的《设计模式》一书中，它是这么定义的：</p>
<blockquote>
<p>The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.</p>
</blockquote>
<p>翻译成中文就是下面这样。为了帮助你理解，我对这个翻译稍微做了补充和解释，也一起放在了下面的括号中。命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。</p>
<span id="more"></span>

<p>落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。我们知道，C 语言支持函数指针，我们可以把函数当作变量传递来传递去。但是，在大部分编程语言中，函数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，我们可以将函数封装成对象。具体来说就是，设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，它类似我们之前讲过的回调。</p>
<p>当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</p>
<p>命令模式的实战讲解上面的讲解比较偏理论，比较不好理解，我这里再结合一个具体的例子来解释一下。</p>
<p>假设我们正在开发一个类似《天天酷跑》或者《QQ 卡丁车》这样的手游。这种游戏本身的复杂度集中在客户端。后端基本上只负责数据（比如积分、生命值、装备）的更新和查询，所以，后端逻辑相对于客户端来说，要简单很多。</p>
<p>考虑到你可能对游戏开发不熟悉，我这里稍微交代一些背景知识。为了提高性能，我们会把游戏中玩家的信息保存在内存中。在游戏进行的过程中，只更新内存中的数据，游戏结束之后，再将内存中的数据存档，也就是持久化到数据库中。为了降低实现的难度，一般来说，同一个游戏场景里的玩家，会被分配到同一台服务上。这样，一个玩家拉取同一个游戏场景中的其他玩家的信息，就不需要跨服务器去查找了，实现起来就简单了很多。</p>
<p>一般来说，游戏客户端和服务器之间的数据交互是比较频繁的，所以，为了节省网络连接建立的开销，客户端和服务器之间一般采用长连接的方式来通信。通信的格式有多种，比如 Protocol Buffer、JSON、XML，甚至可以自定义格式。不管是什么格式，客户端发送给服务器的请求，一般都包括两部分内容：指令和数据。其中，指令我们也可以叫作事件，数据是执行这个指令所需的数据。</p>
<p>服务器在接收到客户端的请求之后，会解析出指令和数据，并且根据指令的不同，执行不同的处理逻辑。对于这样的一个业务场景，一般有两种架构实现思路。</p>
<p>常用的一种实现思路是利用多线程。一个线程接收请求，接收到请求之后，启动一个新的线程来处理请求。具体点讲，一般是通过一个主线程来接收客户端发来的请求。每当接收到一个请求之后，就从一个专门用来处理请求的线程池中，捞出一个空闲线程来处理。另一种实现思路是在一个线程内轮询接收请求和处理请求。这种处理方式不太常见。尽管它无法利用多线程多核处理的优势，但是对于 IO 密集型的业务来说，它避免了多线程不停切换对性能的损耗，并且克服了多线程编程 Bug 比较难调试的缺点，也算是手游后端服务器开发中比较常见的架构模式了。</p>
<p>然后就是第二种实现方式。整个手游后端服务器轮询获取客户端发来的请求，获取到请求之后，借助命令模式，把请求包含的数据和处理逻辑封装为命令对象，并存储在内存队列中。然后，再从队列中取出一定数量的命令来执行。执行完成之后，再重新开始新的一轮轮询。具体的示例代码如下所示，你可以结合着一块看下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GotDiamondCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">  <span class="comment">// 省略成员变量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">GotDiamondCommand</span><span class="params">(<span class="comment">/*数据*/</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 执行相应的逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//GotStartCommand/HitObstacleCommand/ArchiveCommand类省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameApplication</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_HANDLED_REQ_COUNT_PER_LOOP</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Command&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mainloop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      List&lt;Request&gt; requests = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//省略从epoll或者select中获取数据，并封装成Request的逻辑，</span></span><br><span class="line">      <span class="comment">//注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (Request request : requests) &#123;</span><br><span class="line">        <span class="type">Event</span> <span class="variable">event</span> <span class="operator">=</span> request.getEvent();</span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (event.equals(Event.GOT_DIAMOND)) &#123;</span><br><span class="line">          command = <span class="keyword">new</span> <span class="title class_">GotDiamondCommand</span>(<span class="comment">/*数据*/</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.equals(Event.GOT_STAR)) &#123;</span><br><span class="line">          command = <span class="keyword">new</span> <span class="title class_">GotStartCommand</span>(<span class="comment">/*数据*/</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.equals(Event.HIT_OBSTACLE)) &#123;</span><br><span class="line">          command = <span class="keyword">new</span> <span class="title class_">HitObstacleCommand</span>(<span class="comment">/*数据*/</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.equals(Event.ARCHIVE)) &#123;</span><br><span class="line">          command = <span class="keyword">new</span> <span class="title class_">ArchiveCommand</span>(<span class="comment">/*数据*/</span>);</span><br><span class="line">        &#125; <span class="comment">// ...一堆else if...</span></span><br><span class="line"></span><br><span class="line">        queue.add(command);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">handledCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (handledCount &lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        command.execute();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="命令模式-VS-策略模式"><a href="#命令模式-VS-策略模式" class="headerlink" title="命令模式 VS 策略模式"></a>命令模式 VS 策略模式</h1><p>看了刚才的讲解，你可能会觉得，命令模式跟策略模式、工厂模式非常相似啊，那它们的区别在哪里呢？不仅如此，在留言区中我还看到有不止一个同学反映，感觉学过的很多模式都很相似。不知道你有没有类似的感觉呢？</p>
<p>实际上，每个设计模式都应该由两部分组成：第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。不过，代码实现并不是模式必须包含的。如果你单纯地只关注解决方案这一部分，甚至只关注代码实现，就会产生大部分模式看起来都很相似的错觉。实际上，设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式。</p>
<p>之前讲策略模式的时候，我们有讲到，策略模式包含策略的定义、创建和使用三部分，从代码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个特定的应用场景，用来解决根据运行时状态从一组策略中选择不同策略的问题，而工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是其他东西。从设计意图上来，这两个模式完全是两回事儿。</p>
<p>有了刚刚的铺垫，接下来，我们再来看命令模式跟策略模式的区别。你可能会觉得，命令的执行逻辑也可以看作策略，那它是不是就是策略模式了呢？实际上，这两者有一点细微的区别。</p>
<p>在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如，BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-开篇</title>
    <url>/2022/05/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<p><img src="/../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81.png" alt="编写高质量代码"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-建造者模式</title>
    <url>/2022/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 set() 方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p>
<ul>
<li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li>
<li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li>
<li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。</li>
</ul>
<p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。</p>
<span id="more"></span>

<h1 id="ConstructorArg使用创建者模式重构"><a href="#ConstructorArg使用创建者模式重构" class="headerlink" title="ConstructorArg使用创建者模式重构"></a><code>ConstructorArg</code>使用创建者模式重构</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> Scope.SINGLETON;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">lazyInit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClassName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;ConstructorArg&gt; <span class="title function_">getConstructorArgs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> constructorArgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConstructorArgs</span><span class="params">(List&lt;ConstructorArg&gt; constructorArgs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.constructorArgs = constructorArgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Scope <span class="title function_">getScope</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScope</span><span class="params">(Scope scope)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.scope = scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLazyInit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lazyInit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLazyInit</span><span class="params">(<span class="type">boolean</span> lazyInit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lazyInit = lazyInit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getScope().equals(Scope.SINGLETON);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Scope</span> &#123;</span><br><span class="line">        SINGLETON,</span><br><span class="line">        PROTOTYPE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConstructorArg</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isRef</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">private</span> Class type;</span><br><span class="line">        <span class="keyword">private</span> Object arg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRef</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isRef;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Class <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getArg</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> arg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">ConstructorArg</span><span class="params">(<span class="type">boolean</span> isRef, Class type, Object arg)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.isRef = isRef;</span><br><span class="line">            <span class="built_in">this</span>.type = type;</span><br><span class="line">            <span class="built_in">this</span>.arg = arg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">private</span> Class type;</span><br><span class="line">            <span class="keyword">private</span> Object arg;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> ConstructorArg <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ref &amp;&amp; type != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;bean为ref类型时type不需要设置&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!ref &amp;&amp; (type == <span class="literal">null</span> || arg == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;bean不为ref类型时type和arg必须填写&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstructorArg</span>(ref, type, arg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> Builder <span class="title function_">setRef</span><span class="params">(<span class="type">boolean</span> ref)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.ref = ref;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> Builder <span class="title function_">setType</span><span class="params">(Class type)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.type = type;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> Builder <span class="title function_">setArg</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.arg = arg;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// parse方法也需要更改</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;BeanDefinition&gt; <span class="title function_">parse</span><span class="params">(InputStream inputStream)</span> &#123;</span><br><span class="line">        List&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> reader.read(inputStream);<span class="comment">// 获取根节点</span></span><br><span class="line">            <span class="type">Element</span> <span class="variable">beans</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">            <span class="comment">// 获取迭代器</span></span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">beanIt</span> <span class="operator">=</span> beans.elementIterator();</span><br><span class="line">            <span class="comment">// 遍历迭代器，获取根节点信息</span></span><br><span class="line">            <span class="keyword">while</span>(beanIt.hasNext())&#123;</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>();</span><br><span class="line">                <span class="type">Element</span> <span class="variable">bean</span> <span class="operator">=</span> (Element) beanIt.next();</span><br><span class="line"></span><br><span class="line">                List&lt;Attribute&gt; attributes = bean.attributes();</span><br><span class="line">                <span class="comment">// 获取bean属性名和属性值</span></span><br><span class="line">                <span class="keyword">for</span> (Attribute attribute : attributes) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;id&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                        beanDefinition.setId(attribute.getValue());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;class&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                        beanDefinition.setClassName(attribute.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Iterator</span> <span class="variable">argsIt</span> <span class="operator">=</span> bean.elementIterator();</span><br><span class="line">                List&lt;BeanDefinition.ConstructorArg&gt; constructorArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span>(argsIt.hasNext())&#123;</span><br><span class="line">                    BeanDefinition.ConstructorArg.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>.ConstructorArg.Builder();</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">arg</span> <span class="operator">=</span> (Element) argsIt.next();</span><br><span class="line">                    List&lt;Attribute&gt; argAttributes = arg.attributes();</span><br><span class="line">                    <span class="comment">// 获取bean属性名和属性值</span></span><br><span class="line">                    <span class="keyword">for</span> (Attribute attribute : argAttributes) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;type&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                builder.setType(Class.forName(attribute.getValue()));</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                            builder.setArg(arg.getText());</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;ref&quot;</span>.equals(attribute.getName())) &#123;</span><br><span class="line">                            builder.setRef(<span class="literal">true</span>);</span><br><span class="line">                            builder.setArg(attribute.getValue());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    constructorArgs.add(builder.build());</span><br><span class="line">                    beanDefinition.setConstructorArgs(constructorArgs);</span><br><span class="line">                &#125;</span><br><span class="line">                beanDefinitions.add(beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-桥接模式</title>
    <url>/2022/08/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>桥接模式，也叫作桥梁模式，英文是 Bridge Design Pattern。桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”</p>
<p>关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</p>
<span id="more"></span>

<p>JDBC 驱动是桥接模式的经典应用。我们先来看一下，如何利用 JDBC 驱动来查询数据库。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="comment">//加载及注册JDBC驱动程序</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(url);</span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> con.createStatement()；</span><br><span class="line"><span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> <span class="string">&quot;select * from test&quot;</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(query);</span><br><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">  rs.getString(<span class="number">1</span>);</span><br><span class="line">  rs.getInt(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要把 <code>MySQL</code> 数据库换成 <code>Oracle</code> 数据库，只需要把第一行代码中的 <code>com.mysql.jdbc.Driver</code> 换成 <code>oracle.jdbc.driver.OracleDriver</code> 就可以了。</p>
<p>不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库，都只需要改动很少的代码，或者完全不需要改动代码，那如此优雅的数据库切换是如何实现的呢？<br>源码之下无秘密。要弄清楚这个问题，我们先从 <code>com.mysql.jdbc.Driver</code> 这个类的代码看起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.mysql.jdbc;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      java.sql.DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException if a database error occurs.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合 <code>com.mysql.jdbc.Driver</code> 的代码实现，我们可以发现，当执行 <code>Class.forName(“com.mysql.jdbc.Driver”)</code> 这条语句的时候，实际上是做了两件事情。第一件事情是要求 <code>JVM</code> 查找并加载指定的 <code>Driver</code> 类，第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 <code>DriverManager</code> 类中。</p>
<p>现在，我们再来看一下，<code>DriverManager</code> 类是干什么用的。具体的代码如下所示。当我们把具体的 <code>Driver</code> 实现类（比如，<code>com.mysql.jdbc.Driver</code>）注册到 <code>DriverManager</code> 之后，后续所有对 <code>JDBC</code> 接口的调用，都会委派到对具体的 <code>Driver</code> 实现类来执行。而 <code>Driver</code> 实现类都实现了相同的接口（<code>java.sql.Driver</code> ），这也是可以灵活切换 <code>Driver</code> 的原因。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverManager</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;DriverInfo&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">registerDriver</span><span class="params">(java.sql.Driver driver)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">if</span> (driver != <span class="literal">null</span>) &#123;</span><br><span class="line">      registeredDrivers.addIfAbsent(<span class="keyword">new</span> <span class="title class_">DriverInfo</span>(driver));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(String url, String user, String password)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    java.util.<span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Properties();</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">      info.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="literal">null</span>) &#123;</span><br><span class="line">      info.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。那弄懂定义中“抽象”和“实现”两个概念，就是理解桥接模式的关键。那在 JDBC 这个例子中，什么是“抽象”？什么是“实现”呢？</p>
<p>实际上，<code>JDBC</code> 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 <code>Driver</code>（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。<code>JDBC</code> 和 <code>Driver</code> 独立开发，通过对象之间的组合关系，组装在一起。<code>JDBC</code> 的所有逻辑操作，最终都委托给 <code>Driver</code> 来执行。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-模板模式</title>
    <url>/2022/08/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="模板模式的原理与实现"><a href="#模板模式的原理与实现" class="headerlink" title="模板模式的原理与实现"></a>模板模式的原理与实现</h1><p>模板模式，全称是模板方法设计模式，英文是 Template Method Design Pattern。在 GoF 的《设计模式》一书中，它是这么定义的：</p>
<blockquote>
<p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p>
</blockquote>
<p>翻译成中文就是：模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>
<p>这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p>
<p>模板模式主要是用来解决<strong>复用</strong>和<strong>扩展</strong>两个问题。</p>
<span id="more"></span>

<p>以下是一个简单的模板方法代码，<code>templateMethod()</code> 函数定义为 <code>final</code>，是为了避免子类重写它。<code>method1()</code> 和 <code>method2()</code> 定义为 abstract，是为了强迫子类去实现。不过，这些都不是必须的，在实际的项目开发中，模板模式的代码实现比较灵活，待会儿讲到应用场景的时候，我们会有具体的体现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    method1();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    method2();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">AbstractClass</span> <span class="variable">demo</span> <span class="operator">=</span> ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure>

<h2 id="模板模式作用一：复用"><a href="#模板模式作用一：复用" class="headerlink" title="模板模式作用一：复用"></a>模板模式作用一：复用</h2><p>模板模式把一个算法中不变的流程抽象到父类的模板方法 <code>templateMethod()</code> 中，将可变的部分 <code>method1()</code>、<code>method2()</code> 留给子类 <code>ContreteClass1</code> 和 <code>ContreteClass2</code> 来实现。所有的子类都可以复用父类中模板方法定义的流程代码。</p>
<h2 id="模板模式作用二：扩展"><a href="#模板模式作用二：扩展" class="headerlink" title="模板模式作用二：扩展"></a>模板模式作用二：扩展</h2><p>模板模式的第二大作用的是扩展。这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似我们之前讲到的控制反转。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。</p>
<h3 id="Java-Servlet"><a href="#Java-Servlet" class="headerlink" title="Java Servlet"></a>Java Servlet</h3><p>对于 Java Web 项目开发来说，常用的开发框架是 SpringMVC。利用它，我们只需要关注业务代码的编写，底层的原理几乎不会涉及。但是，如果我们抛开这些高级框架来开发 Web 项目，必然会用到 Servlet。实际上，使用比较底层的 Servlet 来开发 Web 项目也不难。我们只需要定义一个继承 HttpServlet 的类，并且重写其中的 doGet() 或 doPost() 方法，来分别处理 get 和 post 请求。</p>
<h3 id="JUnit-TestCase"><a href="#JUnit-TestCase" class="headerlink" title="JUnit TestCase"></a>JUnit TestCase</h3><p>跟 Java Servlet 类似，JUnit 框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown() 等），让框架用户可以在这些扩展点上扩展功能。<br>在使用 JUnit 测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的 TestCase 类。在 TestCase 类中，runBare() 函数是模板方法，它定义了执行测试用例的整体流程：先执行 setUp() 做些准备工作，然后执行 runTest() 运行真正的测试代码，最后执行 tearDown() 做扫尾工作。</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>假设一个框架中的某个类暴露了两个模板方法，并且定义了一堆供模板方法调用的抽象方法，代码示例如下所示。在项目开发中，即便我们只用到这个类的其中一个模板方法，我们还是要在子类中把所有的抽象方法都实现一遍，这相当于无效劳动，有没有其他方式来解决这个问题呢？</p>
<p>在 spring 生命周期中，<code>InstantiationAwareBeanPostProcessorAdapter</code> 就是解决这个问题的。 写个适配器，把所有抽象方法默认实现一下，子类继承这个 adapter 就行了。</p>
<h1 id="模板模式与Callback回调函数有何区别和联系？"><a href="#模板模式与Callback回调函数有何区别和联系？" class="headerlink" title="模板模式与Callback回调函数有何区别和联系？"></a>模板模式与Callback回调函数有何区别和联系？</h1><p>复用和扩展是模板模式的两大作用，实际上，还有另外一个技术概念，也能起到跟模板模式相同的作用，那就是回调（Callback）</p>
<h2 id="回调的原理解析"><a href="#回调的原理解析" class="headerlink" title="回调的原理解析"></a>回调的原理解析</h2><p>相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p>
<p>A 类如何将回调函数传递给 B 类呢？不同的编程语言，有不同的实现方法。C 语言可以使用函数指针，Java 则需要使用包裹了回调函数的类对象，我们简称为回调对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICallback</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">methodToCallback</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(ICallback callback)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    callback.methodToCallback();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BClass</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BClass</span>();</span><br><span class="line">    b.process(<span class="keyword">new</span> <span class="title class_">ICallback</span>() &#123; <span class="comment">//回调对象</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodToCallback</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Call back me.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码实现中，我们可以看出，回调跟模板模式一样，也具有复用和扩展的功能。除了回调函数之外，BClass 类的 process() 函数中的逻辑都可以复用。如果 ICallback、BClass 类是框架代码，AClass 是使用框架的客户端代码，我们可以通过 ICallback 定制 process() 函数，也就是说，框架因此具有了扩展的能力。</p>
<p>实际上，回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用。比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的 URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。</p>
<p>回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。上面的代码实际上是同步回调的实现方式，在 process() 函数返回之前，执行完回调函数 methodToCallback()。而上面支付的例子是异步回调的实现方式，发起支付之后不需要等待回调接口被调用就直接返回。从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。</p>
<h3 id="应用举例一：JdbcTemplate"><a href="#应用举例一：JdbcTemplate" class="headerlink" title="应用举例一：JdbcTemplate"></a>应用举例一：JdbcTemplate</h3><p>Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以，在命名上，这些类使用 Template（模板）这个单词作为后缀。</p>
<p>这些 Template 类的设计思路都很相近，所以，我们只拿其中的 JdbcTemplate 来举例分析一下。Java 提供了 JDBC 类库来封装不同类型的数据库操作。不过，直接使用 JDBC 来编写操作数据库的代码，还是有点复杂的。比如，下面这段是使用 JDBC 来查询用户信息的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">queryUser</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//1.加载驱动</span></span><br><span class="line">      Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">      conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/demo&quot;</span>, <span class="string">&quot;xzg&quot;</span>, <span class="string">&quot;xzg&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.创建statement类对象，用来执行SQL语句</span></span><br><span class="line">      stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.ResultSet类，用来存放获取的结果集</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id=&quot;</span> + id;</span><br><span class="line">      <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">eid</span> <span class="operator">=</span> <span class="literal">null</span>, ename = <span class="literal">null</span>, price = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(resultSet.getLong(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        user.setName(resultSet.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        user.setTelephone(resultSet.getString(<span class="string">&quot;telephone&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> log...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> log...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (conn != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> log...</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (stmt != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          stmt.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> log...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>queryUser() 函数包含很多流程性质的代码，跟业务无关，比如，加载驱动、创建数据库连接、创建 statement、关闭连接、关闭 statement、处理异常。针对不同的 SQL 执行请求，这些流程性质的代码是相同的、可以复用的，我们不需要每次都重新敲一遍。</p>
<p>针对这个问题，Spring 提供了 JdbcTemplate，对 JDBC 进一步封装，来简化数据库编程。使用 JdbcTemplate 查询用户信息，我们只需要编写跟这个业务有关的代码，其中包括，查询用户的 SQL 语句、查询结果与 User 对象之间的映射关系。其他流程性质的代码都封装在了 JdbcTemplate 类中，不需要我们每次都重新编写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateDemo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">queryUser</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id=&quot;</span>+id;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">UserRowMapper</span>()).get(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">UserRowMapper</span> <span class="keyword">implements</span> <span class="title class_">RowMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      user.setId(rs.getLong(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">      user.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">      user.setTelephone(rs.getString(<span class="string">&quot;telephone&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JdbcTemplate 通过回调的机制，将不变的执行流程抽离出来，放到模板方法 execute() 中，将可变的部分设计成回调 StatementCallback，由用户来定制。query() 函数是对 execute() 函数的二次封装，让接口用起来更加方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">query</span><span class="params">(String sql, RowMapper&lt;T&gt; rowMapper)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">    <span class="keyword">return</span> query(sql, <span class="keyword">new</span> <span class="title class_">RowMapperResultSetExtractor</span>&lt;T&gt;(rowMapper));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">query</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">    Assert.notNull(sql, <span class="string">&quot;SQL must not be null&quot;</span>);</span><br><span class="line">    Assert.notNull(rse, <span class="string">&quot;ResultSetExtractor must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Executing SQL query [&quot;</span> + sql + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">QueryStatementCallback</span> <span class="keyword">implements</span> <span class="title class_">StatementCallback</span>&lt;T&gt;, SqlProvider &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs = stmt.executeQuery(sql);</span><br><span class="line">                <span class="type">ResultSet</span> <span class="variable">rsToUse</span> <span class="operator">=</span> rs;</span><br><span class="line">                <span class="keyword">if</span> (nativeJdbcExtractor != <span class="literal">null</span>) &#123;</span><br><span class="line">                    rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> rse.extractData(rsToUse);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                JdbcUtils.closeResultSet(rs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getSql</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sql;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> execute(<span class="keyword">new</span> <span class="title class_">QueryStatementCallback</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">    Assert.notNull(action, <span class="string">&quot;Callback object must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DataSourceUtils.getConnection(getDataSource());</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conToUse</span> <span class="operator">=</span> con;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.nativeJdbcExtractor != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                <span class="built_in">this</span>.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) &#123;</span><br><span class="line">            conToUse = <span class="built_in">this</span>.nativeJdbcExtractor.getNativeConnection(con);</span><br><span class="line">        &#125;</span><br><span class="line">        stmt = conToUse.createStatement();</span><br><span class="line">        applyStatementSettings(stmt);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmtToUse</span> <span class="operator">=</span> stmt;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.nativeJdbcExtractor != <span class="literal">null</span>) &#123;</span><br><span class="line">            stmtToUse = <span class="built_in">this</span>.nativeJdbcExtractor.getNativeStatement(stmt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> action.doInStatement(stmtToUse);</span><br><span class="line">        handleWarnings(stmt);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">        <span class="comment">// Release Connection early, to avoid potential connection pool deadlock</span></span><br><span class="line">        <span class="comment">// in the case when the exception translator hasn&#x27;t been initialized yet.</span></span><br><span class="line">        JdbcUtils.closeStatement(stmt);</span><br><span class="line">        stmt = <span class="literal">null</span>;</span><br><span class="line">        DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">        con = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">throw</span> getExceptionTranslator().translate(<span class="string">&quot;StatementCallback&quot;</span>, getSql(action), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        JdbcUtils.closeStatement(stmt);</span><br><span class="line">        DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="应用举例二：setClickListener-）"><a href="#应用举例二：setClickListener-）" class="headerlink" title="应用举例二：setClickListener(）"></a>应用举例二：setClickListener(）</h3><p>在客户端开发中，我们经常给控件注册事件监听器，比如下面这段代码，就是在 Android 应用开发中，给 Button 控件的点击事件注册监听器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> (Button)findViewById(R.id.button);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;I am clicked.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>从代码结构上来看，事件监听器很像回调，即传递一个包含回调函数（onClick()）的对象给另一个函数。从应用场景上来看，它又很像观察者模式，即事先注册观察者（OnClickListener），当用户点击按钮的时候，发送点击事件给观察者，并且执行相应的 onClick() 函数。</p>
<p>我们前面讲到，回调分为同步回调和异步回调。这里的回调算是异步回调，我们往 setOnClickListener() 函数中注册好回调函数之后，并不需要等待回调函数执行。这也印证了我们前面讲的，异步回调比较像观察者模式。</p>
<h3 id="应用举例三：addShutdownHook"><a href="#应用举例三：addShutdownHook" class="headerlink" title="应用举例三：addShutdownHook()"></a>应用举例三：addShutdownHook()</h3><p>Hook 可以翻译成“钩子”，那它跟 Callback 有什么区别呢？</p>
<p>网上有人认为 Hook 就是 Callback，两者说的是一回事儿，只是表达不同而已。而有人觉得 Hook 是 Callback 的一种应用。Callback 更侧重语法机制的描述，Hook 更加侧重应用场景的描述。我个人比较认可后面一种说法。不过，这个也不重要，我们只需要见了代码能认识，遇到场景会用就可以了。</p>
<p>Hook 比较经典的应用场景是 Tomcat 和 JVM 的 shutdown hook。接下来，我们拿 JVM 来举例说明一下。JVM 提供了 Runtime.addShutdownHook(Thread hook) 方法，可以注册一个 JVM 关闭的 Hook。当应用程序关闭的时候，JVM 会自动调用 Hook 代码。代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShutdownHookDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ShutdownHook</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;I am called during shutting down.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">ShutdownHook</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看 addShutdownHook() 的代码实现，如下所示。这里我只给出了部分相关代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addShutdownHook</span><span class="params">(Thread hook)</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">      sm.checkPermission(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;shutdownHooks&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ApplicationShutdownHooks.add(hook);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationShutdownHooks</span> &#123;</span><br><span class="line">    <span class="comment">/* The set of registered hooks */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdentityHashMap&lt;Thread, Thread&gt; hooks;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">            hooks = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            hooks = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Thread hook)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(hooks == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hook.isAlive())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Hook already running&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hooks.containsKey(hook))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Hook previously registered&quot;</span>);</span><br><span class="line"></span><br><span class="line">        hooks.put(hook, hook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runHooks</span><span class="params">()</span> &#123;</span><br><span class="line">        Collection&lt;Thread&gt; threads;</span><br><span class="line">        <span class="keyword">synchronized</span>(ApplicationShutdownHooks.class) &#123;</span><br><span class="line">            threads = hooks.keySet();</span><br><span class="line">            hooks = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">            hook.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    hook.join();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中我们可以发现，有关 Hook 的逻辑都被封装到 ApplicationShutdownHooks 类中了。当应用程序关闭的时候，JVM 会调用这个类的 runHooks() 方法，创建多个线程，并发地执行多个 Hook。我们在注册完 Hook 之后，并不需要等待 Hook 执行完成，所以，这也算是一种异步回调。</p>
<h1 id="模板模式-VS-回调"><a href="#模板模式-VS-回调" class="headerlink" title="模板模式 VS 回调"></a>模板模式 VS 回调</h1><p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式。</p>
<p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。</p>
<p>前面我们也讲到，组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点。</p>
<ul>
<li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。</li>
<li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。</li>
<li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-状态模式</title>
    <url>/2022/09/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。</p>
<h1 id="什么是有限状态机？"><a href="#什么是有限状态机？" class="headerlink" title="什么是有限状态机？"></a>什么是有限状态机？</h1><p>有限状态机，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p>
<span id="more"></span>

<p>在“超级马里奥”游戏中，马里奥可以变身为多种形态，比如小马里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加 100 积分。</p>
<p>实际上，马里奥形态的转变就是一个状态机。其中，马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加 100 积分）。状态转移如下图所示：</p>
<p><img src="/../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/Mario%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.png" alt="Mario状态转移"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  SMALL(<span class="number">0</span>),</span><br><span class="line">  SUPER(<span class="number">1</span>),</span><br><span class="line">  FIRE(<span class="number">2</span>),</span><br><span class="line">  CAPE(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">State</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarioStateMachine</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MarioStateMachine</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.currentState = State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MarioStateMachine</span> <span class="variable">mario</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MarioStateMachine</span>();</span><br><span class="line">    mario.obtainMushRoom();</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> mario.getScore();</span><br><span class="line">    <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> mario.getCurrentState();</span><br><span class="line">    System.out.println(<span class="string">&quot;mario score: &quot;</span> + score + <span class="string">&quot;; state: &quot;</span> + state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="状态机实现方式一：分支逻辑法"><a href="#状态机实现方式一：分支逻辑法" class="headerlink" title="状态机实现方式一：分支逻辑法"></a>状态机实现方式一：分支逻辑法</h1><p>对于如何实现状态机，最简单直接的实现方式是，参照状态转移图，将每一个状态转移，原模原样地直译成代码。这样编写的代码会包含大量的 if-else 或 switch-case 分支判断逻辑，甚至是嵌套的分支判断逻辑。按照这个实现思路，补全之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarioStateMachine</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MarioStateMachine</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.currentState = State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SMALL)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.currentState = State.SUPER;</span><br><span class="line">      <span class="built_in">this</span>.score += <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">      <span class="built_in">this</span>.currentState = State.CAPE;</span><br><span class="line">      <span class="built_in">this</span>.score += <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">      <span class="built_in">this</span>.currentState = State.FIRE;</span><br><span class="line">      <span class="built_in">this</span>.score += <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.SUPER)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.currentState = State.SMALL;</span><br><span class="line">      <span class="built_in">this</span>.score -= <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.CAPE)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.currentState = State.SMALL;</span><br><span class="line">      <span class="built_in">this</span>.score -= <span class="number">200</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentState.equals(State.FIRE)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.currentState = State.SMALL;</span><br><span class="line">      <span class="built_in">this</span>.score -= <span class="number">300</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是，对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的 if-else 或者 switch-case 分支判断逻辑，可读性和可维护性都很差。如果哪天修改了状态机中的某个状态转移，我们要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入 bug。</p>
<h1 id="状态机实现方式二：查表法"><a href="#状态机实现方式二：查表法" class="headerlink" title="状态机实现方式二：查表法"></a>状态机实现方式二：查表法</h1><p>实际上，上面这种实现方法有点类似 hard code，对于复杂的状态机来说不适用，而状态机的第二种实现方式查表法，就更加合适了。接下来，我们就一块儿来看下，如何利用查表法来补全骨架代码。实际上，除了用状态转移图来表示之外，状态机还可以用二维表来表示，如下所示。在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。</p>
<p><img src="/../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/%E6%9F%A5%E8%A1%A8%E6%B3%95.png" alt="查表法"></p>
<p>相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改 transitionTable 和 actionTable 两个二维数组即可。实际上，如果我们把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">  GOT_MUSHROOM(<span class="number">0</span>),</span><br><span class="line">  GOT_CAPE(<span class="number">1</span>),</span><br><span class="line">  GOT_FIRE(<span class="number">2</span>),</span><br><span class="line">  MET_MONSTER(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Event</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarioStateMachine</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> State[][] transitionTable = &#123;</span><br><span class="line">          &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">          &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">          &#123;CAPE, CAPE, CAPE, SMALL&#125;,</span><br><span class="line">          &#123;FIRE, FIRE, FIRE, SMALL&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] actionTable = &#123;</span><br><span class="line">          &#123;+<span class="number">100</span>, +<span class="number">200</span>, +<span class="number">300</span>, +<span class="number">0</span>&#125;,</span><br><span class="line">          &#123;+<span class="number">0</span>, +<span class="number">200</span>, +<span class="number">300</span>, -<span class="number">100</span>&#125;,</span><br><span class="line">          &#123;+<span class="number">0</span>, +<span class="number">0</span>, +<span class="number">0</span>, -<span class="number">200</span>&#125;,</span><br><span class="line">          &#123;+<span class="number">0</span>, +<span class="number">0</span>, +<span class="number">0</span>, -<span class="number">300</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MarioStateMachine</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.currentState = State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span> &#123;</span><br><span class="line">    executeEvent(Event.GOT_MUSHROOM);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">    executeEvent(Event.GOT_CAPE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">    executeEvent(Event.GOT_FIRE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">    executeEvent(Event.MET_MONSTER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">executeEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">stateValue</span> <span class="operator">=</span> currentState.getValue();</span><br><span class="line">    <span class="type">int</span> <span class="variable">eventValue</span> <span class="operator">=</span> event.getValue();</span><br><span class="line">    <span class="built_in">this</span>.currentState = transitionTable[stateValue][eventValue];</span><br><span class="line">    <span class="built_in">this</span>.score += actionTable[stateValue][eventValue];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.currentState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="状态机实现方式三：状态模式"><a href="#状态机实现方式三：状态模式" class="headerlink" title="状态机实现方式三：状态模式"></a>状态机实现方式三：状态模式</h1><p>在查表法的代码实现中，事件触发的动作只是简单的积分加减，所以，我们用一个 int 类型的二维数组 actionTable 就能表示，二维数组中的值表示积分的加减值。但是，如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能发送消息通知等等），我们就没法用如此简单的二维数组来表示了。这也就是说，查表法的实现方式有一定局限性。</p>
<p>虽然分支逻辑的实现方式不存在这个问题，但它又存在前面讲到的其他问题，比如分支判断逻辑较多，导致代码可读性和可维护性不好等。实际上，针对分支逻辑法存在的问题，我们可以使用状态模式来解决。状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑。我们还是结合代码来理解这句话。</p>
<p>利用状态模式，我们来补全 MarioStateMachine 类，补全后的代码如下所示。</p>
<p>其中，IMario 是状态的接口，定义了所有的事件。SmallMario、SuperMario、CapeMario、FireMario 是 IMario 接口的实现类，分别对应状态机中的 4 个状态。原来所有的状态转移和动作执行的代码逻辑，都集中在 MarioStateMachine 类中，现在，这些代码逻辑被分散到了这 4 个状态类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMario</span> &#123; <span class="comment">//所有状态类的接口</span></span><br><span class="line">  State <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//以下是定义的事件</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallMario</span> <span class="keyword">implements</span> <span class="title class_">IMario</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SmallMario</span><span class="params">(MarioStateMachine stateMachine)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stateMachine = stateMachine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> <span class="title class_">SuperMario</span>(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> <span class="title class_">CapeMario</span>(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> <span class="title class_">FireMario</span>(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// do nothing...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMario</span> <span class="keyword">implements</span> <span class="title class_">IMario</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SuperMario</span><span class="params">(MarioStateMachine stateMachine)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stateMachine = stateMachine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> State.SUPER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// do nothing...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> <span class="title class_">CapeMario</span>(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> <span class="title class_">FireMario</span>(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(<span class="keyword">new</span> <span class="title class_">SmallMario</span>(stateMachine));</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() - <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略CapeMario、FireMario类...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarioStateMachine</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> IMario currentState; <span class="comment">// 不再使用枚举来表示状态</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MarioStateMachine</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.currentState = <span class="keyword">new</span> <span class="title class_">SmallMario</span>(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.obtainMushRoom();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.obtainCape();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.obtainFireFlower();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.meetMonster();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.currentState.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurrentState</span><span class="params">(IMario currentState)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState = currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现不难看懂，我只强调其中的一点，即 MarioStateMachine 和各个状态类之间是双向依赖关系。MarioStateMachine 依赖各个状态类是理所当然的，但是，反过来，各个状态类为什么要依赖 MarioStateMachine 呢？这是因为，各个状态类需要更新 MarioStateMachine 中的两个变量，score 和 currentState。</p>
<p>实际上，上面的代码还可以继续优化，我们可以将状态类设计成单例，毕竟状态类中不包含任何成员变量。但是，当将状态类设计成单例之后，我们就无法通过构造函数来传递 MarioStateMachine 了，而状态类又要依赖 MarioStateMachine，那该如何解决这个问题呢？</p>
<p>实际上，在单例模式的讲解中，我们提到过几种解决方法，你可以回过头去再查看一下。在这里，我们可以通过函数参数将 MarioStateMachine 传递进状态类。根据这个设计思路，我们对上面的代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMario</span> &#123;</span><br><span class="line">  State <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">(MarioStateMachine stateMachine)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">(MarioStateMachine stateMachine)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">(MarioStateMachine stateMachine)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">(MarioStateMachine stateMachine)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallMario</span> <span class="keyword">implements</span> <span class="title class_">IMario</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SmallMario</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmallMario</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SmallMario</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> SmallMario <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> State.SMALL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">(MarioStateMachine stateMachine)</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(SuperMario.getInstance());</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">(MarioStateMachine stateMachine)</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(CapeMario.getInstance());</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">(MarioStateMachine stateMachine)</span> &#123;</span><br><span class="line">    stateMachine.setCurrentState(FireMario.getInstance());</span><br><span class="line">    stateMachine.setScore(stateMachine.getScore() + <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">(MarioStateMachine stateMachine)</span> &#123;</span><br><span class="line">    <span class="comment">// do nothing...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略SuperMario、CapeMario、FireMario类...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarioStateMachine</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">  <span class="keyword">private</span> IMario currentState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MarioStateMachine</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.currentState = SmallMario.getInstance();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushRoom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.obtainMushRoom(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.obtainCape(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.obtainFireFlower(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState.meetMonster(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> State <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.currentState.getName();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurrentState</span><span class="params">(IMario currentState)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.currentState = currentState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，像游戏这种比较复杂的状态机，包含的状态比较多，我优先推荐使用查表法，而状态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下单这种类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-职责链模式</title>
    <url>/2022/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="职责链模式的原理和实现"><a href="#职责链模式的原理和实现" class="headerlink" title="职责链模式的原理和实现"></a>职责链模式的原理和实现</h1><p>职责链模式的英文翻译是 Chain Of Responsibility Design Pattern。在 GoF 的《设计模式》中，它是这么定义的：</p>
<blockquote>
<p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p>
</blockquote>
<p>翻译成中文就是：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。</p>
<span id="more"></span>

<p>在职责链模式中，多个处理器（也就是刚刚定义中说的“接收对象”）依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p>
<p>职责链模式有多种实现方式，我们这里介绍两种比较常用的。第一种实现方式如下所示。其中，Handler 是所有处理器类的抽象父类，handle() 是抽象方法。每个具体的处理器类（HandlerA、HandlerB）的 handle() 函数的代码结构类似，如果它能处理该请求，就不继续往下传递；如果不能处理，则交由后面的处理器来处理（也就是调用 successor.handle()）。HandlerChain 是处理器链，从数据结构的角度来看，它就是一个记录了链头、链尾的链表。其中，记录链尾是为了方便添加处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">Handler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.successor = successor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 利用模板模式，将调用 successor.handle() 的逻辑从具体的处理器类中剥离出来，放到抽象父类中</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> doHandle();</span><br><span class="line">    <span class="keyword">if</span> (successor != <span class="literal">null</span> &amp;&amp; !handled) &#123;</span><br><span class="line">      successor.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerB</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerChain</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">    handler.setSuccessor(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">      head = handler;</span><br><span class="line">      tail = handler;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail.setSuccessor(handler);</span><br><span class="line">    tail = handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">      head.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HandlerChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerChain</span>();</span><br><span class="line">    chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerA</span>());</span><br><span class="line">    chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerB</span>());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种实现方式，代码如下所示。这种实现方式更加简单。HandlerChain 类用数组而非链表来保存所有的处理器，并且需要在 HandlerChain 的 handle() 函数中，依次调用每个处理器的 handle() 函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHandler</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">implements</span> <span class="title class_">IHandler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerB</span> <span class="keyword">implements</span> <span class="title class_">IHandler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerChain</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;IHandler&gt; handlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(IHandler handler)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.handlers.add(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (IHandler handler : handlers) &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> handler.handle();</span><br><span class="line">      <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HandlerChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerChain</span>();</span><br><span class="line">    chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerA</span>());</span><br><span class="line">    chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerB</span>());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 GoF 给出的定义中，如果处理器链上的某个处理器能够处理这个请求，那就不会继续往下传递请求。实际上，职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。这种变体也有两种实现方式：用链表存储处理器和用数组存储处理器，跟上面的两种实现方式类似，只需要稍微修改即可。着了只给出用链表存储处理器的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">Handler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.successor = successor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    doHandle();</span><br><span class="line">    <span class="keyword">if</span> (successor != <span class="literal">null</span>) &#123;</span><br><span class="line">      successor.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doHandle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerB</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerChain</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">    handler.setSuccessor(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">      head = handler;</span><br><span class="line">      tail = handler;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail.setSuccessor(handler);</span><br><span class="line">    tail = handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">      head.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HandlerChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerChain</span>();</span><br><span class="line">    chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerA</span>());</span><br><span class="line">    chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerB</span>());</span><br><span class="line">    chain.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于支持 UGC（User Generated Content，用户生成内容）的应用（比如论坛）来说，用户生成的内容（比如，在论坛中发表的帖子）可能会包含一些敏感词（比如涉黄、广告、反动等词汇）。针对这个应用场景，我们就可以利用职责链模式来过滤这些敏感词。对于包含敏感词的内容，我们有两种处理方式，一种是直接禁止发布，另一种是给敏感词打马赛克（比如，用 *** 替换敏感词）之后再发布。第一种处理方式符合 GoF 给出的职责链模式的定义，第二种处理方式是职责链模式的变体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SexyWordFilter</span> <span class="keyword">implements</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> legal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveWordFilterChain</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;SensitiveWordFilter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(SensitiveWordFilter filter)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return true if content doesn&#x27;t contain sensitive words.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SensitiveWordFilter filter : filters) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!filter.doFilter(content)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SensitiveWordFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SensitiveWordFilterChain</span>();</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">AdsWordFilter</span>());</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">SexyWordFilter</span>());</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">PoliticalWordFilter</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> filterChain.filter(<span class="keyword">new</span> <span class="title class_">Content</span>());</span><br><span class="line">    <span class="keyword">if</span> (!legal) &#123;</span><br><span class="line">      <span class="comment">// 不发表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 发表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用设计模式主要是为了应对代码的复杂性，让其满足开闭原则，提高代码的扩展性。这里应用职责链模式也不例外。</p>
<p><strong>首先，我们来看，职责链模式如何应对代码的复杂性。</strong></p>
<p>将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法。应用职责链模式，我们把各个敏感词过滤函数继续拆分出来，设计成独立的类，进一步简化了 SensitiveWordFilter 类，让 SensitiveWordFilter 类的代码不会过多，过复杂。</p>
<p><strong>其次，我们再来看，职责链模式如何让代码满足开闭原则，提高代码的扩展性。</strong></p>
<p>当我们要扩展新的过滤算法的时候，比如，我们还需要过滤特殊符号，按照非职责链模式的代码实现方式，我们需要修改 SensitiveWordFilter 的代码，违反开闭原则。不过，这样的修改还算比较集中，也是可以接受的。而职责链模式的实现方式更加优雅，只需要新添加一个 Filter 类，并且通过 addFilter() 函数将它添加到 FilterChain 中即可，其他代码完全不需要修改。</p>
<p>不过，你可能会说，即便使用职责链模式来实现，当添加新的过滤算法的时候，还是要修改客户端代码（ApplicationDemo），这样做也没有完全符合开闭原则。</p>
<p>实际上，细化一下的话，我们可以把上面的代码分成两类：框架代码和客户端代码。其中，ApplicationDemo 属于客户端代码，也就是使用框架的代码。除 ApplicationDemo 之外的代码属于敏感词过滤框架代码。假设敏感词过滤框架并不是我们开发维护的，而是我们引入的一个第三方框架，我们要扩展一个新的过滤算法，不可能直接去修改框架的源码。这个时候，利用职责链模式就能达到开篇所说的，在不修改框架源码的情况下，基于职责链模式提供的扩展点，来扩展新的功能。换句话说，我们在框架这个代码范围内实现了开闭原则。</p>
<p>除此之外，利用职责链模式相对于不用职责链的实现方式，还有一个好处，那就是配置过滤算法更加灵活，可以只选择使用某几个过滤算法。</p>
<h1 id="Servlet-Filter"><a href="#Servlet-Filter" class="headerlink" title="Servlet Filter"></a>Servlet Filter</h1><p>Servlet Filter 是 Java Servlet 规范中定义的组件，翻译成中文就是过滤器，它可以实现对 HTTP 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。因为它是 Servlet 规范的一部分，所以，只要是支持 Servlet 的 Web 容器（比如，Tomcat、Jetty 等），都支持过滤器功能。</p>
<p>职责链模式的实现包含处理器接口（IHandler）或抽象类（Handler），以及处理器链（HandlerChain）。</p>
<p>对应到 Servlet Filter，javax.servlet.Filter 就是处理器接口，FilterChain 就是处理器链。</p>
<p>Servlet 中的 FilterChain 只是一个接口定义。具体的实现类由遵从 Servlet 规范的 Web 容器来提供，比如，ApplicationFilterChain 类就是 Tomcat 提供的 FilterChain 的实现类，源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//当前执行到了哪个filter</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n; <span class="comment">//filter的个数</span></span><br><span class="line">  <span class="keyword">private</span> ApplicationFilterConfig[] filters;</span><br><span class="line">  <span class="keyword">private</span> Servlet servlet;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">      <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];</span><br><span class="line">      <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filterConfig.getFilter();</span><br><span class="line">      filter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// filter都处理完毕后，执行servlet</span></span><br><span class="line">      servlet.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(ApplicationFilterConfig filterConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationFilterConfig filter:filters)</span><br><span class="line">      <span class="keyword">if</span> (filter==filterConfig)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == filters.length) &#123;<span class="comment">//扩容</span></span><br><span class="line">      ApplicationFilterConfig[] newFilters = <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[n + INCREMENT];</span><br><span class="line">      System.arraycopy(filters, <span class="number">0</span>, newFilters, <span class="number">0</span>, n);</span><br><span class="line">      filters = newFilters;</span><br><span class="line">    &#125;</span><br><span class="line">    filters[n++] = filterConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationFilterChain 中的 doFilter() 函数的代码实现比较有技巧，实际上是一个递归调用。这样实现主要是为了在一个 doFilter() 方法中，支持双向拦截，既能拦截客户端发送来的请求，也能拦截发送给客户端的响应。</p>
<h1 id="Spring-Interceptor"><a href="#Spring-Interceptor" class="headerlink" title="Spring Interceptor"></a>Spring Interceptor</h1><p>Spring Interceptor，翻译成中文就是拦截器。尽管英文单词和中文翻译都不同，但这两者基本上可以看作一个概念，都用来实现对 HTTP 请求进行拦截处理。它们不同之处在于，Servlet Filter 是 Servlet 规范的一部分，实现依赖于 Web 容器。Spring Interceptor 是 Spring MVC 框架的一部分，由 Spring MVC 框架来提供实现。客户端发送的请求，会先经过 Servlet Filter，然后再经过 Spring Interceptor，最后到达具体的业务代码中。</p>
<p>使用案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;拦截客户端发送来的请求.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 继续后续的处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;拦截发送给客户端的响应.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这里总是被执行.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Spring MVC配置文件中配置interceptors</span></span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">   &lt;mvc:interceptor&gt;</span><br><span class="line">       &lt;mvc:mapping path=<span class="string">&quot;/*&quot;</span>/&gt;</span><br><span class="line">       &lt;bean class=<span class="string">&quot;com.xzg.cd.LogInterceptor&quot;</span> /&gt;</span><br><span class="line">   &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>

<p>Spring Interceptor 底层是如何实现的。当然，它也是基于职责链模式实现的。其中，HandlerExecutionChain 类是职责链模式中的处理器链。它的实现相较于 Tomcat 中的 ApplicationFilterChain 来说，逻辑更加清晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerExecutionChain</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"> <span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptor</span><span class="params">(HandlerInterceptor interceptor)</span> &#123;</span><br><span class="line">  initInterceptorList().add(interceptor);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">  <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">    <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">    <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">     triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, ModelAndView mv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">  <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">    interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Exception ex)</span></span><br><span class="line">   <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">  <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">     logger.error(<span class="string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, ex2);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Spring 框架中，DispatcherServlet 的 doDispatch() 方法来分发请求，它在真正的业务逻辑执行前后，执行 HandlerExecutionChain 中的 applyPreHandle() 和 applyPostHandle() 函数，用来实现拦截的功能。</p>
<h1 id="访问控制实现讨论"><a href="#访问控制实现讨论" class="headerlink" title="访问控制实现讨论"></a>访问控制实现讨论</h1><p>前面在讲代理模式的时候，我们提到，Spring AOP 是基于代理模式来实现的。在实际的项目开发中，我们可以利用 AOP 来实现访问控制功能，比如鉴权、限流、日志等。今天我们又讲到，Servlet Filter、Spring Interceptor 也可以用来实现访问控制。那在项目开发中，类似权限这样的访问控制功能，我们该选择三者（AOP、Servlet Filter、Spring Interceptor）中的哪个来实现呢？有什么参考标准吗？</p>
<p>答：三者应用范围不同: web filter 作用于容器，应用范围影响最大；spring interceptor 作用于框架，范围影响适中；aop 作用于业务逻辑，精细化处理，范围影响最小。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策略模式</title>
    <url>/2022/08/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="策略模式的原理与实现"><a href="#策略模式的原理与实现" class="headerlink" title="策略模式的原理与实现"></a>策略模式的原理与实现</h1><p>策略模式，英文全称是 Strategy Design Pattern。在 GoF 的《设计模式》一书中，它是这样定义的：</p>
<blockquote>
<p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p>
</blockquote>
<p>翻译成中文就是：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p>
<p>工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分。</p>
<span id="more"></span>

<h2 id="策略的定义"><a href="#策略的定义" class="headerlink" title="策略的定义"></a>策略的定义</h2><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//具体的算法...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//具体的算法...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="策略的创建"><a href="#策略的创建" class="headerlink" title="策略的创建"></a>策略的创建</h2><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Strategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    strategies.put(<span class="string">&quot;A&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>());</span><br><span class="line">    strategies.put(<span class="string">&quot;B&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用 getStrategy() 的时候，都创建一个新的策略对象。针对这种情况，我们可以使用上面这种工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。</p>
<p>相反，如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象，那我们就需要按照如下方式来实现策略工厂类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="策略的使用"><a href="#策略的使用" class="headerlink" title="策略的使用"></a>策略的使用</h2><p>我们知道，策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。</p>
<p>这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 策略接口：EvictionStrategy</span></span><br><span class="line"><span class="comment">// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span></span><br><span class="line"><span class="comment">// 策略工厂：EvictionStrategyFactory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCache</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, User&gt; cacheData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> EvictionStrategy eviction;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserCache</span><span class="params">(EvictionStrategy eviction)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.eviction = eviction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时动态确定，根据配置文件的配置决定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">EvictionStrategy</span> <span class="variable">evictionStrategy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    props.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./config.properties&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;eviction_type&quot;</span>);</span><br><span class="line">    evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);</span><br><span class="line">    <span class="type">UserCache</span> <span class="variable">userCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCache</span>(evictionStrategy);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非运行时动态确定，在代码中指定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">EvictionStrategy</span> <span class="variable">evictionStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LruEvictionStrategy</span>();</span><br><span class="line">    <span class="type">UserCache</span> <span class="variable">userCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCache</span>(evictionStrategy);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们也可以看出，“非运行时动态确定”，也就是第二个 Application 中的使用方式，并不能发挥策略模式的优势。在这种应用场景下，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”。</p>
<h2 id="如何利用策略模式避免分支判断？"><a href="#如何利用策略模式避免分支判断？" class="headerlink" title="如何利用策略模式避免分支判断？"></a>如何利用策略模式避免分支判断？</h2><p>实际上，能够移除分支判断逻辑的模式不仅仅有策略模式，后面我们要讲的状态模式也可以。对于使用哪种模式，具体还要看应用场景来定。 策略模式适用于根据不同类型的动态，决定使用哪种策略这样一种应用场景。</p>
<p>我们先通过一个例子来看下，if-else 或 switch-case 分支判断逻辑是如何产生的。具体的代码如下所示。在这个例子中，我们没有使用策略模式，而是将策略的定义、创建、使用直接耦合在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">discount</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">discount</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">OrderType</span> <span class="variable">type</span> <span class="operator">=</span> order.getType();</span><br><span class="line">    <span class="keyword">if</span> (type.equals(OrderType.NORMAL)) &#123; <span class="comment">// 普通订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.GROUPON)) &#123; <span class="comment">// 团购订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123; <span class="comment">// 促销订单</span></span><br><span class="line">      <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> discount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 策略的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscountStrategy</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">calDiscount</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略的创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscountStrategyFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;OrderType, DiscountStrategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    strategies.put(OrderType.NORMAL, <span class="keyword">new</span> <span class="title class_">NormalDiscountStrategy</span>());</span><br><span class="line">    strategies.put(OrderType.GROUPON, <span class="keyword">new</span> <span class="title class_">GrouponDiscountStrategy</span>());</span><br><span class="line">    strategies.put(OrderType.PROMOTION, <span class="keyword">new</span> <span class="title class_">PromotionDiscountStrategy</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> DiscountStrategy <span class="title function_">getDiscountStrategy</span><span class="params">(OrderType type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">discount</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="type">OrderType</span> <span class="variable">type</span> <span class="operator">=</span> order.getType();</span><br><span class="line">    <span class="type">DiscountStrategy</span> <span class="variable">discountStrategy</span> <span class="operator">=</span> DiscountStrategyFactory.getDiscountStrategy(type);</span><br><span class="line">    <span class="keyword">return</span> discountStrategy.calDiscount(order);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重构之后的代码就没有了 if-else 分支判断语句了。实际上，这得益于策略工厂类。在工厂类中，我们用 Map 来缓存策略，根据 type 直接从 Map 中获取对应的策略，从而避免 if-else 分支判断逻辑。等后面讲到使用状态模式来避免分支判断逻辑的时候，你会发现，它们使用的是同样的套路。本质上都是借助“查表法”，根据 type 查表（代码中的 strategies 就是表）替代根据 type 分支判断。</p>
<p>但是，如果业务场景需要每次都创建不同的策略对象，我们就要用另外一种工厂类的实现方式了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscountStrategyFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> DiscountStrategy <span class="title function_">getDiscountStrategy</span><span class="params">(OrderType type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Type should not be null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type.equals(OrderType.NORMAL)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NormalDiscountStrategy</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.GROUPON)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GrouponDiscountStrategy</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PromotionDiscountStrategy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种实现方式相当于把原来的 if-else 分支逻辑，从 OrderService 类中转移到了工厂类中，实际上并没有真正将它移除。得益于策略工厂类，更本质上点讲，是借助“查表法”，根据 type 查表替代根据 type 分支判断。</p>
<p>对于 Java 语言来说，我们可以通过反射来避免对策略工厂类的修改。具体是这么做的：我们通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类；策略工厂类读取配置文件或者搜索被 annotation 标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象；当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用 annotation 标注即可。还记得上一节课的课堂讨论题吗？我们也可以用这种方法来解决。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-装饰器模式</title>
    <url>/2022/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p>
<span id="more"></span>

<p>装饰器模式就是简单的“用组合替代继承”吗？当然不是。从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。</p>
<p>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p>
<p>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-组合模式</title>
    <url>/2022/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="组合模式的原理与实现"><a href="#组合模式的原理与实现" class="headerlink" title="组合模式的原理与实现"></a>组合模式的原理与实现</h1><p>在 GoF 的《设计模式》一书中，组合模式是这样定义的：</p>
<blockquote>
<p>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.</p>
</blockquote>
<p>翻译成中文就是：将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。</p>
<span id="more"></span>

<p>假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p>
<ul>
<li>动态地添加、删除某个目录下的子目录或文件；</li>
<li>统计指定目录下的文件个数；</li>
<li>统计指定目录下的文件总大小。</li>
</ul>
<p>在下面的代码实现中，我们把文件和目录统一用 FileSystemNode 类来表示，并且通过 isFile 属性来区分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemNode</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String path;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> isFile;</span><br><span class="line">  <span class="keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FileSystemNode</span><span class="params">(String path, <span class="type">boolean</span> isFile)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.path = path;</span><br><span class="line">    <span class="built_in">this</span>.isFile = isFile;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNumOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFile) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numOfFiles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      numOfFiles += fileOrDir.countNumOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numOfFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSizeOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFile) &#123;</span><br><span class="line">      <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">      <span class="keyword">if</span> (!file.exists()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> file.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sizeofFiles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      sizeofFiles += fileOrDir.countSizeOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sizeofFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> subNodes.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于文件，我们直接返回文件的个数（返回 1）或大小。对于目录，我们遍历目录中每个子目录或者文件，递归计算它们的个数或大小，然后求和，就是这个目录下的文件个数和文件大小。</p>
<p>如果我们开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，我们最好对文件和目录进行区分设计，定义为 File 和 Directory 两个类。<br>按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FileSystemNode</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> String path;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">FileSystemNode</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.path = path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">countNumOfFiles</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">countSizeOfFiles</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">extends</span> <span class="title class_">FileSystemNode</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNumOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSizeOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    java.io.<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.File(path);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> file.length();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Directory</span> <span class="keyword">extends</span> <span class="title class_">FileSystemNode</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Directory</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNumOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numOfFiles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      numOfFiles += fileOrDir.countNumOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numOfFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSizeOfFiles</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sizeofFiles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">      sizeofFiles += fileOrDir.countSizeOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sizeofFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> &#123;</span><br><span class="line">    subNodes.add(fileOrDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> subNodes.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; size; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">      subNodes.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * /</span></span><br><span class="line"><span class="comment">     * /wz/</span></span><br><span class="line"><span class="comment">     * /wz/a.txt</span></span><br><span class="line"><span class="comment">     * /wz/b.txt</span></span><br><span class="line"><span class="comment">     * /wz/movies/</span></span><br><span class="line"><span class="comment">     * /wz/movies/c.avi</span></span><br><span class="line"><span class="comment">     * /xzg/</span></span><br><span class="line"><span class="comment">     * /xzg/docs/</span></span><br><span class="line"><span class="comment">     * /xzg/docs/d.txt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Directory</span> <span class="variable">fileSystemTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="type">Directory</span> <span class="variable">node_wz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;/wz/&quot;</span>);</span><br><span class="line">    <span class="type">Directory</span> <span class="variable">node_xzg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;/xzg/&quot;</span>);</span><br><span class="line">    fileSystemTree.addSubNode(node_wz);</span><br><span class="line">    fileSystemTree.addSubNode(node_xzg);</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">node_wz_a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/wz/a.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">node_wz_b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/wz/b.txt&quot;</span>);</span><br><span class="line">    <span class="type">Directory</span> <span class="variable">node_wz_movies</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;/wz/movies/&quot;</span>);</span><br><span class="line">    node_wz.addSubNode(node_wz_a);</span><br><span class="line">    node_wz.addSubNode(node_wz_b);</span><br><span class="line">    node_wz.addSubNode(node_wz_movies);</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">node_wz_movies_c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/wz/movies/c.avi&quot;</span>);</span><br><span class="line">    node_wz_movies.addSubNode(node_wz_movies_c);</span><br><span class="line"></span><br><span class="line">    <span class="type">Directory</span> <span class="variable">node_xzg_docs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;/xzg/docs/&quot;</span>);</span><br><span class="line">    node_xzg.addSubNode(node_xzg_docs);</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">node_xzg_docs_d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/xzg/docs/d.txt&quot;</span>);</span><br><span class="line">    node_xzg_docs.addSubNode(node_xzg_docs_d);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;/ files num:&quot;</span> + fileSystemTree.countNumOfFiles());</span><br><span class="line">    System.out.println(<span class="string">&quot;/wz/ files num:&quot;</span> + node_wz.countNumOfFiles());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对照着这个例子，再重新看一下组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”</p>
<p>实际上，刚才讲的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p>
<p>组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。使用组合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也比较局限，它并不是一种很常用的设计模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-观察者模式</title>
    <url>/2022/08/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="原理及应用场景剖析"><a href="#原理及应用场景剖析" class="headerlink" title="原理及应用场景剖析"></a>原理及应用场景剖析</h1><p>观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-Subscribe Design Pattern）。在 GoF 的《设计模式》一书中，它的定义是这样的：</p>
<blockquote>
<p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p>
</blockquote>
<p>翻译成中文就是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p>
<p>一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。</p>
<span id="more"></span>

<p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。不同的应用场景和需求下，这个模式也有截然不同的实现方式，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p>
<h1 id="同步阻塞观察者模式的简易实现"><a href="#同步阻塞观察者模式的简易实现" class="headerlink" title="同步阻塞观察者模式的简易实现"></a>同步阻塞观察者模式的简易实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Message message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">    observers.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">      observer.update(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserverOne</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;ConcreteObserverOne is notified.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserverTwo</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;ConcreteObserverTwo is notified.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">    subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserverOne</span>());</span><br><span class="line">    subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserverTwo</span>());</span><br><span class="line">    subject.notifyObservers(<span class="keyword">new</span> <span class="title class_">Message</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="异步非阻塞观察者模式的简易实现"><a href="#异步非阻塞观察者模式的简易实现" class="headerlink" title="异步非阻塞观察者模式的简易实现"></a>异步非阻塞观察者模式的简易实现</h1><p>对于异步非阻塞观察者模式，如果只是实现一个简易版本，不考虑任何通用性、复用性，实际上是非常容易的。</p>
<p>我们有两种实现方式。其中一种是：在每个 <code>handleRegSuccess()</code> 函数中创建一个新的线程执行代码逻辑；另一种是：在 <code>UserController</code> 的 <code>register()</code> 函数中使用线程池来执行每个观察者的 <code>handleRegSuccess()</code> 函数。两种实现方式的具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 第一种实现方式，其他类代码不变，就没有再重复罗列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegPromotionObserver</span> <span class="keyword">implements</span> <span class="title class_">RegObserver</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> PromotionService promotionService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种实现方式，其他类代码不变，就没有再重复罗列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖注入</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;RegObserver&gt; regObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> Executor executor;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.executor = executor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRegObservers</span><span class="params">(List&lt;RegObserver&gt; observers)</span> &#123;</span><br><span class="line">    regObservers.addAll(observers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Long <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//省略输入参数的校验代码</span></span><br><span class="line">    <span class="comment">//省略userService.register()异常的try-catch代码</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RegObserver observer : regObservers) &#123;</span><br><span class="line">      executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          observer.handleRegSuccess(userId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于第一种实现方式，频繁地创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出。第二种实现方式，尽管利用了线程池解决了第一种实现方式的问题，但线程池、异步执行逻辑都耦合在了 <code>register()</code> 函数中，增加了这部分业务代码的维护成本。</p>
<p>我们知道，框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。针对异步非阻塞观察者模式，我们也可以将它抽象成框架来达到这样的效果，而这个框架就是 <code>EventBus</code> 。</p>
<h1 id="EventBus-框架功能需求介绍"><a href="#EventBus-框架功能需求介绍" class="headerlink" title="EventBus 框架功能需求介绍"></a>EventBus 框架功能需求介绍</h1><p><code>EventBus</code> 翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。其中，<code>Google Guava EventBus</code> 就是一个比较著名的 <code>EventBus</code> 框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式</p>
<h2 id="EventBus例子"><a href="#EventBus例子" class="headerlink" title="EventBus例子"></a>EventBus例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> EventBus eventBus;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_EVENTBUS_THREAD_POOL_SIZE</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//eventBus = new EventBus(); // 同步阻塞模式</span></span><br><span class="line">    eventBus = <span class="keyword">new</span> <span class="title class_">AsyncEventBus</span>(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); <span class="comment">// 异步非阻塞模式</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRegObservers</span><span class="params">(List&lt;Object&gt; observers)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object observer : observers) &#123;</span><br><span class="line">      eventBus.register(observer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Long <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//省略输入参数的校验代码</span></span><br><span class="line">    <span class="comment">//省略userService.register()异常的try-catch代码</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    eventBus.post(userId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegPromotionObserver</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> PromotionService promotionService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Subscribe</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegNotificationObserver</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Subscribe</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    notificationService.sendInboxMessage(userId, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于 <code>EventBus</code>，我们不需要定义 <code>Observer</code> 接口，任意类型的对象都可以注册到 <code>EventBus</code> 中，通过 <code>@Subscribe</code> 注解来标明类中哪个函数可以接收被观察者发送的消息。</p>
<h2 id="Guava-EventBus-的几个主要的类和函数。"><a href="#Guava-EventBus-的几个主要的类和函数。" class="headerlink" title="Guava EventBus 的几个主要的类和函数。"></a>Guava EventBus 的几个主要的类和函数。</h2><ul>
<li>EventBus、AsyncEventBus</li>
</ul>
<p>Guava EventBus 对外暴露的所有可调用接口，都封装在 EventBus 类中。其中，EventBus 实现了同步阻塞的观察者模式，AsyncEventBus 继承自 EventBus，提供了异步非阻塞的观察者模式。具体使用方式如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>(); <span class="comment">// 同步阻塞模式</span></span><br><span class="line"><span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncEventBus</span>(Executors.newFixedThreadPool(<span class="number">8</span>))；<span class="comment">// 异步阻塞模式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>register() 函数</li>
</ul>
<p>EventBus 类提供了 register() 函数用来注册观察者。具体的函数定义如下所示。它可以接受任何类型（Object）的观察者。而在经典的观察者模式的实现中，register() 函数必须接受实现了同一 Observer 接口的类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object object)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>unregister() 函数</li>
</ul>
<p>相对于 register() 函数，unregister() 函数用来从 EventBus 中删除某个观察者。我就不多解释了，具体的函数定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">(Object object)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>post() 函数</li>
</ul>
<p>EventBus 类提供了 post() 函数，用来给观察者发送消息。具体的函数定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Object event)</span>;</span><br></pre></td></tr></table></figure>

<p>跟经典的观察者模式的不同之处在于，当我们调用 post() 函数发送消息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的观察者。所谓可匹配指的是，能接收的消息类型是发送消息（post 函数定义中的 event）类型的父类。</p>
<p>比如，AObserver 能接收的消息类型是 XMsg，BObserver 能接收的消息类型是 YMsg，CObserver 能接收的消息类型是 ZMsg。其中，XMsg 是 YMsg 的父类。当我们如下发送消息的时候，相应能接收到消息的可匹配观察者如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">XMsg</span> <span class="variable">xMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMsg</span>();</span><br><span class="line"><span class="type">YMsg</span> <span class="variable">yMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YMsg</span>();</span><br><span class="line"><span class="type">ZMsg</span> <span class="variable">zMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZMsg</span>();</span><br><span class="line">post(xMsg); =&gt; AObserver接收到消息</span><br><span class="line">post(yMsg); =&gt; AObserver、BObserver接收到消息</span><br><span class="line">post(zMsg); =&gt; CObserver接收到消息</span><br></pre></td></tr></table></figure>

<ul>
<li>@Subscribe 注解</li>
</ul>
<p>EventBus 通过 @Subscribe 注解来标明，某个函数能接收哪种类型的消息。具体的使用代码如下所示。在 DObserver 类中，我们通过 @Subscribe 注解了两个函数 f1()、f2()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DObserver &#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Subscribe</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(PMsg event)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Subscribe</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(QMsg event)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当通过 register() 函数将 DObserver 类对象注册到 EventBus 的时候，EventBus 会根据 @Subscribe 注解找到 f1() 和 f2()，并且将两个函数能接收的消息类型记录下来（PMsg-&gt;f1，QMsg-&gt;f2）。当我们通过 post() 函数发送消息（比如 QMsg 消息）的时候，EventBus 会通过之前的记录（QMsg-&gt;f2），调用相应的函数（f2）。</p>
<h2 id="手把手实现一个-EventBus-框架"><a href="#手把手实现一个-EventBus-框架" class="headerlink" title="手把手实现一个 EventBus 框架"></a>手把手实现一个 EventBus 框架</h2><p><code>EventBus</code>最关键的一个数据结构是 <code>Observer</code> 注册表，记录了消息类型和可接收消息函数的对应关系。当调用 register() 函数注册观察者的时候，<code>EventBus</code> 通过解析 <code>@Subscribe</code> 注解，生成 <code>Observer</code> 注册表。当调用 <code>post()</code> 函数发送消息的时候，<code>EventBus</code> 通过注册表找到相应的可接收消息的函数，然后通过 <code>Java</code> 的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，<code>EventBus</code> 在一个线程内依次执行相应的函数。对于异步非阻塞模式，<code>EventBus</code> 通过一个线程池来执行相应的函数。</p>
<h3 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ObserverAction"><a href="#ObserverAction" class="headerlink" title="ObserverAction"></a>ObserverAction</h3><p>ObserverAction 类用来表示 @Subscribe 注解的方法，其中，target 表示观察者类，method 表示方法。它主要用在 ObserverRegistry 观察者注册表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverAction</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObserverAction</span><span class="params">(Object target, Method method)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="built_in">this</span>.method = method;</span><br><span class="line">        <span class="built_in">this</span>.method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event method方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method.invoke(target, event);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ObserverRegistry"><a href="#ObserverRegistry" class="headerlink" title="ObserverRegistry"></a>ObserverRegistry</h3><p><code>ObserverRegistry</code> 类就是前面讲到的 <code>Observer</code> 注册表，是最复杂的一个类，框架中几乎所有的核心逻辑都在这个类中。这个类大量使用了 <code>Java</code> 的反射语法，不过代码整体来说都不难理解，其中，一个比较有技巧的地方是 <code>CopyOnWriteArraySet</code> 的使用。</p>
<p><code>CopyOnWriteArraySet</code>，能保证在写入数据的时候，不影响数据的读取操作，以此来解决读写并发问题。除此之外，<code>CopyOnWriteSet</code> 还通过加锁的方式，避免了并发写冲突。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; registry = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object observer)</span> &#123;</span><br><span class="line">        Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = findAllObserverActions(observer);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; entry : observerActions.entrySet()) &#123;</span><br><span class="line">            Class&lt;?&gt; eventType = entry.getKey();</span><br><span class="line">            CopyOnWriteArraySet&lt;ObserverAction&gt; registeredEventActions = registry.get(eventType);</span><br><span class="line">            <span class="keyword">if</span> (registeredEventActions == <span class="literal">null</span>) &#123;</span><br><span class="line">                registry.putIfAbsent(eventType, <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;());</span><br><span class="line">                registeredEventActions = registry.get(eventType);</span><br><span class="line">            &#125;</span><br><span class="line">            registeredEventActions.addAll(entry.getValue());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;ObserverAction&gt; <span class="title function_">getMatchedObserverActions</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">        List&lt;ObserverAction&gt; matchedObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Class&lt;?&gt; postedEventType = event.getClass();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; entry : registry.entrySet()) &#123;</span><br><span class="line">            Class&lt;?&gt; eventType = entry.getKey();</span><br><span class="line">            Collection&lt;ObserverAction&gt; eventActions = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (postedEventType.isAssignableFrom(eventType)) &#123;</span><br><span class="line">                matchedObservers.addAll(eventActions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matchedObservers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; findAllObserverActions(Object observer) &#123;</span><br><span class="line">        Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Class&lt;?&gt; clazz = observer.getClass();</span><br><span class="line">        List&lt;Method&gt; annotatedMethods = getAnnotatedMethods(clazz);</span><br><span class="line">        <span class="keyword">for</span> (Method method: annotatedMethods) &#123;</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (!observerActions.containsKey(eventType)) &#123;</span><br><span class="line">                observerActions.put(eventType, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            observerActions.get(eventType).add(<span class="keyword">new</span> <span class="title class_">ObserverAction</span>(observer, method));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> observerActions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Method&gt; <span class="title function_">getAnnotatedMethods</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        List&lt;Method&gt; annotatedMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Method method : clazz.getDeclaredMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">                Preconditions.checkArgument(parameterTypes.length == <span class="number">1</span>,</span><br><span class="line">                        <span class="string">&quot;Method %s has @Subscribe annotation but has %s parameters.&quot;</span></span><br><span class="line">                                + <span class="string">&quot;Subscriber methods must have exactly 1 parameter.&quot;</span>,</span><br><span class="line">                        method, parameterTypes.length);</span><br><span class="line">                annotatedMethods.add(method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> annotatedMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Executor executor;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ObserverRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverRegistry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了复用代码，MoreExecutors.directExecutor()实际上是Google Guava提供的工具类，实际不是多线程，而是单线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EventBus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(MoreExecutors.directExecutor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EventBus</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        registry.register(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">        List&lt;ObserverAction&gt; matchedObserverActions = registry.getMatchedObserverActions(event);</span><br><span class="line">        <span class="keyword">for</span> (ObserverAction observerAction : matchedObserverActions) &#123;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                observerAction.execute(event);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AsyncEventBus"><a href="#AsyncEventBus" class="headerlink" title="AsyncEventBus"></a>AsyncEventBus</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncEventBus</span> <span class="keyword">extends</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AsyncEventBus</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(executor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Observer1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Observer1 handle:&quot;</span> + userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Observer2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Observer2 handle:&quot;</span> + userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">()</span> &#123;</span><br><span class="line">        eventBus = <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObservers</span><span class="params">(List&lt;Object&gt; observers)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object observer : observers) &#123;</span><br><span class="line">            eventBus.register(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//do register and return userId;</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="number">111L</span>;</span><br><span class="line">        eventBus.post(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceForAsync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceForAsync</span><span class="params">()</span> &#123;</span><br><span class="line">        eventBus = <span class="keyword">new</span> <span class="title class_">AsyncEventBus</span>(Executors.newFixedThreadPool(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObservers</span><span class="params">(List&lt;Object&gt; observers)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object observer : observers) &#123;</span><br><span class="line">            eventBus.register(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//do register and return userId;</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="number">111L</span>;</span><br><span class="line">        eventBus.post(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        userService.setObservers(Arrays.asList(<span class="keyword">new</span> <span class="title class_">Observer1</span>(), <span class="keyword">new</span> <span class="title class_">Observer2</span>()));</span><br><span class="line">        userService.register();</span><br><span class="line"></span><br><span class="line">        <span class="type">UserServiceForAsync</span> <span class="variable">userServiceForAsync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceForAsync</span>();</span><br><span class="line">        userServiceForAsync.setObservers(Arrays.asList(<span class="keyword">new</span> <span class="title class_">Observer1</span>(), <span class="keyword">new</span> <span class="title class_">Observer2</span>()));</span><br><span class="line">        userServiceForAsync.register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-解释器模式</title>
    <url>/2022/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>解释器模式的英文翻译是 Interpreter Design Pattern。在 GoF 的《设计模式》一书中，它是这样定义的：</p>
<blockquote>
<p>Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.</p>
</blockquote>
<p>翻译成中文就是：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</p>
<p>看了定义，你估计会一头雾水，因为这里面有很多我们平时开发中很少接触的概念，比如“语言”“语法”“解释器”。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</p>
<p>要想了解“语言”表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。</p>
<span id="more"></span>

<p>在我们平时的项目开发中，监控系统非常重要，它可以时刻监控业务系统的运行情况，及时将异常报告给开发者。比如，如果每分钟接口出错数超过 100，监控系统就通过短信、微信、邮件等方式发送告警给开发者。</p>
<p>一般来讲，监控系统支持开发者自定义告警规则，比如我们可以用下面这样一个表达式，来表示一个告警规则，它表达的意思是：每分钟 API 总出错数超过 100 或者每分钟 API 总调用数超过 10000 就触发告警。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">api_error_per_minute &gt; 100 || api_count_per_minute &gt; 10000</span><br></pre></td></tr></table></figure>

<p>监控系统中，告警模块只负责根据统计数据和告警规则，判断是否触发告警。至于每分钟 API 接口出错数、每分钟接口调用数等统计数据的计算，是由其他模块来负责的。其他模块将统计数据放到一个 Map 中（数据的格式如下所示），发送给告警模块。接下来，我们只关注告警模块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Long&gt; apiStat = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">apiStat.put(<span class="string">&quot;api_error_per_minute&quot;</span>, <span class="number">103</span>);</span><br><span class="line">apiStat.put(<span class="string">&quot;api_count_per_minute&quot;</span>, <span class="number">987</span>);</span><br></pre></td></tr></table></figure>

<p>为了简化讲解和代码实现，我们假设自定义的告警规则只包含“||、&amp;&amp;、&gt;、&lt;、&#x3D;&#x3D;”这五个运算符，其中，“&gt;、&lt;、&#x3D;&#x3D;”运算符的优先级高于“||、&amp;&amp;”运算符，“&amp;&amp;”运算符优先级高于“||”。在表达式中，任意元素之间需要通过空格来分隔。除此之外，用户可以自定义要监控的 key，比如前面的 api_error_per_minute、api_count_per_minute。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlertRuleInterpreter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// key1 &gt; 100 &amp;&amp; key2 &lt; 1000 || key3 == 200</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AlertRuleInterpreter</span><span class="params">(String ruleExpression)</span> &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span>由你来完善</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//&lt;String, Long&gt; apiStat = new HashMap&lt;&gt;();</span></span><br><span class="line">  <span class="comment">//apiStat.put(&quot;key1&quot;, 103);</span></span><br><span class="line">  <span class="comment">//apiStat.put(&quot;key2&quot;, 987);</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span>由你来完善</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="string">&quot;key1 &gt; 100 &amp;&amp; key2 &lt; 30 || key3 &lt; 100 || key4 == 88&quot;</span>;</span><br><span class="line">    <span class="type">AlertRuleInterpreter</span> <span class="variable">interpreter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlertRuleInterpreter</span>(rule);</span><br><span class="line">    Map&lt;String, Long&gt; stats = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    stats.put(<span class="string">&quot;key1&quot;</span>, <span class="number">101l</span>);</span><br><span class="line">    stats.put(<span class="string">&quot;key3&quot;</span>, <span class="number">121l</span>);</span><br><span class="line">    stats.put(<span class="string">&quot;key4&quot;</span>, <span class="number">88l</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">alert</span> <span class="operator">=</span> interpreter.interpret(stats);</span><br><span class="line">    System.out.println(alert);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，我们可以把自定义的告警规则，看作一种特殊“语言”的语法规则。我们实现一个解释器，能够根据规则，针对用户输入的数据，判断是否触发告警。利用解释器模式，我们把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreaterExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String key;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">GreaterExpression</span><span class="params">(String strExpression)</span> &#123;</span><br><span class="line">    String[] elements = strExpression.trim().split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (elements.length != <span class="number">3</span> || !elements[<span class="number">1</span>].trim().equals(<span class="string">&quot;&gt;&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Expression is invalid: &quot;</span> + strExpression);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.key = elements[<span class="number">0</span>].trim();</span><br><span class="line">    <span class="built_in">this</span>.value = Long.parseLong(elements[<span class="number">2</span>].trim());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">GreaterExpression</span><span class="params">(String key, <span class="type">long</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!stats.containsKey(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">statValue</span> <span class="operator">=</span> stats.get(key);</span><br><span class="line">    <span class="keyword">return</span> statValue &gt; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LessExpression/EqualExpression跟GreaterExpression代码类似，这里就省略了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Expression&gt; expressions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AndExpression</span><span class="params">(String strAndExpression)</span> &#123;</span><br><span class="line">    String[] strExpressions = strAndExpression.split(<span class="string">&quot;&amp;&amp;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String strExpr : strExpressions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (strExpr.contains(<span class="string">&quot;&gt;&quot;</span>)) &#123;</span><br><span class="line">        expressions.add(<span class="keyword">new</span> <span class="title class_">GreaterExpression</span>(strExpr));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strExpr.contains(<span class="string">&quot;&lt;&quot;</span>)) &#123;</span><br><span class="line">        expressions.add(<span class="keyword">new</span> <span class="title class_">LessExpression</span>(strExpr));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strExpr.contains(<span class="string">&quot;==&quot;</span>)) &#123;</span><br><span class="line">        expressions.add(<span class="keyword">new</span> <span class="title class_">EqualExpression</span>(strExpr));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Expression is invalid: &quot;</span> + strAndExpression);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AndExpression</span><span class="params">(List&lt;Expression&gt; expressions)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.expressions.addAll(expressions);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Expression expr : expressions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!expr.interpret(stats)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Expression&gt; expressions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">OrExpression</span><span class="params">(String strOrExpression)</span> &#123;</span><br><span class="line">    String[] andExpressions = strOrExpression.split(<span class="string">&quot;\\|\\|&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String andExpr : andExpressions) &#123;</span><br><span class="line">      expressions.add(<span class="keyword">new</span> <span class="title class_">AndExpression</span>(andExpr));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">OrExpression</span><span class="params">(List&lt;Expression&gt; expressions)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.expressions.addAll(expressions);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Expression expr : expressions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (expr.interpret(stats)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlertRuleInterpreter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Expression expression;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AlertRuleInterpreter</span><span class="params">(String ruleExpression)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.expression = <span class="keyword">new</span> <span class="title class_">OrExpression</span>(ruleExpression);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> expression.interpret(stats);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-设计实现一个支持自定义规则的灰度发布组件</title>
    <url>/2022/10/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99%E7%9A%84%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="灰度组件功能需求整理"><a href="#灰度组件功能需求整理" class="headerlink" title="灰度组件功能需求整理"></a>灰度组件功能需求整理</h1><h2 id="灰度规则的格式和存储方式"><a href="#灰度规则的格式和存储方式" class="headerlink" title="灰度规则的格式和存储方式"></a>灰度规则的格式和存储方式</h2><p>我们希望支持不同格式（JSON、YAML、XML 等）、不同存储方式（本地配置文件、Redis、Zookeeper、或者自研配置中心等）的灰度规则配置方式。实际上，这一点跟之前的限流框架中限流规则的格式和存储方式完全一致，代码实现也是相同的</p>
<h2 id="灰度规则的语法格式"><a href="#灰度规则的语法格式" class="headerlink" title="灰度规则的语法格式"></a>灰度规则的语法格式</h2><p>我们支持三种灰度规则语法格式：具体值（比如 893）、区间值（比如 1020-1120）、比例值（比如 %30）。除此之外，对于更加复杂的灰度规则，比如只对 30 天内购买过某某商品并且退货次数少于 10 次的用户进行灰度，我们通过编程的方式来实现。</p>
<h2 id="灰度规则的内存组织方式"><a href="#灰度规则的内存组织方式" class="headerlink" title="灰度规则的内存组织方式"></a>灰度规则的内存组织方式</h2><p>类似于限流框架中的限流规则，我们需要把灰度规则组织成支持快速查找的数据结构，能够快速判定某个灰度对象（darkTarget，比如用户 ID），是否落在灰度规则设定的范围内。</p>
<h2 id="灰度规则热更新"><a href="#灰度规则热更新" class="headerlink" title="灰度规则热更新"></a>灰度规则热更新</h2><p>修改了灰度规则之后，我们希望不重新部署和重启系统，新的灰度规则就能生效，所以，我们需要支持灰度规则热更新。</p>
<p>在 V1 版本中，对于第一点灰度规则的格式和存储方式，我们只支持 YAML 格式本地文件的配置存储方式。对于剩下的三点，我们都要进行实现。考虑到 V1 版本要实现的内容比较多，我们分两步来实现代码，第一步先将大的流程、框架搭建好，第二步再进一步添加、丰富、优化功能。</p>
<h1 id="实现灰度组件基本功能"><a href="#实现灰度组件基本功能" class="headerlink" title="实现灰度组件基本功能"></a>实现灰度组件基本功能</h1><p>在第一步中，我们先实现基于 YAML 格式的本地文件的灰度规则配置方式，以及灰度规则热更新，并且只支持三种基本的灰度规则语法格式。基于编程实现灰度规则的方式，我们留在第二步实现。</p>
<p>我们先把这个基本功能的开发需求，用代码实现出来。它的目录结构及其 Demo 示例如下所示。代码非常简单，只包含 4 个类。接下来，我们针对每个类再详细讲解一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 代码目录结构</span><br><span class="line">com.monochrome.darklaunch</span><br><span class="line">  --DarkLaunch(框架的最顶层入口类)</span><br><span class="line">  --DarkFeature(每个feature的灰度规则)</span><br><span class="line">com.monochrome.darklaunch.rule</span><br><span class="line">  --DarkRule(灰度规则)</span><br><span class="line">  --DarkRuleConfig(用来映射配置到内存中)</span><br><span class="line">com.monochrome.darklaunch.rule.datasource</span><br><span class="line">  --DarkRuleConfigSource(灰度规则源)</span><br><span class="line">  --FileDarkRuleConfigSource(文件型灰度规则源)</span><br><span class="line">com.monochrome.darklaunch.rule.parser</span><br><span class="line">  --DarkRuleConfigParser(灰度规则转换器)</span><br><span class="line">  --JsonDarkRuleConfigParser(Json格式灰度规则转换器)</span><br><span class="line">  --YamlDarkRuleConfigParser(Yaml格式灰度规则转换器)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Demo示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DarkDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DarkLaunch</span> <span class="variable">darkLaunch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DarkLaunch</span>();</span><br><span class="line">    <span class="type">DarkFeature</span> <span class="variable">darkFeature</span> <span class="operator">=</span> darkLaunch.getDarkFeature(<span class="string">&quot;call_newapi_getUserById&quot;</span>);</span><br><span class="line">    System.out.println(darkFeature.enabled());</span><br><span class="line">    System.out.println(darkFeature.dark(<span class="number">893</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#灰度规则配置(dark-rule.yaml)放置在classpath路径下</span></span><br><span class="line"><span class="attr">features:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">call_newapi_getUserById</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">rule:</span> &#123;<span class="number">893</span>,<span class="number">342</span>,<span class="number">1020</span><span class="number">-1120</span>,<span class="string">%30</span>&#125;</span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">call_newapi_registerUser</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">rule:</span> &#123;<span class="number">1391198723</span>, <span class="string">%10</span>&#125;</span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">newalgo_loan</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">rule:</span> &#123;<span class="number">0</span><span class="number">-1000</span>&#125;</span><br></pre></td></tr></table></figure>

<p>从 Demo 代码中，我们可以看出，对于业务系统来说，灰度组件的两个直接使用的类是 DarkLaunch 类和 DarkFeature 类。</p>
<p>我们先来看 DarkLaunch 类。这个类是灰度组件的最顶层入口类。它用来组装其他类对象，串联整个操作流程，提供外部调用的接口。</p>
<p>DarkLaunch 类先读取灰度规则配置文件，映射为内存中的 Java 对象（DarkRuleConfig），然后再将这个中间结构，构建成一个支持快速查询的数据结构（DarkRule）。除此之外，它还负责定期更新灰度规则，也就是前面提到的灰度规则热更新。</p>
<p>为了避免更新规则和查询规则的并发执行冲突，在更新灰度规则的时候，我们并非直接操作老的 DarkRule，而是先创建一个新的 DarkRule，然后等新的 DarkRule 都构建好之后，再“瞬间”赋值给老的 DarkRule。你可以结合着下面的代码一块看下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.darklaunch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.monochrome.darklaunch.rule.DarkRule;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.darklaunch.rule.DarkRuleConfig;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.darklaunch.rule.datasource.DarkRuleConfigSource;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.darklaunch.rule.datasource.FileDarkRuleConfigSource;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.yaml.snakeyaml.Yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DarkLaunch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(DarkLaunch.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_RULE_UPDATE_TIME_INTERVAL</span> <span class="operator">=</span> <span class="number">60</span>; <span class="comment">// in seconds</span></span><br><span class="line">    <span class="keyword">private</span> DarkRuleConfigSource ruleConfigSource;</span><br><span class="line">    <span class="keyword">private</span> DarkRule rule;</span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DarkLaunch</span><span class="params">(<span class="type">int</span> ruleUpdateTimeInterval)</span> &#123;</span><br><span class="line">        ruleConfigSource = <span class="keyword">new</span> <span class="title class_">FileDarkRuleConfigSource</span>();</span><br><span class="line">        <span class="type">DarkRuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> ruleConfigSource.load();</span><br><span class="line">        <span class="built_in">this</span>.rule = <span class="keyword">new</span> <span class="title class_">DarkRule</span>(ruleConfig);</span><br><span class="line">        <span class="built_in">this</span>.executor = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        <span class="built_in">this</span>.executor.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">DarkRuleConfig</span> <span class="variable">newRuleConfig</span> <span class="operator">=</span> ruleConfigSource.load();</span><br><span class="line">                <span class="type">DarkRule</span> <span class="variable">newDarkRule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DarkRule</span>(newRuleConfig);</span><br><span class="line">                rule = newDarkRule;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, ruleUpdateTimeInterval, ruleUpdateTimeInterval, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DarkLaunch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_RULE_UPDATE_TIME_INTERVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> DarkFeature <span class="title function_">getDarkFeature</span><span class="params">(String featureKey)</span> &#123;</span><br><span class="line">        <span class="type">DarkFeature</span> <span class="variable">darkFeature</span> <span class="operator">=</span> <span class="built_in">this</span>.rule.getDarkFeature(featureKey);</span><br><span class="line">        <span class="keyword">return</span> darkFeature;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看下 DarkRuleConfig 类。这个类功能非常简单，只是用来将灰度规则映射到内存中。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.darklaunch.rule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DarkRuleConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;DarkFeatureConfig&gt; features;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;DarkFeatureConfig&gt; <span class="title function_">getFeatures</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> features;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFeatures</span><span class="params">(List&lt;DarkFeatureConfig&gt; features)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.features = features;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DarkFeatureConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String key;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">        <span class="keyword">private</span> String rule;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> enabled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.enabled = enabled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getRule</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rule;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRule</span><span class="params">(String rule)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.rule = rule;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中，我们可以看出来，DarkRuleConfig 类嵌套了一个内部类 DarkFeatureConfig。这两个类跟配置文件的两层嵌套结构完全对应。我把对应关系标注在了下面的示例中，你可以对照着代码看下。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">features:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">call_newapi_getUserById</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">&quot;&#123;893,342,1020-1120,%30&#125;&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">call_newapi_registerUser</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">&quot;&#123;1391198723, %10&#125;&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">newalgo_loan</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">&quot;&#123;0-1000&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们再来看下 DarkRule。DarkRule 包含所有要灰度的业务功能的灰度规则。它用来支持根据业务功能标识（feature key），快速查询灰度规则（DarkFeature）。代码也比较简单，具体如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.darklaunch.rule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.monochrome.darklaunch.DarkFeature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DarkRule</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, DarkFeature&gt; darkFeatures = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DarkRule</span><span class="params">(<span class="meta">@NotNull</span> DarkRuleConfig darkRuleConfig)</span> &#123;</span><br><span class="line">        List&lt;DarkRuleConfig.DarkFeatureConfig&gt; darkFeatureConfigs = darkRuleConfig.getFeatures();</span><br><span class="line">        <span class="keyword">for</span> (DarkRuleConfig.DarkFeatureConfig darkFeatureConfig : darkFeatureConfigs) &#123;</span><br><span class="line">            darkFeatures.put(darkFeatureConfig.getKey(), <span class="keyword">new</span> <span class="title class_">DarkFeature</span>(darkFeatureConfig));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DarkFeature <span class="title function_">getDarkFeature</span><span class="params">(String featureKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> darkFeatures.get(featureKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们最后来看下 DarkFeature 类。DarkFeature 类表示每个要灰度的业务功能的灰度规则。DarkFeature 将配置文件中灰度规则，解析成一定的结构（比如 RangeSet），方便快速判定某个灰度对象是否落在灰度规则范围内。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.darklaunch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.annotations.VisibleForTesting;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Range;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.RangeSet;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.TreeRangeSet;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.darklaunch.rule.DarkRuleConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DarkFeature</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enable;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> percentage;</span><br><span class="line">    <span class="keyword">private</span> RangeSet&lt;Long&gt; rangeSet = TreeRangeSet.create();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DarkFeature</span><span class="params">(DarkRuleConfig.DarkFeatureConfig darkFeatureConfig)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = darkFeatureConfig.getKey();</span><br><span class="line">        <span class="built_in">this</span>.enable = darkFeatureConfig.isEnabled();</span><br><span class="line">        <span class="type">String</span> <span class="variable">darkRule</span> <span class="operator">=</span> darkFeatureConfig.getRule().trim();</span><br><span class="line">        parseDarkRule(darkRule);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseDarkRule</span><span class="params">(String darkRule)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!darkRule.startsWith(<span class="string">&quot;&#123;&quot;</span>) &amp;&amp; !darkRule.endsWith(<span class="string">&quot;&#125;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to parse dark rule:&quot;</span> + darkRule);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] rules = darkRule.substring(<span class="number">1</span>, darkRule.length() - <span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.rangeSet.clear();</span><br><span class="line">        <span class="built_in">this</span>.percentage = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String rule : rules) &#123;</span><br><span class="line">            rule = rule.trim();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(rule)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rule.startsWith(<span class="string">&quot;%&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">newPercentage</span> <span class="operator">=</span> Integer.parseInt(rule.substring(<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (newPercentage &gt; <span class="built_in">this</span>.percentage) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.percentage = newPercentage;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rule.contains(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                String[] parts = rule.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (parts.length != <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to parse dark rule:&quot;</span> + darkRule);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> Long.parseLong(parts[<span class="number">0</span>]);</span><br><span class="line">                <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> Long.parseLong(parts[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to parse dark rule:&quot;</span> + darkRule);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.rangeSet.add(Range.closed(start, end));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">val</span> <span class="operator">=</span> Long.parseLong(rule);</span><br><span class="line">                <span class="built_in">this</span>.rangeSet.add(Range.closed(val, val));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> enable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dark</span><span class="params">(String darkTarget)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">target</span> <span class="operator">=</span> Long.parseLong(darkTarget);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.dark(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dark</span><span class="params">(<span class="type">long</span> darkTarget)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">selected</span> <span class="operator">=</span> <span class="built_in">this</span>.rangeSet.contains(darkTarget);</span><br><span class="line">        <span class="keyword">if</span> (selected) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">reminder</span> <span class="operator">=</span> darkTarget % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (reminder &gt;= <span class="number">0</span> &amp;&amp; reminder &lt;= <span class="built_in">this</span>.percentage) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.darklaunch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.assertj.core.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DarkLaunchTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    DarkLaunch darkLaunch;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        darkLaunch = <span class="keyword">new</span> <span class="title class_">DarkLaunch</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getDarkFeature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DarkFeature</span> <span class="variable">darkFeature</span> <span class="operator">=</span> darkLaunch.getDarkFeature(<span class="string">&quot;call_newapi_getUserById&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">dark</span> <span class="operator">=</span> darkFeature.dark(<span class="number">893</span>);</span><br><span class="line">        assertThat(dark).isTrue();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">dark1</span> <span class="operator">=</span> darkFeature.dark(<span class="number">894</span>);</span><br><span class="line">        assertThat(dark1).isFalse();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">dark2</span> <span class="operator">=</span> darkFeature.dark(<span class="number">1021</span>);</span><br><span class="line">        assertThat(dark2).isTrue();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="添加、优化灰度组件功能"><a href="#添加、优化灰度组件功能" class="headerlink" title="添加、优化灰度组件功能"></a>添加、优化灰度组件功能</h1><p>在第一步中，我们完成了灰度组件的基本功能。在第二步中，我们再实现基于编程的灰度规则配置方式，用来支持更加复杂、更加灵活的灰度规则。</p>
<p>我们需要对于第一步实现的代码，进行一些改造。改造之后的代码目录结构如下所示。其中，DarkFeature、DarkRuleConfig 的基本代码不变，新增了 IDarkFeature 接口，DarkLaunch、DarkRule 的代码有所改动，用来支持编程实现灰度规则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// MVP版代码目录结构</span><br><span class="line">com.monochrome.darklaunch</span><br><span class="line">  --DarkLaunch(框架的最顶层入口类)</span><br><span class="line">  --DarkFeature(每个feature的灰度规则)</span><br><span class="line">com.monochrome.darklaunch.rule</span><br><span class="line">  --DarkRule(灰度规则)</span><br><span class="line">  --DarkRuleConfig(用来映射配置到内存中)</span><br><span class="line">com.monochrome.darklaunch.rule.datasource</span><br><span class="line">  --DarkRuleConfigSource(灰度规则源)</span><br><span class="line">  --FileDarkRuleConfigSource(文件型灰度规则源)</span><br><span class="line">com.monochrome.darklaunch.rule.parser</span><br><span class="line">  --DarkRuleConfigParser(灰度规则转换器)</span><br><span class="line">  --JsonDarkRuleConfigParser(Json格式灰度规则转换器)</span><br><span class="line">  --YamlDarkRuleConfigParser(Yaml格式灰度规则转换器)</span><br><span class="line">// 第二版代码目录结构</span><br><span class="line">com.monochrome.darklaunch</span><br><span class="line">  --DarkLaunch(框架的最顶层入口类，代码有改动)</span><br><span class="line">  --IDarkFeature(feature抽象接口)</span><br><span class="line">  --DarkFeature(实现IDarkFeature接口，基于配置文件的灰度规则，代码不变)</span><br><span class="line">com.monochrome.darklaunch.rule</span><br><span class="line">  --DarkRule(灰度规则，代码有改动)</span><br><span class="line">  --DarkRuleConfig(用来映射配置到内存中)</span><br><span class="line">com.monochrome.darklaunch.rule.datasource</span><br><span class="line">  --DarkRuleConfigSource(灰度规则源)</span><br><span class="line">  --FileDarkRuleConfigSource(文件型灰度规则源)</span><br><span class="line">com.monochrome.darklaunch.rule.parser</span><br><span class="line">  --DarkRuleConfigParser(灰度规则转换器)</span><br><span class="line">  --JsonDarkRuleConfigParser(Json格式灰度规则转换器)</span><br><span class="line">  --YamlDarkRuleConfigParser(Yaml格式灰度规则转换器)</span><br></pre></td></tr></table></figure>

<p>我们先来看下 IDarkFeature 接口，它用来抽象从配置文件中得到的灰度规则，以及编程实现的灰度规则。具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.darklaunch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDarkFeature</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">enabled</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">dark</span><span class="params">(<span class="type">long</span> darkTarget)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">dark</span><span class="params">(String darkTarget)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于这个抽象接口，业务系统可以自己编程实现复杂的灰度规则，然后添加到 DarkRule 中。为了避免配置文件中的灰度规则热更新时，覆盖掉编程实现的灰度规则，在 DarkRule 中，我们对从配置文件中加载的灰度规则和编程实现的灰度规则分开存储。按照这个设计思路，我们对 DarkRule 类进行重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.darklaunch.rule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.monochrome.darklaunch.DarkFeature;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.darklaunch.IDarkFeature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DarkRule</span> &#123;</span><br><span class="line">    <span class="comment">// 从配置文件加载的灰度规则</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, IDarkFeature&gt; darkFeatures = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 编程实现的灰度规则</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, IDarkFeature&gt; programmedDarkFeatures = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DarkRule</span><span class="params">(<span class="meta">@NotNull</span> DarkRuleConfig darkRuleConfig)</span> &#123;</span><br><span class="line">        List&lt;DarkRuleConfig.DarkFeatureConfig&gt; darkFeatureConfigs = darkRuleConfig.getFeatures();</span><br><span class="line">        <span class="keyword">for</span> (DarkRuleConfig.DarkFeatureConfig darkFeatureConfig : darkFeatureConfigs) &#123;</span><br><span class="line">            darkFeatures.put(darkFeatureConfig.getKey(), <span class="keyword">new</span> <span class="title class_">DarkFeature</span>(darkFeatureConfig));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addProgrammedDarkFeature</span><span class="params">(String featureKey, IDarkFeature darkFeature)</span> &#123;</span><br><span class="line">        programmedDarkFeatures.put(featureKey, darkFeature);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IDarkFeature <span class="title function_">getDarkFeature</span><span class="params">(String featureKey)</span> &#123;</span><br><span class="line">        <span class="type">IDarkFeature</span> <span class="variable">darkFeature</span> <span class="operator">=</span> programmedDarkFeatures.get(featureKey);</span><br><span class="line">        <span class="keyword">return</span> darkFeature == <span class="literal">null</span> ? darkFeatures.get(featureKey) : darkFeature;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 DarkRule 代码有所修改，对应地，DarkLaunch 的代码也需要做少许改动，主要有一处修改和一处新增代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.darklaunch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.monochrome.darklaunch.rule.DarkRule;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.darklaunch.rule.DarkRuleConfig;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.darklaunch.rule.datasource.DarkRuleConfigSource;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.darklaunch.rule.datasource.FileDarkRuleConfigSource;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.yaml.snakeyaml.Yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DarkLaunch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(DarkLaunch.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_RULE_UPDATE_TIME_INTERVAL</span> <span class="operator">=</span> <span class="number">60</span>; <span class="comment">// in seconds</span></span><br><span class="line">    <span class="keyword">private</span> DarkRuleConfigSource ruleConfigSource;</span><br><span class="line">    <span class="keyword">private</span> DarkRule rule;</span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DarkLaunch</span><span class="params">(<span class="type">int</span> ruleUpdateTimeInterval)</span> &#123;</span><br><span class="line">        ruleConfigSource = <span class="keyword">new</span> <span class="title class_">FileDarkRuleConfigSource</span>();</span><br><span class="line">        <span class="type">DarkRuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> ruleConfigSource.load();</span><br><span class="line">        <span class="built_in">this</span>.rule = <span class="keyword">new</span> <span class="title class_">DarkRule</span>(ruleConfig);</span><br><span class="line">        <span class="built_in">this</span>.executor = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        <span class="built_in">this</span>.executor.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">DarkRuleConfig</span> <span class="variable">newRuleConfig</span> <span class="operator">=</span> ruleConfigSource.load();</span><br><span class="line">                <span class="type">DarkRule</span> <span class="variable">newDarkRule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DarkRule</span>(newRuleConfig);</span><br><span class="line">                rule = newDarkRule;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, ruleUpdateTimeInterval, ruleUpdateTimeInterval, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DarkLaunch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_RULE_UPDATE_TIME_INTERVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addProgrammedDarkFeature</span><span class="params">(String featureKey, IDarkFeature darkFeature)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rule.addProgrammedDarkFeature(featureKey, darkFeature);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IDarkFeature <span class="title function_">getDarkFeature</span><span class="params">(String featureKey)</span> &#123;</span><br><span class="line">        <span class="type">IDarkFeature</span> <span class="variable">darkFeature</span> <span class="operator">=</span> <span class="built_in">this</span>.rule.getDarkFeature(featureKey);</span><br><span class="line">        <span class="keyword">return</span> darkFeature;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编程实现灰度规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.darklaunch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserPromotionDarkFeature</span> <span class="keyword">implements</span> <span class="title class_">IDarkFeature</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dark</span><span class="params">(<span class="type">long</span> darkTarget)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dark</span><span class="params">(String darkTarget)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addProgrammedDarkFeature</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userPromotionKey</span> <span class="operator">=</span> <span class="string">&quot;user_promotion&quot;</span>;</span><br><span class="line">    darkLaunch.addProgrammedDarkFeature(userPromotionKey, <span class="keyword">new</span> <span class="title class_">UserPromotionDarkFeature</span>());</span><br><span class="line">    <span class="type">IDarkFeature</span> <span class="variable">darkFeature</span> <span class="operator">=</span> darkLaunch.getDarkFeature(userPromotionKey);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">dark</span> <span class="operator">=</span> darkFeature.dark(<span class="number">893</span>);</span><br><span class="line">    assertThat(dark).isFalse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-访问者模式</title>
    <url>/2022/09/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="带你“发明”访问者模式"><a href="#带你“发明”访问者模式" class="headerlink" title="带你“发明”访问者模式"></a>带你“发明”访问者模式</h1><p>假设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到 txt 文件中。如果让你来实现，你会怎么来做呢？</p>
<p>实现这个功能并不难，不同的人有不同的写法，我将其中一种代码实现方式贴在这里。其中，ResourceFile 是一个抽象类，包含一个抽象函数 extract2txt()。PdfFile、PPTFile、WordFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。在 ToolApplication 中，我们可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> String filePath;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ResourceFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PPTFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PPTFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...省略一大坨从PPT中抽取文本的代码...</span></span><br><span class="line">    <span class="comment">//...将抽取出来的文本保存在跟filePath同名的.txt文件中...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract PPT.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PdfFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract PDF.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WordFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract WORD.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果是：</span></span><br><span class="line"><span class="comment">// Extract PDF.</span></span><br><span class="line"><span class="comment">// Extract WORD.</span></span><br><span class="line"><span class="comment">// Extract PPT.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.extract2txt();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title function_">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PdfFile</span>(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">WordFile</span>(<span class="string">&quot;b.word&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PPTFile</span>(<span class="string">&quot;c.ppt&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果工具的功能不停地扩展，不仅要能抽取文本内容，还要支持压缩、提取文件元信息（文件名、大小、更新时间等等）构建索引等一系列的功能，那如果我们继续按照上面的实现思路，就会存在这样几个问题：</p>
<ul>
<li>违背开闭原则，添加一个新的功能，所有类的代码都要修改；</li>
<li>虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；</li>
<li>把所有比较上层的业务逻辑都耦合到 PdfFile、PPTFile、WordFile 类中，导致这些类的职责不够单一，变成了大杂烩。</li>
</ul>
<p>针对上面的问题，我们常用的解决方法就是拆分解耦，把业务操作跟具体的数据结构解耦，设计成独立的类。这里我们按照访问者模式的演进思路来对上面的代码进行重构。重构之后的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> String filePath;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ResourceFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PdfFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(filePath);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...PPTFile、WordFile代码省略...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Extractor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">(PPTFile pptFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract PPT.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">(PdfFile pdfFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract PDF.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">(WordFile wordFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract WORD.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Extractor</span> <span class="variable">extractor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Extractor</span>();</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      extractor.extract2txt(resourceFile);<span class="comment">// 编译报错</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title function_">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PdfFile</span>(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">WordFile</span>(<span class="string">&quot;b.word&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PPTFile</span>(<span class="string">&quot;c.ppt&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中最关键的一点设计是，我们把抽取文本内容的操作，设计成了三个重载函数。函数重载是 Java、C++ 这类面向对象编程语言中常见的语法机制。所谓重载函数是指，在同一类中函数名相同、参数不同的一组函数。</p>
<p>不过，如果你足够细心，就会发现，上面的代码是编译通过不了的，第 37 行会报错。这是为什么呢？我们知道，多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法。</p>
<p>在上面代码的第 35～38 行中，resourceFiles 包含的对象的声明类型都是 ResourceFile，而我们并没有在 Extractor 类中定义参数类型是 ResourceFile 的 extract2txt() 重载函数，所以在编译阶段就通过不了，更别说在运行时根据对象的实际类型执行不同的重载函数了。那如何解决这个问题呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> String filePath;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ResourceFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Extractor extractor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PdfFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Extractor extractor)</span> &#123;</span><br><span class="line">    extractor.extract2txt(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span></span><br><span class="line"><span class="comment">//...Extractor代码不变...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Extractor</span> <span class="variable">extractor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Extractor</span>();</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(extractor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title function_">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PdfFile</span>(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">WordFile</span>(<span class="string">&quot;b.word&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PPTFile</span>(<span class="string">&quot;c.ppt&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行第 30 行的时候，根据多态特性，程序会调用实际类型的 accept 函数，比如 PdfFile 的 accept 函数，也就是第 16 行代码。而 16 行代码中的 this 类型是 PdfFile 的，在编译的时候就确定了，所以会调用 extractor 的 extract2txt(PdfFile pdfFile) 这个重载函数。这个实现思路是不是很有技巧？这是理解访问者模式的关键所在，也是我之前所说的访问者模式不好理解的原因。</p>
<p>现在，如果要继续添加新的功能，比如前面提到的压缩功能，根据不同的文件类型，使用不同的压缩算法来压缩资源文件，那我们该如何实现呢？我们需要实现一个类似 Extractor 类的新类 Compressor 类，在其中定义三个重载函数，实现对不同类型资源文件的压缩。除此之外，我们还要在每个资源文件类中定义新的 accept 重载函数。具体的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> String filePath;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ResourceFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Extractor extractor)</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Compressor compressor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PdfFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Extractor extractor)</span> &#123;</span><br><span class="line">    extractor.extract2txt(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Compressor compressor)</span> &#123;</span><br><span class="line">    compressor.compress(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span></span><br><span class="line"><span class="comment">//...Extractor代码不变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Extractor</span> <span class="variable">extractor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Extractor</span>();</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(extractor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Compressor</span> <span class="variable">compressor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Compressor</span>();</span><br><span class="line">    <span class="keyword">for</span>(ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(compressor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title function_">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PdfFile</span>(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">WordFile</span>(<span class="string">&quot;b.word&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PPTFile</span>(<span class="string">&quot;c.ppt&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭原则。针对这个问题，我们抽象出来一个 Visitor 接口，包含是三个命名非常通用的 visit() 重载函数，分别处理三种不同类型的资源文件。具体做什么业务处理，由实现这个 Visitor 接口的具体的类来决定，比如 Extractor 负责抽取文本内容，Compressor 负责压缩。当我们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改 ToolApplication 的代码就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> String filePath;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ResourceFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor vistor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PdfFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">    visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PdfFile pdfFile)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PPTFile pdfFile)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(WordFile pdfFile)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Extractor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PPTFile pptFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract PPT.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PdfFile pdfFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract PDF.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(WordFile wordFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Extract WORD.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Compressor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PPTFile pptFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Compress PPT.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PdfFile pdfFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Compress PDF.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(WordFile wordFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Compress WORD.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Extractor</span> <span class="variable">extractor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Extractor</span>();</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(extractor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Compressor</span> <span class="variable">compressor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Compressor</span>();</span><br><span class="line">    <span class="keyword">for</span>(ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      resourceFile.accept(compressor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title function_">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PdfFile</span>(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">WordFile</span>(<span class="string">&quot;b.word&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PPTFile</span>(<span class="string">&quot;c.ppt&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新来看访问者模式</p>
<p>访问者者模式的英文翻译是 Visitor Design Pattern。在 GoF 的《设计模式》一书中，它是这么定义的：</p>
<blockquote>
<p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.</p>
</blockquote>
<p>翻译成中文就是：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。定义比较简单，结合前面的例子不难理解，我就不过多解释了。对于访问者模式的代码实现，实际上，在上面例子中，经过层层重构之后的最终代码，就是标准的访问者模式的实现代码。</p>
<p><img src="/../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="访问者模式类图"></p>
<p>最后，我们再来看下，访问者模式的应用场景。</p>
<p>一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中。</p>
<h1 id="为什么支持双分派的语言不需要访问者模式？"><a href="#为什么支持双分派的语言不需要访问者模式？" class="headerlink" title="为什么支持双分派的语言不需要访问者模式？"></a>为什么支持双分派的语言不需要访问者模式？</h1><p>实际上，讲到访问者模式，大部分书籍或者资料都会讲到 Double Dispatch，中文翻译为双分派。</p>
<p>既然有 Double Dispatch，对应的就有 Single Dispatch。 </p>
<h2 id="Single-Dispatch"><a href="#Single-Dispatch" class="headerlink" title="Single Dispatch"></a>Single Dispatch</h2><p>指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。</p>
<h2 id="Double-Dispatch"><a href="#Double-Dispatch" class="headerlink" title="Double Dispatch"></a>Double Dispatch</h2><p>指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。</p>
<p><strong>如何理解“Dispatch”这个单词呢？</strong> 在面向对象编程语言中，我们可以把方法调用理解为一种消息传递，也就是“Dispatch”。一个对象调用另一个对象的方法，就相当于给它发送一条消息。这条消息起码要包含对象名、方法名、方法参数。</p>
<p><strong>如何理解“Single”“Double”这两个单词呢？</strong>“Single”“Double”指的是执行哪个对象的哪个方法，跟几个因素的运行时类型有关。我们进一步解释一下。Single Dispatch 之所以称为“Single”，是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch 之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。</p>
<p>具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch。</p>
<p>Java 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的运行时类型有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;I am ParentClass&#x27;s f().&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;I am ChildClass&#x27;s f().&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleDispatchClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">polymorphismFunction</span><span class="params">(ParentClass p)</span> &#123;</span><br><span class="line">    p.f();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">overloadFunction</span><span class="params">(ParentClass p)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;I am overloadFunction(ParentClass p).&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">overloadFunction</span><span class="params">(ChildClass c)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;I am overloadFunction(ChildClass c).&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoMain</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SingleDispatchClass</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleDispatchClass</span>();</span><br><span class="line">    <span class="type">ParentClass</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildClass</span>();</span><br><span class="line">    demo.polymorphismFunction(p);<span class="comment">//执行哪个对象的方法，由对象的实际类型决定</span></span><br><span class="line">    demo.overloadFunction(p);<span class="comment">//执行对象的哪个方法，由参数对象的声明类型决定</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码执行结果:</span></span><br><span class="line">I am ChildClass<span class="string">&#x27;s f().</span></span><br><span class="line"><span class="string">I am overloadFunction(ParentClass p).</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，第 31 行代码的 polymorphismFunction() 函数，执行 p 的实际类型的 f() 函数，也就是 ChildClass 的 f() 函数。第 32 行代码的 overloadFunction() 函数，匹配的是重载函数中的 overloadFunction(ParentClass p)，也就是根据 p 的声明类型来决定匹配哪个重载函数。</p>
<h1 id="除了访问者模式，上面的例子还有其他实现方案吗？"><a href="#除了访问者模式，上面的例子还有其他实现方案吗？" class="headerlink" title="除了访问者模式，上面的例子还有其他实现方案吗？"></a>除了访问者模式，上面的例子还有其他实现方案吗？</h1><p>我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们要开发一个工具来处理这批资源文件，这其中就包含抽取文本内容、压缩资源文件、提取文件元信息等。实际上，开发这个工具有很多种代码设计和实现思路。</p>
<p>实际上，我们还可以利用工厂模式来实现，定义一个包含 extract2txt() 接口函数的 Extractor 接口。PdfExtractor、PPTExtractor、WordExtractor 类实现 Extractor 接口，并且在各自的 extract2txt() 函数中，分别实现 Pdf、PPT、Word 格式文件的文本内容抽取。ExtractorFactory 工厂类根据不同的文件类型，返回不同的 Extractor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> String filePath;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ResourceFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> ResourceFileType <span class="title function_">getType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PdfFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(filePath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ResourceFileType <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ResourceFileType.PDF;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...PPTFile/WordFile跟PdfFile代码结构类似，此处省略...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Extractor</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">(ResourceFile resourceFile)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfExtractor</span> <span class="keyword">implements</span> <span class="title class_">Extractor</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extract2txt</span><span class="params">(ResourceFile resourceFile)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...PPTExtractor/WordExtractor跟PdfExtractor代码结构类似，此处省略...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtractorFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;ResourceFileType, Extractor&gt; extractors = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    extractors.put(ResourceFileType.PDF, <span class="keyword">new</span> <span class="title class_">PdfExtractor</span>());</span><br><span class="line">    extractors.put(ResourceFileType.PPT, <span class="keyword">new</span> <span class="title class_">PPTExtractor</span>());</span><br><span class="line">    extractors.put(ResourceFileType.WORD, <span class="keyword">new</span> <span class="title class_">WordExtractor</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Extractor <span class="title function_">getExtractor</span><span class="params">(ResourceFileType type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> extractors.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">      <span class="type">Extractor</span> <span class="variable">extractor</span> <span class="operator">=</span> ExtractorFactory.getExtractor(resourceFile.getType());</span><br><span class="line">      extractor.extract2txt(resourceFile);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title function_">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> &#123;</span><br><span class="line">    List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PdfFile</span>(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">WordFile</span>(<span class="string">&quot;b.word&quot;</span>));</span><br><span class="line">    resourceFiles.add(<span class="keyword">new</span> <span class="title class_">PPTFile</span>(<span class="string">&quot;c.ppt&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> resourceFiles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要添加新的功能的时候，比如压缩资源文件，类似抽取文本内容功能的代码实现，我们只需要添加一个 Compressor 接口，PdfCompressor、PPTCompressor、WordCompressor 三个实现类，以及创建它们的 CompressorFactory 工厂类即可。唯一需要修改的只有最上层的 ToolApplication 类。基本上符合“对扩展开放、对修改关闭”的设计原则。</p>
<p>对于资源文件处理工具这个例子，如果工具提供的功能并不是非常多，只有几个而已，那我更推荐使用工厂模式的实现方式，毕竟代码更加清晰、易懂。相反，如果工具提供非常多的功能，比如有十几个，那我更推荐使用访问者模式，因为访问者模式需要定义的类要比工厂模式的实现方式少很多，类太多也会影响到代码的可维护性。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-设计实现一个通用的接口幂等框架</title>
    <url>/2022/10/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h2><p>我们先来看下幂等框架的需求场景。</p>
<p>为了复用代码，我们把通用的功能设计成了公共服务平台。公司内部的其他金融产品的后台系统，会调用公共服务平台的服务，不需要完全从零开始开发。公共服务平台提供的是 RESTful 接口。为了简化开发，调用方一般使用 Feign 框架（一个 HTTP 框架）来访问公共服务平台的接口。</p>
<p>调用方访问公共服务平台的接口，会有三种可能的结果：成功、失败和超时。前两种结果非常明确，调用方可以自己决定收到结果之后如何处理。结果为“成功”，万事大吉。结果为“失败”，一般情况下，调用方会将失败的结果，反馈给用户（移动端 App），让用户自行决定是否重试。</p>
<p>但是，当接口请求超时时，处理起来就没那么容易了。有可能业务逻辑已经执行成功了，只是公共服务平台返回结果给调用方的时候超时了，但也有可能业务逻辑没有执行成功，比如，因为数据库当时存在集中写入，导致部分数据写入超时。总之，超时对应的执行结果是未决的。那调用方调用接口超时时（基于 Feign 框架开发的话，一般是收到 Timeout 异常），该如何处理呢？</p>
<span id="more"></span>

<p>如果接口只包含查询、删除、更新这些操作，那接口天然是幂等的。所以，超时之后，重新再执行一次，也没有任何副作用。不过，这里有两点需要特殊说明一下。</p>
<p>删除操作需要当心 ABA 问题。删除操作超时了，又触发一次删除，但在这次删除之前，又有一次新的插入。后一次删除操作删除了新插入的数据，而新插入的数据本不应该删除。不过，大部分业务都可以容忍 ABA 问题。对于少数不能容忍的业务场景，我们可以针对性的特殊处理。</p>
<p>除此之外，细究起来，update x &#x3D; x+delta 这样格式的更新操作并非幂等，只有 update x&#x3D;y 这样格式的更新操作才是幂等的。不过，后者也存在跟删除同样的 ABA 问题。</p>
<p>如果接口包含修改操作（插入操作、update x&#x3D;x+delta 更新操作），多次重复执行有可能会导致业务上的错误，这是不能接受的。如果插入的数据包含数据库唯一键，可以利用数据库唯一键的排他性，保证不会重复插入数据。除此之外，一般我会建议调用方按照这样几种方式来处理。</p>
<p>第一种处理方式是，调用方访问公共服务平台接口超时时，返回清晰明确的提醒给用户，告知执行结果未知，让用户自己判断是否重试。不过，你可能会说，如果用户看到了超时提醒，但还是重新发起了操作，比如重新发起了转账、充值等操作，那该怎么办呢？实际上，对这种情况，技术是无能为力的。因为两次操作都是用户主动发起的，我们无法判断第二次的转账、充值是新的操作，还是基于上一次超时的重试行为。</p>
<p>第二种处理方式是，调用方调用其他接口，来查询超时操作的结果，明确超时操作对应的业务，是执行成功了还是失败了，然后再基于明确的结果做处理。但是这种处理方法存在一个问题，那就是并不是所有的业务操作，都方便查询操作结果。</p>
<p>第三种处理方式是，调用方在遇到接口超时之后，直接发起重试操作。这样就需要接口支持幂等。我们可以选择在业务代码中触发重试，也可以将重试的操作放到 Feign 框架中完成。因为偶尔发生的超时，在正常的业务逻辑中编写一大坨补救代码，这样做会影响到代码的可读性，有点划不来。当然，如果项目中需要支持超时重试的业务不多，那对于仅有几个业务，特殊处理一下也未尝不可。但是，如果项目中需要支持超时重试的业务比较多，我们最好是把超时重试这些非业务相关的逻辑，统一在框架层面解决。</p>
<p>对响应时间敏感的调用方来说，它们服务的是移动端的用户，过长的等待时间，还不如直接返回超时给用户。所以，这种情况下，第一种处理方式是比较推荐的。但是，对响应时间不敏感的调用方来说，比如 Job 类的调用方，我推荐选择后两种处理方式，能够提高处理的成功率。而第二种处理方法，本身有一定的局限性，因为并不是所有业务操作都方便查询是否执行成功。第三种保证接口幂等的处理方式，是比较通用的解决方案。所以，我们针对这种处理方式，抽象出一套统一的幂等框架，简化幂等接口的开发。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>刚刚我们介绍了幂等框架的需求背景：超时重试需要接口幂等的支持。接下来，我们再对需求进行更加详细的分析和整理，这其中就包括功能性需求和非功能性需求。</p>
<p>不过，在此之前，我们需要先搞清楚一个重要的概念：幂等号。</p>
<p>前面多次提到“幂等”，那“幂等”到底是什么意思呢？放到接口调用的这个场景里，幂等的意思是，针对同一个接口，多次发起同一个业务请求，必须保证业务只执行一次。那如何判定两次接口请求是同一个业务请求呢？也就是说，如何判断两次接口请求是重试关系？而非独立的两个业务请求？比如，两次调用转账接口，尽管转账用户、金额等参数都一样，但我们也无法判断这两个转账请求就是重试关系。</p>
<p>实际上，要确定重试关系，我们就需要给同一业务请求一个唯一标识，也就是“幂等号”！如果两个接口请求，带有相同的幂等号，那我们就判断它们是重试关系，是同一个业务请求，不要重复执行。</p>
<p>幂等号需要保证全局唯一性。它可以有业务含义，比如，用户手机号码是唯一的，对于用户注册接口来说，我们可以拿它作为幂等号。不过，这样就会导致幂等框架的实现，无法完全脱离具体的业务。所以，我们更加倾向于，通过某种算法来随机生成没有业务含义的幂等号。<br>幂等号的概念搞清楚了，我们再来看下框架的功能性需求。</p>
<p>前面也介绍了一些需求分析整理方法，比如画线框图、写用户用例、基于测试驱动开发等。跟限流框架类似，这里我们也借助用户用例和测试驱动开发的思想，先去思考，如果框架最终被开发出来之后，它会如何被使用。我写了一个框架使用的 Demo 示例，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////// 使用方式一: 在业务代码中处理幂等 ////////////</span></span><br><span class="line"><span class="comment">// 接口调用方</span></span><br><span class="line"><span class="type">Idempotence</span> <span class="variable">idempotence</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Idempotence</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">idempotenceId</span> <span class="operator">=</span> idempotence.createId();</span><br><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> createOrderWithIdempotence(..., idempotenceId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现方</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Idempotence idempontence; <span class="comment">// 依赖注入</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Order <span class="title function_">createOrderWithIdempotence</span><span class="params">(..., String idempotenceId)</span> &#123;</span><br><span class="line">    <span class="comment">// 前置操作</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">existed</span> <span class="operator">=</span> idempotence.check(idempotenceId);</span><br><span class="line">    <span class="keyword">if</span> (existed) &#123;</span><br><span class="line">      <span class="comment">// 两种处理方式：</span></span><br><span class="line">      <span class="comment">// 1. 查询order，并且返回；</span></span><br><span class="line">      <span class="comment">// 2. 返回duplication operation Exception</span></span><br><span class="line">    &#125;</span><br><span class="line">    idempotence.record(idempotenceId);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//...执行正常业务逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Order <span class="title function_">createOrder</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////// 使用方式二：在框架层面处理幂等 //////////////</span></span><br><span class="line"><span class="comment">// 接口调用方</span></span><br><span class="line"><span class="type">Idempotence</span> <span class="variable">idempotence</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Idempotence</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">idempotenceId</span> <span class="operator">=</span> idempotence.createId();</span><br><span class="line"><span class="comment">//...通过feign框架将幂等号添加到http header中...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现方</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">  <span class="meta">@IdempotenceRequired</span></span><br><span class="line">  <span class="keyword">public</span> Order <span class="title function_">createOrder</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在AOP切面中处理幂等</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdempotenceSupportAdvice</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> Idempotence idempotence;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;@annotation(com.xzg.cd.idempotence.annotation.IdempotenceRequired)&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">controllerPointcut</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Around(value = &quot;controllerPointcut()&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 从HTTP header中获取幂等号idempotenceId</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前置操作</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">existed</span> <span class="operator">=</span> idempotence.check(idempotenceId);</span><br><span class="line">    <span class="keyword">if</span> (existed) &#123;</span><br><span class="line">      <span class="comment">// 两种处理方式：</span></span><br><span class="line">      <span class="comment">// 1. 查询order，并且返回；</span></span><br><span class="line">      <span class="comment">// 2. 返回duplication operation Exception</span></span><br><span class="line">    &#125;</span><br><span class="line">    idempotence.record(idempotenceId)</span><br><span class="line">    </span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合刚刚的 Demo，从使用的角度来说，幂等框架的主要处理流程是这样的。接口调用方生成幂等号，并且跟随接口请求，将幂等号传递给接口实现方。接口实现方接收到接口请求之后，按照约定，从 HTTP Header 或者接口参数中，解析出幂等号，然后通过幂等号查询幂等框架。如果幂等号已经存在，说明业务已经执行或正在执行，则直接返回；如果幂等号不存在，说明业务没有执行过，则记录幂等号，继续执行业务。</p>
<p><strong>对于幂等框架，我们再来看下，它都有哪些非功能性需求。</strong></p>
<p>在易用性方面，我们希望框架接入简单方便，学习成本低。只需编写简单的配置以及少许代码，就能完成接入。除此之外，框架最好对业务代码低侵入松耦合，在统一的地方（比如 Spring AOP 中）接入幂等框架，而不是将它耦合在业务代码中。</p>
<p>在性能方面，针对每个幂等接口，在正式处理业务逻辑之前，我们都要添加保证幂等的处理逻辑。这或多或少地会增加接口请求的响应时间。而对于响应时间比较敏感的接口服务来说，我们要让幂等框架尽可能低延迟，尽可能减少对接口请求本身响应时间的影响。</p>
<p>在容错性方面，跟限流框架相同，不能因为幂等框架本身的异常，导致接口响应异常，影响服务本身的可用性。所以，幂等框架要有高度的容错性。比如，存储幂等号的外部存储器挂掉了，幂等逻辑无法正常运行，这个时候业务接口也要能正常服务才行。</p>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="幂等处理正常流程"><a href="#幂等处理正常流程" class="headerlink" title="幂等处理正常流程"></a>幂等处理正常流程</h2><p>调用方从发起接口请求到接收到响应，一般要经过三个阶段。第一个阶段是调用方发送请求并被实现方接收，第二个阶段是执行接口对应的业务逻辑，第三个阶段是将执行结果返回给调用方。为了实现接口幂等，我们需要将幂等相关的逻辑，添加在这三个阶段中。</p>
<p>正常情况下，幂等号随着请求传递到接口实现方之后，接口实现方将幂等号解析出来，传递给幂等框架。幂等框架先去数据库（比如 Redis）中查找这个幂等号是否已经存在。如果存在，说明业务逻辑已经或者正在执行，就不要重复执行了。如果幂等号不存在，就将幂等号存储在数据库中，然后再执行相应的业务逻辑。</p>
<p>正常情况下，幂等处理流程是非常简单的，难点在于如何应对异常情况。在这三个阶段中，如果第一个阶段出现异常，比如发送请求失败或者超时，幂等号还没有记录下来，重试请求会被执行，符合我们的预期。如果第三个阶段出现异常，业务逻辑执行完成了，只是在发送结果给调用方的时候，失败或者超时了，这个时候，幂等号已经记录下来，重试请求不会被执行，也符合我们的预期。也就是说，第一、第三阶段出现异常，上述的幂等处理逻辑都可以正确应对。</p>
<p>但是，如果第二个阶段业务执行的过程出现异常，处理起来就复杂多了。接下来，我们就看下幂等框架该如何应对这一阶段的各种异常。我分了三类异常来讲解，它们分别是业务代码异常、业务系统宕机、幂等框架异常。</p>
<h2 id="业务代码异常处理"><a href="#业务代码异常处理" class="headerlink" title="业务代码异常处理"></a>业务代码异常处理</h2><p>当业务代码在执行过程中抛出异常的时候，我们是否应该认定为业务处理失败，然后将已经记录的幂等号删除，允许重新执行业务逻辑呢？</p>
<p>对于这个问题，我们要分业务异常和系统异常来区分对待。那什么是业务异常？什么是系统异常呢？我举个例子解释一下。比如，A 用户发送消息给 B 用户，但是查询 B 用户不存在，抛出 UserNotExisting 异常，我们把这种业务上不符合预期叫做业务异常。因为数据库挂掉了，业务代码访问数据库时，就会报告数据库异常，我们把这种非业务层面的、系统级的异常，叫做系统异常。</p>
<p>遇到业务异常（比如 UserNotExisting 异常），我们不删除已经记录的幂等号，不允许重新执行同样的业务逻辑，因为再次重新执行也是徒劳的，还是会报告异常。相反，遇到系统异常（比如数据库访问异常），我们将已经记录的幂等号删除，允许重新执行这段业务逻辑。因为在系统级问题修复之后（比如数据库恢复了），重新执行之前失败的业务逻辑，就有可能会成功。</p>
<p>实际上，为了让幂等框架尽可能的灵活，低侵入业务逻辑，发生异常（不管是业务异常还是系统异常），是否允许再重试执行业务逻辑，交给开发这块业务的工程师来决定是最合适的了，毕竟他最清楚针对每个异常该如何处理。而幂等框架本身不参与这个决定，它只需要提供删除幂等号的接口，由业务工程师来决定遇到异常的时候，是否需要调用这个删除接口，删除已经记录的幂等号。</p>
<h2 id="业务系统宕机处理"><a href="#业务系统宕机处理" class="headerlink" title="业务系统宕机处理"></a>业务系统宕机处理</h2><p>刚刚分析的是代码异常，我们再来看下，如果在业务处理的过程中，业务系统宕机了（你可以简单理解为部署了业务系统的机器宕机了），幂等框架是否还能正确工作呢？</p>
<p>如果幂等号已经记录下了，但是因为机器宕机，业务还没来得及执行，按照刚刚的幂等框架的处理流程，即便机器重启，业务也不会再被触发执行了，这个时候该怎么办呢？除此之外，如果记录幂等号成功了，但是在捕获到系统异常之后，要删除幂等号之前，机器宕机了，这个时候又该怎么办？</p>
<p>如果希望幂等号的记录和业务的执行完全一致，我们就要把它们放到一个事务中。执行成功，必然会记录幂等号；执行失败，幂等号记录也会被自动回滚。因为幂等框架和业务系统各自使用独立的数据库来记录数据，所以，这里涉及的事务属于分布式事务。如果为了解决这个问题，引入分布式事务，那幂等框架的开发难度提高了很多，并且框架使用起来也复杂了很多，性能也会有所损失。</p>
<p>针对这个问题，我们还有另外一种解决方案。那就是，在存储业务数据的业务数据库（ 比如 MySQL）中，建一张表来记录幂等号。幂等号先存储到业务数据库中，然后再同步给幂等框架的 Redis 数据库。这样做的好处是，我们不需要引入分布式事务框架，直接利用业务数据库本身的事务属性，保证业务数据和幂等号的写入操作，要么都成功，要么都失败。不过，这个解决方案会导致幂等逻辑，跟业务逻辑没有完全解耦，不符合我们之前讲到的低侵入、松耦合的设计思想。</p>
<p>实际上，做工程不是做理论。对于这种极少发生的异常，在工程中，我们能够做到，在出错时能及时发现问题、能够根据记录的信息人工修复就可以了。虽然看起来解决方案不优雅，不够智能，不够自动化，但是，这比编写一大坨复杂的代码逻辑来解决，要好使得多。所以，我们建议业务系统记录 SQL 的执行日志，在日志中附加上幂等号。这样我们就能在机器宕机时，根据日志来判断业务执行情况和幂等号的记录是否一致。</p>
<h2 id="幂等框架异常处理"><a href="#幂等框架异常处理" class="headerlink" title="幂等框架异常处理"></a>幂等框架异常处理</h2><p>我们前面提到，限流框架本身的异常，不能导致接口响应异常。那对于幂等框架来说，是否也适用这条设计原则呢？</p>
<p>对于限流来说，限流框架执行异常（比如，Redis 访问超时或者访问失败），我们可以触发服务降级，让限流功能暂时不起作用，接口还能正常执行。如果大量的限流接口调用异常，在具有完善监控的情况下，这些异常很快就会被运维发现并且修复，所以，短暂的限流失效，也不会对业务系统产生太多影响。毕竟限流只是一个针对突发情况的保护机制，平时并不起作用。如果偶尔的极个别的限流接口调用异常，本不应该被放过的几个接口请求，因为限流的暂时失效被放过了，对于这种情况，绝大部分业务场景都是可以接受的。毕竟限流不可能做到非常精确，多放过一两个接口请求几乎没影响。</p>
<p>对于幂等来说，尽管它应对的也是超时重试等特殊场景，但是，如果本不应该重新执行的业务逻辑，因为幂等功能的暂时失效，被重复执行了，就会导致业务出错（比如，多次执行转账，钱多转了）。对于这种情况，绝大部分业务场景都是无法接受的。所以，在幂等逻辑执行异常时，我们选择让接口请求也失败，相应的业务逻辑就不会被重复执行了。毕竟接口请求失败（比如转钱没转成功），比业务执行出错（比如多转了钱），修复的成本要低很多。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="V1-版本功能需求"><a href="#V1-版本功能需求" class="headerlink" title="V1 版本功能需求"></a>V1 版本功能需求</h2><p>最终得到的幂等框架的设计思路是很简单的，主要包含下面这样两个主要的功能开发点：</p>
<ul>
<li>实现生成幂等号的功能；</li>
<li>实现存储、查询、删除幂等号的功能。</li>
</ul>
<p>在 V1 版本中，我们会实现上面罗列的所有功能。针对这两个功能点，我们先来说下实现思路。</p>
<h3 id="实现生成幂等号的功能"><a href="#实现生成幂等号的功能" class="headerlink" title="实现生成幂等号的功能"></a>实现生成幂等号的功能</h3><p>幂等号用来标识两个接口请求是否是同一个业务请求，换句话说，两个接口请求是否是重试关系，而非独立的两个请求。接口调用方需要在发送接口请求的同时，将幂等号一块传递给接口实现方。那如何来生成幂等号呢？一般有两种生成方式。一种方式是集中生成并且分派给调用方，另一种方式是直接由调用方生成。</p>
<p>对于第一种生成方式，我们需要部署一套幂等号的生成系统，并且提供相应的远程接口（Restful 或者 RPC 接口），调用方通过调用远程接口来获取幂等号。这样做的好处是，对调用方完全隐藏了幂等号的实现细节。当我们需要改动幂等号的生成算法时，调用方不需要改动任何代码。</p>
<p>对于第二种生成方式，调用方按照跟接口实现方预先商量好的算法，自己来生成幂等号。这种实现方式的好处在于，不用像第一种方式那样调用远程接口，所以执行效率更高。但是，一旦需要修改幂等号的生成算法，就需要修改每个调用方的代码。</p>
<p>并且，每个调用方自己实现幂等号的生成算法也会有问题。一方面，重复开发，违反 DRY 原则。另一方面，工程师的开发水平层次不齐，代码难免会有 bug。除此之外，对于复杂的幂等号生成算法，比如依赖外部系统 Redis 等，显然更加适合上一种实现方式，可以避免调用方为了使用幂等号引入新的外部系统。</p>
<p>权衡来讲，既考虑到生成幂等号的效率，又考虑到代码维护的成本，我们选择第二种实现方式，并且在此基础上做些改进，由幂等框架来统一提供幂等号生成算法的代码实现，并封装成开发类库，提供给各个调用方复用。除此之外，我们希望生成幂等号的算法尽可能的简单，不依赖其他外部系统。</p>
<p>实际上，对于幂等号的唯一要求就是全局唯一。全局唯一 ID 的生成算法有很多。比如，简单点的有取 UUID，复杂点的可以把应用名拼接在 UUID 上，方便做问题排查。总体上来讲，幂等号的生成算法并不难。</p>
<h3 id="实现存储、查询、删除幂等号的功能"><a href="#实现存储、查询、删除幂等号的功能" class="headerlink" title="实现存储、查询、删除幂等号的功能"></a>实现存储、查询、删除幂等号的功能</h3><p>从现在的需求来看，幂等号只是为了判重。在数据库中，我们只需要存储一个幂等号就可以，不需要太复杂的存储结构，所以，我们不选择使用复杂的关系型数据库，而是选择使用更加简单的、读写更加快速的键值数据库，比如 Redis。</p>
<p>在幂等判重逻辑中，我们需要先检查幂等号是否存在。如果没有存在，再将幂等号存储进 Redis。多个线程（同一个业务实例的多个线程）或者多进程（多个业务实例）同时执行刚刚的“检查 - 设置”逻辑时，就会存在竞争关系（竞态，race condition）。比如，A 线程检查幂等号不存在，在 A 线程将幂等号存储进 Redis 之前，B 线程也检查幂等号不存在，这样就会导致业务被重复执行。为了避免这种情况发生，我们要给“检查 - 设置”操作加锁，让同一时间只有一个线程能执行。除此之外，为了避免多进程之间的竞争，普通的线程锁还不起作用，我们需要分布式锁。</p>
<p>引入分布式锁会增加开发的难度和复杂度，而 Redis 本身就提供了把“检查 - 设置”操作作为原子操作执行的命令：setnx(key, value)。它先检查 key 是否存在，如果存在，则返回结果 0；如果不存在，则将 key 值存下来，并将值设置为 value，返回结果 1。因为 Redis 本身是单线程执行命令的，所以不存在刚刚讲到的并发问题。</p>
<h2 id="最小原型代码实现"><a href="#最小原型代码实现" class="headerlink" title="最小原型代码实现"></a>最小原型代码实现</h2><p>V1 版本要实现的功能和实现思路，现在已经很明确了。现在，我们来看下具体的代码实现。还是跟限流框架同样的实现方法，我们先不考虑设计和代码质量，怎么简单怎么来，先写出 MVP 代码，然后基于这个最简陋的版本做优化重构。</p>
<p>V1 版本的功能非常简单，我们用一个类就能搞定，代码如下所示。只用了不到 30 行代码，就搞定了一个框架，是不是觉得有点不可思议。对于这段代码，你可以先思考下，有哪些值得优化的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.idempotence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.pool2.impl.GenericObjectPoolConfig;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.HostAndPort;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisCluster;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Idempotence</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Idempotence</span><span class="params">(String redisClusterAddress, GenericObjectPoolConfig config)</span> &#123;</span><br><span class="line">        String[] addressArray = redisClusterAddress.split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">        Set&lt;HostAndPort&gt; redisNodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String address : addressArray) &#123;</span><br><span class="line">            String[] hostAndPort = address.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            redisNodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(hostAndPort[<span class="number">0</span>], Integer.valueOf(hostAndPort[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.jedisCluster = <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(redisNodes, config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">genId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveIfAbsent</span><span class="params">(String idempotenceId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">success</span> <span class="operator">=</span> jedisCluster.setnx(idempotenceId, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> success == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String idempotenceId)</span> &#123;</span><br><span class="line">        jedisCluster.del(idempotenceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Review-最小原型代码"><a href="#Review-最小原型代码" class="headerlink" title="Review 最小原型代码"></a>Review 最小原型代码</h2><p>尽管 MVP 代码很少，但仔细推敲，也有很多值得优化的地方。现在，我们就站在 Code Reviewer 的角度，分析一下这段代码。我把我的所有意见都放到代码注释中了，你可以对照着代码一块看下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Idempotence</span> &#123;</span><br><span class="line">    <span class="comment">// comment-1: 如果要替换存储方式，是不是很麻烦呢？</span></span><br><span class="line">    <span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// comment-2: 如果幂等框架要跟业务系统复用jedisCluster连接呢？</span></span><br><span class="line">    <span class="comment">// comment-3: 是不是应该注释说明一下redisClusterAddress的格式，以及config是否可以传递进null呢？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Idempotence</span><span class="params">(String redisClusterAddress, GenericObjectPoolConfig config)</span> &#123;</span><br><span class="line">        <span class="comment">// comment-4: 这段逻辑放到构造函数里，不容易写单元测试呢</span></span><br><span class="line">        String[] addressArray= redisClusterAddress.split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">        Set&lt;HostAndPort&gt; redisNodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String address : addressArray) &#123;</span><br><span class="line">            String[] hostAndPort = address.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            redisNodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(hostAndPort[<span class="number">0</span>], Integer.valueOf(hostAndPort[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.jedisCluster = <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(redisNodes, config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// comment-5: generateId()是不是比缩写要好点？</span></span><br><span class="line">    <span class="comment">// comment-6: 根据接口隔离原则，这个函数跟其他函数的使用场景完全不同，这个函数主要用在调用方，其他函数用在实现方，是不是应该分别放到两个类中？</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">genId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// comment-7: 返回值的意义是不是应该注释说明一下？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveIfAbsent</span><span class="params">(String idempotenceId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">success</span> <span class="operator">=</span> jedisCluster.setnx(idempotenceId, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> success == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String idempotenceId)</span> &#123;</span><br><span class="line">        jedisCluster.del(idempotenceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，MVP 代码主要涉及下面这样几个问题。</p>
<ul>
<li>代码可读性问题：有些函数的参数和返回值的格式和意义不够明确，需要注释补充解释一下。genId() 函数使用了缩写，全拼 generateId() 可能更好些！</li>
<li>代码可扩展性问题：按照现在的代码实现方式，如果改变幂等号的存储方式和生成算法，代码修改起来会比较麻烦。除此之外，基于接口隔离原则，我们应该将 genId() 函数跟其他函数分离开来，放到两个类中。独立变化，隔离修改，更容易扩展！</li>
<li>代码可测试性问题：解析 Redis Cluster 地址的代码逻辑较复杂，但因为放到了构造函数中，无法对它编写单元测试。</li>
<li>代码灵活性问题：业务系统有可能希望幂等框架复用已经建立好的 jedisCluster，而不是单独给幂等框架创建一个 jedisCluster。</li>
</ul>
<h2 id="重构最小原型代码"><a href="#重构最小原型代码" class="headerlink" title="重构最小原型代码"></a>重构最小原型代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 代码目录结构</span><br><span class="line">com.xzg.cd.idempotence</span><br><span class="line"> --Idempotence</span><br><span class="line"> --IdempotenceIdGenerator(幂等号生成类)</span><br><span class="line"> --IdempotenceStorage(接口：用来读写幂等号)</span><br><span class="line"> --RedisClusterIdempotenceStorage(IdempotenceStorage的实现类)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.idempotence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.monochrome.idempotence.storage.IdempotenceStorage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Idempotence</span> &#123;</span><br><span class="line"></span><br><span class="line">    IdempotenceStorage idempotenceStorage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Idempotence</span><span class="params">(IdempotenceStorage idempotenceStorage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.idempotenceStorage = idempotenceStorage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveIfAbsent</span><span class="params">(String idempotenceId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> idempotenceStorage.saveIfAbsent(idempotenceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String idempotenceId)</span> &#123;</span><br><span class="line">        idempotenceStorage.delete(idempotenceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.idempotence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdempotenceIdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.idempotence.storage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IdempotenceStorage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">saveIfAbsent</span><span class="params">(String idempotenceId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String idempotenceId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.idempotence.storage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.pool2.impl.GenericObjectPoolConfig;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.HostAndPort;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisCluster;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdempotenceStorage</span> <span class="keyword">implements</span> <span class="title class_">IdempotenceStorage</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisClusterAddress the format is 128.91.12.1:3455;128.91.12.2:3452;289.13.2.12:8978</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config should not be null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdempotenceStorage</span><span class="params">(String redisClusterAddress, GenericObjectPoolConfig config)</span> &#123;</span><br><span class="line">        Set&lt;HostAndPort&gt; redisNodes = parseHostAndPorts(redisClusterAddress);</span><br><span class="line">        <span class="built_in">this</span>.jedisCluster = <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(redisNodes, config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;HostAndPort&gt; <span class="title function_">parseHostAndPorts</span><span class="params">(String redisClusterAddress)</span> &#123;</span><br><span class="line">        String[] addressArray= redisClusterAddress.split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">        Set&lt;HostAndPort&gt; redisNodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String address : addressArray) &#123;</span><br><span class="line">            String[] hostAndPort = address.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            redisNodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(hostAndPort[<span class="number">0</span>], Integer.valueOf(hostAndPort[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisNodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Save &#123; <span class="doctag">@idempotenceId</span> &#125; into storage if it does not exist.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idempotenceId 幂等ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the &#123; <span class="doctag">@idempotenceId</span> &#125; is saved, otherwise return false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveIfAbsent</span><span class="params">(String idempotenceId)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> jedisCluster.setnx(idempotenceId, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> == result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String idempotenceId)</span> &#123;</span><br><span class="line">        jedisCluster.del(idempotenceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我再总结罗列一下，针对之前发现的问题，我们都做了哪些代码改动。主要有下面这样几点，你可以结合着代码一块看下。</p>
<p>在代码可读性方面，我们对构造函数、saveIfAbsense() 函数的参数和返回值做了注释，并且将 genId() 函数改为全拼 generateId()。不过，对于这个函数来说，缩写实际上问题也不大。</p>
<p>在代码可扩展性方面，我们按照基于接口而非实现的编程原则，将幂等号的读写独立出来，设计成 IdempotenceStorage 接口和RedisClusterIdempotenceStorage 实现类。RedisClusterIdempotenceStorage 实现了基于 Redis Cluster 的幂等号读写。如果我们需要替换新的幂等号读写方式，比如基于单个 Redis 而非 Redis Cluster，我们就可以再定义一个实现了 IdempotenceStorage 接口的实现类：RedisIdempotenceStorage。</p>
<p>除此之外，按照接口隔离原则，我们将生成幂等号的代码抽离出来，放到 IdempotenceIdGenerator 类中。这样，调用方只需要依赖这个类的代码就可以了。幂等号生成算法的修改，跟幂等号存储逻辑的修改，两者完全独立，一个修改不会影响另外一个。</p>
<p>在代码可测试性方面，我们把原本放在构造函数中的逻辑抽离出来，放到了 parseHostAndPorts() 函数中。这个函数本应该是 Private 访问权限的，但为了方便编写单元测试，我们把它设置为成了 Protected 访问权限，并且通过注解 @VisibleForTesting 做了标明。</p>
<p>在代码灵活性方面，为了方便复用业务系统已经建立好的 jedisCluster，我们提供了一个新的构造函数，支持业务系统直接传递 jedisCluster 来创建 Idempotence 对象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-门面模式</title>
    <url>/2022/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>门面模式，也叫外观模式，英文全称是 Facade Design Pattern。在 GoF 的《设计模式》一书中，门面模式是这样定义的：</p>
<blockquote>
<p>Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.</p>
</blockquote>
<p>翻译成中文就是：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p>
<p>假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用。</p>
<span id="more"></span>

<p>我们知道，类、模块、系统之间的“通信”，一般都是通过接口调用来完成的。接口设计的好坏，直接影响到类、模块、系统是否好用。所以，我们要多花点心思在接口设计上。我经常说，完成接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不到哪里去。</p>
<p>接口粒度设计得太大，太小都不好。太大会导致接口不可复用，太小会导致接口不易用。在实际的开发中，接口的可复用性和易用性需要“微妙”的权衡。针对这个问题，我的一个基本的处理原则是，尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。</p>
<p>门面模式除了解决接口易用性问题之外，还可以用它来解决性能问题和分布式事务问题。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-适配器模式</title>
    <url>/2022/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="适配器模式的原理与实现"><a href="#适配器模式的原理与实现" class="headerlink" title="适配器模式的原理与实现"></a>适配器模式的原理与实现</h1><p>适配器模式的英文翻译是 Adapter Design Pattern。顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p>
<span id="more"></span>

<p>适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p>
<p>具体的代码实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 类适配器: 基于继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fb</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptor</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.fa();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...重新实现f2()...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象适配器：基于组合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fb</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptor</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Adaptor</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">    adaptee.fa(); <span class="comment">//委托给Adaptee</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...重新实现f2()...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123;</span><br><span class="line">    adaptee.fc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对这两种实现方式，在实际的开发中，到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度。</p>
<ul>
<li>如果 Adaptee 接口并不多，那两种实现方式都可以。</li>
<li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</li>
<li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</li>
</ul>
<h1 id="适配器模式应用场景总结"><a href="#适配器模式应用场景总结" class="headerlink" title="适配器模式应用场景总结"></a>适配器模式应用场景总结</h1><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>
<h2 id="封装有缺陷的接口设计"><a href="#封装有缺陷的接口设计" class="headerlink" title="封装有缺陷的接口设计"></a>封装有缺陷的接口设计</h2><p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CD</span> &#123; <span class="comment">//这个类来自外部sdk，我们无权修改它的代码</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticFunction1</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uglyNamingFunction2</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tooManyParamsFunction3</span><span class="params">(<span class="type">int</span> paramA, <span class="type">int</span> paramB, ...)</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lowPerformanceFunction4</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配器模式进行重构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">function1</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">function2</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fucntion3</span><span class="params">(ParamsWrapperDefinition paramsWrapper)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">function4</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：适配器类的命名不一定非得末尾带Adaptor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDAdaptor</span> <span class="keyword">extends</span> <span class="title class_">CD</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function1</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>.staticFunction1();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.uglyNamingFucntion2();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function3</span><span class="params">(ParamsWrapperDefinition paramsWrapper)</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...reimplement it...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统一多个类的接口设计"><a href="#统一多个类的接口设计" class="headerlink" title="统一多个类的接口设计"></a>统一多个类的接口设计</h2><p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。</p>
<p>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASensitiveWordsFilter</span> &#123; <span class="comment">// A敏感词过滤系统提供的接口</span></span><br><span class="line">  <span class="comment">//text是原始文本，函数输出用***替换敏感词之后的文本</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterSexyWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterPoliticalWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSensitiveWordsFilter</span>  &#123; <span class="comment">// B敏感词过滤系统提供的接口</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CSensitiveWordsFilter</span> &#123; <span class="comment">// C敏感词过滤系统提供的接口</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text, String mask)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiskManagement</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">ASensitiveWordsFilter</span> <span class="variable">aFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ASensitiveWordsFilter</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">BSensitiveWordsFilter</span> <span class="variable">bFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSensitiveWordsFilter</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">CSensitiveWordsFilter</span> <span class="variable">cFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CSensitiveWordsFilter</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterSensitiveWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maskedText</span> <span class="operator">=</span> aFilter.filterSexyWords(text);</span><br><span class="line">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">    maskedText = bFilter.filter(maskedText);</span><br><span class="line">    maskedText = cFilter.filter(maskedText, <span class="string">&quot;***&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配器模式进行改造</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISensitiveWordsFilter</span> &#123; <span class="comment">// 统一接口定义</span></span><br><span class="line">  String <span class="title function_">filter</span><span class="params">(String text)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASensitiveWordsFilterAdaptor</span> <span class="keyword">implements</span> <span class="title class_">ISensitiveWordsFilter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ASensitiveWordsFilter aFilter;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maskedText</span> <span class="operator">=</span> aFilter.filterSexyWords(text);</span><br><span class="line">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">    <span class="keyword">return</span> maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span></span><br><span class="line"><span class="comment">// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiskManagement</span> &#123; </span><br><span class="line">  <span class="keyword">private</span> List&lt;ISensitiveWordsFilter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSensitiveWordsFilter</span><span class="params">(ISensitiveWordsFilter filter)</span> &#123;</span><br><span class="line">    filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">filterSensitiveWords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maskedText</span> <span class="operator">=</span> text;</span><br><span class="line">    <span class="keyword">for</span> (ISensitiveWordsFilter filter : filters) &#123;</span><br><span class="line">      maskedText = filter.filter(maskedText);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maskedText;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="替换依赖的外部系统"><a href="#替换依赖的外部系统" class="headerlink" title="替换依赖的外部系统"></a>替换依赖的外部系统</h2><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 外部系统A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在我们的项目中，外部系统A的使用示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> IA a;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">(IA a)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将外部系统A替换成外部系统B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BAdaptor</span> implemnts IA &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BAdaptor</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b= b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    b.fb();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span></span><br><span class="line"><span class="comment">// 只需要将BAdaptor如下注入到Demo即可。</span></span><br><span class="line"><span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(<span class="keyword">new</span> <span class="title class_">BAdaptor</span>(<span class="keyword">new</span> <span class="title class_">B</span>()));</span><br></pre></td></tr></table></figure>

<h2 id="兼容老版本接口"><a href="#兼容老版本接口" class="headerlink" title="兼容老版本接口"></a>兼容老版本接口</h2><p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。</p>
<p>JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。为了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使用 Iterator 才行。</p>
<p>单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。但是，使用 Java 开发的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor。代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Emueration <span class="title function_">emumeration</span><span class="params">(<span class="keyword">final</span> Collection c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Enumeration</span>() &#123;</span><br><span class="line">      <span class="type">Iterator</span> <span class="variable">i</span> <span class="operator">=</span> c.iterator();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasMoreElments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i.hashNext();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> Object <span class="title function_">nextElement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i.next():</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="适配不同格式的数据"><a href="#适配不同格式的数据" class="headerlink" title="适配不同格式的数据"></a>适配不同格式的数据</h2><p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">&quot;Larry&quot;</span>, <span class="string">&quot;Moe&quot;</span>, <span class="string">&quot;Curly&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="剖析适配器模式在-Java-日志中的应用"><a href="#剖析适配器模式在-Java-日志中的应用" class="headerlink" title="剖析适配器模式在 Java 日志中的应用"></a>剖析适配器模式在 Java 日志中的应用</h1><p>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。</p>
<p>大部分日志框架都提供了相似的功能，比如按照不同级别（debug、info、warn、erro……）打印日志等，但它们却并没有实现统一的接口。这主要可能是历史的原因，它不像 JDBC 那样，一开始就制定了数据库操作的接口规范。<br>如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选一个就好。但是，如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。</p>
<p>比如，项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是 logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式。所以，我们要针对每种日志框架编写不同的配置文件（比如，日志存储的文件地址、打印日志的格式）。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。所以，为了解决这个问题，我们需要统一日志打印框架。<br>如果你是做 Java 开发的，那 Slf4j 这个日志框架你肯定不陌生，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）来使用。</p>
<p>不仅如此，Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范。Slf4j 也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。具体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// slf4j统一的接口定义</span></span><br><span class="line"><span class="keyword">package</span> org.slf4j;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTraceEnabled</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">(String msg)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">(String format, Object arg)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">(String format, Object arg1, Object arg2)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">(String format, Object[] argArray)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">(String msg, Throwable t)</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDebugEnabled</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String format, Object arg)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String format, Object arg1, Object arg2)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String format, Object[] argArray)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg, Throwable t)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...省略info、warn、error等一堆接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// log4j日志框架的适配器</span></span><br><span class="line"><span class="comment">// Log4jLoggerAdapter实现了LocationAwareLogger接口，</span></span><br><span class="line"><span class="comment">// 其中LocationAwareLogger继承自Logger接口，</span></span><br><span class="line"><span class="comment">// 也就相当于Log4jLoggerAdapter实现了Logger接口。</span></span><br><span class="line"><span class="keyword">package</span> org.slf4j.impl;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Log4jLoggerAdapter</span> <span class="keyword">extends</span> <span class="title class_">MarkerIgnoringBase</span></span><br><span class="line">  <span class="keyword">implements</span> <span class="title class_">LocationAwareLogger</span>, Serializable &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">transient</span> org.apache.log4j.Logger logger; <span class="comment">// log4j</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDebugEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> logger.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    logger.log(FQCN, Level.DEBUG, msg, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String format, Object arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="type">FormattingTuple</span> <span class="variable">ft</span> <span class="operator">=</span> MessageFormatter.format(format, arg);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String format, Object arg1, Object arg2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="type">FormattingTuple</span> <span class="variable">ft</span> <span class="operator">=</span> MessageFormatter.format(format, arg1, arg2);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String format, Object[] argArray)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="type">FormattingTuple</span> <span class="variable">ft</span> <span class="operator">=</span> MessageFormatter.arrayFormat(format, argArray);</span><br><span class="line">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg, Throwable t)</span> &#123;</span><br><span class="line">    logger.log(FQCN, Level.DEBUG, msg, t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略一堆接口的实现...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用 Slf4j 提供的接口来编写打印日志的代码，具体使用哪种日志框架实现（log4j、logback……），是可以动态地指定的（使用 Java 的 SPI 技术，使用 META-INF&#x2F;Services 写上同名文件），只需要将相应的 SDK 导入到项目中即可。</p>
<p>不过，你可能会说，如果一些老的项目没有使用 Slf4j，而是直接使用比如 JCL 来打印日志，那如果想要替换成其他日志框架，比如 log4j，该怎么办呢？实际上，Slf4j 不仅仅提供了从其他日志框架到 Slf4j 的适配器，还提供了反向适配器，也就是从 Slf4j 到其他日志框架的适配。我们可以先将 JCL 切换为 Slf4j，然后再将 Slf4j 切换为 log4j。经过两次适配器的转换，我们就能成功将 JCL 切换为了 log4j。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-设计实现一个支持各种算法的限流框架</title>
    <url>/2022/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84%E9%99%90%E6%B5%81%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>公司成立初期，团队人少。公司集中精力开发一个金融理财产品（我们把这个项目叫做 X 项目）。整个项目只做了简单的前后端分离，后端的所有代码都在一个 GitHub 仓库中，整个后端作为一个应用来部署，没有划分微服务。</p>
<p>遇到了行业风口，公司发展得不错，公司开始招更多人，开发更多的金融产品，比如专注房贷的理财产品、专注供应链的产品、专注消费贷的借款端产品等等。在产品形态上，每个金融产品都做成了独立的 App。</p>
<p>对于不同的金融产品，尽管移动端长得不一样，但是后端的很多功能、代码都是可以复用的。为了快速上线，针对每个应用，公司都成立一个新的团队，然后拷贝 X 项目的代码，在此基础之上修改、添加新的功能。</p>
<p>这样成立新团队，拷贝老代码，改改就能上线一个新产品的开发模式，在一开始很受欢迎。产品上线快，也给公司赢得了竞争上的优势。但时间一长，这样的开发模式暴露出来的问题就越来越多了。而且随着公司的发展，公司也过了急速扩张期，人招得太多，公司开始考虑研发效率问题了。</p>
<p>因为所有的项目的代码都是从 X 项目拷贝来的，多个团队同时维护相似的代码，显然是重复劳动，协作起来也非常麻烦。任何团队发现代码的 bug，都要同步到其他团队做相同的修改。而且，各个团队对代码独立迭代，改得面目全非，即便要添加一个通用的功能，每个团队也都要基于自己的代码再重复开发。</p>
<p>除此之外，公司成立初期，各个方面条件有限，只能招到开发水平一般的员工，而且追求快速上线，所以，X 项目的代码质量很差，结构混乱、命名不规范、到处是临时解决方案、埋了很多坑，在烂代码之上不停地堆砌烂代码，时间长了，代码的可读性越来越差、维护成本越来越高，甚至高过了重新开发的成本。</p>
<span id="more"></span>

<p>我们可以把公共的功能、代码抽离出来，形成一个独立的项目，部署成一个公共服务平台。所有金融产品的后端还是参照 MVC 三层架构独立开发，不过，它们只实现自己特有的功能，对于一些公共的功能，通过远程调用公共服务平台提供的接口来实现。</p>
<p>这里提到的公共服务平台，有点类似现在比较火的“中台”或“微服务”。不过，为了减少部署、维护多个微服务的成本，我们把所有公共的功能，放到一个项目中开发，放到一个应用中部署。只不过，我们要未雨绸缪，事先按照领域模型，将代码的模块化做好，等到真的有哪个模块的接口调用过于集中，性能出现瓶颈的时候，我们再把它拆分出来，设计成独立的微服务来开发和部署。</p>
<p>经过这样的拆分之后，我们可以指派一个团队，集中维护公共服务平台的代码。开发一个新的金融产品，也只需要更少的人员来参与，因为他们只需要开发、维护产品特有的功能和代码就可以了。整体上，维护成本降低了。除此之外，公共服务平台的代码集中到了一个团队手里，重构起来不需要协调其他团队和项目，也便于我们重构、改善代码质量。</p>
<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>对于公共服务平台来说，接口请求来自很多不同的系统（后面统称为调用方），比如各种金融产品的后端系统。在系统上线一段时间里，我们遇到了很多问题。比如，因为调用方代码 bug 、不正确地使用服务（比如启动 Job 来调用接口获取数据）、业务上面的突发流量（比如促销活动），导致来自某个调用方的接口请求数突增，过度争用服务的线程资源，而来自其他调用方的接口请求，因此来不及响应而排队等待，导致接口请求的响应时间大幅增加，甚至出现超时。</p>
<p>我们可以开发接口限流功能，限制每个调用方对接口请求的频率。当超过预先设定的访问频率后，我们就触发限流熔断，比如，限制调用方 app-1 对公共服务平台总的接口请求频率不超过 1000 次 &#x2F; 秒，超过之后的接口请求都会被拒绝。除此之外，为了更加精细化地限流，除了限制每个调用方对公共服务平台总的接口请求频率之外，我们还希望能对单独某个接口的访问频率进行限制，比如，限制 app-1 对接口 &#x2F;user&#x2F;query 的访问频率为每秒钟不超过 100 次。</p>
<p>我们希望开发出来的东西有一定的影响力，即便做不到在行业内有影响力，起码也要做到在公司范围内有影响力。所以，从一开始，我们就不想把这个限流功能，做成只有我们项目可用。我们希望把它开发成一个通用的框架，能够应用到各个业务系统中，甚至可以集成到微服务治理平台中。实际上，这也体现了业务开发中要具备的抽象意识、框架意识。我们要善于识别出通用的功能模块，将它抽象成通用的框架、组件、类库等。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>这里，我们借助用户用例和测试驱动开发的思想，先去思考，如果框架最终被开发出来之后，它会如何被使用。我一般会找一个框架的应用场景，针对这个场景写一个框架使用的 Demo 程序，这样能够很直观地看到框架长什么样子。知道了框架应该长什么样，就相当于应试教育中确定了考试题目。针对明确的考题去想解决方案，这是我们多年应试教育锻炼之后最擅长做的。</p>
<p>对于限流框架来说，我们来看下它的应用场景。</p>
<p>首先我们需要设置限流规则。为了做到在不修改代码的前提下修改规则，我们一般会把规则放到配置文件中（比如 XML、YAML 配置文件）。在集成了限流框架的应用启动的时候，限流框架会将限流规则，按照事先定义的语法，解析并加载到内存中。我写了一个限流规则的 Demo 配置，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">configs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">appId:</span> <span class="string">app-1</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">api:</span> <span class="string">/v1/user</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">100</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">api:</span> <span class="string">/v1/order</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">50</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">appId:</span> <span class="string">app-2</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">api:</span> <span class="string">/v1/user</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">50</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">api:</span> <span class="string">/v1/order</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>在接收到接口请求之后，应用会将请求发送给限流框架，限流框架会告诉应用，这个接口请求是允许继续处理，还是触发限流熔断。如果我们用代码来将这个过程表示出来的话，就是下面这个 Demo 的样子。如果项目使用的是 Spring 框架，我们可以利用 Spring AOP，把这段限流代码放在统一的切面中，在切面中拦截接口请求，解析出请求对应的调用方 APP ID 和 URL，然后验证是否对此调用方的这个接口请求进行限流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">appId</span> <span class="operator">=</span> <span class="string">&quot;app-1&quot;</span>; <span class="comment">// 调用方APP-ID</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://www.eudemon.com/v1/user/12345&quot;</span>;<span class="comment">// 请求url</span></span><br><span class="line"><span class="type">RateLimiter</span> <span class="variable">ratelimiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RateLimiter</span>();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">passed</span> <span class="operator">=</span> ratelimiter.limit(appId, url);</span><br><span class="line"><span class="keyword">if</span> (passed) &#123;</span><br><span class="line">  <span class="comment">// 放行接口请求，继续后续的处理。</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 接口请求被限流。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合刚刚的 Demo，从使用的角度来说，限流框架主要包含两部分功能：配置限流规则和提供编程接口（RateLimiter 类）验证请求是否被限流。不过，作为通用的框架，除了功能性需求之外，非功能性需求也非常重要，有时候会决定一个框架的成败，比如，框架的易用性、扩展性、灵活性、性能、容错性等。</p>
<p>对于限流框架，我们来看它都有哪些非功能性需求。</p>
<p>易用性方面，我们希望限流规则的配置、编程接口的使用都很简单。我们希望提供各种不同的限流算法，比如基于内存的单机限流算法、基于 Redis 的分布式限流算法，能够让使用者自由选择。除此之外，因为大部分项目都是基于 Spring 开发的，我们还希望限流框架能非常方便地集成到使用 Spring 框架的项目中。<br>扩展性、灵活性方面，我们希望能够灵活地扩展各种限流算法。同时，我们还希望支持不同格式（JSON、YAML、XML 等格式）、不同数据源（本地文件配置或 Zookeeper 集中配置等）的限流规则的配置方式。</p>
<p>性能方面，因为每个接口请求都要被检查是否限流，这或多或少会增加接口请求的响应时间。而对于响应时间比较敏感的接口服务来说，我们要让限流框架尽可能低延迟，尽可能减少对接口请求本身响应时间的影响。</p>
<p>容错性方面，接入限流框架是为了提高系统的可用性、稳定性，不能因为限流框架的异常，反过来影响到服务本身的可用性。所以，限流框架要有高度的容错性。比如，分布式限流算法依赖集中存储器 Redis。如果 Redis 挂掉了，限流逻辑无法正常运行，这个时候业务接口也要能正常服务才行。</p>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>分析环节跟之前讲过的面向对象分析很相似，都是做需求的梳理。但是，项目实战中的设计和实现，跟面向对象设计和实现就不是一回事儿了。这里的“设计”指的是系统设计，主要是划分模块，对模块进行设计。这里的“实现”实际上等于面向对象设计加实现。因为我们前面讲到，面向对象设计与实现是聚焦在代码层面的，主要产出的是类的设计和实现。</p>
<p>我们分限流规则、限流算法、限流模式、集成使用这 4 个模块，来讲解限流框架的设计思路。看如何通过合理的设计，实现一个满足易用、易扩展、灵活、低延时、高容错等非功能性需求的限流框架。</p>
<h2 id="限流规则"><a href="#限流规则" class="headerlink" title="限流规则"></a>限流规则</h2><p>框架需要定义限流规则的语法格式，包括调用方、接口、限流阈值、时间粒度这几个元素。框架用户按照这个语法格式来配置限流规则。我举了一个例子来说明一下，如下所示。其中，unit 表示限流时间粒度，默认情况下是 1 秒。limit 表示在 unit 时间粒度内最大允许的请求次数。拿第一条规则来举例，它表示的意思就是：调用方 app-1 对接口 &#x2F;v1&#x2F;user 每分钟的最大请求次数不能超过 100 次。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">configs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">appId:</span> <span class="string">app-1</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">api:</span> <span class="string">/v1/user</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">100</span></span><br><span class="line">    <span class="string">unit：60</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">api:</span> <span class="string">/v1/order</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">50</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">appId:</span> <span class="string">app-2</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">api:</span> <span class="string">/v1/user</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">50</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">api:</span> <span class="string">/v1/order</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>对于限流时间粒度的选择，我们既可以选择限制 1 秒钟内不超过 1000 次，也可以选择限制 10 毫秒内不超过 10 次，还可以选择限制 1 分钟内不超过 6 万次。虽然看起来这几种限流规则是等价的，但过大的时间粒度会达不到限流的效果。比如，有可能 6 万次请求集中在 1 秒中到达，限制 1 分钟不超过 6 万次，就起不到保护的作用；相反，因为接口访问在细时间粒度上随机性很大，并不会很均匀。过小的时间粒度，会误杀很多本不应该限流的请求。所以，尽管越细的时间粒度限流整形效果越好，流量曲线越平滑，但也并不是时间粒度越小越合适。</p>
<p>我们知道，Spring 框架支持各种格式的配置文件，比如 XML、YAML、Porperties 等。除此之外，基于约定优于配置原则，Spring 框架用户只需要将配置文件按照约定来命名，并且放置到约定的路径下，Spring 框架就能按照约定自动查找和加载配置文件。</p>
<p>大部分 Java 程序员已经习惯了 Spring 的配置方式，基于我们前面讲的最小惊奇原则，在限流框架中，我们也延续 Spring 的配置方式，支持 XML、YAML、Properties 等几种配置文件格式，同时，约定默认的配置文件名为 ratelimiter-rule.yaml，默认放置在 classpath 路径中。</p>
<p>除此之外，为了提高框架的兼容性、易用性，除了刚刚讲的本地文件的配置方式之外，我们还希望兼容从其他数据源获取配置的方式，比如 Zookeeper 或者自研的配置中心。</p>
<h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><p>常见的限流算法有：固定时间窗口限流算法、滑动时间窗口限流算法、令牌桶限流算法、漏桶限流算法。其中，固定时间窗口限流算法最简单。我们只需要选定一个起始时间起点，之后每来一个接口请求，我们都给计数器（记录当前时间窗口内的访问次数）加一，如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许 100 次接口请求），累加访问次数超过限流值（比如 100 次），就触发限流熔断，拒绝接口请求。当进入下一个时间窗口之后，计数器清零重新计数。</p>
<p>不过，固定时间窗口的限流算法的缺点也很明显。这种算法的限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。我们来举一个例子。假设我们限流规则为每秒钟不超过 100 次接口请求。第一个 1 秒时间窗口内，100 次接口请求都集中在最后的 10 毫秒内，在第二个 1 秒时间窗口内，100 次接口请求都集中在最开始的 10 毫秒内。虽然两个时间窗口内流量都符合限流要求 (小于等于 100 个接口请求)，但在两个时间窗口临界的 20 毫秒内集中有 200 次接口请求，固定时间窗口限流算法没法对这种情况进行限流，集中在这 20 毫秒内的 200 次请求有可能会压垮系统。</p>
<p>为了让流量更加平滑，于是就有了更加高级的滑动时间窗口限流算法、令牌桶限流算法和漏桶限流算法。</p>
<p>尽管固定时间窗口限流算法没法做到让流量很平滑，但大部分情况下，它已经够用了。默认情况下，框架使用固定时间窗口限流算法做限流。不过，考虑到框架的扩展性，我们需要预先做好设计，预留好扩展点，方便今后扩展其他限流算法。除此之外，为了提高框架的易用性、灵活性，我们最好将其他几种常用的限流算法，也在框架中实现出来，供框架用户根据自己业务场景自由选择。</p>
<h2 id="限流模式"><a href="#限流模式" class="headerlink" title="限流模式"></a>限流模式</h2><p>我们把限流模式分为两种：单机限流和分布式限流。所谓单机限流，就是针对单个实例的访问频率进行限制。注意这里的单机并不是真的一台物理机器，而是一个服务实例，因为有可能一台物理机器部署多个实例。所谓的分布式限流，就是针对某个服务的多个实例的总的访问频率进行限制。我举个例子来解释一下。</p>
<p>假设我们开发了一个用户相关的微服务，为了提高服务能力，我们部署了 5 个实例。我们限制某个调用方，对单个实例的某个接口的访问频率，不能超过 100 次 &#x2F; 秒。这就是单机限流。我们限制某个调用方，对 5 个实例的某个接口的总访问频率，不能超过 500 次 &#x2F; 秒。这就是所谓的分布式限流。</p>
<p>从实现的角度来分析，单机限流和分布式限流的主要区别在接口访问计数器的实现。单机限流只需要在单个实例中维护自己的接口请求计数器。而分布式限流需要集中管理计数器（比如使用 Redis 存储接口访问计数），这样才能做到多个实例对同一个计数器累加计数，以便实现对多个实例总访问频率的限制。</p>
<p>前面我们讲到框架要高容错，不能因为框架的异常，影响到集成框架的应用的可用性和稳定性。除此之外，我们还讲到框架要低延迟。限流逻辑的执行不能占用太长时间，不能或者很少影响接口请求本身的响应时间。因为分布式限流基于外部存储 Redis，网络通信成本较高，实际上，高容错、低延迟设计的主要场景就是基于 Redis 实现的分布式限流。</p>
<p>对于 Redis 的各种异常情况，我们处理起来并不难，捕获并封装为统一的异常，向上抛出或者吞掉就可以了。比较难处理的是 Redis 访问超时。Redis 访问超时会严重影响接口的响应时间，甚至导致接口请求超时。所以，在访问 Redis 时，我们需要设置合理的超时时间。一旦超时，我们就判定为限流失效，继续执行接口请求。Redis 访问超时时间的设置既不能太大也不能太小，太大可能会影响到接口的响应时间，太小可能会导致太多的限流失效。我们可以通过压测或者线上监控，获取到 Redis 访问时间分布情况，再结合接口可以容忍的限流延迟时间，权衡设置一个较合理的 Redis 超时时间。</p>
<h2 id="集成使用"><a href="#集成使用" class="headerlink" title="集成使用"></a>集成使用</h2><p>限流框架也应该满足低侵入松耦合设计思想。因为框架是需要集成到应用中使用的，我们希望框架尽可能低侵入，与业务代码松耦合，替换、删除起来也更容易些。</p>
<p>我们还可以开发一个 Ratelimiter-Spring 类库，能够方便使用了 Spring 的项目集成限流框架，将易用性做到极致。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="V1-版本功能需求"><a href="#V1-版本功能需求" class="headerlink" title="V1 版本功能需求"></a>V1 版本功能需求</h2><p>在 V1 版本中，对于接口类型，我们只支持 HTTP 接口（也就 URL）的限流，暂时不支持 RPC 等其他类型的接口限流。对于限流规则，我们只支持本地文件配置，配置文件格式只支持 YAML。对于限流算法，我们只支持固定时间窗口算法。对于限流模式，我们只支持单机限流。</p>
<p>尽管功能“裁剪”之后，V1 版本实现起来简单多了，但在编程开发的同时，我们还是要考虑代码的扩展性，预留好扩展点。这样，在接下来的新版本开发中，我们才能够轻松地扩展新的限流算法、限流模式、限流规则格式和数据源。</p>
<h2 id="最小原型代码"><a href="#最小原型代码" class="headerlink" title="最小原型代码"></a>最小原型代码</h2><p>项目实战中的实现等于面向对象设计加实现。而面向对象设计与实现一般可以分为四个步骤：划分职责识别类、定义属性和方法、定义类之间的交互关系、组装类并提供执行入口。</p>
<p>在平时的工作中，大部分程序员都是边写代码边做设计，边思考边重构，并不会严格地按照步骤，先做完类的设计再去写代码。而且，如果想一下子就把类设计得很好、很合理，也是比较难的。过度追求完美主义，只会导致迟迟下不了手，连第一行代码也敲不出来。所以，我的习惯是，先完全不考虑设计和代码质量，先把功能完成，先把基本的流程走通，哪怕所有的代码都写在一个类中也无所谓。然后，我们再针对这个 MVP 代码（最小原型代码）做优化重构，比如，将代码中比较独立的代码块抽离出来，定义成独立的类或函数。</p>
<p>我们按照先写 MVP 代码的思路，把代码实现出来。它的目录结构如下所示。代码非常简单，只包含 5 个类，接下来，我们针对每个类一一讲解一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.monochrome.ratelimiter</span><br><span class="line">  --RateLimiter</span><br><span class="line">com.monochrome.ratelimiter.rule</span><br><span class="line">  --ApiLimit</span><br><span class="line">  --RuleConfig</span><br><span class="line">  --RateLimitRule</span><br><span class="line">com.monochrome.ratelimiter.alg</span><br><span class="line">  --RateLimitAlg</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.ratelimiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.monochrome.ratelimiter.alg.RateLimitAlg;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.ratelimiter.rule.ApiLimit;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.ratelimiter.rule.RateLimitRule;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.ratelimiter.rule.RuleConfig;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.slf4j.internal.Logger;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.slf4j.internal.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.yaml.snakeyaml.Yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(RateLimiter.class);</span><br><span class="line">    <span class="comment">// 为每个api在内存中存储限流计数器</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, RateLimitAlg&gt; counters = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> RateLimitRule rule;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RateLimiter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 将限流规则配置文件rate-limiter-rule.yaml中的内容读取到RuleConfig中</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="built_in">this</span>.getClass().getResourceAsStream(<span class="string">&quot;./rate-limiter-rule.yaml&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">                ruleConfig = yaml.loadAs(in, RuleConfig.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;close file error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将限流规则构建成支持快速查找的数据结构RateLimitRule</span></span><br><span class="line">        <span class="built_in">this</span>.rule = <span class="keyword">new</span> <span class="title class_">RateLimitRule</span>(ruleConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">limit</span><span class="params">(String appId, String url)</span> &#123;</span><br><span class="line">        <span class="type">ApiLimit</span> <span class="variable">apiLimit</span> <span class="operator">=</span> rule.getLimit(appId, url);</span><br><span class="line">        <span class="keyword">if</span> (apiLimit == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取api对应在内存中的限流计数器（rateLimitCounter）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">counterKey</span> <span class="operator">=</span> appId + <span class="string">&quot;:&quot;</span> + apiLimit.getApi();</span><br><span class="line">        <span class="type">RateLimitAlg</span> <span class="variable">rateLimitCounter</span> <span class="operator">=</span> counters.get(counterKey);</span><br><span class="line">        <span class="keyword">if</span> (rateLimitCounter == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">RateLimitAlg</span> <span class="variable">newRateLimitCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RateLimitAlg</span>(apiLimit.getLimit());</span><br><span class="line">            rateLimitCounter = counters.putIfAbsent(counterKey, newRateLimitCounter);</span><br><span class="line">            <span class="keyword">if</span> (rateLimitCounter == <span class="literal">null</span>) &#123;</span><br><span class="line">                rateLimitCounter = newRateLimitCounter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否限流</span></span><br><span class="line">        <span class="keyword">return</span> rateLimitCounter.tryAcquire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RateLimiter 类用来串联整个限流流程。它先读取限流规则配置文件，映射为内存中的 Java 对象（RuleConfig），然后再将这个中间结构构建成一个支持快速查询的数据结构（RateLimitRule）。除此之外，这个类还提供供用户直接使用的最顶层接口（limit() 接口）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.ratelimiter.rule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;AppRuleConfig&gt; configs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;AppRuleConfig&gt; <span class="title function_">getConfigs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConfigs</span><span class="params">(List&lt;AppRuleConfig&gt; configs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configs = configs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AppRuleConfig</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String appId;</span><br><span class="line">        <span class="keyword">private</span> List&lt;ApiLimit&gt; limits;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AppRuleConfig</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AppRuleConfig</span><span class="params">(String appId, List&lt;ApiLimit&gt; limits)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.appId = appId;</span><br><span class="line">            <span class="built_in">this</span>.limits = limits;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getAppId</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> appId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAppId</span><span class="params">(String appId)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.appId = appId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;ApiLimit&gt; <span class="title function_">getLimits</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> limits;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLimits</span><span class="params">(List&lt;ApiLimit&gt; limits)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.limits = limits;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中，我们可以看出来，RuleConfig 类嵌套了另外两个类 AppRuleConfig 和 ApiLimit。这三个类跟配置文件的三层嵌套结构完全对应。我把对应关系标注在了下面的示例中，你可以对照着代码看下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">configs:          #&lt;!--对应RuleConfig--&gt;</span><br><span class="line">  - appId: app-1    #&lt;!--对应AppRuleConfig--&gt;</span><br><span class="line">    limits:</span><br><span class="line">      - api: /v1/user #&lt;!--对应ApiLimit--&gt;</span><br><span class="line">        limit: 100</span><br><span class="line">        unit: 60</span><br><span class="line">      - api: /v1/order</span><br><span class="line">        limit: 50</span><br><span class="line">  - appId: app-2</span><br><span class="line">    limits:</span><br><span class="line">      - api: /v1/user</span><br><span class="line">        limit: 50</span><br><span class="line">      - api: /v1/order</span><br><span class="line">        limit: 50</span><br></pre></td></tr></table></figure>

<p>你可能会好奇，有了 RuleConfig 来存储限流规则，为什么还要 RateLimitRule 类呢？这是因为，限流过程中会频繁地查询接口对应的限流规则，为了尽可能地提高查询速度，我们需要将限流规则组织成一种支持按照 URL 快速查询的数据结构。考虑到 URL 的重复度比较高，且需要按照前缀来匹配，我们这里选择使用 Trie 树这种数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.ratelimiter.rule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitRule</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, ApiLimit&gt; apiLimitMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RateLimitRule</span><span class="params">(RuleConfig ruleConfig)</span> &#123;</span><br><span class="line">        List&lt;RuleConfig.AppRuleConfig&gt; configs = ruleConfig.getConfigs();</span><br><span class="line">        <span class="keyword">for</span> (RuleConfig.AppRuleConfig config : configs) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">appId</span> <span class="operator">=</span> config.getAppId();</span><br><span class="line">            List&lt;ApiLimit&gt; limits = config.getLimits();</span><br><span class="line">            <span class="keyword">for</span> (ApiLimit limit : limits) &#123;</span><br><span class="line">                apiLimitMap.putIfAbsent(appId + <span class="string">&quot;:&quot;</span> + limit.getApi(), limit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ApiLimit <span class="title function_">getLimit</span><span class="params">(String appId, String api)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> apiLimitMap.get(appId + <span class="string">&quot;:&quot;</span> + api);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后，我们看下 RateLimitAlg 这个类。</strong></p>
<p>这个类是限流算法实现类。它实现了最简单的固定时间窗口限流算法。每个接口都要在内存中对应一个 RateLimitAlg 对象，记录在当前时间窗口内已经被访问的次数。RateLimitAlg 类的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.ratelimiter.alg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.annotations.VisibleForTesting;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Stopwatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitAlg</span> &#123;</span><br><span class="line">    <span class="comment">/* timeout for &#123;@code Lock.tryLock() &#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TRY_LOCK_TIMEOUT</span> <span class="operator">=</span> <span class="number">200L</span>;  <span class="comment">// 200ms.</span></span><br><span class="line">    <span class="keyword">private</span> Stopwatch stopwatch;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">currentCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RateLimitAlg</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(limit, Stopwatch.createStarted());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RateLimitAlg</span><span class="params">(<span class="type">int</span> limit, Stopwatch stopwatch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        <span class="built_in">this</span>.stopwatch = stopwatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">updatedCount</span> <span class="operator">=</span> currentCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">if</span> (updatedCount &lt;= limit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock(TRY_LOCK_TIMEOUT, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stopwatch.elapsed(TimeUnit.MILLISECONDS) &gt; TimeUnit.SECONDS.toMillis(<span class="number">1</span>)) &#123;</span><br><span class="line">                        currentCount.set(<span class="number">0</span>);</span><br><span class="line">                        stopwatch.reset();</span><br><span class="line">                    &#125;</span><br><span class="line">                    updatedCount = currentCount.incrementAndGet();</span><br><span class="line">                    <span class="keyword">return</span> updatedCount &lt;= limit;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;tryAcquire() wait lock too long:&quot;</span> + TRY_LOCK_TIMEOUT + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;tryAcquire() is interrupted by lock-time-out.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Review-最小原型代码"><a href="#Review-最小原型代码" class="headerlink" title="Review 最小原型代码"></a>Review 最小原型代码</h2><p>刚刚给出的 MVP 代码，虽然总共也就 200 多行，但已经实现了 V1 版本中规划的功能。不过，从代码质量的角度来看，它还有很多值得优化的地方。现在，我们现在站在一个 Code Reviewer 的角度，来分析一下这段代码的设计和实现。</p>
<p>结合 SOLID、DRY、KISS、LOD、基于接口而非实现编程、高内聚松耦合等经典的设计思想和原则，以及编码规范，我们从代码质量评判标准的角度重点剖析一下，这段代码在可读性、扩展性等方面的表现。其他方面的表现，比如复用性、可测试性等，这些你可以比葫芦画瓢，自己来进行分析。</p>
<h3 id="代码的可读性"><a href="#代码的可读性" class="headerlink" title="代码的可读性"></a><strong>代码的可读性</strong></h3><p>影响代码可读性的因素有很多。我们重点关注目录设计（package 包）是否合理、模块划分是否清晰、代码结构是否高内聚低耦合，以及是否符合统一的编码规范这几点。</p>
<p>因为涉及的代码不多，目录结构前面也给出了，总体来说比较简单，所以目录设计、包的划分没有问题。</p>
<p>按照上节课中的模块划分，RuleConfig、ApiLimit、RateLimitRule 属于“限流规则”模块，负责限流规则的构建和查询。RateLimitAlg 属于“限流算法”模块，提供了基于内存的单机固定时间窗口限流算法。RateLimiter 类属于“集成使用”模块，作为最顶层类，组装其他类，提供执行入口（也就是调用入口）。不过，RateLimiter 类作为执行入口，我们希望它只负责组装工作，而不应该包含具体的业务逻辑，所以，RateLimiter 类中，从配置文件中读取限流规则这块逻辑，应该拆分出来设计成独立的类。</p>
<p>如果我们把类与类之间的依赖关系图画出来，你会发现，它们之间的依赖关系很简单，每个类的职责也比较单一，所以类的设计满足单一职责原则、LOD 迪米特法则、高内聚松耦合的要求。</p>
<p>从编码规范上来讲，没有超级大的类、函数、代码块。类、函数、变量的命名基本能达意，也符合最小惊奇原则。虽然，有些命名不能一眼就看出是干啥的，有些命名采用了缩写，比如 RateLimitAlg，但是我们起码能猜个八九不离十，结合注释（限于篇幅注释都没有写，并不代表不需要写），很容易理解和记忆。</p>
<p>总结一下，在最小原型代码中，目录设计、代码结构、模块划分、类的设计还算合理清晰，基本符合编码规范，代码的可读性不错！</p>
<h3 id="代码的扩展性"><a href="#代码的扩展性" class="headerlink" title="代码的扩展性"></a><strong>代码的扩展性</strong></h3><p>实际上，这段代码最大的问题就是它的扩展性，也是我们最关注的，毕竟后续还有更多版本的迭代开发。编写可扩展代码，关键是要建立扩展意识。这就像下象棋，我们要多往前想几步，为以后做准备。在写代码的时候，我们要时刻思考，这段代码如果要扩展新的功能，那是否可以在尽量少改动代码的情况下完成，还是需要要大动干戈，推倒重写。</p>
<p>具体到 MVP 代码，不易扩展的最大原因是，没有遵循基于接口而非实现的编程思想，没有接口抽象意识。比如，RateLimitAlg 类只是实现了固定时间窗口限流算法，也没有提炼出更加抽象的算法接口。如果我们要替换其他限流算法，就要改动比较多的代码。其他类的设计也有同样的问题，比如 RateLimitRule。</p>
<p>除此之外，在 RateLimiter 类中，配置文件的名称、路径，是硬编码在代码中的。尽管我们说约定优于配置，但也要兼顾灵活性，能够让用户在需要的时候，自定义配置文件名称、路径。而且，配置文件的格式只支持 Yaml，之后扩展其他格式，需要对这部分代码做很大的改动。</p>
<h2 id="重构最小原型代码"><a href="#重构最小原型代码" class="headerlink" title="重构最小原型代码"></a>重构最小原型代码</h2><p>根据刚刚对 MVP 代码的剖析，我们发现，它的可读性没有太大问题，问题主要在于可扩展性。主要的修改点有两个，一个是将 RateLimiter 中的规则配置文件的读取解析逻辑拆出来，设计成独立的类，另一个是参照基于接口而非实现编程思想，对于 RateLimitRule、RateLimitAlg 类提炼抽象接口。</p>
<p>按照这个修改思路，我们对代码进行重构。重构之后的目录结构如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 重构前：</span><br><span class="line">com.xzg.ratelimiter</span><br><span class="line">  --RateLimiter</span><br><span class="line">com.xzg.ratelimiter.rule</span><br><span class="line">  --ApiLimit</span><br><span class="line">  --RuleConfig</span><br><span class="line">  --RateLimitRule</span><br><span class="line">com.xzg.ratelimiter.alg</span><br><span class="line">  --RateLimitAlg</span><br><span class="line">  </span><br><span class="line">// 重构后：</span><br><span class="line">com.xzg.ratelimiter</span><br><span class="line">  --RateLimiter(有所修改)</span><br><span class="line">com.xzg.ratelimiter.rule</span><br><span class="line">  --ApiLimit(不变)</span><br><span class="line">  --RuleConfig(不变)</span><br><span class="line">  --RateLimitRule(抽象接口)</span><br><span class="line">  --TrieRateLimitRule(实现类，就是重构前的RateLimitRule）</span><br><span class="line">com.xzg.ratelimiter.rule.parser</span><br><span class="line">  --RuleConfigParser(抽象接口)</span><br><span class="line">  --YamlRuleConfigParser(Yaml格式配置文件解析类)</span><br><span class="line">  --JsonRuleConfigParser(Json格式配置文件解析类)</span><br><span class="line">com.xzg.ratelimiter.rule.datasource</span><br><span class="line">  --RuleConfigSource(抽象接口)</span><br><span class="line">  --FileRuleConfigSource(基于本地文件的配置类)</span><br><span class="line">com.xzg.ratelimiter.alg</span><br><span class="line">  --RateLimitAlg(抽象接口)</span><br><span class="line">  --FixedTimeWinRateLimitAlg(实现类，就是重构前的RateLimitAlg)</span><br></pre></td></tr></table></figure>

<p>其中，RateLimiter 类重构之后的代码如下所示。代码的改动集中在构造函数中，通过调用 RuleConfigSource 来实现了限流规则配置文件的加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(RateLimiter.class);</span><br><span class="line">    <span class="comment">// 为每个api在内存中存储限流计数器</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, RateLimitAlg&gt; counters = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> RateLimitRule rule;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RateLimiter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 主要修改在这儿，调用RuleConfigSource类来实现配置加载，支持多种配置文件的读取</span></span><br><span class="line">        <span class="type">RuleConfigSource</span> <span class="variable">ruleConfigSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileRuleConfigSource</span>();</span><br><span class="line">        <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> ruleConfigSource.load();</span><br><span class="line">        <span class="comment">// 将限流规则构建成支持快速查找的数据结构RateLimitRule</span></span><br><span class="line">        <span class="built_in">this</span>.rule = <span class="keyword">new</span> <span class="title class_">RateLimitRule</span>(ruleConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">limit</span><span class="params">(String appId, String url)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看下，从 RateLimiter 中拆分出来的限流规则加载的逻辑，现在是如何设计的。这部分涉及的类主要是下面几个。我把关键代码也贴在了下面。其中，各个 Parser 和 RuleConfigSource 类的设计有点类似策略模式，如果要添加新的格式的解析，只需要实现对应的 Parser 类，并且添加到 FileRuleConfig 类的 PARSER_MAP 中就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.xzg.ratelimiter.rule.parser</span><br><span class="line">  --RuleConfigParser(抽象接口)</span><br><span class="line">  --YamlRuleConfigParser(Yaml格式配置文件解析类)</span><br><span class="line">  --JsonRuleConfigParser(Json格式配置文件解析类)</span><br><span class="line">com.xzg.ratelimiter.rule.datasource</span><br><span class="line">  --RuleConfigSource(抽象接口)</span><br><span class="line">  --FileRuleConfigSource(基于本地文件的配置类)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.ratelimiter.rule.parser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.monochrome.ratelimiter.rule.RuleConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RuleConfigParser</span> &#123;</span><br><span class="line">    RuleConfig <span class="title function_">parse</span><span class="params">(String configText)</span>;</span><br><span class="line">    RuleConfig <span class="title function_">parse</span><span class="params">(InputStream inputStream)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.ratelimiter.rule.parser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.monochrome.ratelimiter.rule.RuleConfig;</span><br><span class="line"><span class="keyword">import</span> org.yaml.snakeyaml.Yaml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlRuleConfigParser</span> <span class="keyword">implements</span> <span class="title class_">RuleConfigParser</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RuleConfig <span class="title function_">parse</span><span class="params">(String configText)</span> &#123;</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        <span class="keyword">return</span> yaml.loadAs(configText, RuleConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RuleConfig <span class="title function_">parse</span><span class="params">(InputStream inputStream)</span> &#123;</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        <span class="keyword">return</span> yaml.loadAs(inputStream, RuleConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.ratelimiter.rule.datasource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.monochrome.ratelimiter.rule.RuleConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    RuleConfig <span class="title function_">load</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.ratelimiter.rule.datasource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.monochrome.ratelimiter.rule.RuleConfig;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.ratelimiter.rule.parser.JsonRuleConfigParser;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.ratelimiter.rule.parser.RuleConfigParser;</span><br><span class="line"><span class="keyword">import</span> com.monochrome.ratelimiter.rule.parser.YamlRuleConfigParser;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileRuleConfigSource</span> <span class="keyword">implements</span> <span class="title class_">RuleConfigSource</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(FileRuleConfigSource.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">API_LIMIT_CONFIG_NAME</span> <span class="operator">=</span> <span class="string">&quot;rate-limiter-rule&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">YAML_EXTENSION</span> <span class="operator">=</span> <span class="string">&quot;yaml&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">YML_EXTENSION</span> <span class="operator">=</span> <span class="string">&quot;yml&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JSON_EXTENSION</span> <span class="operator">=</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SUPPORT_EXTENSIONS = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;YAML_EXTENSION, YML_EXTENSION, JSON_EXTENSION&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, RuleConfigParser&gt; PARSER_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        PARSER_MAP.put(YAML_EXTENSION, <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>());</span><br><span class="line">        PARSER_MAP.put(YML_EXTENSION, <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>());</span><br><span class="line">        PARSER_MAP.put(JSON_EXTENSION, <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String extension : SUPPORT_EXTENSIONS) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getResourceAsStream(<span class="string">&quot;/&quot;</span> + getFileNameByExt(extension))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">RuleConfigParser</span> <span class="variable">ruleConfigParser</span> <span class="operator">=</span> PARSER_MAP.get(extension);</span><br><span class="line">                    <span class="keyword">return</span> ruleConfigParser.parse(in);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;close file error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getFileNameByExt</span><span class="params">(String extension)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> API_LIMIT_CONFIG_NAME + <span class="string">&quot;.&quot;</span> + extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写个UT测试下"><a href="#写个UT测试下" class="headerlink" title="写个UT测试下"></a>写个UT测试下</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">configs:</span>          <span class="comment">#&lt;!--对应RuleConfig--&gt;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">appId:</span> <span class="string">app-1</span>    <span class="comment">#&lt;!--对应AppRuleConfig--&gt;</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">api:</span> <span class="string">/v1/user</span> <span class="comment">#&lt;!--对应ApiLimit--&gt;</span></span><br><span class="line">        <span class="attr">limit:</span> <span class="number">50</span></span><br><span class="line">        <span class="attr">unit:</span> <span class="number">60</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">api:</span> <span class="string">/v1/order</span></span><br><span class="line">        <span class="attr">limit:</span> <span class="number">50</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">appId:</span> <span class="string">app-2</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">api:</span> <span class="string">/v1/user</span></span><br><span class="line">        <span class="attr">limit:</span> <span class="number">50</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">api:</span> <span class="string">/v1/order</span></span><br><span class="line">        <span class="attr">limit:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monochrome.ratelimiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RateLimiterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RateLimiter rateLimiter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        rateLimiter = <span class="keyword">new</span> <span class="title class_">RateLimiter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">limit</span> <span class="operator">=</span> rateLimiter.limit(<span class="string">&quot;app-1&quot;</span>, <span class="string">&quot;/v1/user&quot;</span>);</span><br><span class="line">            assertThat(limit).isTrue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">limit2</span> <span class="operator">=</span> rateLimiter.limit(<span class="string">&quot;app-1&quot;</span>, <span class="string">&quot;/v1/user&quot;</span>);</span><br><span class="line">        assertThat(limit2).isFalse();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-迭代器模式</title>
    <url>/2022/09/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="迭代器模式的原理和实现"><a href="#迭代器模式的原理和实现" class="headerlink" title="迭代器模式的原理和实现"></a>迭代器模式的原理和实现</h1><p>迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern）。在开篇中我们讲到，它用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</p>
<p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。对于迭代器模式，我画了一张简单的类图，你可以看一看，先有个大致的印象。</p>
<p><img src="/../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="迭代模式类图"></p>
<span id="more"></span>

<p>线性数据结构包括数组和链表，在大部分编程语言中都有对应的类来封装这两种数据结构，在开发中直接拿来用就可以了。假设在这种新的编程语言中，这两个数据结构分别对应 ArrayList 和 LinkedList 两个类。除此之外，我们从两个类中抽象出公共的接口，定义为 List 接口，以方便开发者基于接口而非实现编程，编写的代码能在两种数据存储结构之间灵活切换。</p>
<p>现在，我们针对 ArrayList 和 LinkedList 两个线性容器，设计实现对应的迭代器。按照之前给出的迭代器模式的类图，我们定义一个迭代器接口 Iterator，以及针对两种容器的具体的迭代器实现类 ArrayIterator 和 ListIterator。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 接口定义方式一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">  E <span class="title function_">currentItem</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口定义方式二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">  E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>terator 接口有两种定义方式。在第一种定义中，next() 函数用来将游标后移一位元素，currentItem() 函数用来返回当前游标指向的元素。在第二种定义中，返回当前元素与后移一位这两个操作，要放到同一个函数 next() 中完成。第一种定义方式更加灵活一些，比如我们可以多次调用 currentItem() 查询当前元素，而不移动游标。所以，在接下来的实现中，我们选择第一种接口定义方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.arrayList = arrayList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != arrayList.size(); <span class="comment">//注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    cursor++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">currentItem</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cursor &gt;= arrayList.size()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrayList.get(cursor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">&quot;xzg&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;zheng&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;String&gt; iterator = <span class="keyword">new</span> <span class="title class_">ArrayIterator</span>(names);</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.currentItem());</span><br><span class="line">      iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码实现中，我们需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，我们可以在容器中定义一个 iterator() 方法，来创建对应的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在 List 接口中。具体的代码实现和使用示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">  Iterator <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//...省略其他接口函数...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">&quot;xzg&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;zheng&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      System.out.println(iterator.currentItem());</span><br><span class="line">      iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="迭代器模式的优势"><a href="#迭代器模式的优势" class="headerlink" title="迭代器模式的优势"></a>迭代器模式的优势</h1><p>一般来讲，遍历集合数据有三种方法：for 循环、foreach 循环、iterator 迭代器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;xzg&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;zheng&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种遍历方式：for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line">  System.out.print(names.get(i) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种遍历方式：foreach循环</span></span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">  System.out.print(name + <span class="string">&quot;,&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种遍历方式：迭代器遍历</span></span><br><span class="line">Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  System.out.print(iterator.next() + <span class="string">&quot;,&quot;</span>);<span class="comment">//Java中的迭代器接口是第二种定义方式，next()既移动游标又返回数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，foreach 循环只是一个语法糖而已，底层是基于迭代器来实现的。也就是说，上面代码中的第二种遍历方式（foreach 循环代码）的底层实现，就是第三种遍历方式（迭代器遍历代码）。这两种遍历方式可以看作同一种遍历方式，也就是迭代器遍历方式。</p>
<p>从上面的代码来看，for 循环遍历方式比起迭代器遍历方式，代码看起来更加简洁。那我们为什么还要用迭代器来遍历容器呢？为什么还要给容器设计对应的迭代器呢？原因有以下三个。</p>
<p>首先，对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用 for 循环来遍历就足够了。但是，对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性。</p>
<p>前面也多次提到，应对复杂性的方法就是拆分。我们可以将遍历操作拆分到迭代器类中。比如，针对图的遍历，我们就可以定义 DFSIterator、BFSIterator 两个迭代器类，让它们分别来实现深度优先遍历和广度优先遍历。其次，将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。</p>
<p>最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链表，客户端代码只需要将迭代器类从 LinkedIterator 切换为 ReversedLinkedIterator 即可，其他代码都不需要修改。除此之外，添加新的遍历算法，我们只需要扩展新的迭代器类，也更符合开闭原则。</p>
<p>简单总结一下优势：</p>
<ul>
<li>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</li>
<li>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；</li>
<li>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</li>
</ul>
<h1 id="在遍历的同时增删集合元素会发生什么？"><a href="#在遍历的同时增删集合元素会发生什么？" class="headerlink" title="在遍历的同时增删集合元素会发生什么？"></a>在遍历的同时增删集合元素会发生什么？</h1><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为，也就是说，运行结果到底是对还是错，要视情况而定。</p>
<p>在遍历的时候删除游标后面的元素或在游标的后面添加元素，就不会存在任何问题</p>
<h1 id="如何应对遍历时改变集合导致的未决行为？"><a href="#如何应对遍历时改变集合导致的未决行为？" class="headerlink" title="如何应对遍历时改变集合导致的未决行为？"></a>如何应对遍历时改变集合导致的未决行为？</h1><p>当通过迭代器来遍历集合的时候，增加、删除集合元素会导致不可预期的遍历结果。有两种比较干脆利索的解决方案：一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。</p>
<p>实际上，第一种解决方案比较难实现，我们要确定遍历开始和结束的时间点。遍历开始的时间节点我们很容易获得。我们可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍历结束的时间点又不好确认。</p>
<p>实际上，第二种解决方法更加合理。Java 语言就是采用的这种解决方案，增删元素之后，让遍历报错。接下来，我们具体来看一下如何实现。怎么确定在遍历时候，集合有没有增删元素呢？我们在 ArrayList 中定义一个成员变量 modCount，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给 modCount 加 1。当通过调用集合上的 iterator() 函数来创建迭代器的时候，我们把 modCount 值传递给迭代器的 expectedModCount 成员变量，之后每次调用迭代器上的 hasNext()、next()、currentItem() 函数，我们都会检查集合上的 modCount 是否等于 expectedModCount，也就是看，在创建完迭代器之后，modCount 是否改变过。</p>
<p>如果两个值不相同，那就说明集合存储的元素已经改变了，要么增加了元素，要么删除了元素，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以我们选择 fail-fast 解决方式，抛出运行时异常，结束掉程序，让程序员尽快修复这个因为不正确使用迭代器而产生的 bug。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">  <span class="keyword">private</span> ArrayList arrayList;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayIterator</span><span class="params">(ArrayList arrayList)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.arrayList = arrayList;</span><br><span class="line">    <span class="built_in">this</span>.expectedModCount = arrayList.modCount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">return</span> cursor &lt; arrayList.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    cursor++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">currentItem</span><span class="params">()</span> &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">return</span> arrayList.get(cursor);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arrayList.modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    names.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    names.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">    iterator.next();</span><br><span class="line">    names.remove(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    iterator.next();<span class="comment">//抛出ConcurrentModificationException异常</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何在遍历的同时安全地删除集合元素？像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 remove() 方法，能够在遍历集合的同时，安全地删除集合中的元素。不过，需要说明的是，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里本身就不合适。我个人觉得，Java 迭代器中提供的 remove() 方法还是比较鸡肋的，作用有限。它只能删除游标指向的前一个元素，而且一个 next() 函数之后，只能跟着最多一个 remove() 操作，多次调用 remove() 操作会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">      checkForComodification();</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">      Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">      cursor = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">      checkForComodification();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码实现中，迭代器类新增了一个 lastRet 成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和 lastRet 值，来保证不会因为删除元素而导致某个元素遍历不到。如果通过容器来删除元素，并且希望更新迭代器中的游标值来保证遍历不出错，我们就要维护这个容器都创建了哪些迭代器，每个迭代器是否还在使用等信息，代码实现就变得比较复杂了。</p>
<h1 id="实现一个支持“快照”功能的迭代器"><a href="#实现一个支持“快照”功能的迭代器" class="headerlink" title="实现一个支持“快照”功能的迭代器"></a>实现一个支持“快照”功能的迭代器</h1><p>理解这个问题最关键的是理解“快照”两个字。所谓“快照”，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。</p>
<p>接下来，我举一个例子来解释一下上面这段话。具体的代码如下所示。容器 list 中初始存储了 3、8、2 三个元素。尽管在创建迭代器 iter1 之后，容器 list 删除了元素 3，只剩下 8、2 两个元素，但是，通过 iter1 遍历的对象是快照，而非容器 list 本身。所以，遍历的结果仍然是 3、8、2。同理，iter2、iter3 也是在各自的快照上遍历，输出的结果如代码中注释所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">8</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iter1 = list.iterator();<span class="comment">//snapshot: 3, 8, 2</span></span><br><span class="line">list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));<span class="comment">//list：3, 8</span></span><br><span class="line">Iterator&lt;Integer&gt; iter2 = list.iterator();<span class="comment">//snapshot: 3, 8</span></span><br><span class="line">list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));<span class="comment">//list：8</span></span><br><span class="line">Iterator&lt;Integer&gt; iter3 = list.iterator();<span class="comment">//snapshot: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：3 8 2</span></span><br><span class="line"><span class="keyword">while</span> (iter1.hasNext()) &#123;</span><br><span class="line">  System.out.print(iter1.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：3 8</span></span><br><span class="line"><span class="keyword">while</span> (iter2.hasNext()) &#123;</span><br><span class="line">  System.out.print(iter2.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：8</span></span><br><span class="line"><span class="keyword">while</span> (iter3.hasNext()) &#123;</span><br><span class="line">  System.out.print(iter3.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>

<p>下面是针对这个功能需求的骨架代码，其中包含 ArrayList、SnapshotArrayIterator 两个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 成员变量、私有函数等随便你定义</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 由你来完善</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 由你来完善</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SnapshotArrayIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotArrayIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 成员变量、私有函数等随便你定义</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 由你来完善</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;<span class="comment">//返回当前元素，并且游标后移一位</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 由你来完善</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h2><p>在迭代器类中定义一个成员变量 snapshot 来存储快照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。具体的代码实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mono.monochrome.iterator.snapshot1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">java</span>.util.ArrayList&lt;E&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> java.util.Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SnapshotArrayIterator</span>&lt;&gt;(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotArrayIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;E&gt; snapshot;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SnapshotArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.snapshot = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="built_in">this</span>.snapshot.addAll(arrayList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor &lt; snapshot.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">currentItem</span> <span class="operator">=</span> snapshot.get(cursor);</span><br><span class="line">            cursor++;</span><br><span class="line">            <span class="keyword">return</span> currentItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">8</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; iter1 = list.iterator();<span class="comment">//snapshot: 3, 8, 2</span></span><br><span class="line">        list.remove(<span class="number">2</span>);<span class="comment">//list：3, 8</span></span><br><span class="line">        Iterator&lt;Integer&gt; iter2 = list.iterator();<span class="comment">//snapshot: 3, 8</span></span><br><span class="line">        list.remove(<span class="number">3</span>);<span class="comment">//list：8</span></span><br><span class="line">        Iterator&lt;Integer&gt; iter3 = list.iterator();<span class="comment">//snapshot: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果：3 8 2</span></span><br><span class="line">        <span class="keyword">while</span> (iter1.hasNext()) &#123;</span><br><span class="line">            System.out.print(iter1.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果：3 8</span></span><br><span class="line">        <span class="keyword">while</span> (iter2.hasNext()) &#123;</span><br><span class="line">            System.out.print(iter2.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果：8</span></span><br><span class="line">        <span class="keyword">while</span> (iter3.hasNext()) &#123;</span><br><span class="line">            System.out.print(iter3.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个解决方案虽然简单，但代价也有点高。每次创建迭代器的时候，都要拷贝一份数据到快照中，会增加内存的消耗。如果一个容器同时有多个迭代器在遍历元素，就会导致数据在内存中重复存储多份。不过，庆幸的是，Java 中的拷贝属于浅拷贝，也就是说，容器中的对象并非真的拷贝了多份，而只是拷贝了对象的引用而已。</p>
<h2 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h2><p>我们可以在容器中，为每个元素保存两个时间戳，一个是添加时间戳 addTimestamp，一个是删除时间戳 delTimestamp。当元素被加入到集合中的时候，我们将 addTimestamp 设置为当前时间，将 delTimestamp 设置成最大长整型值（Long.MAX_VALUE）。当元素被删除时，我们将 delTimestamp 更新为当前时间，表示已经被删除。</p>
<p>注意，这里只是标记删除，而非真正将它从容器中删除。</p>
<p>同时，每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 addTimestamp&lt;snapshotTimestamp&lt;delTimestamp 的元素，才是属于这个迭代器的快照。</p>
<p>如果元素的 addTimestamp&gt;snapshotTimestamp，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的 delTimestamp&lt;snapshotTimestamp，说明元素在创建迭代器之前就被删除掉了，也不属于这个迭代器的快照。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mono.monochrome.iterator.snapshot2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> monochrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E obj)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E obj)</span>;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mono.monochrome.iterator.snapshot2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> actualSize; <span class="comment">//不包含标记删除元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> totalSize; <span class="comment">//包含标记删除元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span>[] addTimestamps;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span>[] delTimestamps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_CAPACITY];</span><br><span class="line">        <span class="built_in">this</span>.addTimestamps = <span class="keyword">new</span> <span class="title class_">long</span>[DEFAULT_CAPACITY];</span><br><span class="line">        <span class="built_in">this</span>.delTimestamps = <span class="keyword">new</span> <span class="title class_">long</span>[DEFAULT_CAPACITY];</span><br><span class="line">        <span class="built_in">this</span>.totalSize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.actualSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">        elements[totalSize] = obj;</span><br><span class="line">        addTimestamps[totalSize] = System.currentTimeMillis();</span><br><span class="line">        delTimestamps[totalSize] = Long.MAX_VALUE;</span><br><span class="line">        totalSize++;</span><br><span class="line">        actualSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalSize; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (elements[i].equals(obj) &amp;&amp; delTimestamps[i] == Long.MAX_VALUE) &#123;</span><br><span class="line">                delTimestamps[i] = System.currentTimeMillis();</span><br><span class="line">                actualSize--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">actualSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.actualSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.totalSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= totalSize) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (E) elements[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getAddTimestamp</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= totalSize) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addTimestamps[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelTimestamp</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= totalSize) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> delTimestamps[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SnapshotArrayIterator</span>&lt;&gt;(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SnapshotArrayIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> snapshotTimestamp;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cursorInAll; <span class="comment">// 在整个容器中的下标，而非快照中的下标</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> leftCount; <span class="comment">// 快照中还有几个元素未被遍历</span></span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SnapshotArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.snapshotTimestamp = System.currentTimeMillis();</span><br><span class="line">            <span class="built_in">this</span>.cursorInAll = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.leftCount = arrayList.actualSize();</span><br><span class="line">            <span class="built_in">this</span>.arrayList = arrayList;</span><br><span class="line"></span><br><span class="line">            justNext(); <span class="comment">// 先跳到这个迭代器快照的第一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursorInAll &lt; arrayList.totalSize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">currentItem</span> <span class="operator">=</span> arrayList.get(cursorInAll);</span><br><span class="line">            cursorInAll++;</span><br><span class="line">            justNext();</span><br><span class="line">            <span class="keyword">return</span> currentItem;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">justNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (cursorInAll &lt; arrayList.totalSize()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">addTimestamp</span> <span class="operator">=</span> arrayList.getAddTimestamp(cursorInAll);</span><br><span class="line">                <span class="type">long</span> <span class="variable">delTimestamp</span> <span class="operator">=</span> arrayList.getDelTimestamp(cursorInAll);</span><br><span class="line">                <span class="keyword">if</span> (snapshotTimestamp &gt; addTimestamp &amp;&amp; snapshotTimestamp &lt; delTimestamp) &#123;</span><br><span class="line">                    leftCount--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cursorInAll++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，上面的解决方案相当于解决了一个问题，又引入了另外一个问题。ArrayList 底层依赖数组这种数据结构，原本可以支持快速的随机访问，在 O(1) 时间复杂度内获取下标为 i 的元素，但现在，删除数据并非真正的删除，只是通过时间戳来标记删除，这就导致无法支持按照下标快速随机访问了。如果你对数组随机访问这块知识点不了解，可以去看我的《数据结构与算法之美》专栏，这里我就不展开讲解了。</p>
<p>现在，我们来看怎么解决这个问题：让容器既支持快照遍历，又支持随机访问？</p>
<p>解决的方法也不难，我稍微提示一下。我们可以在 ArrayList 中存储两个数组。一个支持标记删除的，用来实现快照遍历功能；一个不支持标记删除的（也就是将要删除的数据直接从数组中移除），用来支持随机访问。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
